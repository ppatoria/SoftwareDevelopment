#+BEGIN_HTML
<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="org-style.css" type="text/css" />
<style type="text/css"/></style>
#+END_HTML
#+TITLE: MVC
#+BEGIN_HTML
<div id="postamble">
<p class="author"> Author: Pralay Patoria
<a href="mailto:ppatoria@gmail.com">&lt;ppatoria@gmail.com&gt;</a>
</p>
<p class="date"> Date: 24-12-2013</p>
</div>
#+END_HTML
#+OPTIONS: date:nil, creator:nil, author:nil				

[TABLE-OF-CONTENTS]

* Model-View-Controller (MVC) 

** Forces
The following forces act on a system within this context and must be reconciled as you consider a solution to the problem:

 - User interface logic tends to change more frequently than business logic. In some cases, the application displays the same data in different ways. 
 - Designing visually appealing and efficient HTML pages generally requires a different skill set than does developing complex business logic. 
 - User interface activity generally consists of two parts: presentation and update. The presentation part retrieves data from a data source and formats the data for display. When the user performs an action based on the data, the update part passes control back to the business logic to update the data. In Web applications, a single page request combines the processing of the action associated with the link that the user selected with the rendering of the target page. In many cases, the target page may not be directly related to the action. For example, imagine a simple Web application that shows a list of items. The user returns to the main list page after either adding an item to the list or deleting an item from the list. Therefore, the application must render the same page (the list) after executing two quite different commands (adding or deleting)-all within the same HTTP request.
 - User interface code tends to be more device-dependent than business logic
 - Creating automated tests for user interfaces is generally more difficult and time-consuming than for business logic.** Therefore, reducing the amount of code that is directly tied to the user interface enhances the testability of the application. 


** Pattern 
The Model-View-Controller (MVC) pattern separates the modeling of the domain, the presentation, and the actions based on user input into three separate classes [Burbeck92]: 

 - Model: The model manages the behavior and data of the application domain, responds to requests for information about its state (usually from the view), and responds to instructions to change state (usually from the controller).

 - View: The view manages the display of information. 

 - Controller: The controller interprets the mouse and keyboard inputs from the user, informing the model and/or the view to change as appropriate. 

Figure  depicts the structural relationship between the three objects.

[[mvc.gif]]


It is important to note that both the view and the controller depend on the model. However, the model depends on neither the view nor the controller. This is one the key benefits of the separation. This separation allows the model to be built and tested independent of the visual presentation. The separation between view and controller is secondary in many rich-client applications, and, in fact, many user interface frameworks implement the roles as one object.

Figure  shows the structure of the active MVC using Observer and how the observer isolates the model from referencing views directly. 

[[MVC-Extented.gif]]

Figure More diagrams


[[MVC-Extented1.gif]]

[[mvc1.gif]]


[[mvc2.gif]]

[[mvc3.gif]]


[[mvc4.gif]]


[[mvc5.jpg]]


[[mvc6.jpg]]

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML>
<HEAD>
<TITLE></TITLE>
</HEAD>
<BODY>
<A name=1></a><IMG src="c#-4-nutshell-1_1.jpg"><br>
<hr>
<A name=2></a><IMG src="c#-4-nutshell-2_1.jpg"><br>
<hr>
<A name=3></a><b>C# 4.0</b><br>
<b>IN A NUTSHELL</b><br>
<hr>
<A name=4></a><hr>
<A name=5></a><b>C# 4.0</b><br>
<b>IN A NUTSHELL</b><br>
<b>Fourth Edition</b><br>
<i><b>Joseph Albahari and Ben Albahari</b></i><br>
Beijing <b>· </b>Cambridge <b>· </b>Farnham <b>· </b>Köln <b>· </b>Sebastopol <b>· </b>Taipei <b>· </b>Tokyo<br>
<hr>
<A name=6></a><b>C# 4.0 in a Nutshell, Fourth Edition<br></b>by Joseph Albahari and Ben Albahari<br>
Copyright © 2010 Joseph Albahari and Ben Albahari. All rights reserved.<br>Printed in the United States of America.<br>
Published by O'Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.<br>
O'Reilly books may be purchased for educational, business, or sales promotional use. Online<br>editions are also available for most titles (<i>http://my.safaribooksonline.com</i>). For more infor-<br>mation,  contact  our  corporate/institutional  sales  department:  (800)  998-9938  or<br><i>corporate@oreilly.com</i>.<br>
<b>Editor: </b>Laurel R.T. Ruma<br>
<b>Indexer: </b>John Bickelhaupt<br>
<b>Production Editor: </b>Loranah Dimant<br>
<b>Cover Designer: </b>Karen Montgomery<br>
<b>Copyeditor: </b>Audrey Doyle<br>
<b>Interior Designer: </b>David Futato<br>
<b>Proofreader: </b>Colleen Toporek<br>
<b>Illustrator: </b>Robert Romano<br>
<b>Printing History:</b><br>
March 2002:<br>
First Edition. <br>
August 2003:<br>
Second Edition. <br>
September 2007:<br>
Third Edition. <br>
January 2010:<br>
Fourth Edition. <br>
Nutshell Handbook, the Nutshell Handbook logo, and the O'Reilly logo are registered trade-<br>marks of O'Reilly Media, Inc. <i>C# 4.0 in a Nutshell</i>, the image of a Numidian crane, and related<br>trade dress are trademarks of O'Reilly Media, Inc.<br>
Many of the designations used by manufacturers and sellers to distinguish their products are<br>claimed as trademarks. Where those designations appear in this book, and O'Reilly Media,<br>Inc. was aware of a trademark claim, the designations have been printed in caps or initial caps.<br>
While every precaution has been taken in the preparation of this book, the publisher and<br>authors assume no responsibility for errors or omissions, or for damages resulting from the<br>use of the information contained herein.<br>
ISBN: 978-0-596-80095-6<br>
[M]<br>
1263924338<br>
<hr>
<A name=7></a><b>Table of Contents</b><br>
<b>Preface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  xiii</b><br>
<b>1. Introducing C# and the .NET Framework  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1</b><br>
Object Orientation<br>
1<br>
Type Safety<br>
2<br>
Memory Management<br>
2<br>
Platform Support<br>
3<br>
C#'s Relationship with the CLR<br>
3<br>
The CLR and .NET Framework<br>
3<br>
What's New in C# 4.0<br>
5<br>
<b>2. C# Language Basics  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7</b><br>
A First C# Program<br>
7<br>
Syntax<br>
10<br>
Type Basics<br>
12<br>
Numeric Types<br>
21<br>
Boolean Type and Operators<br>
28<br>
Strings and Characters<br>
30<br>
Arrays<br>
32<br>
Variables and Parameters<br>
36<br>
Expressions and Operators<br>
44<br>
Statements<br>
48<br>
Namespaces<br>
56<br>
<b>3. Creating Types in C#  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63</b><br>
Classes<br>
63<br>
Inheritance<br>
76<br>
The object Type<br>
85<br>
<b>v</b><br>
<hr>
<A name=8></a>Structs<br>
89<br>
Access Modifiers<br>
90<br>
Interfaces<br>
92<br>
Enums<br>
97<br>
Nested Types<br>
100<br>
Generics<br>
101<br>
<b>4. Advanced C#  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  115</b><br>
Delegates<br>
115<br>
Events<br>
124<br>
Lambda Expressions<br>
130<br>
Anonymous Methods<br>
134<br>
try Statements and Exceptions<br>
134<br>
Enumeration and Iterators<br>
143<br>
Nullable Types<br>
148<br>
Operator Overloading<br>
153<br>
Extension Methods<br>
157<br>
Anonymous Types<br>
160<br>
Dynamic Binding<br>
161<br>
Attributes<br>
169<br>
Unsafe Code and Pointers<br>
170<br>
Preprocessor Directives<br>
174<br>
XML Documentation<br>
176<br>
<b>5. Framework Overview  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  181</b><br>
The CLR and Core Framework<br>
183<br>
Applied Technologies<br>
187<br>
<b>6. Framework Fundamentals  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193</b><br>
String and Text Handling<br>
193<br>
Dates and Times<br>
206<br>
Dates and Time Zones<br>
213<br>
Formatting and Parsing<br>
219<br>
Standard Format Strings and Parsing Flags<br>
225<br>
Other Conversion Mechanisms<br>
232<br>
Globalization<br>
235<br>
Working with Numbers<br>
237<br>
Enums<br>
240<br>
Tuples<br>
244<br>
The Guid Struct<br>
245<br>
Equality Comparison<br>
245<br>
Order Comparison<br>
255<br>
Utility Classes<br>
258<br>
<b>vi | Table of Contents</b><br>
<hr>
<A name=9></a><b>7. Collections  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  263</b><br>
Enumeration<br>
263<br>
The ICollection and IList Interfaces<br>
271<br>
The Array Class<br>
273<br>
Lists, Queues, Stacks, and Sets<br>
282<br>
Dictionaries<br>
292<br>
Customizable Collections and Proxies<br>
298<br>
Plugging in Equality and Order<br>
304<br>
<b>8. LINQ Queries  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  311</b><br>
Getting Started<br>
311<br>
Fluent Syntax<br>
314<br>
Query Expressions<br>
320<br>
Deferred Execution<br>
324<br>
Subqueries<br>
330<br>
Composition Strategies<br>
333<br>
Projection Strategies<br>
337<br>
Interpreted Queries<br>
339<br>
LINQ to SQL and Entity Framework<br>
346<br>
Building Query Expressions<br>
361<br>
<b>9. LINQ Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  367</b><br>
Overview<br>
369<br>
Filtering<br>
371<br>
Projecting<br>
375<br>
Joining<br>
387<br>
Ordering<br>
394<br>
Grouping<br>
397<br>
Set Operators<br>
400<br>
The Zip Operator<br>
401<br>
Conversion Methods<br>
402<br>
Element Operators<br>
404<br>
Aggregation Methods<br>
406<br>
Quantifiers<br>
411<br>
Generation Methods<br>
412<br>
<b>10. LINQ to XML  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413</b><br>
Architectural Overview<br>
413<br>
X-DOM Overview<br>
414<br>
Instantiating an X-DOM<br>
418<br>
Navigating and Querying<br>
420<br>
Updating an X-DOM<br>
425<br>
Working with Values<br>
428<br>
Documents and Declarations<br>
431<br>
Names and Namespaces<br>
434<br>
<b>Table of Contents | vii</b><br>
<hr>
<A name=10></a>Annotations<br>
440<br>
Projecting into an X-DOM<br>
441<br>
<b>11. Other XML Technologies  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 447</b><br>
XmlReader<br>
448<br>
XmlWriter<br>
457<br>
Patterns for Using XmlReader/XmlWriter<br>
459<br>
XmlDocument<br>
463<br>
XPath<br>
466<br>
XSD and Schema Validation<br>
471<br>
XSLT<br>
474<br>
<b>12. Disposal and Garbage Collection  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  475</b><br>
IDisposable, Dispose, and Close<br>
475<br>
Automatic Garbage Collection<br>
480<br>
Finalizers<br>
482<br>
How the Garbage Collector Works<br>
487<br>
Managed Memory Leaks<br>
491<br>
Weak References<br>
494<br>
<b>13. Diagnostics and Code Contracts  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 499</b><br>
Conditional Compilation<br>
499<br>
Debug and Trace Classes<br>
502<br>
Code Contracts Overview<br>
506<br>
Preconditions<br>
510<br>
Postconditions<br>
514<br>
Assertions and Object Invariants<br>
517<br>
Contracts on Interfaces and Abstract Methods<br>
518<br>
Dealing with Contract Failure<br>
519<br>
Selectively Enforcing Contracts<br>
521<br>
Static Contract Checking<br>
523<br>
Debugger Integration<br>
524<br>
Processes and Process Threads<br>
525<br>
StackTrace and StackFrame<br>
526<br>
Windows Event Logs<br>
528<br>
Performance Counters<br>
530<br>
The Stopwatch Class<br>
535<br>
<b>14. Streams and I/O  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  537</b><br>
Stream Architecture<br>
537<br>
Using Streams<br>
539<br>
Stream Adapters<br>
552<br>
File and Directory Operations<br>
559<br>
Memory-Mapped Files<br>
569<br>
Compression<br>
571<br>
<b>viii | Table of Contents</b><br>
<hr>
<A name=11></a>Isolated Storage<br>
573<br>
<b>15. Networking  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  579</b><br>
Network Architecture<br>
579<br>
Addresses and Ports<br>
581<br>
URIs<br>
582<br>
Request/Response Architecture<br>
584<br>
HTTP-Specific Support<br>
592<br>
Writing an HTTP Server<br>
597<br>
Using FTP<br>
600<br>
Using DNS<br>
602<br>
Sending Mail with SmtpClient<br>
603<br>
Using TCP<br>
604<br>
Receiving POP3 Mail with TCP<br>
606<br>
<b>16. Serialization  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  609</b><br>
Serialization Concepts<br>
609<br>
The Data Contract Serializer<br>
613<br>
Data Contracts and Collections<br>
622<br>
Extending Data Contracts<br>
625<br>
The Binary Serializer<br>
628<br>
Binary Serialization Attributes<br>
630<br>
Binary Serialization with ISerializable<br>
634<br>
XML Serialization<br>
637<br>
<b>17. Assemblies  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647</b><br>
What's in an Assembly?<br>
647<br>
Strong Names and Assembly Signing<br>
652<br>
Assembly Names<br>
655<br>
Authenticode Signing<br>
657<br>
The Global Assembly Cache<br>
661<br>
Resources and Satellite Assemblies<br>
663<br>
Resolving and Loading Assemblies<br>
671<br>
Deploying Assemblies Outside the Base Folder<br>
675<br>
Packing a Single-File Executable<br>
676<br>
Working with Unreferenced Assemblies<br>
678<br>
<b>18. Reflection and Metadata  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  681</b><br>
Reflecting and Activating Types<br>
682<br>
Reflecting and Invoking Members<br>
688<br>
Reflecting Assemblies<br>
700<br>
Working with Attributes<br>
701<br>
Dynamic Code Generation<br>
707<br>
Emitting Assemblies and Types<br>
714<br>
Emitting Type Members<br>
717<br>
<b>Table of Contents | ix</b><br>
<hr>
<A name=12></a>Emitting Generic Methods and Types<br>
723<br>
Awkward Emission Targets<br>
725<br>
Parsing IL<br>
728<br>
<b>19. Dynamic Programming  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  735</b><br>
The Dynamic Language Runtime<br>
735<br>
Numeric Type Unification<br>
737<br>
Dynamic Member Overload Resolution<br>
738<br>
Implementing Dynamic Objects<br>
744<br>
Interoperating with Dynamic Languages<br>
747<br>
<b>20. Security  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  751</b><br>
Permissions<br>
751<br>
Code Access Security (CAS)<br>
755<br>
Allowing Partially Trusted Callers<br>
758<br>
The Transparency Model in CLR 4.0<br>
761<br>
Sandboxing Another Assembly<br>
769<br>
Operating System Security<br>
772<br>
Identity and Role Security<br>
775<br>
Cryptography Overview<br>
776<br>
Windows Data Protection<br>
777<br>
Hashing<br>
778<br>
Symmetric Encryption<br>
780<br>
Public Key Encryption and Signing<br>
784<br>
<b>21. Threading  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  789</b><br>
Threading's Uses and Misuses<br>
789<br>
Getting Started<br>
791<br>
Thread Pooling<br>
800<br>
Synchronization<br>
805<br>
Locking<br>
808<br>
Thread Safety<br>
817<br>
Nonblocking Synchronization<br>
825<br>
Signaling with Event Wait Handles<br>
832<br>
Signaling with Wait and Pulse<br>
840<br>
The Barrier Class<br>
849<br>
The Event-Based Asynchronous Pattern<br>
851<br>
BackgroundWorker<br>
852<br>
Interrupt and Abort<br>
855<br>
Safe Cancellation<br>
857<br>
Lazy Initialization<br>
860<br>
Thread-Local Storage<br>
862<br>
Reader/Writer Locks<br>
865<br>
Timers<br>
869<br>
<b>x | Table of Contents</b><br>
<hr>
<A name=13></a><b>22. Parallel Programming  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  873</b><br>
Why PFX?<br>
874<br>
PLINQ<br>
877<br>
The Parallel Class<br>
892<br>
Task Parallelism<br>
898<br>
Working with AggregateException<br>
912<br>
Concurrent Collections<br>
914<br>
SpinLock and SpinWait<br>
920<br>
<b>23. Asynchronous Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  927</b><br>
Why Asynchronous Methods Exist<br>
927<br>
Asynchronous Method Signatures<br>
928<br>
Asynchronous Methods Versus Asynchronous Delegates<br>
930<br>
Using Asynchronous Methods<br>
930<br>
Asynchronous Methods and Tasks<br>
934<br>
Writing Asynchronous Methods<br>
937<br>
Fake Asynchronous Methods<br>
940<br>
Alternatives to Asynchronous Methods<br>
941<br>
<b>24. Application Domains  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  943</b><br>
Application Domain Architecture<br>
943<br>
Creating and Destroying Application Domains<br>
945<br>
Using Multiple Application Domains<br>
946<br>
Using DoCallBack<br>
948<br>
Monitoring Application Domains<br>
949<br>
Domains and Threads<br>
950<br>
Sharing Data Between Domains<br>
951<br>
<b>25. Native and COM Interoperability  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 957</b><br>
Calling into Native DLLs<br>
957<br>
Type Marshaling<br>
958<br>
Callbacks from Unmanaged Code<br>
961<br>
Simulating a C Union<br>
962<br>
Shared Memory<br>
963<br>
Mapping a Struct to Unmanaged Memory<br>
965<br>
COM Interoperability<br>
969<br>
Calling a COM Component from C#<br>
971<br>
Embedding Interop Types<br>
975<br>
Primary Interop Assemblies<br>
975<br>
Exposing C# Objects to COM<br>
976<br>
<b>26. Regular Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  977</b><br>
Regular Expression Basics<br>
977<br>
Quantifiers<br>
982<br>
Zero-Width Assertions<br>
983<br>
<b>Table of Contents | xi</b><br>
<hr>
<A name=14></a>Groups<br>
985<br>
Replacing and Splitting Text<br>
987<br>
Cookbook Regular Expressions<br>
988<br>
Regular Expressions Language Reference<br>
992<br>
<b>Appendix: C# Keywords  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  997</b><br>
<b>Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1005</b><br>
<b>xii | Table of Contents</b><br>
<hr>
<A name=15></a><b>Preface</b><br>
C# 4.0 further enhances Microsoft's flagship programming language with much-<br>requested features--including support for dynamic programming, type parameter<br>variance, and optional and named parameters. At the same time, the CLR and .NET<br>Framework have grown to include a rich set of features for parallel programming,<br>code contracts, and a new code security model.<br>
The price of this growth is that there's more than ever to learn. Although tools such<br>as Microsoft's IntelliSense--and online references--are excellent in helping you on<br>the job, they presume an existing map of conceptual knowledge. This book provides<br>exactly that map of knowledge in a concise and unified style--free of clutter and<br>long introductions.<br>
Like the previous edition, <i>C# 4.0 in a Nutshell</i> is organized entirely around concepts<br>and use cases, making it friendly both to sequential reading and to random browsing.<br>It  also  plumbs  significant  depths  while  assuming  only  basic  background<br>knowledge--making it accessible to intermediate as well as advanced readers.<br>
This book covers C#, the CLR, and the core Framework assemblies. We've chosen<br>this focus to allow space for difficult topics such as concurrency, security, and ap-<br>plication domains--without compromising depth or readability. Features new to<br>C# 4.0 and the associated Framework are flagged so that you can also use this book<br>as a C# 3.0 reference.<br>
<b>Intended Audience<br></b>This book targets intermediate to advanced audiences. No prior knowledge of C#<br>is required, but some general programming experience is necessary. For the begin-<br>ner, this book complements, rather than replaces, a tutorial-style introduction to<br>programming.<br>
<b>xiii</b><br>
<hr>
<A name=16></a>If you're already familiar with C# 3.0, you'll find more than 100 pages dedicated to<br>the new features of C# 4.0 and Framework 4.0. In addition, many chapters have<br>been enhanced from the previous edition, most notably the chapters on the C#<br>language, .NET Framework fundamentals, memory management, threading, and<br>COM interoperability. We've also updated the LINQ chapters to make the examples<br>friendly to both LINQ to SQL and Entity Framework programmers.<br>
This book is an ideal companion to any of the vast array of books that focus on an<br>applied technology such as WPF, ASP.NET, or WCF. The areas of the language<br>and .NET Framework that such books omit, <i>C# 4.0 in a Nutshell</i> covers in detail--<br>and vice versa.<br>
If you're looking for a book that skims every .NET Framework technology, this is<br>not for you. This book is also unsuitable if you want a replacement for IntelliSense<br>(i.e., the alphabetical listings of types and type members that appeared in the C#<br>1.1 edition of this book).<br>
<b>How This Book Is Organized<br></b>The first three chapters after the introduction concentrate purely on C#, starting<br>with the basics of syntax, types, and variables, and finishing with advanced topics<br>such as unsafe code and preprocessor directives. If you're new to the language, you<br>should read these chapters sequentially.<br>
The remaining chapters cover the core .NET Framework, including such topics as<br>LINQ,  XML,  collections,  I/O  and  networking,  memory  management,  reflection,<br>dynamic programming, attributes, security, concurrency, application domains, and<br>native interoperability. You can read most of these chapters randomly, except for<br>Chapters 6 and 7, which lay a foundation for subsequent topics. The three chapters<br>on LINQ are also best read in sequence.<br>
<b>What You Need to Use This Book<br></b>The examples in this book require a C# 4.0 compiler and Microsoft .NET Frame-<br>work 4.0. You will also find Microsoft's .NET documentation useful to look up<br>individual types and members. The easiest way to get all three--along with an in-<br>tegrated development environment--is to install Microsoft Visual Studio 2010. Any<br>edition is suitable for what's taught in this book, including Visual Studio Express (a<br>free download). Visual Studio also includes an express edition of SQL Server, re-<br>quired to run the LINQ to SQL and Entity Framework examples, and IntelliSense,<br>which pops up type member listings as you type.<br>
For Chapters 2 through 4, Chapter 6, Chapters 8 through 10, and Chapter 24, the<br>code samples are available in the free code-snippet IDE, LINQPad. The samples<br>include everything in those chapters from simple expressions to complete programs<br>and are fully editable, allowing you to learn interactively. You can download LINQ-<br>Pad from <i>http://www.linqpad.net</i>; to obtain the additional samples, click "Download<br>more samples" in the Samples tab at the bottom left. You can then advance through<br>each sample with a single click.<br>
<b>xiv | Preface</b><br>
<hr>
<A name=17></a><b>Conventions Used in This Book<br></b>The  book  uses  basic  UML  notation  to  illustrate  relationships  between  types,  as<br>shown in Figure P-1. A slanted rectangle means an abstract class; a circle means an<br>interface. A line with a hollow triangle denotes inheritance, with the triangle pointing<br>to the base type. A line with an arrow denotes a one-way association; a line without<br>an arrow denotes a two-way association.<br>
<i>Figure P-1. Sample diagram</i><br>
The following typographical conventions are used in this book:<br>
<i>Italic</i><br>
Indicates new terms, URIs, filenames, and directories<br>
Constant width<br>
Indicates C# code, keywords and identifiers, and program output<br>
<b>Constant width bold</b><br>
Shows a highlighted section of code<br>
<i>Constant width italic</i><br>
Shows text that should be replaced with user-supplied values<br>
<b>Preface | xv</b><br>
<hr>
<A name=18></a>This icon signifies a tip, suggestion, or general note.<br>
This icon indicates a warning or caution.<br>
<b>Using Code Examples<br></b>This book is here to help you get your job done. In general, you may use the code<br>in this book in your programs and documentation. You do not need to contact us<br>for permission unless you're reproducing a significant portion of the code. For ex-<br>ample, writing a program that uses several chunks of code from this book does not<br>require permission. Selling or distributing a CD-ROM of examples from O'Reilly<br>books <i>does</i> require permission. Answering a question by citing this book and quoting<br>example code does not require permission. Incorporating a significant amount of<br>example  code  from  this  book  into  your  product's  documentation  <i>does</i>  require<br>permission.<br>
We appreciate, but do not require, attribution. An attribution usually includes the<br>title, author, publisher, and ISBN. For example: "<i>C# 4.0 in a Nutshell</i> by Joseph<br>Albahari  and  Ben  Albahari.  Copyright  2010  Joseph  Albahari  and  Ben  Albahari,<br>978-0-596-80095-6."<br>
If you feel your use of code examples falls outside fair use or the permission given<br>here, feel free to contact us at <i>permissions@oreilly.com</i>.<br>
<b>We'd Like to Hear from You<br></b>Please address comments and questions concerning this book to the publisher:<br>
O'Reilly Media, Inc.<br>1005 Gravenstein Highway North<br>Sebastopol, CA 95472<br>800-998-9938 (in the United States or Canada)<br>707-829-0515 (international or local)<br>707-829-0104 (fax)<br>
We have a web page for this book, where we list errata, examples, and any additional<br>information. You can access this page at:<br>
<i>http://www.oreilly.com/catalog/9780596800956</i><br>
Code listings and additional resources are provided at:<br>
<i>http://www.albahari.com/nutshell/</i><br>
<b>xvi | Preface</b><br>
<hr>
<A name=19></a>To comment or ask technical questions about this book, send email to the following,<br>quoting the book's ISBN (9780596800956):<br>
<i>bookquestions@oreilly.com</i><br>
For  more  information  about  our  books,  conferences,  Resource  Centers,  and  the<br>O'Reilly Network, see our website at:<br>
<i>http://www.oreilly.com</i><br>
<b>Safari® Books Online</b><br>
Safari Books Online is an on-demand digital library that lets you easily<br>search over 7,500 technology and creative reference books and videos<br>to find the answers you need quickly.<br>
With a subscription, you can read any page and watch any video from our library<br>online. Read books on your cell phone and mobile devices. Access new titles before<br>they are available for print, and get exclusive access to manuscripts in development<br>and post feedback for the authors. Copy and paste code samples, organize your<br>favorites, download chapters, bookmark key sections, create notes, print out pages,<br>and benefit from tons of other time-saving features.<br>
O'Reilly Media has uploaded this book to the Safari Books Online service. To have<br>full digital access to this book and others on similar topics from O'Reilly and other<br>publishers, sign up for free at <i>http://my.safaribooksonline.com</i>.<br>
<b>Acknowledgments<br>Joseph Albahari<br></b>First, I want to thank my brother and coauthor, Ben Albahari, for initially persuading<br>me  to  take  on  what  has  become  a  highly  successful  project.  I  particularly  enjoy<br>working with Ben in probing difficult topics: he shares my willingness to question<br>conventional wisdom, and the tenacity to pull things apart until it becomes clear<br>how they <i>really</i> work.<br>
I am most indebted to the superb technical reviewers. Starting with the reviewers at<br>Microsoft, the extensive input from Stephen Toub (Parallel Programming team) and<br>Chris Burrows (C# Compiler team) significantly enhanced the chapters on concur-<br>rency, dynamic programming, and the C# language. From the CLR team, I received<br>invaluable input on security and memory management from Shawn Farkas, Brian<br>Grunkemeyer, Maoni Stephens, and David DeWinter. And on Code Contracts, the<br>feedback from Brian Grunkemeyer, Mike Barnett, and Melitta Andersen raised this<br>chapter to the next quality bar. Thank you, people--both for your prompt feedback<br>and for answering all my questions. I really appreciate it!<br>
<b>Preface | xvii</b><br>
<hr>
<A name=20></a>I have the highest praise for Jon Skeet (author of <i>C# in Depth</i> and Stack Overflow<br>extraordinaire), whose perceptive suggestions enhanced numerous chapters (you<br>work for Google, but we'll forgive you!). I'm similarly grateful for the keen eye of<br>C# MVP Nicholas Paldino, who spotted errors and omissions that others missed.<br>I'd also like to thank C# MVPs Mitch Wheat and Brian Peek, and reviewers of the<br>3.0  edition  upon  which  this  book  was  based.  This  includes  the  aforementioned<br>Nicholas Paldino, who applied his thoroughness and breadth of knowledge to most<br>chapters  of  the  book,  and  Krzysztof  Cwalina,  Matt  Warren,  Joel  Pobar,  Glyn<br>Griffiths, Ion Vasilian, Brad Abrams, Sam Gentile, and Adam Nathan.<br>
Finally, I want to thank the O'Reilly team, including my prompt and efficient editor,<br>Laurel  Ruma,  my  publicist,  Kathryn  Barrett,  my  copyeditor,  Audrey  Doyle,  and<br>members of my family, Miri and Sonia.<br>
<b>Ben Albahari<br></b>Because my brother wrote his acknowledgments first, you can infer most of what I<br>want to say :) We've actually both been programming since we were kids (we shared<br>an Apple IIe; he was writing his own operating system while I was writing Hangman),<br>so it's cool that we're now writing books together. I hope the enriching experience<br>we had writing the book will translate into an enriching experience for you reading<br>the book.<br>
I'd also like to thank my former colleagues at Microsoft. Many smart people work<br>there, not just in terms of intellect but also in a broader emotional sense, and I miss<br>working with them. In particular, I learned a lot from Brian Beckman, to whom I<br>am indebted.<br>
<b>xviii | Preface</b><br>
<hr>
<A name=21></a><b>1</b><br>
<b>Introducing C# and the .NET</b><br>
<b>Framework</b><br>
C# is a general-purpose, type-safe, object-oriented programming language. The goal<br>of  the  language  is  programmer  productivity.  To  this  end,  the  language  balances<br>simplicity,  expressiveness,  and  performance.  The  chief  architect  of  the  language<br>since its first version is Anders Hejlsberg (creator of Turbo Pascal and architect of<br>Delphi). The C# language is platform-neutral, but it was written to work well with<br>the Microsoft .NET Framework.<br>
<b>Object Orientation<br></b>C# is a rich implementation of the object-orientation paradigm, which includes<br><i>encapsulation</i>,  <i>inheritance</i>,  and  <i>polymorphism</i>.  Encapsulation  means  creating  a<br>boundary around an <i>object</i>, to separate its external (public) behavior from its internal<br>(private)  implementation  details.  The  distinctive  features  of  C#  from  an  object-<br>oriented perspective are:<br>
<i>Unified type system</i><br>
The  fundamental  building  block  in  C#  is  an  encapsulated  unit  of  data  and<br>functions called a <i>type</i>. C# has a <i>unified type system</i>, where all types ultimately<br>share a common base type. This means that all types, whether they represent<br>business objects or are primitive types such as numbers, share the same basic<br>set of functionality. For example, any type can be converted to a string by calling<br>its ToString method.<br>
<i>Classes and interfaces</i><br>
In the pure object-oriented paradigm, the only kind of type is a class. In C#,<br>there are several other kinds of types, one of which is an <i>interface</i> (similar to<br>Java interfaces). An interface is like a class except it is only a definition for a<br>type, not an implementation. It's particularly useful in scenarios where multiple<br>inheritance is required (unlike languages such as C++ and Eiffel, C# does not<br>support multiple inheritance of classes).<br>
<b>1</b><br>
<hr>
<A name=22></a><i>Properties, methods, and events</i><br>
In the pure object-oriented paradigm, all functions are <i>methods</i> (this is the case<br>in Smalltalk). In C#, methods are only one kind of <i>function member</i>, which also<br>includes <i>properties</i> and <i>events</i> (there are others, too). Properties are function<br>members that encapsulate a piece of an object's state, such as a button's color<br>or a label's text. Events are function members that simplify acting on object<br>state changes.<br>
<b>Type Safety<br></b>C# is primarily a <i>type-safe</i> language, meaning that types can interact only through<br>protocols  they  define,  thereby  ensuring  each  type's  internal  consistency.  For  in-<br>stance, C# prevents you from interacting with a <i>string</i> type as though it were an<br><i>integer</i> type.<br>
More specifically, C# supports <i>static typing</i>, meaning that the language enforces<br>type safety at <i>compile time</i>. This is in addition to <i>dynamic</i> type safety, which the .NET<br>CLR enforces at <i>runtime</i>.<br>
Static typing eliminates a large class of errors before a program is even run. It shifts<br>the burden away from runtime unit tests onto the compiler to verify that all the types<br>in a program fit together correctly. This makes large programs much easier to man-<br>age, more predictable, and more robust. Furthermore, static typing allows tools such<br>as IntelliSense in Visual Studio to help you write a program, since it knows for a<br>given variable what type it is, and hence what methods you can call on that variable.<br>
C# 4.0 allows parts of your code to be dynamically typed via<br>the new dynamic keyword. However, C# remains a predomi-<br>nately statically typed language.<br>
C# is called a <i>strongly typed language</i> because its type rules (whether enforced stat-<br>ically or dynamically) are very strict. For instance, you cannot call a function that's<br>designed to accept an integer with a floating-point number, unless you first <i>explic-<br>itly</i> convert the floating-point number to an integer. This helps prevent mistakes.<br>
Strong typing also plays a role in enabling C# code to run in a sandbox--an envi-<br>ronment where every aspect of security is controlled by the host. In a sandbox, it is<br>important that you cannot arbitrarily corrupt the state of an object by bypassing its<br>type rules.<br>
<b>Memory Management<br></b>C# relies on the runtime to perform automatic memory management. The CLR has<br>a garbage collector that executes as part of your program, reclaiming memory for<br>objects that are no longer referenced. This frees programmers from explicitly deal-<br>locating the memory for an object, eliminating the problem of incorrect pointers<br>encountered in languages such as C++.<br>
<b>2 | Chapter 1:</b><b>Introducing C# and the .NET Framework</b><br>
<hr>
<A name=23></a>C# does not eliminate pointers: it merely makes them unnecessary for most pro-<br>
<b>Introducing C#</b><br>
gramming tasks. For performance-critical hotspots and interoperability, pointers<br>
<b>and .NET</b><br>
may be used, but they are permitted only in blocks that are explicitly marked unsafe.<br>
<b>Platform Support<br></b>C# is typically used for writing code that runs on Windows platforms. Although<br>Microsoft standardized the C# language and the CLR through ECMA, the total<br>amount of resources (both inside and outside of Microsoft) dedicated to supporting<br>C# on non-Windows platforms is relatively small. This means that languages such<br>as  Java  are  sensible  choices  when  multiplatform  support  is  of  primary  concern.<br>Having  said  this,  C#  can  be  used  to  write  cross-platform  code  in  the  following<br>scenarios:<br>
· C# code may run on the server and dish up DHTML that can run on any plat-<br>
form. This is precisely the case for ASP.NET.<br>
· C# code may run on a runtime other than the Microsoft Common Language<br>
Runtime. The most notable example is the Mono project, which has its own<br>C# compiler and runtime, running on Linux, Solaris, Mac OS X, and Windows.<br>
· C# code may run on a host that supports Microsoft Silverlight (supported for<br>
Windows and Mac OS X). This is a new technology that is analogous to Adobe's<br>Flash Player.<br>
<b>C#'s Relationship with the CLR<br></b>C# depends on a runtime equipped with a host of features such as automatic mem-<br>ory management and exception handling. The design of C# closely maps to the<br>design of the CLR, which provides these runtime features (although C# is technically<br>independent of the CLR). Furthermore, the C# type system maps closely to the CLR<br>type system (e.g., both share the same definitions for primitive types).<br>
<b>The CLR and .NET Framework<br></b>The  .NET  Framework  consists  of  a  runtime  called  the  <i>Common  Language  Run-<br>time</i> (CLR) and a vast set of libraries. The libraries consist of core libraries (which<br>this book is concerned with) and applied libraries, which depend on the core libra-<br>ries. Figure 1-1 is a visual overview of those libraries (and also serves as a navigational<br>aid to the book).<br>
The CLR is the runtime for executing <i>managed code</i>. C# is one of several <i>managed<br>languages</i> that get compiled into managed code. Managed code is packaged into an<br><i>assembly</i>, in the form of either an executable file (an <i>.exe</i>) or a library (a <i>.dll</i>), along<br>with type information, or <i>metadata</i>.<br>
Managed code is represented in <i>Intermediate Language</i> or <i>IL</i>. When the CLR loads<br>an assembly, it converts the IL into the native code of the machine, such as x86. This<br>conversion is done by the CLR's JIT (Just-In-Time) compiler. An assembly retains<br>
<b>The CLR and .NET Framework | 3</b><br>
<hr>
<A name=24></a><i>Figure 1-1. This depicts the topics covered in this book and the chapters in which they are<br>found. The names of specialized frameworks and class libraries beyond the scope of this book<br>are grayed out and displayed outside the boundaries of The Nutshell.</i><br>
almost all of the original source language constructs, which makes it easy to inspect<br>and even generate code dynamically.<br>
Red Gate's .NET Reflector application is an invaluable tool for<br>examining the contents of an assembly (you can also use it as a<br>decompiler).<br>
The CLR performs as a host for numerous runtime services. Examples of these serv-<br>ices include memory management, the loading of libraries, and security services.<br>
The CLR is language-neutral, allowing developers to build applications in multiple<br>languages (e.g., C#, Visual Basic .NET, Managed C++, Delphi.NET, Chrome .NET,<br>and J#).<br>
The .NET Framework consists of libraries for writing just about any Windows- or<br>web-based  application.  Chapter  5  gives  an  overview  of  the  .NET  Framework<br>libraries.<br>
<b>4 | Chapter 1:</b><b>Introducing C# and the .NET Framework</b><br>
<hr>
<A name=25></a><b>What's New in C# 4.0</b><br>
<b>Introducing C#</b><br>
<b>and .NET</b><br>
The new features in C# 4.0 are:<br>
· Dynamic binding<br>· Type variance with generic interfaces and delegates<br>· Optional parameters<br>· Named arguments<br>· COM interoperability improvements<br>
<i>Dynamic binding</i> (Chapters 4 and 19) is C# 4.0's biggest innovation. This feature<br>was inspired by dynamic languages such as Python, Ruby, JavaScript, and Smalltalk.<br>Dynamic binding defers <i>binding</i>--the process of resolving types and members--<br>from  compile  time  to  runtime.  Although  C#  remains  a  predominantly  statically<br>typed language, a variable of type dynamic is resolved in a late-bound manner. For<br>example:<br>
dynamic d = &quot;hello&quot;;<br>
Console.WriteLine (d.ToUpper());  // HELLO<br>Console.WriteLine (d.Foo());      // Compiles OK but gives <i>runtime</i> error<br>
Calling an object dynamically is useful in scenarios that would otherwise require<br>complicated reflection code. Dynamic binding is also useful when interoperating<br>with dynamic languages and COM components.<br>
<i>Optional parameters</i> (Chapter 2) allow functions to specify default parameter values<br>so that callers can omit arguments. An optional parameter declaration such as:<br>
void Foo (int <b>x = 23</b>) { Console.WriteLine (x); }<br>
can be called as follows:<br>
Foo(); // 23<br>
<i>Named arguments</i> (Chapter 2) allow a function caller to identify an argument by<br>name rather than position. For example, the preceding method can now be called<br>as follows:<br>
Foo (x:5);<br>
<i>Type variance</i> (Chapters 3 and 4) allows generic interfaces and generic delegates to<br>mark their type parameters as covariant or contravariant. This enables code such as<br>the following to work:<br>
IEnumerable&lt;string&gt; x = ...;<br>IEnumerable&lt;object&gt; y = x;<br>
<i>COM interoperability</i> (Chapter 25) has been enhanced in C# 4.0 in three ways. First,<br>arguments can be passed by reference without the ref keyword. This feature is par-<br>ticularly useful in conjunction with optional parameters. It means that the following<br>C# 3.0 code to open a Word document:<br>
<b>What's New in C# 4.0 | 5</b><br>
<hr>
<A name=26></a>object o1 = &quot;foo.doc&quot;;<br>
object o2 = Missing.Value;<br>object o3 = Missing.Value;<br>...<br>
word.Open (ref o1, ref o2, ref o3...);<br>
can now be simplified to:<br>
word.Open (&quot;Foo.doc&quot;);<br>
Second, assemblies that contain COM interop types can now be <i>linked</i> rather than<br><i>referenced</i>. Linked interop types support type equivalence, avoiding the need for<br><i>Primary  Interop  Assemblies</i>  and  putting  an  end  to  versioning  and  deployment<br>headaches.<br>
Third, functions that return <i>variant</i> types from linked interop types are mapped to<br>dynamic rather than object, eliminating the need for casting.<br>
<b>6 | Chapter 1:</b><b>Introducing C# and the .NET Framework</b><br>
<hr>
<A name=27></a><b>2</b><br>
<b>C# Language Basics</b><br>
In this chapter, we introduce the basics of the C# language.<br>
All programs and code snippets in this and the following two<br>chapters  are  available  as  interactive  samples  in  LINQPad.<br>Working through these samples in conjunction with the book<br>accelerates  learning  in  that  you  can  edit  the  samples  and  in-<br>stantly see the results without needing to set up projects and<br>solutions in Visual Studio.<br>
To download the samples, click the Samples tab in LINQPad<br>and then click "Download more samples." LINQPad is free--<br>go to <i>http://www.linqpad.net</i>.<br>
<b>A First C# Program<br></b>Here is a program that multiplies 12 by 30 and prints the result, 360, to the screen.<br>The double forward slash indicates that the remainder of a line is a <i>comment</i>:<br>
using System;                     // Importing namespace<br>
class Test                        // Class declaration<br>{<br>  static void Main()              //   Method declaration<br>  {<br>    int x = 12 * 30;              //     Statement 1<br>
    Console.WriteLine (x);        //     Statement 2<br>  }                               //   End of method<br>}                                 // End of class<br>
At the heart of this program lie two <i>statements</i>. Statements in C# execute sequen-<br>tially. Each statement is terminated by a semicolon:<br>
    int x = 12 * 30;<br>    Console.WriteLine (x);<br>
<b>7</b><br>
<hr>
<A name=28></a>The first statement computes the <i>expression</i> 12 * 30 and stores the result in a <i>local<br>variable</i>,  named  x,  which  is  an  integer  type.  The  second  statement  calls  the<br>Console class's WriteLine <i>method</i>, to print the variable x to a text window on the<br>screen.<br>
A <i>method</i> performs an action in a series of statements, called a <i>statement block</i>--a<br>pair  of  braces  containing  zero  or  more  statements.  We  defined  a  single  method<br>named Main:<br>
  static void Main()<br>
  {<br>
    ...<br>
  }<br>
Writing higher-level functions that call upon lower-level functions simplifies a pro-<br>gram. We can <i>refactor</i> our program with a reusable method that multiplies an integer<br>by 12 as follows:<br>
using System;<br>
class Test<br>
{<br>  static void Main()<br>  {<br>
    Console.WriteLine (FeetToInches (30));      // 360<br>
    Console.WriteLine (FeetToInches (100));     // 1200<br>
  }<br>
  static int FeetToInches (int feet)<br>
  {<br>    int inches = feet * 12;<br>
    return inches;<br>  }<br>}<br>
A method can receive <i>input</i> data from the caller by specifying <i>parameters</i> and <i>out-<br>put</i> data back to the caller by specifying a <i>return type</i>. We defined a method called<br>FeetToInches that has a parameter for inputting feet, and a return type for outputting<br>inches:<br>
static <b>int</b> FeetToInches (<b>int feet</b>) {...}<br>
The <i>literals</i> 30 and 100 are the <i>arguments</i> passed to the FeetToInches method. The<br>Main method in our example has empty parentheses because it has no parameters,<br>and is void because it doesn't return any value to its caller:<br>
static <b>void</b> Main<b>()</b><br>
C# recognizes a method called Main as signaling the default entry point of execution.<br>The Main method may optionally return an integer (rather than void) in order to<br>return a value to the execution environment. The Main method can also optionally<br>accept an array of strings as a parameter (that will be populated with any arguments<br>passed to the executable). For example:<br>
static int Main (string[] args) {...}<br>
<b>8 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=29></a>An array (such as string[]) represents a fixed number of ele-<br>ments of a particular type. Arrays are specified by placing square<br>brackets  after  the  element  type  and  are  described  in  "Ar-<br>rays" on page 32.<br>
Methods are one of several kinds of functions in C#. Another kind of function we<br>
<b>C# Basics</b><br>
used was the * <i>operator</i>, used to perform multiplication. There are also <i>construc-<br>tors</i>, <i>properties</i>, <i>events</i>, <i>indexers</i>, and <i>finalizers</i>.<br>
In our example, the two methods are grouped into a class. A <i>class</i> groups function<br>members  and  data  members  to  form  an  object-oriented  building  block.  The<br>Console class groups members that handle command-line input/output functional-<br>ity, such as the WriteLine method. Our Test class groups two methods--the Main<br>method and the FeetToInches method. A class is a kind of <i>type</i>, which we will ex-<br>amine in "Type Basics" on page 12.<br>
At  the  outermost  level  of  a  program,  types  are  organized  into  <i>namespaces</i>.  The<br>using directive was used to make the System namespace available to our application,<br>to use the Console class. We could define all our classes within the TestPrograms<br>namespace, as follows:<br>
using System;<br>
namespace TestPrograms<br>{<br>  class Test  {...}<br>  class Test2 {...}<br>
}<br>
The .NET Framework is organized into nested namespaces. For example, this is the<br>namespace that contains types for handling text:<br>
using System.Text;<br>
The using directive is there for convenience; you can also refer to a type by its fully<br>qualified  name,  which  is  the  type  name  prefixed  with  its  namespace,  such  as<br>System.Text.StringBuilder.<br>
<b>Compilation<br></b>The C# compiler compiles source code, specified as a set of files with the <i>.cs</i> exten-<br>sion,  into  an  <i>assembly</i>.  An  assembly  is  the  unit  of  packaging  and  deployment<br>in .NET. An assembly can be either an <i>application</i> or a <i>library</i>. A normal console or<br>Windows <i>application</i> has a Main method and is an <i>.exe</i> file. A library is a <i>.dll</i> and is<br>equivalent to an <i>.exe</i> without an entry point. Its purpose is to be called upon (<i>ref-<br>erenced</i>) by an application or by other libraries. The .NET Framework is a set of<br>libraries.<br>
<b>A First C# Program | 9</b><br>
<hr>
<A name=30></a>The name of the C# compiler is <i>csc.exe</i>. You can either use an IDE such as Visual<br>Studio to compile, or call csc manually from the command line. To compile man-<br>ually, first save a program to a file such as <i>MyFirstProgram.cs</i>, and then go to the<br>command  line  and  invoke  csc  (located  under  <i>%SystemRoot%\Microsoft.NET<br>\Framework\&lt;framework-version&gt;</i> where <i>%SystemRoot%</i> is your Windows direc-<br>tory) as follows:<br>
csc MyFirstProgram.cs<br>
This produces an application named <i>MyFirstProgram.exe</i>.<br>
To produce a library (<i>.dll</i>), do the following:<br>
csc /target:library MyFirstProgram.cs<br>
We explain assemblies in detail in Chapter 16.<br>
<b>Syntax<br></b>C# syntax is based on C and C++ syntax. In this section, we will describe C#'s<br>elements of syntax, using the following program:<br>
using System;<br>
class Test<br>
{<br>  static void Main()<br>  {<br>    int x = 12 * 30;<br>
    Console.WriteLine (x);<br>  }<br>}<br>
<b>Identifiers and Keywords<br></b><i>Identifiers</i> are names that programmers choose for their classes, methods, variables,<br>and so on. These are the identifiers in our example program, in the order they appear:<br>
System   Test   Main   x   Console   WriteLine<br>
An  identifier  must  be  a  whole  word,  essentially  made  up  of  Unicode  characters<br>starting with a letter or underscore. C# identifiers are case-sensitive. By convention,<br>parameters,  local  variables,  and  private  fields  should  be  in  camel  case  (e.g.,<br>myVariable), and all other identifiers should be in Pascal case (e.g., MyMethod).<br>
<i>Keywords</i> are names reserved by the compiler that you can't use as identifiers. These<br>are the keywords in our example program:<br>
using   class   static   void   int<br>
<b>10 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=31></a>Here is the full list of C# keywords:<br>
abstract<br>
as<br>
base<br>
bool<br>
break<br>
byte<br>
case<br>
catch<br>
char<br>
checked<br>
class<br>
const<br>
continue<br>
decimal<br>
default<br>
delegate<br>
do<br>
double<br>
else<br>
enum<br>
<b>C# Basics</b><br>
event<br>
explicit<br>
extern<br>
false<br>
finally<br>
fixed<br>
float<br>
for<br>
foreach<br>
goto<br>
if<br>
implicit<br>
in<br>
int<br>
interface<br>
internal<br>
is<br>
lock<br>
long<br>
namespace<br>
new<br>
null<br>
object<br>
operator<br>
out<br>
override<br>
params<br>
private<br>
protected<br>
public<br>
readonly<br>
ref<br>
return<br>
sbyte<br>
sealed<br>
short<br>
sizeof<br>
stackalloc<br>
static<br>
string<br>
struct<br>
switch<br>
this<br>
throw<br>
true<br>
try<br>
typeof<br>
uint<br>
ulong<br>
unchecked<br>
unsafe<br>
ushort<br>
using<br>
virtual<br>
volatile<br>
void<br>
while<br>
 <br>
 <br>
 <br>
<b>Avoiding conflicts<br></b>If you really want to use an identifier that clashes with a keyword, you can do so by<br>qualifying it with the @ prefix. For instance:<br>
class class  {...}      // Illegal<br>class @class {...}      // Legal<br>
The @ symbol doesn't form part of the identifier itself. So @myVariable is the same as<br>myVariable.<br>
The @ prefix can be useful when consuming libraries written in<br>other .NET languages that have different keywords.<br>
<b>Contextual keywords<br></b>Some keywords are <i>contextual</i>, meaning that they can also be used as identifiers--<br>without an @ symbol. These are:<br>
add<br>
ascending<br>
by<br>
descending<br>
dynamic<br>
equals<br>
from<br>
get<br>
global<br>
group<br>
in<br>
into<br>
join<br>
let<br>
on<br>
orderby<br>
partial<br>
remove<br>
select<br>
set<br>
value<br>
var<br>
where<br>
yield<br>
<b>Syntax | 11</b><br>
<hr>
<A name=32></a>With contextual keywords, ambiguity cannot arise within the context in which they<br>are used.<br>
<b>Literals, Punctuators, and Operators<br></b><i>Literals</i> are primitive pieces of data statically embedded into the program. The lit-<br>erals we used in our example program are 12 and 30.<br><i>Punctuators</i> help demarcate the structure of the program. These are the punctuators<br>we used in our example program:<br>
;   {   }<br>
The semicolon is used to terminate a statement. This means that statements can<br>wrap multiple lines:<br>
Console.WriteLine<br>
  (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);<br>
The braces are used to group multiple statements into a statement block.<br>
An <i>operator</i> transforms and combines expressions. Most operators in C# are de-<br>noted with a symbol, such as the multiplication operator, *. We will discuss oper-<br>ators in more detail later in the chapter. These are the operators we used in our<br>example program:<br>
.  ()   *   =<br>
The period denotes a member of something (or a decimal point with numeric liter-<br>als). The parentheses are used when declaring or calling a method; empty paren-<br>theses are used when the method accepts no arguments. The equals sign is used for <br><i>assignment</i> (the double equals sign, ==, is used for equality comparison, as we'll see<br>later).<br>
<b>Comments<br></b>C# offers two different styles of source-code documentation: <i>single-line comments<br></i>and <i>multiline comments</i>. A single-line comment begins with a double forward slash<br>and continues until the end of the line. For example:<br>
int x = 3;   // Comment about assigning 3 to x<br>
A multiline comment begins with /* and ends with */. For example:<br>
int x = 3;   /* This is a comment that<br>                spans two lines */<br>
Comments may embed XML documentation tags, explained in "XML Documen-<br>tation" on page 176 in Chapter 4.<br>
<b>Type Basics<br></b>A <i>type</i> defines the blueprint for a value. A <i>value</i> is a storage location denoted by a<br><i>variable</i>  or  a  <i>constant</i>.  A  variable  represents  a  value  that  can  change,  whereas  a<br>
<b>12 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=33></a>constant represents an invariant (we will visit constants later in the chapter). We<br>created a local variable named x in our first program:<br>
static void Main()<br>{<br>  int x = 12 * 30;<br>
  Console.WriteLine (x);<br>}<br>
<b>C# Basics</b><br>
All values in C# are an <i>instance</i> of a specific type. The meaning of a value, and the<br>set of possible values a variable can have, is determined by its type. The type of x is<br>int.<br>
<b>Predefined Type Examples<br></b>Predefined types are types that are specially supported by the compiler. The int type<br>is a predefined type for representing the set of integers that fit into 32 bits of memory,<br>from -231 to 231-1. We can perform functions such as arithmetic with instances of<br>the int type as follows:<br>
int x = 12 * 30;<br>
Another predefined C# type is string. The string type represents a sequence of<br>characters, such as ".NET" or "<i>http://oreilly.com</i>". We can work with strings by<br>calling functions on them as follows:<br>
string message = &quot;Hello world&quot;;<br>string upperMessage = message.ToUpper();<br>
Console.WriteLine (upperMessage);               // HELLO WORLD<br>
int x = 2010;<br>message = message + x.ToString();<br>Console.WriteLine (message);                    // Hello world2010<br>
The  predefined  bool  type  has  exactly  two  possible  values:  true  and  false.  The<br>bool type is commonly used to conditionally branch execution flow based with an<br>if statement. For example:<br>
bool simpleVar = false;<br>if (simpleVar)<br>  Console.WriteLine (&quot;This will not print&quot;);<br>
int x = 5000;<br>bool lessThanAMile = x &lt; 5280;<br>if (lessThanAMile)<br>  Console.WriteLine (&quot;This will print&quot;);<br>
In C#, predefined types (also referred to as built-in types) are<br>recognized  with  a  C#  keyword.  The  System  namespace  in<br>the .NET Framework contains many important types that are<br>not predefined by C# (e.g., DateTime).<br>
<b>Type Basics | 13</b><br>
<hr>
<A name=34></a><b>Custom Type Examples<br></b>Just as we can build complex functions from simple functions, we can build complex<br>types from primitive types. In this example, we will define a custom type named<br>UnitConverter--a class that serves as a blueprint for unit conversions:<br>
using System;<br>
public class UnitConverter<br>
{<br>  int ratio;                                                 // Field<br>
  public UnitConverter (int unitRatio) {ratio = unitRatio; } // Constructor<br>  public int Convert   (int unit)    {return unit * ratio; } // Method<br>
}<br>
class Test<br>
{<br>  static void Main()<br>  {<br>
    UnitConverter feetToInchesConverter = new UnitConverter (12);<br>
    UnitConverter milesToFeetConverter  = new UnitConverter (5280);<br>
    Console.WriteLine (feetToInchesConverter.Convert(30));    // 360<br>    Console.WriteLine (feetToInchesConverter.Convert(100));   // 1200<br>
    Console.WriteLine (feetToInchesConverter.Convert(<br>
                         milesToFeetConverter.Convert(1)));   // 63360<br>
  }<br>}<br>
<b>Members of a type<br></b>A  type  contains  <i>data  members</i>  and  <i>function  members</i>.  The  data  member  of<br>UnitConverter  is  the  <i>field</i>  called  ratio.  The  function  members  of  UnitConverter<br>are the Convert method and the UnitConverter's <i>constructor</i>.<br>
<b>Symmetry of predefined types and custom types<br></b>A beautiful aspect of C# is that predefined types and custom types have few differ-<br>ences. The predefined int type serves as a blueprint for integers. It holds data--32<br>bits--and provides function members that use that data, such as ToString. Similarly,<br>our custom UnitConverter type acts as a blueprint for unit conversions. It holds<br>data--the ratio--and provides function members to use that data.<br>
<b>Constructors and instantiation<br></b>Data is created by <i>instantiating</i> a type. Predefined types can be instantiated simply<br>by using a literal. For example, the following line instantiates two integers (12 and<br>30), which are used to compute a third instance, x:<br>
int x = 12 * 30;<br>
The new operator is needed to create a new instance of a custom type. We created<br>and declared an instance of the UnitConverter type with this statement:<br>
UnitConverter feetToInchesConverter = new UnitConverter (12);<br>
<b>14 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=35></a>Immediately after the new operator instantiates an object, the object's <i>constructor</i> is<br>called to perform initialization. A constructor is defined like a method, except that<br>the method name and return type are reduced to the name of the enclosing type:<br>
public class UnitConverter<br>
{<br>  ...<br>
  <b>public UnitConverter (int unitRatio) { ratio = unitRatio; }</b><br>
<b>C# Basics</b><br>
  ...<br>
}<br>
<b>Instance versus static members<br></b>The data members and function members that operate on the <i>instance</i> of the type<br>are called instance members. The UnitConverter's Convert method and the int's<br>ToString method are examples of instance members. By default, members are in-<br>stance members.<br>
Data members and function members that don't operate on the instance of the type,<br>but  rather  on  the  type  itself,  must  be  marked  as  static.  The  Test.Main  and<br>Console.WriteLine methods are static methods. The Console class is actually a <i>static<br>class</i>, which means <i>all</i> its members are static. You never actually create instances of<br>a Console--one console is shared across the whole application.<br>To contrast instance from static members, in the following code the instance field<br>Name pertains to an instance of a particular Panda, whereas Population pertains to the<br>set of all Panda instances:<br>
public class Panda<br>{<br>  public string Name;             // Instance field<br>  public static int Population;   // Static field<br>
  public Panda (string n)         // Constructor<br>  {<br>    Name = n;                     // Assign the instance field<br>    Population = Population + 1;  // Increment the static Population field<br>  }<br>}<br>
The following code creates two instances of the Panda, prints their names, and then<br>prints the total population:<br>
using System;<br>
class Program<br>{<br>  static void Main()<br>  {<br>    Panda p1 = new Panda (&quot;Pan Dee&quot;);<br>
    Panda p2 = new Panda (&quot;Pan Dah&quot;);<br>
    Console.WriteLine (p1.Name);      // Pan Dee<br>    Console.WriteLine (p2.Name);      // Pan Dah<br>
    Console.WriteLine (Panda.Population);   // 2<br>
<b>Type Basics | 15</b><br>
<hr>
<A name=36></a>  }<br>
}<br>
<b>The public keyword<br></b>The public keyword exposes members to other classes. In this example, if the Name<br>field in Panda was not public, the Test class could not access it. Marking a member<br>public  is  how  a  type  communicates:  "Here  is  what  I  want  other  types  to  see--<br>everything else is my own private implementation details." In object-oriented terms,<br>we say that the public members <i>encapsulate</i> the private members of the class.<br>
<b>Conversions<br></b>C# can convert between instances of compatible types. A conversion always creates<br>a new value from an existing one. Conversions can be either  <i>implicit</i> or <i>explicit</i>:<br>implicit conversions happen automatically, and explicit conversions require a <i>cast</i>.<br>In the following example, we <i>implicitly</i> cast an int to a long type (which has twice<br>the bitwise capacity of an int) and <i>explicitly</i> cast an int to a short type (which has<br>half the capacity of an int):<br>
int x = 12345;       // int is a 32-bit integer<br>
long y = x;          // Implicit conversion to 64-bit integer<br>short z = (short)x;  // Explicit conversion to 16-bit integer<br>
Implicit conversions are allowed when both of the following are true:<br>
· The compiler can guarantee they will always succeed.<br>· No information is lost in conversion.*<br>
Conversely, <i>explicit</i> conversions are required when one of the following is true:<br>
· The compiler cannot guarantee they will always succeed.<br>· Information may be lost during conversion.<br>
The  <i>numeric  conversions</i>  that  we  just  saw  are  built  into  the<br>language.  C#  also  supports  <i>reference  conversions</i>  and  <i>boxing<br>conversions</i> (see Chapter 3) as well as <i>custom conversions</i> (see<br>"Operator Overloading" on page 153 in Chapter 4). The com-<br>piler  doesn't  enforce  the  aforementioned  rules  with  custom<br>conversions, so it's possible for badly designed types to behave<br>otherwise.<br>
<b>Value Types Versus Reference Types<br></b>All C# types fall into the following categories:<br>
· Value types<br>· Reference types<br>
* A minor caveat is that very large long values lose some precision when converted to double.<br>
<b>16 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=37></a>· Generic type parameters<br>· Pointer types<br>
In this section, we'll describe value types and reference types.<br>In  "Generics"  on  page  101  in  Chapter  3,  we'll  cover  generic<br>type  parameters,  and  in  "Unsafe  Code  and  Point-<br>
<b>C# Basics</b><br>
ers" on page 170 in Chapter 4, we'll cover pointer types.<br>
<i>Value types</i> comprise most built-in types (specifically, all numeric types, the char<br>type, and the bool type) as well as custom struct and enum types.<br><i>Reference types</i> comprise all class, array, delegate, and interface types.<br>
The fundamental difference between value types and reference types is how they are<br>handled in memory.<br>
<b>Value types<br></b>The content of a <i>value type</i> variable or constant is simply a value. For example, the<br>content of the built-in value type, int, is 32 bits of data.<br>You can define a custom value type with the struct keyword (see Figure 2-1):<br>
public struct Point { public int X, Y; }<br>
<i>Figure 2-1. A value type instance in memory</i><br>
The assignment of a value type instance always <i>copies</i> the instance. For example:<br>
static void Main()<br>{<br>  Point p1 = new Point();<br>  p1.X = 7;<br>
  Point p2 = p1;             // Assignment causes copy<br>
  Console.WriteLine (p1.X);  // 7<br>  Console.WriteLine (p2.X);  // 7<br>
  p1.X = 9;                  // Change p1.X<br>
  Console.WriteLine (p1.X);  // 9<br>  Console.WriteLine (p2.X);  // 7<br>}<br>
Figure 2-2 shows that p1 and p2 have independent storage.<br>
<b>Type Basics | 17</b><br>
<hr>
<A name=38></a><i>Figure 2-2. Assignment copies a value-type instance</i><br>
<b>Reference types<br></b>A reference type is more complex than a value type, having two parts: an <i>object</i> and<br>the <i>reference</i> to that object. The content of a reference-type variable or constant is<br>a reference to an object that contains the value. Here is the Point type from our<br>previous example rewritten as a class, rather than a struct (shown in Figure 2-3):<br>
public class Point { public int X, Y; }<br>
<i>Figure 2-3. A reference-type instance in memory</i><br>
Assigning a reference-type variable copies the reference, not the object instance. This<br>allows multiple variables to refer to the same object--something not ordinarily pos-<br>sible with value types. If we repeat the previous example, but with Point now a class,<br>an operation to X affects Y:<br>
static void Main()<br>{<br>  Point p1 = new Point();<br>  p1.X = 7;<br>
  Point p2 = p1;             // Copies p1 reference<br>
  Console.WriteLine (p1.X);  // 7<br>  Console.WriteLine (p2.X);  // 7<br>
  p1.X = 9;                  // Change p1.X<br>
  Console.WriteLine (p1.X);  // 9<br>  Console.WriteLine (p2.X);  // 9<br>
}<br>
Figure 2-4 shows that p1 and p2 are two references that point to the same object.<br>
<b>18 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=39></a><b>C# Basics</b><br>
<i>Figure 2-4. Assignment copies a reference</i><br>
<b>Null<br></b>A reference can be assigned the literal null, indicating that the reference points to<br>no object:<br>
class Point {...}<br>...<br>
Point p = null;<br>
Console.WriteLine (p == null);   // True<br>
// The following line generates a runtime error<br>
// (a NullReferenceException is thrown):<br>
Console.WriteLine (p.X);<br>
In contrast, a value type cannot ordinarily have a null value:<br>
struct Point {...}<br>...<br>
Point p = null;  // Compile-time error<br>int x = null;    // Compile-time error<br>
C# also has a construct called <i>nullable types</i> for representing<br>value-type nulls (see "Nullable Types" on page 148 in Chap-<br>ter 4).<br>
<b>Storage overhead<br></b>Value-type instances occupy precisely the memory required to store their fields. In<br>this example, Point takes eight bytes of memory:<br>
struct Point<br>{<br>  int x;  // 4 bytes<br>  int y;  // 4 bytes<br>}<br>
<b>Type Basics | 19</b><br>
<hr>
<A name=40></a>Technically, the CLR positions fields within the type at an ad-<br>dress that's a multiple of the fields' size (up to a maximum of 8<br>bytes). Thus, the following actually consumes 16 bytes of mem-<br>ory (with the 7 bytes following the first field "wasted"):<br>
struct A { byte b; long l; }<br>
Reference types require separate allocations of memory for the reference and object.<br>The  object  consumes  as  many  bytes  as  its  fields,  plus  additional  administrative<br>overhead.  The  precise  overhead  is  intrinsically  private  to  the  implementation  of<br>the .NET runtime, but at minimum the overhead is eight bytes, used to store a key<br>to  the  object's  type,  as  well  as  temporary  information  such  as  its  lock  state  for<br>multithreading and a flag to indicate whether it has been fixed from movement by<br>the garbage collector. Each reference to an object requires an extra 4 or 8 bytes,<br>depending on whether the .NET runtime is running on a 32- or 64-bit platform.<br>
<b>Predefined Type Taxonomy<br></b>The predefined types in C# are:<br>
<i>Value types</i><br>
· Numeric<br>
-- Signed integer (sbyte, short, int, long)<br>-- Unsigned integer (byte, ushort, uint, ulong)<br>-- Real number (float, double, decimal)<br>
· Logical (bool)<br>· Character (char)<br>
<i>Reference types</i><br>
· String (string)<br>· Object (object)<br>
Predefined types in C# alias Framework types in the System namespace. There is<br>only a syntactic difference between these two statements:<br>
int i = 5;<br>System.Int32 i = 5;<br>
The set of predefined <i>value</i> types excluding decimal are known as <i>primitive types</i> in<br>the CLR. Primitive types are so called because they are supported directly via in-<br>structions in compiled code, and this usually translates to direct support on the<br>underlying processor. For example:<br>
                   <b>// Underlying hexadecimal representation<br></b>int i = 7;         // 0x7<br>bool b = true;     // 0x1<br>char c = 'A';      // 0x41<br>float f = 0.5f;    // uses IEEE floating-point encoding<br>
The System.IntPtr and System.UIntPtr types are also primitive (see Chapter 25).<br>
<b>20 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=41></a><b>Numeric Types<br></b>C# has the predefined numeric types shown in Table 2-1.<br>
<i>Table 2-1. Predefined numeric types in C#</i><br>
<b>C# type</b><br>
<b>System type</b><br>
<b>Suffix</b><br>
<b>Size</b><br>
<b>Range</b><br>
<b>C# Basics</b><br>
<b>Integral--signed</b><br>
sbyte<br>
SByte<br>
 <br>
8 bits<br>
-27 to 27-1<br>
short<br>
Int16<br>
 <br>
16 bits<br>
-215 to 215-1<br>
int<br>
Int32<br>
 <br>
32 bits<br>
-231 to 231-1<br>
long<br>
Int64<br>
L<br>
64 bits<br>
-263 to 263-1<br>
<b>Integral--unsigned</b><br>
byte<br>
Byte<br>
 <br>
8 bits<br>
0 to 28-1<br>
ushort<br>
UInt16<br>
 <br>
16 bits<br>
0 to 216-1<br>
uint<br>
UInt32<br>
U<br>
32 bits<br>
0 to 232-1<br>
ulong<br>
UInt64<br>
UL<br>
64 bits<br>
0 to 264-1<br>
<b>Real</b><br>
float<br>
Single<br>
F<br>
32 bits<br>
± (~10-45 to 1038)<br>
double<br>
Double<br>
D<br>
64 bits<br>
± (~10-324 to 10308)<br>
decimal<br>
Decimal<br>
M<br>
128 bits<br>
± (~10-28 to 1028)<br>
Of the <i>integral</i> types, int and long are first-class citizens and are favored by both C#<br>and the runtime. The other integral types are typically used for interoperability or<br>when space efficiency is paramount.<br>
Of the <i>real</i> number types, float and double are called <i>floating-point types</i> and are<br>typically used for scientific calculations. The decimal type is typically used for fi-<br>nancial  calculations,  where  base-10-accurate  arithmetic  and  high  precision  are<br>required.<br>
<b>Numeric Literals<br></b><i>Integral literals</i> can use decimal or hexadecimal notation; hexadecimal is denoted<br>with the 0x prefix. For example:<br>
int x = 127;<br>long y = 0x7F;<br>
<i>Real literals</i> can use decimal and/or exponential notation. For example:<br>
double d = 1.5;<br>double million = 1E06;<br>
 Technically, decimal is a floating-point type too, although it's not referred to as such in the C#<br>
language specification.<br>
<b>Numeric Types | 21</b><br>
<hr>
<A name=42></a><b>Numeric literal type inference<br></b>By default, the compiler <i>infers</i> a numeric literal to be either double or an integral type:<br>
· If the literal contains a decimal point or the exponential symbol (E), it is a double.<br>· Otherwise, the literal's type is the first type in this list that can fit the literal's<br>
value: int, uint, long, and ulong.<br>
For example:<br>
Console.WriteLine (        1.0.GetType());  // Double  <i>(double)</i><br>
Console.WriteLine (       1E06.GetType());  // Double  <i>(double)</i><br>
Console.WriteLine (          1.GetType());  // Int32   <i>(int)</i><br>
Console.WriteLine ( 0xF0000000.GetType());  // UInt32  <i>(uint)</i><br>
<b>Numeric suffixes<br></b><i>Numeric suffixes</i> explicitly define the type of a literal. Suffixes can be either lower-<br>or uppercase, and are as follows:<br>
<b>Category</b><br>
<b>C# type</b><br>
<b>Notes</b><br>
<b>Example</b><br>
F<br>
float<br>
 <br>
float f = 1.0F;<br>
D<br>
double<br>
 <br>
double d = 1D;<br>
M<br>
decimal<br>
 <br>
decimal d = 1.0M;<br>
U<br>
uint or ulong<br>
Combinable with L<br>
uint i = 1U;<br>
L<br>
long or ulong<br>
Combinable with U<br>
ulong i = 1UL;<br>
The suffixes U and L are rarely necessary, because the uint, long, and ulong types can<br>nearly always be either <i>inferred</i> or <i>implicitly converted</i> from int:<br>
long i = 5;     // Implicit lossless conversion from int literal to long<br>
The D suffix is technically redundant, in that all literals with a decimal point are<br>inferred to be double. And you can always add a decimal point to a numeric literal:<br>
double x = 4.0;<br>
The F and M suffixes are the most useful and should always be applied when speci-<br>fying float or decimal literals. Without the F suffix, the following line would not<br>compile, because 4.5 would be inferred to be of type double, which has no implicit<br>conversion to float:<br>
float f = 4.5F;<br>
The same principle is true for a decimal literal:<br>
decimal d = -1.23M;     // Will not compile without the M suffix.<br>
We describe the semantics of numeric conversions in detail in the following section.<br>
<b>22 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=43></a><b>Numeric Conversions</b><br>
<b>Integral to integral conversions<br></b>Integral conversions are <i>implicit</i> when the destination type can represent every pos-<br>sible value of the source type. Otherwise, an <i>explicit</i> conversion is required. For<br>example:<br>
<b>C# Basics</b><br>
int x = 12345;       // int is a 32-bit integral<br>long y = x;          // Implicit conversion to 64-bit integral<br>
short z = (short)x;  // Explicit conversion to 16-bit integral<br>
<b>Floating-point to floating-point conversions<br></b>A float can be implicitly converted to a double, since a double can represent every<br>possible value of a float. The reverse conversion must be explicit.<br>
<b>Floating-point to integral conversions<br></b>All integral types may be implicitly converted to all floating-point numbers:<br>
int i = 1;<br>
float f = i;<br>
The reverse conversion must be explicit:<br>
int i2 = (int)f;<br>
When you cast from a floating-point number to an integral, any<br>fractional portion is truncated; no rounding is performed. The<br>static class System.Convert provides methods that round while<br>converting between various numeric types (see Chapter 6).<br>
Implicitly converting a large integral type to a floating-point type preserves <i>magni-<br>tude</i> but may occasionally lose <i>precision</i>. This is because floating-point types always<br>have more magnitude than integral types, but may have less precision. Rewriting<br>our example with a larger number demonstrates this:<br>
int i1 = 100000001;<br>float f = i1;          // Magnitude preserved, precision lost<br>int i2 = (int)f;       // 100000000<br>
<b>Decimal conversions<br></b>All integral types can be implicitly converted to the decimal type, since a decimal<br>can represent every possible C# integral value. All other numeric conversions to and<br>from a decimal type must be explicit.<br>
<b>Arithmetic Operators<br></b>The arithmetic operators (+, -, *, /, %) are defined for all numeric types except the<br>8- and 16-bit integral types:<br>
<b>Numeric Types | 23</b><br>
<hr>
<A name=44></a>+    Addition<br>
-    Subtraction<br>*    Multiplication<br>/    Division<br>
%    Remainder after division<br>
<b>Increment and Decrement Operators<br></b>The increment and decrement operators (++, --) increment and decrement numeric<br>types by 1. The operator can either precede or follow the variable, depending on<br>whether you want the variable to be updated <i>before</i> or <i>after</i> the expression is eval-<br>uated. For example:<br>
int x = 0;<br>Console.WriteLine (x++);   // Outputs 0; x is now 1<br>
Console.WriteLine (++x);   // Outputs 2; x is now 2<br>
Console.WriteLine (--x);   // Outputs 1; x is now 1<br>
<b>Specialized Integral Operations</b><br>
<b>Integral division<br></b>Division  operations  on  integral  types  always  truncate  remainders.  Dividing  by  a<br>variable whose value is zero generates a runtime error (a DivideByZeroException):<br>
int a = 2 / 3;      // 0<br>
int b = 0;<br>int c = 5 / b;      // throws DivisionByZeroException<br>
Dividing by the <i>literal</i> 0 generates a compile-time error.<br>
<b>Integral overflow<br></b>At runtime, arithmetic operations on integral types can overflow. By default, this<br>happens silently--no exception is thrown. Although the C# specification is agnostic<br>as to the result of an overflow, the CLR always causes wraparound behavior. For<br>example, decrementing the minimum possible int value results in the maximum<br>possible int value:<br>
int a = int.MinValue;<br>a--;<br>Console.WriteLine (a == int.MaxValue); // True<br>
<b>Integral arithmetic overflow check operators<br></b>The checked operator tells the runtime to generate an OverflowException rather than<br>failing silently when an integral expression or statement exceeds the arithmetic limits<br>of that type. The checked operator affects expressions with the ++, --, +, - (binary<br>and unary), *, /, and explicit conversion operators between integral types.<br>
checked can be used around either an expression or a statement block. For example:<br>
int a = 1000000;<br>int b = 1000000;<br>
<b>24 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=45></a>int c = <b>checked</b> (a * b);      // Checks just the expression.<br>
<b>checked</b>                       // Checks all expressions<br><b>{</b>                             // in statement block.<br>
   ...<br>
   c = a * b;<br>   ...<br>
<b>C# Basics</b><br>
<b>}</b><br>
You can make arithmetic overflow checking the default for all expressions in a pro-<br>gram by compiling with the /checked+ command-line switch (in Visual Studio, go<br>to Advanced Build Settings). If you then need to disable overflow checking just for<br>specific expressions or statements, you can do so with the unchecked operator. For<br>example,  the  following  code  will  not  throw  exceptions--even  if  compiled<br>with /checked+:<br>
int x = int.MaxValue;<br>int y = <b>unchecked</b> (x + 1);<br>
<b>unchecked</b> { int z = x + 1; }<br>
<b>Overflow checking for constant expressions<br></b>Regardless of the /checked compiler switch, expressions evaluated at compile time<br>are always overflow-checked--unless you apply the unchecked operator:<br>
int x = int.MaxValue + 1;               // Compile-time error<br>int y = unchecked (int.MaxValue + 1);   // No errors<br>
<b>Bitwise operators<br></b>C# supports the following bitwise operators:<br>
<b>Operator</b><br>
<b>Meaning</b><br>
<b>Sample expression</b><br>
<b>Result</b><br>
~<br>
Complement<br>
~0xfU<br>
0xfffffff0U<br>
&amp;<br>
And<br>
0xf0 &amp; 0x33<br>
0x30<br>
|<br>
Or<br>
0xf0 | 0x33<br>
0xf3<br>
^<br>
Exclusive Or<br>
0xff00 ^ 0x0ff0<br>
0xf0f0<br>
&lt;&lt;<br>
Shift left<br>
0x20 &lt;&lt; 2<br>
0x80<br>
&gt;&gt;<br>
Shift right<br>
0x20 &gt;&gt; 1<br>
0x10<br>
<b>8- and 16-Bit Integrals<br></b>The 8- and 16-bit integral types are byte, sbyte, short, and ushort. These types lack<br>their own arithmetic operators, so C# implicitly converts them to larger types as<br>required. This can cause a compile-time error when trying to assign the result back<br>to a small integral type:<br>
short x = 1, y = 1;<br>short z = x + y;          // Compile-time error<br>
<b>Numeric Types | 25</b><br>
<hr>
<A name=46></a>In this case, x and y are implicitly converted to int so that the addition can be per-<br>formed. This means the result is also an int, which cannot be implicitly cast back<br>to a short (because it could cause loss of data). To make this compile, we must add<br>an explicit cast:<br>
short z = (short) (x + y);   // OK<br>
<b>Special Float and Double Values<br></b>Unlike integral types, floating-point types have values that certain operations treat<br>specially.  These  special  values  are  NaN  (Not  a  Number),  +,  -,  and  -0.  The<br>float and double classes have constants for NaN, +, and -, as well as other values<br>
(MaxValue, MinValue, and Epsilon). For example:<br>
Console.WriteLine (double.NegativeInfinity);   // -Infinity<br>
The constants that represent special values for double and float are as follows:<br>
<b>Special value</b><br>
<b>Double constant</b><br>
<b>Float constant</b><br>
NaN<br>
double.NaN<br>
float.NaN<br>
+<br>
double.PositiveInfinity<br>
float.PositiveInfinity<br>
-<br>
double.NegativeInfinity<br>
float.NegativeInfinity<br>
-0<br>
-0.0<br>
-0.0f<br>
Dividing a nonzero number by zero results in an infinite value. For example:<br>
Console.WriteLine ( 1.0 /  0.0);                  //  Infinity<br>Console.WriteLine (-1.0 /  0.0);                  // -Infinity<br>
Console.WriteLine ( 1.0 / -0.0);                  // -Infinity<br>Console.WriteLine (-1.0 / -0.0);                  //  Infinity<br>
Dividing zero by zero, or subtracting infinity from infinity, results in a NaN. For<br>example:<br>
Console.WriteLine ( 0.0 /  0.0);                  //  NaN<br>Console.WriteLine ((1.0 /  0.0) - (1.0 / 0.0));   //  NaN<br>
When using ==, a NaN value is never equal to another value, even another NaN<br>value:<br>
Console.WriteLine (0.0 / 0.0 == double.NaN);    // False<br>
To  test  whether  a  value  is  NaN,  you  must  use  the  float.IsNaN  or  double.IsNaN<br>method:<br>
Console.WriteLine (double.IsNaN (0.0 / 0.0));   // True<br>
When using object.Equals, however, two NaN values are equal:<br>
Console.WriteLine (object.Equals (0.0 / 0.0, double.NaN));   // True<br>
<b>26 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=47></a>NaNs are sometimes useful in representing special values. In<br>WPF,  double.NaN  represents  a  measurement  whose  value  is<br>"Automatic." Another way to represent such a value is with a<br>nullable type (Chapter 4); another is with a custom struct that<br>wraps a numeric type and adds an additional field (Chapter 3).<br>
<b>C# Basics</b><br>
float and double follow the specification of the IEEE 754 format types, supported<br>natively by almost all processors. You can find detailed information on the behavior<br>of these types at <i>http://www.ieee.org</i>.<br>
<b>double Versus decimal<br></b>double is useful for scientific computations (such as computing spatial coordinates).<br>decimal is useful for financial computations and values that are "man-made" rather<br>than the result of real-world measurements. Here's a summary of the differences:<br>
<b>Category</b><br>
<b>double</b><br>
<b>decimal</b><br>
Internal representation<br>
Base 2<br>
Base 10<br>
Precision<br>
15-16 significant figures<br>
28-29 significant figures<br>
Range<br>
±(~10-324 to ~10308)<br>
±(~10-28 to ~1028)<br>
Special values<br>
+0, -0, +, -, and NaN<br>
None<br>
Speed<br>
Native to processor<br>
Non-native to processor (about 10 times slower than<br>double)<br>
<b>Real Number Rounding Errors<br></b>float  and  double  1internally  represent  numbers  in  base  2.  For  this  reason,  only<br>numbers expressible in base 2 are represented precisely. Practically, this means most<br>literals with a fractional component (which are in base 10) will not be represented<br>precisely. For example:<br>
float tenth = 0.1f;                       // Not quite 0.1<br>float one   = 1f;<br>Console.WriteLine (one - tenth * 10f);    // -1.490116E-08<br>
This  is  why  float  and  double  are  bad  for  financial  calculations.  In  contrast,<br>decimal works in base 10 and so can precisely represent numbers expressible in base<br>10  (as  well  as  its  factors,  base  2  and  base  5).  Since  real  literals  are  in  base  10,<br>decimal can precisely represent numbers such as 0.1. However, neither double nor<br>decimal can precisely represent a fractional number whose base 10 representation is<br>recurring:<br>
decimal m = 1M / 6M;               // 0.1666666666666666666666666667M<br>
double  d = 1.0 / 6.0;             // 0.16666666666666666<br>
This leads to accumulated rounding errors:<br>
decimal notQuiteWholeM = m+m+m+m+m+m;  // 1.0000000000000000000000000002M<br>double  notQuiteWholeD = d+d+d+d+d+d;  // 0.99999999999999989<br>
<b>Numeric Types | 27</b><br>
<hr>
<A name=48></a>which breaks equality and comparison operations:<br>
Console.WriteLine (notQuiteWholeM == 1M);   // False<br>
Console.WriteLine (notQuiteWholeD &lt; 1.0);   // True<br>
<b>Boolean Type and Operators<br></b>C#'s bool type (aliasing the System.Boolean type) is a logical value that can be as-<br>signed the literal true or false.<br>Although a Boolean value requires only one bit of storage, the runtime will use one<br>byte of memory, since this is the minimum chunk that the runtime and processor<br>can  efficiently  work  with.  To  avoid  space  inefficiency  in  the  case  of  arrays,  the<br>Framework provides a BitArray class in the System.Collections namespace that is<br>designed to use just one bit per Boolean value.<br>
<b>Bool Conversions<br></b>No conversions can be made from the bool type to numeric types or vice versa.<br>
<b>Equality and Comparison Operators<br></b>==  and  !=  test  for  equality  and  inequality  of  any  type,  but  always  return  a  bool<br>value. Value types typically have a very simple notion of equality:<br>
int x = 1;<br>int y = 2;<br>
int z = 1;<br>Console.WriteLine (x == y);         // False<br>
Console.WriteLine (x == z);         // True<br>
For reference types, equality, by default, is based on <i>reference</i>, as opposed to the<br>actual <i>value</i> of the underlying object (more on this in Chapter 6):<br>
public class Dude<br>{<br>  public string Name;<br>  public Dude (string n) { Name = n; }<br>}<br>...<br>Dude d1 = new Dude (&quot;John&quot;);<br>Dude d2 = new Dude (&quot;John&quot;);<br>Console.WriteLine (d1 == d2);       // False<br>Dude d3 = d1;<br>Console.WriteLine (d1 == d3);       // True<br>
The equality and comparison operators, ==, !=, &lt;, &gt;, &gt;=, and &lt;=, work for all numeric<br>types, but should be used with caution with real numbers (as we saw in "Real Num-<br>ber Rounding Errors" on page 27). The comparison operators also work on enum<br>
 It's possible to <i>overload</i> these operators (Chapter 4) such that they return a non-bool type, but<br>
this is almost never done in practice.<br>
<b>28 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=49></a>type members, by comparing their underlying integral values. We describe this in<br>"Enums" on page 97 in Chapter 3.<br>
We explain the equality and comparison operators in greater detail in Chapter 4 in<br>the  sections  "Operator  Overloading"  on  page  153  and  "Equality  Compari-<br>son" on page 245 and in the section "Order Comparison" on page 255 in Chapter 6.<br>
<b>Conditional Operators</b><br>
<b>C# Basics</b><br>
The &amp;&amp; and || operators test for <i>and</i> and <i>or</i> conditions. They are frequently used in<br>conjunction  with  the  !  operator,  which  expresses  <i>not</i>.  In  this  example,  the<br>UseUmbrella method returns true if it's rainy or sunny (to protect us from the rain<br>or the sun), as long as it's not also windy (since umbrellas are useless in the wind):<br>
static bool UseUmbrella (bool rainy, bool sunny, bool windy)<br>{<br>  return !windy &amp;&amp; (rainy || sunny);<br>
}<br>
The &amp;&amp; and || operators <i>short-circuit</i> evaluation when possible. In the preceding<br>example, if it is windy, the expression (rainy || sunny) is not even evaluated. Short-<br>circuiting is essential in allowing expressions such as the following to run without<br>throwing a NullReferenceException:<br>
if (sb != null &amp;&amp; sb.Length &gt; 0) ...<br>
The &amp; and | operators also test for <i>and</i> and <i>or</i> conditions:<br>
return !windy &amp; (rainy | sunny);<br>
The difference is that they <i>do not short-circuit</i>. For this reason, they are rarely used<br>in place of conditional operators.<br>
Unlike in C and C++, the &amp; and | operators perform (non-short-<br>circuiting) <i>boolean</i> comparisons when applied to bool expres-<br>sions. The &amp; and | operators perform <i>bitwise</i> operations only<br>when applied to numbers.<br>
The ternary conditional operator (simply called the <i>conditional operator</i>) has the<br>form q ? a : b, where if condition q is true, a is evaluated, else b is evaluated. For<br>example:<br>
static int Max (int a, int b)<br>{<br>  return (a &gt; b) ? a : b;<br>}<br>
The conditional operator is particularly useful in LINQ queries (Chapter 8).<br>
<b>Boolean Type and Operators | 29</b><br>
<hr>
<A name=50></a><b>Strings and Characters<br></b>C#'s char type (aliasing the System.Char type) represents a Unicode character and<br>occupies two bytes. A char literal is specified inside single quotes:<br>
char c = 'A';       // Simple character<br>
<i>Escape sequences</i> express characters that cannot be expressed or interpreted literally.<br>An escape sequence is a backslash followed by a character with a special meaning.<br>For example:<br>
char newLine = '\n';<br>char backSlash = '\\';<br>
The escape sequence characters are shown in Table 2-2.<br>
<i>Table 2-2. Escape sequence characters</i><br>
<b>Char</b><br>
<b>Meaning</b><br>
<b>Value</b><br>
\'<br>
Single quote<br>
0x0027<br>
\&quot;<br>
Double quote<br>
0x0022<br>
\\<br>
Backslash<br>
0x005C<br>
\0<br>
Null<br>
0x0000<br>
\a<br>
Alert<br>
0x0007<br>
\b<br>
Backspace<br>
0x0008<br>
\f<br>
Form feed<br>
0x000C<br>
\n<br>
New line<br>
0x000A<br>
\r<br>
Carriage return<br>
0x000D<br>
\t<br>
Horizontal tab<br>
0x0009<br>
\v<br>
Vertical tab<br>
0x000B<br>
The \u (or \x) escape sequence lets you specify any Unicode character via its four-<br>digit hexadecimal code:<br>
char copyrightSymbol = '\u00A9';<br>char omegaSymbol     = '\u03A9';<br>char newLine         = '\u000A';<br>
<b>Char Conversions<br></b>An implicit conversion from a char to a numeric type works for the numeric types<br>that can accommodate an unsigned short. For other numeric types, an explicit con-<br>version is required.<br>
<b>String Type<br></b>C#'s string type (aliasing the System.String type, covered in depth in Chapter 6)<br>represents an immutable sequence of Unicode characters. A string literal is specified<br>inside double quotes:<br>
<b>30 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=51></a>string a = &quot;Heat&quot;;<br>
string is a reference type, rather than a value type. Its equality<br>operators, however, follow value-type semantics:<br>
string a = &quot;test&quot;;<br>
string b = &quot;test&quot;;<br>
Console.Write (a == b);  // True<br>
<b>C# Basics</b><br>
The escape sequences that are valid for char literals also work inside strings:<br>
string a = &quot;Here's a tab:<b>\t</b>&quot;;<br>
The cost of this is that whenever you need a literal backslash, you must write it twice:<br>
string a1 = &quot;\\\\server\\fileshare\\helloworld.cs&quot;;<br>
To avoid this problem, C# allows <i>verbatim</i> string literals. A verbatim string literal<br>is prefixed with @ and does not support escape sequences. The following verbatim<br>string is identical to the preceding one:<br>
string a2 = <b>@</b> &quot;\\server\fileshare\helloworld.cs&quot;;<br>
A verbatim string literal can also span multiple lines:<br>
string escaped  = &quot;First Line\r\nSecond Line&quot;;<br>
string verbatim = @&quot;First Line<br>Second Line&quot;;<br>
// Assuming your IDE uses CR-LF line separators:<br>
Console.WriteLine (escaped == verbatim);  // True<br>
You can include the double-quote character in a verbatim literal by writing it twice:<br>
string xml = @&quot;&lt;customer id=&quot;&quot;123&quot;&quot;&gt;&lt;/customer&gt;&quot;;<br>
<b>String concatenation<br></b>The + operator concatenates two strings:<br>
string s = &quot;a&quot; + &quot;b&quot;;<br>
The righthand operand may be a nonstring value, in which case ToString is called<br>on that value. For example:<br>
string s = &quot;a&quot; + 5;  // a5<br>
Since string is immutable, using the + operator repeatedly to build up a string is<br>inefficient: a better solution is to use the System.Text.StringBuilder type (described<br>in Chapter 6).<br>
<b>String comparisons<br></b>string does not support &lt; and &gt; operators for comparisons. You must use the string's<br>CompareTo method, described in Chapter 6.<br>
<b>Strings and Characters | 31</b><br>
<hr>
<A name=52></a><b>Arrays<br></b>An array represents a fixed number of elements of a particular type. The elements<br>in an array are always stored in a contiguous block of memory, providing highly<br>efficient access.<br>
An array is denoted with square brackets after the element type. For example:<br>
char[] vowels = new char[5];    // Declare an array of 5 characters<br>
Square brackets also <i>index</i> the array, accessing a particular element by position:<br>
vowels [0] = 'a';<br>
vowels [1] = 'e';<br>
vowels [2] = 'i';<br>vowels [3] = 'o';<br>
vowels [4] = 'u';<br>
Console.WriteLine (vowels [1]);      // e<br>
This prints "e" because array indexes start at 0. We can use a for loop statement to<br>iterate through each element in the array. The for loop in this example cycles the<br>integer i from 0 to 4:<br>
for (int i = 0; i &lt; vowels.Length; i++)<br>
  Console.Write (vowels [i]);            // aeiou<br>
The Length property of an array returns the number of elements in the array. Once<br>an array has been created, its length cannot be changed. The System.Collection<br>namespace  and  subnamespaces  provide  higher-level  data  structures,  such  as  dy-<br>namically sized arrays and dictionaries.<br>
An <i>array initialization expression</i> specifies each element of an array. For example:<br>
char[] vowels = new char[] {'a','e','i','o','u'};<br>
or simply:<br>
char[] vowels = {'a','e','i','o','u'};<br>
All arrays inherit from the System.Array class, providing common services for all<br>arrays. These members include methods to get and set elements regardless of the<br>array type, and are described in "The Array Class" on page 273 in Chapter 7.<br>
<b>Default Element Initialization<br></b>Creating an array always preinitializes the elements with default values. The default<br>value for a type is the result of a bitwise zeroing of memory. For example, consider<br>creating an array of integers. Since int is a value type, this allocates 1,000 integers<br>in one contiguous block of memory. The default value for each element will be 0:<br>
int[] a = new int[1000];<br>Console.Write (a[123]);            // 0<br>
<b>32 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=53></a><b>Value types versus reference types<br></b>Whether an array element type is a value type or a reference type has important<br>performance implications. When the element type is a value type, each element value<br>is allocated as part of the array. For example:<br>
public <b>struct</b> Point { public int X, Y; }<br>...<br>
<b>C# Basics</b><br>
Point[] a = new Point[1000];<br>
int x = a[500].X;                  // 0<br>
Had Point been a class, creating the array would have merely allocated 1,000 null<br>references:<br>
public <b>class</b> Point { public int X, Y; }<br>
...<br>
Point[] a = new Point[1000];<br>
int x = a[500].X;                  // Runtime error, NullReferenceException<br>
To avoid this error, we must explicitly instantiate 1,000 Points after instantiating<br>the array:<br>
Point[] a = new Point[1000];<br>
for (int i = 0; i &lt; a.Length; i++) // Iterate i from 0 to 999<br>   a[i] = new Point();             // Set array element i with new point<br>
An array <i>itself</i> is always a reference type object, regardless of the element type. For<br>instance, the following is legal:<br>
int[] a = null;<br>
<b>Multidimensional Arrays<br></b>Multidimensional arrays come in two varieties: <i>rectangular</i> and <i>jagged</i>. Rectangular<br>arrays represent an <i>n</i>-dimensional block of memory, and jagged arrays are arrays of<br>arrays.<br>
<b>Rectangular arrays<br></b>Rectangular  arrays  are  declared  using  commas  to  separate  each  dimension.  The<br>following declares a rectangular two-dimensional array, where the dimensions are<br>3 by 3:<br>
int [,] matrix = new int [3, 3];<br>
The GetLength method of an array returns the length for a given dimension (starting<br>at 0):<br>
for (int i = 0; i &lt; matrix.GetLength(0); i++)<br>  for (int j = 0; j &lt; matrix.GetLength(1); j++)<br>    matrix [i, j] = i * 3 + j;<br>
A rectangular array can be initialized as follows (each element in this example is<br>initialized to be identical to the previous example):<br>
<b>Arrays | 33</b><br>
<hr>
<A name=54></a>int[,] matrix = new int[,]<br>
{<br>  {0,1,2},<br>  {3,4,5},<br>
  {6,7,8}<br>
};<br>
<b>Jagged arrays<br></b>Jagged arrays are declared using successive square brackets to represent each di-<br>mension. Here is an example of declaring a jagged two-dimensional array, where<br>the outermost dimension is 3:<br>
int [][] matrix = new int [3][];<br>
The inner dimensions aren't specified in the declaration. Unlike a rectangular array,<br>each inner array can be an arbitrary length. Each inner array is implicitly initialized<br>to null rather than an empty array. Each inner array must be created manually:<br>
for (int i = 0; i &lt; matrix.Length; i++)<br>
{<br>  matrix[i] = new int [3];                    // Create inner array<br>  for (int j = 0; j &lt; matrix[i].Length; j++)<br>
    matrix[i][j] = i * 3 + j;<br>
}<br>
A jagged array can be initialized as follows (each element in this example is initialized<br>to be identical to the previous example):<br>
int[][] matrix = new int[][]<br>{<br>  new int[] {0,1,2},<br>  new int[] {3,4,5},<br>  new int[] {6,7,8}<br>};<br>
<b>Simplified Array Initialization Expressions<br></b>There are two ways to shorten array initialization expressions. The first is to omit<br>the new operator and type qualifications:<br>
char[] vowels = {'a','e','i','o','u'};<br>
int[,] rectangularMatrix =<br>{<br>  {0,1,2},<br>  {3,4,5},<br>  {6,7,8}<br>};<br>
int[][] jaggedMatrix =<br>{<br>  new int[] {0,1,2},<br>  new int[] {3,4,5},<br>  new int[] {6,7,8}<br>};<br>
<b>34 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=55></a>The second approach is to use the var keyword, which tells the compiler to implicitly<br>type a local variable:<br>
var i = 3;           // i is implicitly of type int<br>var s = &quot;sausage&quot;;   // s is implicitly of type string<br>
// Therefore:<br>
var rectMatrix = new int[,]    // rectMatrix is implicitly of type int[,]<br>
<b>C# Basics</b><br>
{<br>  {0,1,2},<br>
  {3,4,5},<br>
  {6,7,8}<br>
};<br>
var jaggedMat = new int[][]    // jaggedMat is implicitly of type int[][]<br>
{<br>  new int[] {0,1,2},<br>  new int[] {3,4,5},<br>  new int[] {6,7,8}<br>
};<br>
Implicit typing can be taken one stage further with single-dimensional arrays. You<br>can omit the type qualifier after the new keyword and have the compiler <i>infer</i> the<br>array type:<br>
var vowels = new[] {'a','e','i','o','u'};   // Compiler infers char[]<br>
The elements must all be implicitly convertible to a single type in order for implicit<br>array typing to work. For example:<br>
var x = new[] {1,10000000000};   // all convertible to long<br>
<b>Bounds Checking<br></b>All array indexing is bounds-checked by the runtime. If you use an invalid index, an<br>IndexOutOfRangeException is thrown:<br>
int[] arr = new int[3];<br>arr[3] = 1;               // IndexOutOfRangeException thrown<br>
As  with  Java,  array  bounds  checking  is  necessary  for  type  safety  and  simplifies<br>debugging.<br>
Generally, the performance hit from bounds checking is minor,<br>and the JIT (Just-in-Time) compiler can perform optimizations,<br>such as determining in advance whether all indexes will be safe<br>before entering a loop, thus avoiding a check on each iteration.<br>In addition, C# provides "unsafe" code that can explicitly by-<br>pass bounds checking (see the section "Unsafe Code and Point-<br>ers" on page 170 in Chapter 4).<br>
<b>Arrays | 35</b><br>
<hr>
<A name=56></a><b>Variables and Parameters<br></b>A variable represents a storage location that has a modifiable value. A variable can<br>be a <i>local variable</i>, <i>parameter</i> (<i>value</i>, <i>ref</i>, or <i>out</i>), <i>field</i> (<i>instance</i> or <i>static</i>), or <i>array<br>element</i>.<br>
<b>The Stack and the Heap<br></b>The stack and the heap are the places where variables and constants reside. Each<br>has very different lifetime semantics.<br>
<b>Stack<br></b>The stack is a block of memory for storing local variables and parameters. The stack<br>logically grows and shrinks as a function is entered and exited. Consider the fol-<br>lowing method (to avoid distraction, input argument checking is ignored):<br>
static int Factorial (int x)<br>
{<br>  if (x == 0) return 1;<br>
  return x * Factorial (x-1);<br>}<br>
This method is recursive, meaning that it calls itself. Each time the method is entered,<br>a  new  int  is  allocated  on  the  stack,  and  each  time  the  method  exits,  the  int  is<br>deallocated.<br>
<b>Heap<br></b>The heap is a block of memory in which <i>objects</i> (i.e., reference-type instances) reside.<br>Whenever a new object is created, it is allocated on the heap, and a reference to that<br>object is returned. During a program's execution, the heap starts filling up as new<br>objects are created. The runtime has a garbage collector that periodically deallocates<br>objects from the heap, so your computer does not run out of memory. An object is<br>eligible for deallocation as soon as nothing references it.<br>
In the following example, we start by creating a StringBuilder object referenced by<br>the variable ref1, and then write out its content. That StringBuilder object is then<br>immediately eligible for garbage collection, because nothing subsequently uses it.<br>
Then, we create another StringBuilder referenced by variable ref2, and copy that<br>reference to ref3. Even though ref2 is not used after that point, ref3 keeps the same<br>StringBuilder object alive--ensuring that it doesn't become eligible for collection<br>until we've finished using ref3.<br>
using System;<br>using System.Text;<br>
class Test<br>{<br>  static void Main()<br>  {<br>    StringBuilder ref1 = new StringBuilder (&quot;object1&quot;);<br>
<b>36 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=57></a>    Console.WriteLine (ref1);<br>
    // The StringBuilder referenced by ref1 is now eligible for GC.<br>
    StringBuilder ref2 = new StringBuilder (&quot;object2&quot;);<br>
    StringBuilder ref3 = ref2;<br>
    // The StringBuilder referenced by ref2 is NOT yet eligible for GC.<br>
    Console.WriteLine (ref3);                   // object2<br>
<b>C# Basics</b><br>
  }<br>
}<br>
Value-type instances (and object references) live wherever the variable was declared.<br>If the instance was declared as a field within an object, or as an array element, that<br>instance lives on the heap.<br>
You can't explicitly delete objects in C#, as you can in C++. An<br>unreferenced  object  is  eventually  collected  by  the  garbage<br>collector.<br>
The heap also stores static fields and constants. Unlike objects allocated on the heap<br>(which can get garbage-collected), these live until the application domain is torn<br>down.<br>
<b>Definite Assignment<br></b>C# enforces a definite assignment policy. In practice, this means that outside of an<br>unsafe context, it's impossible to access uninitialized memory. Definite assignment<br>has three implications:<br>
· Local variables must be assigned a value before they can be read.<br>· Function arguments must be supplied when a method is called.<br>· All other variables (such as fields and array elements) are automatically initial-<br>
ized by the runtime.<br>
For example, the following code results in a compile-time error:<br>
static void Main()<br>{<br>  int x;<br>  Console.WriteLine (x);        // Compile-time error<br>}<br>
Fields and array elements are automatically initialized with the default values for<br>their type. The following code outputs 0, because array elements are implicitly as-<br>signed to their default values:<br>
static void Main()<br>{<br>  int[] ints = new int[2];<br>  Console.WriteLine (ints[0]);    // 0<br>}<br>
<b>Variables and Parameters | 37</b><br>
<hr>
<A name=58></a>The following code outputs  0, because fields are implicitly assigned to a default<br>value:<br>
class Test<br>{<br>  static int x;<br>
  static void Main() { Console.WriteLine (x); }   // 0<br>}<br>
<b>Default Values<br></b>All type instances have a default value. The default value for the predefined types is<br>the result of a bitwise zeroing of memory:<br>
<b>Type</b><br>
<b>Default value</b><br>
All reference types<br>
null<br>
All numeric and enum types<br>
0<br>
char type<br>
'\0'<br>
bool type<br>
false<br>
You can obtain the default value for any type using the default keyword (in practice,<br>this is useful with generics, which we'll cover in Chapter 3):<br>
decimal d = default (decimal);<br>
The default value in a custom value type (i.e., struct) is the same as the default value<br>for each field defined by the custom type.<br>
<b>Parameters<br></b>A method has a sequence of parameters. Parameters define the set of arguments that<br>must be provided for that method. In this example, the method Foo has a single<br>parameter named p, of type int:<br>
static void Foo (int p)<br>{<br>  p = p + 1;                // Increment p by 1<br>  Console.WriteLine(p);     // Write p to screen<br>}<br>static void Main() { Foo (8); }<br>
You can control how parameters are passed with the ref and out modifiers:<br>
<b>Parameter modifier</b><br>
<b>Passed by</b><br>
<b>Variable must be definitely assigned</b><br>
None<br>
Value<br>
Going in<br>
ref<br>
Reference<br>
Going in<br>
out<br>
Reference<br>
Going out<br>
<b>38 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=59></a><b>Passing arguments by value<br></b>By default, arguments in C# are <i>passed by value</i>, which is by far the most common<br>case. This means a copy of the value is created when passed to the method:<br>
class Test<br>{<br>  static void Foo (int p)<br>
  {<br>
<b>C# Basics</b><br>
    p = p + 1;                // Increment p by 1<br>    Console.WriteLine (p);    // Write p to screen<br>  }<br>
  static void Main()<br>
  {<br>    int x = 8;<br>
    Foo (x);                  // Make a copy of x<br>    Console.WriteLine (x);    // x will still be 8<br>
  }<br>}<br>
Assigning p a new value does not change the contents of x, since p and x reside in<br>different memory locations.<br>
Passing a reference-type argument by value copies the <i>reference</i>, but not the object.<br>In the following example, Foo sees the same StringBuilder object that Main instan-<br>tiated, but has an independent <i>reference</i> to it. In other words, sb and fooSB are sep-<br>arate variables that reference the same StringBuilder object:<br>
class Test<br>
{<br>  static void Foo (StringBuilder fooSB)<br>  {<br>    fooSB.Append (&quot;test&quot;);<br>    fooSB = null;<br>  }<br>
  static void Main()<br>  {<br>    StringBuilder sb = new StringBuilder();<br>    Foo (sb);<br>    Console.WriteLine (sb.ToString());    // test<br>  }<br>}<br>
Because fooSB is a <i>copy</i> of a reference, setting it to null doesn't make sb null. (If,<br>however, fooSB was declared and called with the ref modifier, sb <i>would</i> become<br>null.)<br>
<b>The ref modifier<br></b>To <i>pass by reference</i>, C# provides the ref parameter modifier. In the following ex-<br>ample, p and x refer to the same memory locations:<br>
class Test<br>{<br>
<b>Variables and Parameters | 39</b><br>
<hr>
<A name=60></a>  static void Foo (<b>ref</b> int p)<br>
  {<br>    p = p + 1;               // Increment p by 1<br>    Console.WriteLine (p);   // Write p to screen<br>
  }<br>
  static void Main()<br>  {<br>
    int x = 8;<br>
    Foo (<b>ref</b>  x);            // Ask Foo to deal directly with x<br>    Console.WriteLine (x);   // x is now 9<br>  }<br>
}<br>
Now assigning p a new value changes the contents of x. Notice how the ref modifier<br>is required both when writing and when calling the method.§ This makes it very<br>clear what's going on.<br>
The  ref  modifier  is  essential  in  implementing  a  swap  method  (later,  in  "Gener-<br>ics" on page 101 in Chapter 3, we will show how to write a swap method that works<br>with any type):<br>
class Test<br>{<br>  static void Swap (ref string a, ref string b)<br>
  {<br>
    string temp = a;<br>    a = b;<br>    b = temp;<br>  }<br>
  static void Main()<br>  {<br>    string x = &quot;Penn&quot;;<br>    string y = &quot;Teller&quot;;<br>    Swap (ref x, ref y);<br>    Console.WriteLine (x);   // Teller<br>    Console.WriteLine (y);   // Penn<br>  }<br>}<br>
A parameter can be passed by reference or by value, regardless<br>of whether the parameter type is a reference type or a value type.<br>
<b>The out modifier<br></b>An out argument is like a ref argument, except it:<br>
· Need not be assigned before going into the function<br>
§ An exception to this rule is when calling COM methods. We discuss this in Chapter 25.<br>
<b>40 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=61></a>· Must be assigned before it comes <i>out</i> of the function<br>
The out modifier is most commonly used to get multiple return values back from a<br>method. For example:<br>
class Test<br>
{<br>  static void Split (string name, out string firstNames,<br>
                     out string lastName)<br>
<b>C# Basics</b><br>
  {<br>
     int i = name.LastIndexOf (' ');<br>
     firstNames = name.Substring (0, i);<br>     lastName   = name.Substring (i + 1);<br>
  }<br>
  static void Main()<br>  {<br>    string a, b;<br>
    Split (&quot;Stevie Ray Vaughn&quot;, out a, out b);<br>
    Console.WriteLine (a);                      // Stevie Ray<br>
    Console.WriteLine (b);                      // Vaughn<br>  }<br>
}<br>
Like a ref parameter, an out parameter is passed by reference.<br>
<b>Implications of passing by reference<br></b>When you pass an argument by reference, you alias the storage location of an existing<br>variable rather than create a new storage location. In the following example, the<br>variables x and y represent the same instance:<br>
class Test<br>{<br>  static int x;<br>
  static void Main() { Foo (out x); }<br>
  static void Foo (out int y)<br>  {<br>    Console.WriteLine (x);                // x is 0<br>    y = 1;                                // Mutate y<br>    Console.WriteLine (x);                // x is 1<br>  }<br>}<br>
<b>The params modifier<br></b>The params parameter modifier may be specified on the last parameter of a method<br>so  that  the  method  accepts  any  number  of  parameters  of  a  particular  type.  The<br>parameter type must be declared as an array. For example:<br>
class Test<br>{<br>  static int Sum (params int[] ints)<br>  {<br>    int sum = 0;<br>
<b>Variables and Parameters | 41</b><br>
<hr>
<A name=62></a>    for (int i = 0; i &lt; ints.Length; i++)<br>
      sum += ints[i];                       // Increase sum by ints[i]<br>    return sum;<br>  }<br>
  static void Main()<br>  {<br>    int total = Sum (1, 2, 3, 4);<br>
    Console.WriteLine (total);              // 10<br>
  }<br>}<br>
You can also supply a params argument as an ordinary array. The first line in Main is<br>semantically equivalent to this:<br>
int total = Sum (new int[] { 1, 2, 3, 4 } );<br>
<b>Optional parameters (C# 4.0)<br></b>From C# 4.0, methods, constructors, and indexers (Chapter 3) can declare <i>optional<br>parameters</i>. A parameter is optional if it specifies a <i>default value</i> in its declaration:<br>
void Foo (int <b>x = 23</b>) { Console.WriteLine (x); }<br>
Optional parameters may be omitted when calling the method:<br>
Foo();     // 23<br>
The <i>default argument</i> of 23 is actually <i>passed</i> to the optional parameter x--the com-<br>piler bakes the value 23 into the compiled code at the <i>calling</i> side. The preceding<br>call to Foo is semantically identical to:<br>
Foo (23);<br>
because the compiler simply substitutes the default value of an optional parameter<br>wherever it is used.<br>
Adding an optional parameter to a public method that's called<br>from another assembly requires recompilation of both assem-<br>blies--just as though the parameter were mandatory.<br>
The default value of an optional parameter must be specified by a constant expres-<br>sion, or a parameterless constructor of a value type. Optional parameters cannot be<br>marked with ref or out.<br>Mandatory parameters must occur <i>before</i> optional parameters in both the method<br>declaration and the method call (the exception is with params arguments, which still<br>always come last). In the following example, the explicit value of 1 is passed to x,<br>and the default value of 0 is passed to y:<br>
void Foo (int x = 0, int y = 0) { Console.WriteLine (x + &quot;, &quot; + y); }<br>
void Test()<br>{<br>  Foo(1);    // 1, 0<br>}<br>
<b>42 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=63></a>To do the converse (pass a default value to x and an explicit value to y), you must<br>combine optional parameters with <i>named arguments</i>.<br>
<b>Named arguments (C# 4.0)<br></b>Rather than identifying an argument by position, you can identify an argument by<br>name. For example:<br>
<b>C# Basics</b><br>
void Foo (int x, int y) { Console.WriteLine (x + &quot;, &quot; + y); }<br>
void Test()<br>{<br>  Foo (<b>x:1, y:2</b>);  // 1, 2<br>
}<br>
Named arguments can occur in any order. The following calls to Foo are semantically<br>identical:<br>
Foo (x:1, y:2);<br>
Foo (y:2, x:1);<br>
A subtle difference is that argument expressions are evaluated<br>in the order in which they appear at the <i>calling</i> site. In general,<br>this makes a difference only with interdependent side-effecting<br>expressions such as the following, which writes 0, 1:<br>
int a = 0;<br>Foo (y: ++a, x: --a);  // ++a is evaluated first<br>
Of course, you would almost certainly avoid writing such code<br>in practice!<br>
You can mix named and positional parameters:<br>
Foo (1, y:2);<br>
However, there is a restriction: positional parameters must come before named ar-<br>guments. So we couldn't call Foo like this:<br>
Foo (x:1, 2);         // Compile-time error<br>
Named arguments are particularly useful in conjunction with optional parameters.<br>For instance, consider the following method:<br>
void Bar (int a = 0, int b = 0, int c = 0, int d = 0) { ... }<br>
We can call this supplying only a value for d as follows:<br>
Bar (d:3);<br>
This is particularly useful when calling COM APIs, and is discussed in detail in<br>Chapter 25.<br>
<b>Variables and Parameters | 43</b><br>
<hr>
<A name=64></a><b>var--Implicitly Typed Local Variables<br></b>It is often the case that you declare and initialize a variable in one step. If the compiler<br>is able to infer the type from the initialization expression, you can use the keyword <br>var (introduced in C# 3.0) in place of the type declaration. For example:<br>
var x = &quot;hello&quot;;<br>var y = new System.Text.StringBuilder();<br>
var z = (float)Math.PI;<br>
This is precisely equivalent to:<br>
string x = &quot;hello&quot;;<br>
System.Text.StringBuilder y = new System.Text.StringBuilder();<br>
float z = (float)Math.PI;<br>
Because of this direct equivalence, implicitly typed variables are statically typed. For<br>example, the following generates a compile-time error:<br>
var x = 5;<br>
x = &quot;hello&quot;;    // Compile-time error; x is of type int<br>
var  can  decrease  code  readability  in  the  case  when  <i>you  can't<br>deduce the type purely by looking at the variable declaration</i>. For<br>example:<br>
Random r = new Random();<br>
var x = r.Next();<br>
What type is x?<br>
In "Anonymous Methods" on page 134 in Chapter 4, we will describe a scenario<br>where the use of var is mandatory.<br>
<b>Expressions and Operators<br></b>An  <i>expression</i>  essentially  denotes  a  value.  The  simplest  kinds  of  expressions  are<br>constants and variables. Expressions can be transformed and combined using op-<br>erators. An <i>operator</i> takes one or more input <i>operands</i> to output a new expression.<br>
Here is an example of a <i>constant expression</i>:<br>
12<br>
We can use the * operator to combine two operands (the literal expressions 12 and<br>30), as follows:<br>
12 * 30<br>
Complex expressions can be built because an operand may itself be an expression,<br>such as the operand (12 * 30) in the following example:<br>
1 + (12 * 30)<br>
<b>44 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=65></a>Operators in C# are classed as <i>unary</i>, <i>binary</i>, or <i>ternary</i>--depending on the number<br>of operands they work on (one, two, or three). The binary operators always use<br><i>infix</i> notation, where the operator is placed <i>between</i> the two operands.<br>
<b>Primary Expressions<br></b>Primary expressions include expressions composed of operators that are intrinsic to<br>the basic plumbing of the language. Here is an example:<br>
<b>C# Basics</b><br>
Math.Log (1)<br>
This expression is composed of two primary expressions. The first expression per-<br>forms a member-lookup (with the . operator), and the second expression performs<br>a method call (with the () operator).<br>
<b>Void Expressions<br></b>A void expression is an expression that has no value. For example:<br>
Console.WriteLine (1)<br>
A void expression, since it has no value, cannot be used as an operand to build more<br>complex expressions:<br>
1 + Console.WriteLine (1)      // Compile-time error<br>
<b>Assignment Expressions<br></b>An assignment expression uses the = operator to assign the result of another expres-<br>sion to a variable. For example:<br>
x = x * 5<br>
An assignment expression is not a void expression. It actually carries the assignment<br>value, and so can be incorporated into another expression. In the following example,<br>the expression assigns 2 to x and 10 to y:<br>
y = 5 * (x = 2)<br>
This style of expression can be used to initialize multiple values:<br>
a = b = c = d = 0<br>
The <i>compound assignment operators</i> are syntactic shortcuts that combine assign-<br>ment with another operator. For example:<br>
x *= 2    // equivalent to x = x * 2<br>x &lt;&lt;= 1   // equivalent to x = x &lt;&lt; 1<br>
(A subtle exception to this rule is with <i>events</i>, which we describe in Chapter 4: the<br>+=  and  -=  operators  here  are  treated  specially  and  map  to  the  event's  add  and<br>remove accessors.)<br>
<b>Expressions and Operators | 45</b><br>
<hr>
<A name=66></a><b>Operator Precedence and Associativity<br></b>When an expression contains multiple operators, <i>precedence</i> and <i>associativity</i> de-<br>termine the order of evaluation. Operators with higher precedence execute before<br>operators of lower precedence. If the operators have the same precedence, the op-<br>erator's associativity determines the order of evaluation.<br>
<b>Precedence<br></b>The following expression:<br>
1 + 2 * 3<br>
is evaluated as follows because * has a higher precedence than +:<br>
1 + (2 * 3)<br>
<b>Left-associative operators<br></b>Binary operators (except for assignment, lambda, and null coalescing operators) are<br><i>left-associative</i>; in other words, they are evaluated from left to right. For example,<br>the following expression:<br>
8 / 4 / 2<br>
is evaluated as follows due to left associativity:<br>
( 8 / 4 ) / 2    // 1<br>
You can insert parentheses to change the actual order of evaluation:<br>
8 / ( 4 / 2 )    // 4<br>
<b>Right-associative operators<br></b>The  <i>assignment  operators</i>,  lambda,  null  coalescing,  and  conditional  operator  are<br><i>right-associative</i>; in other words, they are evaluated from right to left. Right asso-<br>ciativity allows multiple assignments such as the following to compile:<br>
x = y = 3;<br>
This first assigns 3 to y, and then assigns the result of that expression (3) to x.<br>
<b>Operator Table<br></b>Table 2-3 lists C#'s operators in order of precedence. Operators in the same category<br>have the same precedence. We explain user-overloadable operators in "Operator<br>Overloading" on page 153 in Chapter 4.<br>
<i>Table 2-3. C# operators (categories in order of precedence)</i><br>
<b>User-</b><br>
<b>Category</b><br>
<b>Operator symbol</b><br>
<b>Operator name</b><br>
<b>Example</b><br>
<b>overloadable</b><br>
Primary<br>
()<br>
Grouping<br>
while(x)<br>
No<br>
 <br>
.<br>
Member access<br>
x.y<br>
No<br>
<b>46 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=67></a><b>User-</b><br>
<b>Category</b><br>
<b>Operator symbol</b><br>
<b>Operator name</b><br>
<b>Example</b><br>
<b>overloadable</b><br>
 <br>
-&gt;<br>
Pointer to struct (un-<br>
x-&gt;y<br>
No<br>
safe)<br>
 <br>
()<br>
Function call<br>
x()<br>
No<br>
 <br>
[]<br>
Array/index<br>
a[x]<br>
Via indexer<br>
<b>C# Basics</b><br>
 <br>
++<br>
Post-increment<br>
x++<br>
Yes<br>
 <br>
--<br>
Post-decrement<br>
x--<br>
Yes<br>
 <br>
new<br>
Create instance<br>
new Foo()<br>
No<br>
 <br>
stackalloc<br>
Unsafe stack alloca-<br>
stackalloc(10)<br>
No<br>
tion<br>
 <br>
typeof<br>
Get type from identi-<br>
typeof(int)<br>
No<br>
fier<br>
 <br>
checked<br>
Integral overflow<br>
checked(x)<br>
No<br>
check on<br>
 <br>
unchecked<br>
Integral overflow<br>
unchecked(x)<br>
No<br>
check off<br>
Unary<br>
sizeof<br>
Get size of struct<br>
sizeof(int)<br>
No<br>
 <br>
+<br>
Positive value of<br>
+x<br>
Yes<br>
 <br>
-<br>
Negative value of<br>
-x<br>
Yes<br>
 <br>
!<br>
Not<br>
!x<br>
Yes<br>
 <br>
<br>
Bitwise complement<br>
x<br>
Yes<br>
 <br>
++<br>
Pre-increment<br>
++x<br>
Yes<br>
 <br>
--<br>
Pre-decrement<br>
--x<br>
Yes<br>
 <br>
()<br>
Cast<br>
(int)x<br>
No<br>
 <br>
*<br>
Value at address (un-<br>
*x<br>
No<br>
safe)<br>
 <br>
&amp;<br>
Address of value (un-<br>
&amp;x<br>
No<br>
safe)<br>
Multiplicative<br>
*<br>
Multiply<br>
x * y<br>
Yes<br>
 <br>
/<br>
Divide<br>
x / y<br>
Yes<br>
 <br>
%<br>
Remainder<br>
x % y<br>
Yes<br>
Additive<br>
+<br>
Add<br>
x + y<br>
Yes<br>
 <br>
-<br>
Subtract<br>
x - y<br>
Yes<br>
Shift<br>
&lt;&lt;<br>
Shift left<br>
x &gt;&gt; 1<br>
Yes<br>
 <br>
&gt;&gt;<br>
Shift right<br>
x &lt;&lt; 1<br>
Yes<br>
Relational<br>
&lt;<br>
Less than<br>
x &lt; y<br>
Yes<br>
 <br>
&gt;<br>
Greater than<br>
x &gt; y<br>
Yes<br>
 <br>
&lt;=<br>
Less than or equal to<br>
x &lt;= y<br>
Yes<br>
<b>Expressions and Operators | 47</b><br>
<hr>
<A name=68></a><b>User-</b><br>
<b>Category</b><br>
<b>Operator symbol</b><br>
<b>Operator name</b><br>
<b>Example</b><br>
<b>overloadable</b><br>
 <br>
&gt;=<br>
Greater than or equal<br>
x &gt;= y<br>
Yes<br>
to<br>
 <br>
is<br>
Type is or is subclass of<br>
x is y<br>
No<br>
 <br>
as<br>
Type conversion<br>
x as y<br>
No<br>
Equality<br>
==<br>
Equals<br>
x == y<br>
Yes<br>
 <br>
!=<br>
Not equals<br>
x != y<br>
Yes<br>
Logical And<br>
&amp;<br>
And<br>
x &amp; y<br>
Yes<br>
Logical Xor<br>
^<br>
Exclusive Or<br>
x ^ y<br>
Yes<br>
Logical Or<br>
|<br>
Or<br>
x | y<br>
Yes<br>
Conditional And<br>
&amp;&amp;<br>
Conditional And<br>
x &amp;&amp; y<br>
Via &amp;<br>
Conditional Or<br>
||<br>
Conditional Or<br>
x || y<br>
Via |<br>
Null coalescing<br>
??<br>
Null coalescing<br>
x ?? y<br>
No<br>
Conditional<br>
?:<br>
Conditional<br>
isTrue ? thenThis<br>
No<br>
Value : elseThis<br>Value<br>
Assignment<br>
=<br>
Assign<br>
x = y<br>
No<br>
 <br>
*=<br>
Multiply self by<br>
x *= 2<br>
Via *<br>
 <br>
/=<br>
Divide self by<br>
x /= 2<br>
Via /<br>
 <br>
+=<br>
Add to self<br>
x += 2<br>
Via +<br>
 <br>
-=<br>
Subtract from self<br>
x -= 2<br>
Via -<br>
 <br>
&lt;&lt;=<br>
Shift self left by<br>
x &lt;&lt;= 2<br>
Via &lt;&lt;<br>
 <br>
&gt;&gt;=<br>
Shift self right by<br>
x &gt;&gt;= 2<br>
Via &gt;&gt;<br>
 <br>
&amp;=<br>
And self by<br>
x &amp;= 2<br>
Via &amp;<br>
 <br>
^=<br>
Exclusive-Or self by<br>
x ^= 2<br>
Via ^<br>
 <br>
|=<br>
Or self by<br>
x |= 2<br>
Via |<br>
Lambda<br>
=&gt;<br>
Lambda<br>
x =&gt; x + 1<br>
No<br>
<b>Statements<br></b>Functions  comprise  statements  that  execute  sequentially  in  the  textual  order  in<br>which they appear. A <i>statement block</i> is a series of statements appearing between<br>braces (the {} tokens).<br>
<b>Declaration Statements<br></b>A declaration statement declares a new variable, optionally initializing the variable<br>with an expression. A declaration statement ends in a semicolon. You may declare<br>multiple variables of the same type in a comma-separated list. For example:<br>
<b>48 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=69></a>string someWord = &quot;rosebud&quot;;<br>
int someNumber = 42;<br>bool rich = true, famous = false;<br>
A constant declaration is like a variable declaration, except that the variable cannot<br>be changed after it has been declared, and the initialization must occur with the<br>declaration:<br>
const double c = 2.99792458E08;<br>
<b>C# Basics</b><br>
c += 10;                        // Compile-time Error<br>
<b>Local variables<br></b>The scope of a local or constant variable extends throughout the current block. You<br>cannot declare another local variable with the same name in the current block or in<br>any nested blocks. For example:<br>
static void Main()<br>
{<br>  int x;<br>
  {<br>
    int y;<br>
    int x;            // Error - x already defined<br>  }<br>
  {<br>
    int y;            // OK - y not in scope<br>
  }<br>  Console.Write (y);  // Error - y is out of scope<br>}<br>
A variable's scope extends in <i>both directions</i> throughout its code<br>block. This means that if we moved the initial declaration of x<br>in this example to the bottom of the method, we'd get the same<br>error.<br>
<b>Expression Statements<br></b>Expression statements are expressions that are also valid statements. An expression<br>statement  must  either  change  state  or  call  something  that  might  change  state.<br>Changing state essentially means changing a variable. The possible expression state-<br>ments are:<br>
· Assignment expressions (including increment and decrement expressions)<br>· Method call expressions (both void and nonvoid)<br>· Object instantiation expressions<br>
Here are some examples:<br>
// Declare variables with declaration statements:<br>string s;<br>int x, y;<br>System.Text.StringBuilder sb;<br>
<b>Statements | 49</b><br>
<hr>
<A name=70></a>// Expression statements<br>
x = 1 + 2;                 // Assignment expression<br>x++;                       // Increment expression<br>y = Math.Max (x, 5);       // Assignment expression<br>
Console.WriteLine (y);     // Method call expression<br>
sb = new StringBuilder();  // Assignment expression<br>new StringBuilder();       // Object instantiation expression<br>
When you call a constructor or a method that returns a value, you're not obliged to<br>use the result. However, unless the constructor or method changes state, the state-<br>ment is completely useless:<br>
new StringBuilder();     // Legal, but useless<br>
new string ('c', 3);     // Legal, but useless<br>
x.Equals (y);            // Legal, but useless<br>
<b>Selection Statements<br></b>C#  has  the  following  mechanisms  to  conditionally  control  the  flow  of  program<br>execution:<br>
· Selection statements (if, switch)<br>· Conditional operator (?:)<br>· Loop statements (while, do..while, for, foreach)<br>
This  section  covers  the  simplest  two  constructs:  the  if-else  statement  and  the<br>switch statement.<br>
<b>The if statement<br></b>An if statement executes a body of code depending on whether a bool expression<br>is true. For example:<br>
if (5 &lt; 2 * 3)<br>{<br>  Console.WriteLine (&quot;true&quot;);       // True<br>}<br>
If the body of code is a single statement, you can optionally omit the braces:<br>
if (5 &lt; 2 * 3)<br>  Console.WriteLine (&quot;true&quot;);       // True<br>
<b>The else clause<br></b>An if statement is optionally followed by an else clause:<br>
if (2 + 2 == 5)<br>  Console.WriteLine (&quot;Does not compute&quot;);<br>else<br>  Console.WriteLine (&quot;False&quot;);        // False<br>
Within an else clause, you can nest another if statement:<br>
if (2 + 2 == 5)<br>  Console.WriteLine (&quot;Does not compute&quot;);<br>else<br>
<b>50 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=71></a>  <b>if (2 + 2 == 4)</b><br>
    <b>Console.WriteLine (&quot;Computes&quot;);    // Computes</b><br>
<b>Changing the flow of execution with braces<br></b>An  else  clause  always  applies  to  the  immediately  preceding  if  statement  in  the<br>statement block. For example:<br>
if (true)<br>
<b>C# Basics</b><br>
  if (false)<br>
    Console.WriteLine();<br>
  else<br>
    Console.WriteLine (&quot;executes&quot;);<br>
This is semantically identical to:<br>
if (true)<br>{<br>  if (false)<br>
    Console.WriteLine();<br>
  else<br>    Console.WriteLine (&quot;executes&quot;);<br>
}<br>
We can change the execution flow by moving the braces:<br>
if (true)<br>
{<br>  if (false)<br>    Console.WriteLine();<br>}<br>else<br>  Console.WriteLine (&quot;does not execute&quot;);<br>
With braces, you explicitly state your intention. This can improve the readability of<br>nested if statements--even when not required by the compiler. A notable exception<br>is with the following pattern:<br>
static void TellMeWhatICanDo (int age)<br>{<br>  if (age &gt;= 35)<br>    Console.WriteLine (&quot;You can be president!&quot;);<br>  <b>else if</b> (age &gt;= 21)<br>    Console.WriteLine (&quot;You can drink!&quot;);<br>  <b>else if</b> (age &gt;= 18)<br>    Console.WriteLine (&quot;You can vote!&quot;);<br>  else<br>    Console.WriteLine (&quot;You can wait!&quot;);<br>}<br>
Here, we've arranged the if and else statements to mimic the "elsif" construct of<br>other  languages  (and  C#'s  #elif  preprocessor  directive).  Visual  Studio's  auto-<br>formatting  recognizes  this  pattern  and  preserves  the  indentation.  Semantically,<br>though, each if statement following an else statement is functionally nested within<br>the else statement.<br>
<b>Statements | 51</b><br>
<hr>
<A name=72></a><b>The switch statement<br></b>switch statements let you branch program execution based on a selection of possible<br>values that a variable may have. switch statements may result in cleaner code than<br>multiple if statements, since switch statements require an expression to be evaluated<br>only once. For instance:<br>
static void ShowCard(int cardNumber)<br>
{<br>  switch (cardNumber)<br>
  {<br>    case 13:<br>
      Console.WriteLine (&quot;King&quot;);<br>
      break;<br>
    case 12:<br>      Console.WriteLine (&quot;Queen&quot;);<br>      break;<br>
    case 11:<br>
      Console.WriteLine (&quot;Jack&quot;);<br>
      break;<br>    case -1:                         // Joker is -1<br>
      goto case 12;                  // In this game joker counts as queen<br>
    default:                         // Executes for any other cardNumber<br>
      Console.WriteLine (cardNumber);<br>
      break;<br>
  }<br>
}<br>
You can only switch on an expression of a type that can be statically evaluated, which<br>restricts it to the built-in integral types, string type, and enum types.<br>At the end of each case clause, you must say explicitly where execution is to go next,<br>with some kind of jump statement. Here are the options:<br>
· break (jumps to the end of the switch statement)<br>· goto case <i>x</i> (jumps to another case clause)<br>· goto default (jumps to the default clause)<br>· Any other jump statement--namely, return, throw, continue, or goto <i>label</i><br>
When more than one value should execute the same code, you can list the common<br>cases sequentially:<br>
switch (cardNumber)<br>{<br>  <b>case 13:<br></b>  <b>case 12:<br></b>  <b>case 11:<br></b>    Console.WriteLine (&quot;Face card&quot;);<br>    break;<br>  default:<br>    Console.WriteLine (&quot;Plain card&quot;);<br>    break;<br>}<br>
<b>52 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=73></a>This feature of a switch statement can be pivotal in terms of producing cleaner code<br>than multiple if-else statements.<br>
<b>Iteration Statements<br></b>C#  enables  a  sequence  of  statements  to  execute  repeatedly  with  the  while,  do-<br>while, for, and foreach statements.<br>
<b>C# Basics</b><br>
<b>while and do-while loops<br></b>while loops repeatedly execute a body of code while a bool expression is true. The<br>expression is tested <i>before</i> the body of the loop is executed. For example:<br>
int i = 0;<br>
while (i &lt; 3)<br>
{<br>  Console.WriteLine (i);<br>
  i++;<br>
}<br>
OUTPUT:<br>
0<br>1<br>2<br>
do-while loops differ in functionality from  while loops only in that they test the<br>expression <i>after</i> the statement block has executed (ensuring that the block is always<br>executed at least once). Here's the preceding example rewritten with a do-while loop:<br>
int i = 0;<br>
do<br>{<br>  Console.WriteLine (i);<br>  i++;<br>}<br>while (i &lt; 3);<br>
<b>for loops<br></b>for loops are like while loops with special clauses for <i>initialization</i> and <i>iteration</i> of<br>a loop variable. A for loop contains three clauses as follows:<br>
for (<i>initialization-clause</i>; <i>condition-clause</i>; <i>iteration-clause</i>)<br>  <i>statement-or-statement-block</i><br>
<i>Initialization clause</i><br>
Executed  before  the  loop  begins;  used  to  initialize  one  or  more  <i>iteration<br></i>variables<br>
<i>Condition clause</i><br>
The bool expression that, while true, will execute the body<br>
<i>Iteration clause</i><br>
Executed <i>after</i> each iteration of the statement block; used typically to update<br>the iteration variable<br>
<b>Statements | 53</b><br>
<hr>
<A name=74></a>For example, the following prints the numbers 0 through 2:<br>
for (int i = 0; i &lt; 3; i++)<br>
  Console.WriteLine (i);<br>
The following prints the first 10 Fibonacci numbers (where each number is the sum<br>of the previous two):<br>
for (int i = 0, prevFib = 1, curFib = 1; i &lt; 10; i++)<br>
{<br>  Console.WriteLine (prevFib);<br>
  int newFib = prevFib + curFib;<br>
  prevFib = curFib; curFib = newFib;<br>}<br>
Any of the three parts of the for statement may be omitted. One can implement an<br>infinite loop such as the following (though while(true) may be used instead):<br>
for (;;)<br>  Console.WriteLine (&quot;interrupt me&quot;);<br>
<b>foreach loops<br></b>The foreach statement iterates over each element in an enumerable object. Most of<br>the types in C# and the .NET Framework that represent a set or list of elements are<br>enumerable. For example, both an array and a string are enumerable. Here is an<br>example  of  enumerating  over  the  characters  in  a  string,  from  the  first  character<br>through to the last:<br>
foreach (char c in &quot;beer&quot;)   // c is the <i>iteration variable<br></i>  Console.WriteLine (c);<br>
OUTPUT:<br>b<br>e<br>e<br>r<br>
We  define  enumerable  objects  in  "Enumeration  and  Iterators"  on  page  143  in<br>Chapter 4.<br>
<b>Jump Statements<br></b>The C# jump statements are break, continue, goto, return, and throw.<br>
Jump statements obey the reliability rules of try statements (see<br>"try Statements and Exceptions" on page 134 in Chapter 4).<br>This means that:<br>
· A  jump  out  of  a  try  block  always  executes  the  try's<br>
finally block before reaching the target of the jump.<br>
· A jump cannot be made from the inside to the outside of<br>
a finally block.<br>
<b>54 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=75></a><b>The break statement<br></b>The  break  statement  ends  the  execution  of  the  body  of  an  iteration  or  switch<br>statement:<br>
int x = 0;<br>
while (true)<br>{<br>  if (x++ &gt; 5)<br>
<b>C# Basics</b><br>
    <b>break</b> ;      // break from the loop<br>
}<br>// execution continues here after break<br>
...<br>
<b>The continue statement<br></b>The continue statement forgoes the remaining statements in a loop and makes an<br>early start on the next iteration. The following loop skips even numbers:<br>
for (int i = 0; i &lt; 10; i++)<br>{<br>  if ((i % 2) == 0)       // If i is even,<br>
    continue;             // continue with next iteration<br>
  Console.Write (i + &quot; &quot;);<br>
}<br>
OUTPUT: 1 3 5 7 9<br>
<b>The goto statement<br></b>The goto statement transfers execution to another label within the statement block.<br>The form is as follows:<br>
goto <i>statement-label</i>;<br>
Or, when used within a switch statement:<br>
goto case <i>case-constant</i>;<br>
A label statement is just a placeholder in a code block, denoted with a colon suffix.<br>The following iterates the numbers 1 through 5, mimicking a for loop:<br>
int i = 1;<br><b>startLoop:<br></b>if (i &lt;= 5)<br>{<br>  Console.Write (i + &quot; &quot;);<br>  i++;<br>  <b>goto startLoop;<br></b>}<br>
OUTPUT: 1 2 3 4 5<br>
The goto <i>case-constant</i> transfers execution to another case in a switch block (see<br>"The switch statement" on page 52).<br>
<b>Statements | 55</b><br>
<hr>
<A name=76></a><b>The return statement<br></b>The  return  statement  exits  the  method  and  must  return  an  expression  of  the<br>method's return type if the method is nonvoid:<br>
static decimal AsPercentage (decimal d)<br>
{<br>  decimal p = d * 100m;<br>
  return p;             // Return to the calling method with value<br>
}<br>
A return statement can appear anywhere in a method.<br>
<b>The throw statement<br></b>The throw statement throws an exception to indicate an error has occurred (see "try<br>Statements and Exceptions" on page 134 in Chapter 4):<br>
if (w == null)<br>
  throw new ArgumentNullException (...);<br>
<b>Miscellaneous Statements<br></b>The lock statement is a syntactic shortcut for calling the Enter and Exit methods of<br>the Monitor class (see Chapter 19).<br>The using statement provides an elegant syntax for calling Dispose on objects that<br>implement  IDisposable,  within  a  finally  block  (see  "try  Statements  and  Excep-<br>tions"  on  page  134  in  Chapter  4  and  "IDisposable,  Dispose,  and<br>Close" on page 475 in Chapter 12).<br>
C# overloads the using keyword to have independent meanings<br>in different contexts. Specifically, the using <i>directive</i> is different<br>from the using <i>statement</i>.<br>
<b>Namespaces<br></b>A namespace is a domain within which type names must be unique. Types are typ-<br>ically organized into hierarchical namespaces--both to avoid naming conflicts and<br>to make type names easier to find. For example, the RSA type that handles public key<br>encryption is defined within the following namespace:<br>
System.Security.Cryptography<br>
A namespace forms an integral part of a type's name. The following code calls RSA's<br>Create method:<br>
System.Security.Cryptography.RSA rsa =<br>  System.Security.Cryptography.RSA.Create();<br>
<b>56 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=77></a>Namespaces are independent of assemblies, which are units of<br>deployment such as an <i>.exe</i> or <i>.dll</i> (described in Chapter 16).<br>
Namespaces also have no impact on member visibility--public,<br>internal, private, and so on.<br>
The namepace keyword defines a namespace for types within that block. For example:<br>
<b>C# Basics</b><br>
namespace Outer.Middle.Inner<br>
{<br>  class Class1 {}<br>
  class Class2 {}<br>
}<br>
The dots in the namespace indicate a hierarchy of nested namespaces. The code that<br>follows is semantically identical to the preceding example:<br>
namespace Outer<br>
{<br>  namespace Middle<br>
  {<br>    namespace Inner<br>
    {<br>
      class Class1 {}<br>
      class Class2 {}<br>    }<br>  }<br>
}<br>
You can refer to a type with its <i>fully qualified name</i>, which includes all namespaces<br>from the outermost to the innermost. For example, we could refer to Class1 in the<br>preceding example as Outer.Middle.Inner.Class1.<br>Types not defined in any namespace are said to reside in the <i>global namespace</i>. The<br>global namespace also includes top-level namespaces, such as Outer in our example.<br>
<b>The using Directive<br></b>The using directive <i>imports</i> a namespace. This is a convenient way to refer to types<br>without their fully qualified names. This example is semantically identical to our<br>previous example:<br>
using Outer.Middle.Inner;<br>
class Test<br>{<br>  static void Main()<br>  {<br>    <b>Class1 c;<br></b>  }<br>}<br>
<b>Namespaces | 57</b><br>
<hr>
<A name=78></a><b>Rules Within a Namespace</b><br>
<b>Name scoping<br></b>Names declared in outer namespaces can be used unqualified within inner name-<br>spaces. Here, the names Middle and Class1 are implicitly imported into Inner:<br>
namespace Outer<br>{<br>  namespace Middle<br>
  {<br>
    class Class1 {}<br>
    namespace Inner<br>
    {<br>
      class Class2 : <b>Class1</b>  {}<br>
    }<br>  }<br>
}<br>
If you want to refer to a type in a different branch of your namespace hierarchy, you<br>can use a partially qualified name. In the following example, we base SalesReport<br>on Common.ReportBase:<br>
namespace MyTradingCompany<br>{<br>  namespace Common<br>
  {<br>    class ReportBase {}<br>  }<br>  namespace ManagementReporting<br>  {<br>    class SalesReport : <b>Common.ReportBase</b>  {}<br>  }<br>}<br>
<b>Name hiding<br></b>If the same type name appears in both an inner and an outer namespace, the inner<br>name wins. To refer to the type in the outer namespace, you must qualify its name:<br>
namespace Outer<br>{<br>  class Foo { }<br>
  namespace Inner<br>  {<br>    class Foo { }<br>
    class Test<br>    {<br>      Foo f1;         // = Outer.Inner.Foo<br>      Outer.Foo f2;   // = Outer.Foo<br>    }<br>  }<br>
}<br>
<b>58 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=79></a>All type names are converted to fully qualified names at compile<br>time. Intermediate Language (IL) code contains no unqualified<br>or partially qualified names.<br>
<b>Repeated namespaces</b><br>
<b>C# Basics</b><br>
You can repeat a namespace declaration, as long as the type names within the name-<br>spaces don't conflict:<br>
namespace Outer.Middle.Inner<br>
{<br>  class Class1 {}<br>
}<br>
namespace Outer.Middle.Inner<br>
{<br>  class Class2 {}<br>}<br>
We can even break the example into two source files such that we could compile<br>each class into a different assembly.<br>
Source file 1:<br>
namespace Outer.Middle.Inner<br>
{<br>  class Class1 {}<br>}<br>
Source file 2:<br>
namespace Outer.Middle.Inner<br>{<br>  class Class2 {}<br>}<br>
<b>Nested using directive<br></b>You can nest a using directive within a namespace. This allows you to scope the<br>using directive within a namespace declaration. In the following example, Class1 is<br>visible in one scope, but not in another:<br>
namespace N1<br>{<br>  class Class1 {}<br>}<br>
namespace N2<br>{<br>  using N1;<br>
  class Class2 : Class1 {}<br>}<br> <br>
<b>Namespaces | 59</b><br>
<hr>
<A name=80></a>namespace N2<br>
{<br>  class Class3 : Class1 {}   // Compile-time error<br>}<br>
<b>Aliasing Types and Namespaces<br></b>Importing a namespace can result in type-name collision. Rather than importing the<br>whole namespace, you can import just the specific types you need, giving each type<br>an alias. For example:<br>
using PropertyInfo2 = System.Reflection.PropertyInfo;<br>class Program { PropertyInfo2 p; }<br>
An entire namespace can be aliased, as follows:<br>
using R = System.Reflection;<br>
class Program { R.PropertyInfo p; }<br>
<b>Advanced Namespace Features</b><br>
<b>Extern<br></b>Extern aliases allow your program to reference two types with the same fully quali-<br>fied  name  (i.e.,  the  namespace  and  type  name  are  identical).  This  is  an  unusual<br>scenario and can occur only when the two types come from different assemblies.<br>Consider the following example:<br>
Library 1:<br>
// csc target:library /out:Widgets1.dll widgetsv1.cs<br>
namespace Widgets<br>{<br>  public class Widget {}<br>}<br>
Library 2:<br>
// csc target:library /out:Widgets2.dll widgetsv2.cs<br>
namespace Widgets<br>{<br>  public class Widget {}<br>}<br>
Application:<br>
// csc /r:Widgets1.dll /r:Widgets2.dll application.cs<br>
using Widgets;<br> <br>
class Test<br>{<br>  static void Main()<br>
<b>60 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=81></a>  {<br>
    Widget w = new Widget();<br>  }<br>}<br>
The application cannot compile, because Widget is ambiguous. Extern aliases can<br>resolve the ambiguity in our application:<br>
// csc /r:W1=Widgets1.dll /r:W2=Widgets2.dll application.cs<br>
<b>C# Basics</b><br>
extern alias W1;<br>
extern alias W2;<br>
class Test<br>{<br>  static void Main()<br>
  {<br>
    W1.Widgets.Widget w1 = new W1.Widgets.Widget();<br>
    W2.Widgets.Widget w2 = new W2.Widgets.Widget();<br>
  }<br>}<br>
<b>Namespace alias qualifiers<br></b>As we mentioned earlier, names in inner namespaces hide names in outer name-<br>spaces. However, sometimes even the use of a fully qualified type name does not<br>resolve the conflict. Consider the following example:<br>
namespace N<br>
{<br>  class A<br>
  {<br>    public class B {}                    // Nested type<br>    static void Main() { new A.B(); }    // Instantiate class B<br>  }<br>}<br>
namespace A<br>{<br>  class B {}<br>}<br>
The Main method could be instantiating either the nested class B, or the class B within<br>the namespace A. The compiler always gives higher precedence to identifiers in the<br>current namespace; in this case, the nested B class.<br>To resolve such conflicts, a namespace name can be qualified, relative to one of the<br>following:<br>
· The global namespace--the root of all namespaces (identified with the con-<br>
textual keyword global)<br>
· The set of extern aliases<br>
<b>Namespaces | 61</b><br>
<hr>
<A name=82></a>The :: token is used for namespace alias qualification. In this example, we qualify<br>using the global namespace (this is most commonly seen in auto-generated code to<br>avoid name conflicts):<br>
namespace N<br>
{<br>  class A<br>
  {<br>
    static void Main()<br>
    {<br>
      System.Console.WriteLine (new A.B());<br>      System.Console.WriteLine (new global::A.B());<br>
    }<br>
    public class B {}<br>  }<br>}<br>
namespace A<br>
{<br>  class B {}<br>
}<br>
Here is an example of qualifying with an alias (adapted from the example in "Ex-<br>tern" on page 60):<br>
extern alias W1;<br>extern alias W2;<br>
class Test<br>
{<br>  static void Main()<br>  {<br>    W1::Widgets.Widget w1 = new W1::Widgets.Widget();<br>    W2::Widgets.Widget w2 = new W2::Widgets.Widget();<br>  }<br>}<br>
<b>62 | Chapter 2:</b><b>C# Language Basics</b><br>
<hr>
<A name=83></a><b>3</b><br>
<b>Creating Types in C#</b><br>
In this chapter, we will delve into types and type members.<br>
<b>Classes<br></b>A class is the most common kind of reference type. The simplest possible class dec-<br>laration is as follows:<br>
class YourClassName<br>{<br>}<br>
A more complex class optionally has the following:<br>
Preceding the keyword class<br>
Attributes and class modifiers. The non-nested class modifiers are public, internal,<br>abstract, sealed, static, unsafe, and partial<br>
Following YourClassName<br>
Generic type parameters, a base class, and interfaces<br>
Within the braces<br>
Class members (these are methods, properties, indexers, events, fields, constructors,<br>operator functions, nested types, and a finalizer)<br>
This chapter covers all of these constructs except attributes, operator functions, and<br>the unsafe keyword, which are covered in Chapter 4. The following sections will<br>enumerate each of the class members.<br>
<b>Fields<br></b>A <i>field</i> is a variable that is a member of a class or struct. For example:<br>
class Octopus<br>{<br>  <b>string name;<br></b>  <b>public int Age = 10;<br></b>}<br>
<b>63</b><br>
<hr>
<A name=84></a>Fields allow the following modifiers:<br>
Static modifier<br>
static<br>
Access modifiers<br>
public internal private protected<br>
Inheritance modifier<br>
new<br>
Unsafe code modifier<br>
unsafe<br>
Read-only modifier<br>
readonly<br>
Threading modifier<br>
volatile<br>
<b>The readonly modifier<br></b>The readonly modifier prevents a field from being modified after construction. A<br>read-only field can be assigned only in its declaration or within the enclosing type's<br>constructor.<br>
<b>Field initialization<br></b>Field initialization is optional. An uninitialized field has a default value (0, \0, null,<br>false). Field initializers run before constructors:<br>
public int Age = 10;<br>
<b>Declaring multiple fields together<br></b>For convenience, you may declare multiple fields of the same type in a comma-<br>separated list. This is a convenient way for all the fields to share the same attributes<br>and field modifiers. For example:<br>
static readonly int legs = 8,<br>                    eyes = 1;<br>
<b>Methods<br></b>A method performs an action in a series of statements. A method can receive <i>input<br></i>data from the caller by specifying <i>parameters</i> and <i>output</i> data back to the caller by<br>specifying a <i>return type</i>. A method can specify a void return type, indicating that it<br>doesn't return any value to its caller. A method can also output data back to the<br>caller via ref/out parameters.<br>A method's <i>signature</i> must be unique within the type. A method's signature com-<br>prises its name and parameter types (but not the parameter <i>names</i>, nor the return<br>type).<br>
Methods allow the following modifiers:<br>
Static modifier<br>
static<br>
Access modifiers<br>
public internal private protected<br>
Inheritance modifiers<br>
new virtual abstract override sealed<br>
Unmanaged code modifiers<br>
unsafe extern<br>
<b>64 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=85></a><b>Overloading methods<br></b>A type may overload methods (have multiple methods with the same name), as long<br>as the signatures are different. For example, the following methods can all coexist<br>in the same type:<br>
void Foo (int x);<br>void Foo (double x);<br>
void Foo (int x, float y);<br>void Foo (float x, int y);<br>
However, the following pairs of methods cannot coexist in the same type, since the<br>return type and the params modifier are not part of a method's signature:<br>
void  Foo (int x);<br>
<b>Creating Types</b><br>
float Foo (int x);           // Compile-time error<br>
void  Goo (int[] x);<br>
void  Goo (params int[] x);  // Compile-time error<br>
<b>Pass-by-value versus pass-by-reference<br></b>Whether a parameter is pass-by-value or pass-by-reference is also part of the signa-<br>ture. For example, Foo(int) can coexist with either Foo(ref int) or Foo(out int).<br>However, Foo(ref int) and Foo(out int) cannot coexist:<br>
void Foo (int x);<br>
void Foo (ref int x);      // OK so far<br>
void Foo (out int x);      // Compile-time error<br>
<b>Instance Constructors<br></b>Constructors run initialization code on a class or struct. A constructor is defined like<br>a method, except that the method name and return type are reduced to the name of<br>the enclosing type:<br>
public class Panda<br>{<br>  string name;                   // Define field<br>  public Panda (string n)        // Define constructor<br>  {<br>    name = n;                    // Initialization code (set up field)<br>  }<br>}<br>...<br>
Panda p = new Panda (&quot;Petey&quot;);   // Call constructor<br>
Constructors allow the following modifiers:<br>
Access modifiers<br>
public internal private protected<br>
Unmanaged code modifiers<br>
unsafe extern<br>
<b>Classes | 65</b><br>
<hr>
<A name=86></a><b>Overloading constructors<br></b>A class or struct may overload constructors. To avoid code duplication, one con-<br>structor may call another, using the this keyword:<br>
using System;<br>
public class Wine<br>
{<br>  public decimal Price;<br>
  public int Year;<br>
  public Wine (decimal price) { Price = price; }<br>  public Wine (decimal price, int year) <b>: this (price)</b> { Year = year; }<br>
}<br>
When one constructor calls another, the <i>called constructor</i> executes first.<br>
You can pass an <i>expression</i> into another constructor as follows:<br>
public Wine (decimal price, DateTime year) : this (price, <b>year.Year</b>) { }<br>
The expression itself cannot make use of the this reference, for example, to call an<br>instance method. It can, however, call static methods.<br>
<b>Implicit parameterless constructors<br></b>For classes, the C# compiler automatically generates a parameterless constructor if<br>and only if you do not define any constructors. However, as soon as you define at<br>least  one  constructor,  the  parameterless  constructor  is  no  longer  automatically<br>generated.<br>
For structs, a parameterless constructor is intrinsic to the struct; therefore, you can-<br>not define your own. The role of a struct's implicit parameterless constructor is to<br>initialize each field with default values.<br>
<b>Constructor and field initialization order<br></b>Previously,  we  saw  that  fields  can  be  initialized  with  default  values  in  their<br>declaration:<br>
class Player<br>{<br>  int shields = 50;   // Initialized first<br>  int health = 100;   // Initialized second<br>}<br>
Field initializations occur <i>before</i> the constructor is executed, and in the declaration<br>order of the fields.<br>
<b>Nonpublic constructors<br></b>Constructors do not need to be public. A common reason to have a nonpublic con-<br>structor is to control instance creation via a static method call. The static method<br>could be used to return an object from a pool rather than necessarily creating a new<br>object, or return various subclasses based on input arguments. The template for that<br>pattern is shown next:<br>
<b>66 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=87></a>public class Class1<br>
{<br>  Class1() {}                             // Private constructor<br>  public static Class1 Create (...)<br>
  {<br>
    // Perform custom logic here to return an instance of Class1<br>    ...<br>  }<br>
}<br>
<b>Object Initializers<br></b>To simplify object initialization, the accessible fields or properties of an object can<br>be initialized in a single statement directly after construction. For example, consider<br>
<b>Creating Types</b><br>
the following class:<br>
public class Bunny<br>{<br>  public string Name;<br>
  public bool LikesCarrots;<br>
  public bool LikesHumans;<br>
  public Bunny () {}<br>
  public Bunny (string n) { Name = n; }<br>}<br>
Using object initializers, you can instantiate Bunny objects as follows:<br>
// Note parameterless constructors can omit empty parentheses<br>Bunny b1 = new Bunny { Name=&quot;Bo&quot;, LikesCarrots=true, LikesHumans=false };<br>Bunny b2 = new Bunny (&quot;Bo&quot;)     { LikesCarrots=true, LikesHumans=false };<br>
The code to construct b1 and b2 is precisely equivalent to:<br>
Bunny <i>temp1</i> = new Bunny();    // <i>temp1</i> is a compiler-generated name<br><i>temp1</i>.Name = &quot;Bo&quot;;<br><i>temp1</i>.LikesCarrots = true;<br><i>temp1</i>.LikesHumans = false;<br>Bunny b1 = <i>temp1</i>;<br>
Bunny <i>temp2</i> = new Bunny (&quot;Bo&quot;);<br><i>temp2</i>.LikesCarrots = true;<br><i>temp2</i>.LikesHumans = false;<br>Bunny b2 = <i>temp2</i>;<br>
The temporary variables are to ensure that if an exception is thrown during initial-<br>ization, you can't end up with a half-initialized object.<br>
Object initializers were introduced in C# 3.0.<br>
<b>Classes | 67</b><br>
<hr>
<A name=88></a><b>Object Initializers Versus Optional Parameters</b><br>
Instead of using object initializers, we could make Bunny's constructor accept op-<br>tional parameters:<br>
public Bunny (string name,<br>              bool likesCarrots = false,<br>              bool likesHumans = false)<br>
{<br>  Name = name;<br>
  LikesCarrots = likesCarrots;<br>  LikesHumans = likesHumans;<br>
}<br>
This would allow us to construct a Bunny as follows:<br>
Bunny b1 = new Bunny (name: &quot;Bo&quot;,<br>
                      likesCarrots: true);<br>
An advantage of this approach is that we could make Bunny's fields (or <i>proper-<br>ties</i>, as we'll explain shortly) read-only if we choose. Making fields or properties<br>read-only  is  good  practice  when  there's  no  valid  reason  for  them  to  change<br>throughout the life of the object.<br>
The disadvantage in this approach is that each optional parameter value is baked<br>into the <i>calling site</i>. In other words, C# translates our constructor call into this:<br>
Bunny b1 = new Bunny (&quot;Bo&quot;, true<b>, false</b>);<br>
This can be problematic if we instantiate the Bunny class from another assembly,<br>and  later  modify  Bunny  by  adding  another  optional  parameter--such  as  likes<br>Cats. Unless the referencing assembly is also recompiled, it will continue to call<br>the (now nonexistent) constructor with three parameters and fail at runtime. (A<br>subtler problem is that if we changed the value of one of the optional parameters,<br>callers in other assemblies would continue to use the old optional value until they<br>were recompiled.)<br>
Hence, optional parameters are best avoided in public functions if you want to<br>offer binary compatibility between assembly versions.<br>
<b>The this Reference<br></b>The this reference refers to the instance itself. In the following example, the Marry<br>method uses this to set the partner's mate field:<br>
public class Panda<br>{<br>  public Panda Mate;<br>
  public void Marry (Panda partner)<br>  {<br>    Mate = partner;<br>    partner.Mate = this;<br>
  }<br>}<br>
<b>68 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=89></a>The this reference also disambiguates a local variable or parameter from a field. For<br>example:<br>
public class Test<br>{<br>  string name;<br>
  public Test (string name) { this.name = name; }<br>}<br>
The this reference is valid only within nonstatic members of a class or struct.<br>
<b>Properties<br></b>Properties look like fields from the outside, but internally they contain logic, like<br>
<b>Creating Types</b><br>
methods do. For example, you can't tell by looking at the following code whether<br>CurrentPrice is a field or a property:<br>
Stock msft = new Stock();<br>
msft.CurrentPrice = 30;<br>
msft.CurrentPrice -= 3;<br>
Console.WriteLine (msft.CurrentPrice);<br>
A property is declared like a field, but with a get/set block added. Here's how to<br>implement CurrentPrice as a property:<br>
public class Stock<br>
{<br>  decimal currentPrice;           // The private &quot;backing&quot; field<br>
  public decimal CurrentPrice     // The public property<br>  {<br>
    get { return currentPrice; } set { currentPrice = value; }<br>  }<br>}<br>
get and set denote property <i>accessors</i>. The get accessor runs when the property is<br>read. It must return a value of the property's type. The set accessor is run when the<br>property is assigned. It has an implicit parameter named value of the property's type<br>that you typically assign to a private field (in this case, currentPrice).<br>Although properties are accessed in the same way as fields, they differ in that they<br>give the implementer complete control over getting and setting its value. This control<br>enables  the  implementer  to  choose  whatever  internal  representation  is  needed,<br>without exposing the internal details to the user of the property. In this example,<br>the set method could throw an exception if value was outside a valid range of values.<br>
Throughout this book, we use public fields extensively to keep<br>the examples free of distraction. In a real application, you would<br>typically favor public properties over public fields, in order to<br>promote encapsulation.<br>
<b>Classes | 69</b><br>
<hr>
<A name=90></a>Properties allow the following modifiers:<br>
Static modifier<br>
static<br>
Access modifiers<br>
public internal private protected<br>
Inheritance modifiers<br>
new virtual abstract override sealed<br>
Unmanaged code modifiers<br>
unsafe extern<br>
<b>Read-only and calculated properties<br></b>A property is read-only if it specifies only a get accessor, and it is write-only if it<br>specifies only a set accessor. Write-only properties are rarely used.<br>A  property  typically  has  a  dedicated  backing  field  to  store  the  underlying  data.<br>However, a property can also be computed from other data. For example:<br>
decimal currentPrice, sharesOwned;<br>
public decimal Worth<br>
{<br>  get { return currentPrice * sharesOwned; }<br>
}<br>
<b>Automatic properties<br></b>The most common implementation for a property is a getter and/or setter that simply<br>reads and writes to a private field of the same type as the property. An <i>automatic<br>property</i> declaration instructs the compiler to provide this implementation. We can<br>redeclare the first example in this section as follows:<br>
public class Stock<br>{<br>  ...<br>  public decimal CurrentPrice { get; set; }<br>}<br>
The compiler automatically generates a private backing field of a compiler-generated<br>name that cannot be referred to. The set accessor can be marked private if you want<br>to expose the property as read-only to other types. Automatic properties were in-<br>troduced in C# 3.0.<br>
<b>get and set accessibility<br></b>The get and set accessors can have different access levels. The typical use case for<br>this is to have a public property with an internal or private access modifier on the<br>setter:<br>
public class Foo<br>{<br>  private decimal x;<br>  public decimal X<br>  {<br>    get         { return x;  }<br>    <b>private</b> set { x = Math.Round (value, 2); }<br>
<b>70 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=91></a>  }<br>
}<br>
Notice that you declare the property itself with the more permissive access level<br>(public, in this case), and then add the modifier to the accessor that you want to be<br><i>less</i> accessible.<br>
<b>CLR property implementation<br></b>C# property accessors internally compile to methods called get_<i>XXX</i> and set_<i>XXX</i>:<br>
public int  get_CurrentPrice {...}<br>
public void set_CurrentPrice (decimal value) {...}<br>
Simple nonvirtual property accessors are <i>inlined</i> by the JIT (Just-In-Time) compiler,<br>
<b>Creating Types</b><br>
eliminating any performance difference between accessing a property and a field.<br>Inlining is an optimization in which a method call is replaced with the body of that<br>method.<br>
<b>Indexers<br></b>Indexers provide a natural syntax for accessing elements in a class or struct that<br>encapsulate a list or dictionary of values. Indexers are similar to properties, but are<br>accessed via an index argument rather than a property name. The string class has<br>an indexer that lets you access each of its char values via an int index:<br>
string s = &quot;hello&quot;;<br>Console.WriteLine (s[0]); // 'h'<br>
Console.WriteLine (s[3]); // 'l'<br>
The syntax for using indexers is like that for using arrays when the index is an integer<br>type.<br>
Indexers have the same modifiers as properties (see "Proper-<br>ties" on page 69).<br>
<b>Implementing an indexer<br></b>To write an indexer, define a property called this, specifying the arguments in square<br>brackets. For instance:<br>
class Sentence<br>{<br>  string[] words = &quot;The quick brown fox&quot;.Split();<br>
  <b>public string this [int wordNum]      // indexer<br></b>  <b>{<br></b>    <b>get { return words [wordNum];  }<br></b>    <b>set { words [wordNum] = value; }<br></b>  <b>}<br></b>}<br>
<b>Classes | 71</b><br>
<hr>
<A name=92></a>Here's how we could use this indexer:<br>
Sentence s = new Sentence();<br>
Console.WriteLine (s[3]);       // fox<br>
s[3] = &quot;kangaroo&quot;;<br>Console.WriteLine (s[3]);       // kangaroo<br>
A type may declare multiple indexers, each with parameters of different types. An<br>indexer can also take more than one parameter:<br>
public string this [int arg1, string arg2]<br>
{<br>  get { ... }  set { ... }<br>}<br>
If you omit the set accessor, an indexer becomes read-only.<br>
<b>CLR indexer implementation<br></b>Indexers internally compile to methods called get_Item and set_Item, as follows:<br>
public string get_Item (int wordNum) {...}<br>
public void set_Item (int wordNum, string value) {...}<br>
The compiler chooses the name "Item" by default--you can actually change this by<br>decorating your indexer with the following attribute:<br>
[System.Runtime.CompilerServices.IndexerName (&quot;Blah&quot;)]<br>
<b>Constants<br></b>A <i>constant</i> is a field whose value can never change. A constant is evaluated statically<br>at compile time and the compiler literally substitutes its value whenever used, rather<br>like a macro in C++. A constant can be any of the built-in numeric types, bool, char,<br>string, or an enum type.<br>
A constant is declared with the const keyword and must be initialized with a value.<br>For example:<br>
public class Test<br>{<br>  <b>public const string Message = &quot;Hello World&quot;;<br></b>}<br>
A constant is much more restrictive than a static readonly field--both in the types<br>you can use and in field initialization semantics. A constant also differs from a static<br>readonly field in that the evaluation of the constant occurs at compile time. For<br>example:<br>
public static double Circumference (double radius)<br>{<br>  return 2 * System.Math.PI * radius;<br>}<br>
is compiled to:<br>
<b>72 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=93></a>public static double Circumference (double radius)<br>
{<br>  return 6.2831853071795862 * radius;<br>}<br>
It makes sense for PI to be a constant, since it can never change. In contrast, a static<br>readonly field can have a different value per application.<br>
A static readonly field is also advantageous when exposing to<br>other assemblies a value that might change in a later version.<br>For instance, suppose assembly X exposes a constant as follows:<br>
public const int MaximumThreads = 20;<br>
<b>Creating Types</b><br>
If assembly Y references X and uses this constant, the value 20<br>will be baked into assembly Y when compiled. This means that<br>if X is later recompiled with the constant set to 50, Y will still use<br>the old value of 20 <i>until</i> Y <i>is recompiled</i>. A static readonly field<br>avoids this problem.<br>
Constants can also be declared local to a method. For example:<br>
static void Main()<br>
{<br>  const double twoPI  = 2 * System.Math.PI;<br>
  ...<br>
}<br>
Constants allow the following modifiers:<br>
Access modifiers<br>
public internal private protected<br>
Inheritance modifier<br>
new<br>
<b>Static Constructors<br></b>A static constructor executes once per <i>type</i>, rather than once per <i>instance</i>. A type<br>can define only one static constructor, and it must be parameterless and have the<br>same name as the type:<br>
class Test<br>{<br>  static Test() { Console.WriteLine (&quot;Type Initialized&quot;); }<br>}<br>
The runtime automatically invokes a static constructor just prior to the type being<br>used. Two things trigger this:<br>
· Instantiating the type<br>· Accessing a static member in the type<br>
The only modifiers allowed by static constructors are unsafe and extern.<br>
<b>Classes | 73</b><br>
<hr>
<A name=94></a>If a static constructor throws an unhandled exception (Chap-<br>ter 4), that type becomes <i>unusable</i> for the life of the application.<br>
<b>Static constructors and field initialization order<br></b>Static field initializers run just <i>before</i> the static constructor is called. If a type has no<br>static constructor, field initializers will execute just prior to the type being used--<br>or <i>anytime earlier</i> at the whim of the runtime. (This means that the presence of a<br>static constructor may cause field initializers to execute later in the program than<br>they would otherwise.)<br>
Static field initializers run in the order in which the fields are declared. The following<br>example illustrates this: X is initialized to 0 and Y is initialized to 3.<br>
class Foo<br>
{<br>  public static int X = Y;    // 0<br>  public static int Y = 3;    // 3<br>
}<br>
If we swap the two field initializers around, both fields are initialized to 3. The next<br>example prints 0 followed by 3 because the field initializer that instantiates a Foo<br>executes before X is initialized to 3:<br>
class Program<br>{<br>  static void Main() { Console.WriteLine (Foo.X); }   // 3<br>}<br>
class Foo<br>{<br>  <b>public static Foo Instance = new Foo();<br></b>  <b>public static int X = 3;</b><br>
  Foo() { Console.WriteLine (X); }   // 0<br>}<br>
If we swap the two lines in boldface, the example prints 3 followed by 3.<br>
<b>Static Classes<br></b>A class can be marked static, indicating that it must be composed solely of static<br>members and cannot be subclassed. The System.Console and System.Math classes are<br>good examples of static classes.<br>
<b>Finalizers<br></b>Finalizers are class-only methods that execute before the garbage collector reclaims<br>the memory for an unreferenced object. The syntax for a finalizer is the name of the<br>class prefixed with the ~ symbol:<br>
<b>74 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=95></a>class Class1<br>
{<br>  ~Class1()<br>  {<br>
    ...<br>
  }<br>}<br>
This is actually C# syntax for overriding Object's Finalize method, and the compiler<br>expands it into the following method declaration:<br>
protected override void Finalize()<br>
{<br>  ...<br>
  base.Finalize();<br>
<b>Creating Types</b><br>
}<br>
We discuss garbage collection and finalizers fully in Chapter 12.<br>
Finalizers allow the following modifier:<br>
Unmanaged code modifier<br>
unsafe<br>
<b>Partial Types and Methods<br></b>Partial types allow a type definition to be split--typically across multiple files. A<br>common scenario is for a partial class to be auto-generated from some other source<br>(e.g., an XSD), and for that class to be augmented with additional hand-authored<br>methods. For example:<br>
// PaymentFormGen.cs - auto-generated<br>partial class PaymentForm { ... }<br>
// PaymentForm.cs - hand-authored<br>partial class PaymentForm { ... }<br>
Each participant must have the partial declaration; the following is illegal:<br>
partial class PaymentForm {}<br>
class PaymentForm {}<br>
Participants cannot have conflicting members. A constructor with the same param-<br>eters,  for  instance,  cannot  be  repeated.  Partial  types  are  resolved  entirely  by  the<br>compiler, which means that each participant must be available at compile time and<br>must reside in the same assembly.<br>
There are two ways to specify a base class with partial classes:<br>
· Specify the (same) base class on each participant. For example:<br>
partial class PaymentForm : ModalForm {}<br>partial class PaymentForm : ModalForm {}<br>
· Specify the base class on just one participant. For example:<br>
partial class PaymentForm : ModalForm {}<br>partial class PaymentForm {}<br>
<b>Classes | 75</b><br>
<hr>
<A name=96></a>In addition, each participant can independently specify interfaces to implement. We<br>cover  base  classes  and  interfaces  in  "Inheritance"  on  page  76  and  "Interfa-<br>ces" on page 92.<br>
<b>Partial methods<br></b>A partial type may contain <i>partial methods</i>. These let an auto-generated partial type<br>provide customizable hooks for manual authoring. For example:<br>
partial class PaymentForm    // In auto-generated file<br>
{<br>  ...<br>
  partial void ValidatePayment (decimal amount);<br>
}<br>
partial class PaymentForm    // In hand-authored file<br>
{<br>  ...<br>  partial void ValidatePayment (decimal amount)<br>  {<br>
    if (amount &gt; 100)<br>
      ...<br>
  }<br>}<br>
A  partial  method  consists  of  two  parts:  a  <i>definition</i>  and  an  <i>implementation</i>.  The<br>definition is typically written by a code generator, and the implementation is typi-<br>cally manually authored. If an implementation is not provided, the definition of the<br>partial method is compiled away. This allows auto-generated code to be liberal in<br>providing hooks, without having to worry about code bloat. Partial methods must<br>be void and are implicitly private.<br>Partial methods were introduced in C# 3.0.<br>
<b>Inheritance<br></b>A  class  can  <i>inherit</i>  from  another  class  to  extend  or  customize  the  original  class.<br>Inheriting from a class lets you reuse the functionality in that class instead of building<br>it from scratch. A class can inherit from only a single class, but can itself be inherited<br>by many classes, thus forming a class hierarchy. In this example, we start by defining<br>a class called Asset:<br>
public class Asset<br>{<br>  public string Name;<br>}<br>
Next, we define classes called Stock and House, which will inherit from Asset. They<br>get everything an Asset has, plus any additional members that they define:<br>
public class Stock <b>: Asset</b>   // inherits from Asset<br>{<br>  public long SharesOwned;<br>}<br>
<b>76 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=97></a>public class House <b>: Asset</b>   // inherits from Asset<br>
{<br>  public decimal Mortgage;<br>}<br>
Here's how we can use these classes:<br>
Stock msft = new Stock { Name=&quot;MSFT&quot;,<br>
                         SharesOwned=1000 };<br>
Console.WriteLine (msft.Name);         // MSFT<br>Console.WriteLine (msft.SharesOwned);  // 1000<br>
House mansion = new House { Name=&quot;Mansion&quot;,<br>
<b>Creating Types</b><br>
                            Mortgage=250000 };<br>
Console.WriteLine (mansion.Name);      // Mansion<br>
Console.WriteLine (mansion.Mortgage);  // 250000<br>
The <i>subclasses</i>, Stock and House, inherit the Name property from the <i>base class</i>, Asset.<br>
A subclass is also called a <i>derived class</i>.<br>
A base class is also called a <i>superclass</i>.<br>
<b>Polymorphism<br></b>References are polymorphic. This means a variable of type <i>x</i> can refer to an object<br>that subclasses <i>x</i>. For instance, consider the following method:<br>
public static void Display (Asset asset)<br>{<br>  System.Console.WriteLine (asset.Name);<br>}<br>
This method can display both a Stock and a House, since they are both Assets:<br>
Stock msft    = new Stock ... ;<br>House mansion = new House ... ;<br>
Display (msft);<br>
Display (mansion);<br>
Polymorphism works on the basis that subclasses (Stock and House) have all the<br>features of their base class (Asset). The converse, however, is not true. If Display<br>was modified to accept a House, you could not pass in an Asset:<br>
static void Main() { Display (new Asset()); }    // Compile-time error<br>
public static void Display (House house)         // Will not accept Asset<br>{<br>  System.Console.WriteLine (house.Mortgage);<br>}<br>
<b>Inheritance | 77</b><br>
<hr>
<A name=98></a><b>Casting and Reference Conversions<br></b>An object reference can be:<br>
· Implicitly <i>upcast</i> to a base class reference<br>· Explicitly <i>downcast</i> to a subclass reference<br>
Upcasting and downcasting between compatible reference types performs <i>reference<br>conversions</i>: a new reference is created that points to the <i>same</i> object. An upcast<br>always succeeds; a downcast succeeds only if the object is suitably typed.<br>
<b>Upcasting<br></b>An upcast operation creates a base class reference from a subclass reference. For<br>example:<br>
Stock msft = new Stock();<br>
<b>Asset a = msft;              // Upcast</b><br>
After the upcast, variable a still references the same Stock object as variable msft.<br>The object being referenced is not itself altered or converted:<br>
Console.WriteLine (a == msft);        // True<br>
Although a and msft refer to the identical object, a has a more restrictive view on<br>that object:<br>
Console.WriteLine (a.Name);           // OK<br>Console.WriteLine (a.SharesOwned);    // Error: SharesOwned undefined<br>
The last line generates a compile-time error because the variable a is of type Asset,<br>even though it refers to an object of type Stock. To get to its SharedOwned field, you<br>must <i>downcast</i> the Asset to a Stock.<br>
<b>Downcasting<br></b>A downcast operation creates a subclass reference from a base class reference. For<br>example:<br>
Stock msft = new Stock();<br>Asset a = msft;                      // Upcast<br><b>Stock s = (Stock)a;                  // Downcast<br></b>Console.WriteLine (s.SharesOwned);   // &lt;No error&gt;<br>Console.WriteLine (s == a);          // True<br>Console.WriteLine (s == msft);       // True<br>
As with an upcast, only references are affected--not the underlying object. A down-<br>cast requires an explicit cast because it can potentially fail at runtime:<br>
House h = new House();<br>Asset a = h;               // Upcast always succeeds<br>Stock s = (Stock)a;        // Downcast fails: <b>a</b> is not a Stock<br>
If a downcast fails, an InvalidCastException is thrown. This is an example of <i>runtime<br>type checking</i> (we will elaborate on this concept in "Static and Runtime Type Check-<br>ing" on page 87).<br>
<b>78 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=99></a><b>The as operator<br></b>The as operator performs a downcast that evaluates to null (rather than throwing<br>an exception) if the downcast fails:<br>
Asset a = new Asset();<br>
Stock s = a as Stock;       // s is null; no exception thrown<br>
This is useful when you're going to subsequently test whether the result is null:<br>
<b>if (s != null)</b> Console.WriteLine (s.SharesOwned);<br>
Without such a test, a cast is advantageous, because if it fails, a<br>more descriptive exception is thrown. We can illustrate by com-<br>
<b>Creating Types</b><br>
paring the following two lines of code:<br>
int shares = ((Stock)a).SharesOwned;    // Approach #1<br>int shares = (a as Stock).SharesOwned;  // Approach #2<br>
If  a  is  not  a  Stock,  the  first  line  throws  an  InvalidCastExcep<br>tion, which is an accurate description of what went wrong. The<br>second line throws a NullReferenceException, which is ambig-<br>uous. Was a not a Stock or was a null?<br>
The  as  operator  cannot  perform  <i>custom  conversions</i>  (see  "Operator  Overload-<br>ing" on page 153 in Chapter 4) and it cannot do numeric conversions:<br>
long x = 3 as long;    // Compile-time error<br>
The as and cast operators will also perform upcasts, although<br>this is not terribly useful because an implicit conversion will do<br>the job.<br>
<b>The is operator<br></b>The is operator tests whether a reference conversion would succeed; in other words,<br>whether an object derives from a specified class (or implements an interface). It is<br>often used to test before downcasting.<br>
if (a is Stock)<br>  Console.WriteLine (((Stock)a).SharesOwned);<br>
The is operator does not consider custom or numeric conversions, but it does con-<br>sider <i>unboxing conversions</i> (see "The object Type" on page 85).<br>
<b>Virtual Function Members<br></b>A function marked as virtual can be <i>overridden</i> by subclasses wanting to provide a<br>specialized implementation. Methods, properties, indexers, and events can all be<br>declared virtual:<br>
<b>Inheritance | 79</b><br>
<hr>
<A name=100></a>public class Asset<br>
{<br>  public string Name;<br>  public <b>virtual</b> decimal Liability { get { return 0; } }<br>
}<br>
A subclass overrides a virtual method by applying the override modifier:<br>
public class Stock : Asset<br>
{<br>  public long SharesOwned;<br>}<br>
public class House : Asset<br>
{<br>  public decimal Mortgage;<br>
  public <b>override</b> decimal Liability { get { return Mortgage; } }<br>}<br>
By default, the Liability of an Asset is 0. A Stock does not need to specialize this<br>behavior. However, the House specializes the Liability property to return the value<br>of the Mortgage:<br>
House mansion = new House { Name=&quot;McMansion&quot;, Mortgage=250000 };<br>Console.WriteLine (mansion.Liability);      // 250000<br>
The signatures, return types, and accessibility of the virtual and overridden methods<br>must be identical. An overridden method can call its base class implementation via<br>the base keyword (we will cover this in "The base Keyword" on page 82).<br>
<b>Abstract Classes and Abstract Members<br></b>A  class  declared  as  <i>abstract</i>  can  never  be  instantiated.  Instead,  only  its  concrete<br><i>subclasses</i> can be instantiated.<br>
Abstract classes are able to define <i>abstract members</i>. Abstract members are like vir-<br>tual  members,  except  they  don't  provide  a  default  implementation.  That  imple-<br>mentation must be provided by the subclass, unless that subclass is also declared<br>abstract:<br>
public <b>abstract</b> class Asset<br>{<br>  // Note empty implementation<br>  public <b>abstract</b> decimal NetValue { get; }<br>}<br>
public class Stock : Asset<br>{<br>  public long SharesOwned;<br>  public decimal CurrentPrice;<br>
  // Override like a virtual method.<br>  public <b>override</b> decimal NetValue<br>  {<br>    get { return CurrentPrice * SharesOwned; }<br>
<b>80 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=101></a>  }<br>
}<br>
<b>Hiding Inherited Members<br></b>A base class and a subclass may define identical members. For example:<br>
public class A      { public int Counter = 1; }<br>public class B : A  { public int Counter = 2; }<br>
The Counter field in class B is said to <i>hide</i> the Counter field in class A. Usually, this<br>happens by accident, when a member is added to the base type <i>after</i> an identical<br>member was added to the subtype. For this reason, the compiler generates a warning,<br>and then resolves the ambiguity as follows:<br>
<b>Creating Types</b><br>
· References to A (at compile time) bind to A.Counter.<br>· References to B (at compile time) bind to B.Counter.<br>
Occasionally, you want to hide a member deliberately, in which case you can apply<br>the new modifier to the member in the subclass. The new modifier <i>does nothing more<br>than suppress the compiler warning that would otherwise result</i>:<br>
public class A     { public     int Counter = 1; }<br>
public class B : A { public <b>new</b> int Counter = 2; }<br>
The  new  modifier  communicates  your  intent  to  the  compiler--and  other<br>programmers--that the duplicate member is not an accident.<br>
C# overloads the new keyword to have independent meanings<br>in different contexts. Specifically, the new <i>operator</i> is different<br>from the new <i>member</i> modifier.<br>
<b>new versus virtual<br></b>Consider the following class hierarchy:<br>
public class BaseClass<br>{<br>  public virtual void Foo()  { Console.WriteLine (&quot;BaseClass.Foo&quot;); }<br>}<br>
public class Overrider : BaseClass<br>{<br>  public <b>override</b> void Foo() { Console.WriteLine (&quot;Overrider.Foo&quot;); }<br>}<br>
public class Hider : BaseClass<br>
{<br>  public <b>new</b> void Foo()      { Console.WriteLine (&quot;Hider.Foo&quot;); }<br>}<br>
The differences in behavior between Overrider and Hider are demonstrated in the<br>following code:<br>
<b>Inheritance | 81</b><br>
<hr>
<A name=102></a>Overrider over = new Overrider();<br>
BaseClass b1 = over;<br>over.Foo();                         // Overrider.Foo<br>b1.Foo();                           // Overrider.Foo<br>
Hider h = new Hider();<br>BaseClass b2 = h;<br>h.Foo();                           // Hider.Foo<br>
b2.Foo();                          // <b>BaseClass.Foo</b><br>
<b>Sealing Functions and Classes<br></b>An overridden function member may <i>seal</i> its implementation with the sealed key-<br>word to prevent it from being overridden by further subclasses. In our earlier virtual<br>function  member  example,  we  could  have  sealed  House's  implementation  of<br>Liability, preventing a class that derives from House from overriding Liability, as<br>follows:<br>
public <b>sealed</b> override decimal Liability { get { return Mortgage; } }<br>
You can also seal the class itself, implicitly sealing all the virtual functions, by ap-<br>plying the sealed modifier to the class itself. Sealing a class is more common than<br>sealing a function member.<br>
<b>The base Keyword<br></b>The base keyword is similar to the this keyword. It serves two essential purposes:<br>
· Accessing an overridden function member from the subclass<br>· Calling a base class constructor (see the next section)<br>
In this example, House uses the base keyword to access Asset's implementation of<br>Liability:<br>
public class House : Asset<br>{<br>  ...<br>  public override decimal Liability<br>  {<br>    get { return <b>base.</b>Liability + Mortgage; }<br>  }<br>}<br>
With  the  base keyword, we access  Asset's  Liability property  <i>nonvirtually</i>. This<br>means we will always access Asset's version of this property--regardless of the in-<br>stance's actual runtime type.<br>
The same approach works if Liability is <i>hidden</i> rather than <i>overridden</i>. (You can<br>also  access  hidden  members  by  casting  to  the  base  class  before  invoking  the<br>function.)<br>
<b>82 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=103></a><b>Constructors and Inheritance<br></b>A subclass must declare its own constructors. For example, if we define Subclass as<br>follows:<br>
public class Baseclass<br>
{<br>  public int X;<br>
  public Baseclass () { }<br>  public Baseclass (int x) { this.X = x; }<br>
}<br>
public class Subclass : Baseclass { }<br>
<b>Creating Types</b><br>
the following is illegal:<br>
Subclass s = new Subclass (123);<br>
Subclass must hence "redefine" any constructors it wants to expose. In doing so,<br>however, it can call any of the base class's constructors with the base keyword:<br>
public class Subclass : Baseclass<br>
{<br>  public Subclass (int x) <b>: base (x)</b> { }<br>}<br>
The base keyword works rather like the this keyword, except that it calls a con-<br>structor in the base class.<br>
Base  class  constructors  always  execute  first;  this  ensures  that  <i>base</i>  initialization<br>occurs before <i>specialized</i> initialization.<br>
<b>Implicit calling of the parameterless base class constructor<br></b>If a constructor in a subclass omits the base keyword, the base type's <i>parameter-<br>less</i> constructor is implicitly called:<br>
public class BaseClass<br>{<br>  public int X;<br>  public BaseClass() { X = 1; }<br>}<br>
public class Subclass : BaseClass<br>{<br>  public Subclass() { Console.WriteLine (X); }  // 1<br>}<br>
If the base class has no parameterless constructor, subclasses are forced to use the<br>base keyword in their constructors.<br>
<b>Inheritance | 83</b><br>
<hr>
<A name=104></a><b>Constructor and field initialization order<br></b>When an object is instantiated, initialization takes place in the following order:<br>
1. From subclass to base class:<br>
a. Fields are initialized.<br>
b. Arguments to base-class constructor calls are evaluated.<br>
2. From base class to subclass:<br>
a. Constructor bodies execute.<br>
The following code demonstrates:<br>
public class B<br>{<br>  int x = 0;         // Executes 3rd<br>
  public B (int x)<br>
  {<br>    ...              // Executes 4th<br>
  }<br>
}<br>public class D : B<br>
{<br>  int y = 0;         // Executes 1st<br>
  public D (int x)<br>    : base (<b>x + 1</b>)   // Executes 2nd<br>
  {<br>
     ...             // Executes 5th<br>
  }<br>}<br>
<b>Overloading and Resolution<br></b>Inheritance has an interesting impact on method overloading. Consider the follow-<br>ing two overloads:<br>
static void Foo (Asset a) { }<br>static void Foo (House h) { }<br>
When an overload is called, the most specific type has precedence:<br>
House h = new House (...);<br>Foo(h);                      // Calls Foo(House)<br>
The particular overload to call is determined statically (at compile time) rather than<br>at runtime. The following code calls Foo(Asset), even though the runtime type of <br>a is House:<br>
Asset a = new House (...);<br>Foo(a);                      // Calls Foo(Asset)<br>
<b>84 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=105></a>If you cast Asset to dynamic (Chapter 4), the decision as to which<br>overload to call is deferred until runtime, and is then based on<br>the object's actual type:<br>
Asset a = new House (...);<br>Foo ((dynamic)a);   // Calls Foo(House)<br>
<b>The object Type<br></b>object (System.Object) is the ultimate base class for all types. Any type can be upcast<br>to object.<br>
<b>Creating Types</b><br>
To illustrate how this is useful, consider a general-purpose <i>stack</i>. A stack is a data<br>structure  based  on  the  principle  of  LIFO--"Last-In  First-Out."  A  stack  has  two<br>operations: <i>push</i> an object on the stack, and <i>pop</i> an object off the stack. Here is a<br>simple implementation that can hold up to 10 objects:<br>
public class Stack<br>
{<br>  int position;<br>
  <b>object</b>[] data = new object[10];<br>  public void Push (<b>object</b> obj)   { data[position++] = obj;  }<br>  public <b>object</b> Pop()             { return data[--position]; }<br>
}<br>
Because Stack works with the object type, we can Push and Pop instances of <i>any<br>type</i> to and from the Stack:<br>
Stack stack = new Stack();<br>
stack.Push (&quot;sausage&quot;);<br>string s = (string) stack.Pop();   // Downcast, so explicit cast is needed<br>
Console.WriteLine (s);             // sausage<br>
object is a reference type, by virtue of being a class. Despite this, value types, such<br>as int, can also be cast to and from object, and so be added to our stack. This feature<br>of C# is called <i>type unification</i> and is demonstrated here:<br>
stack.Push (3);<br>int three = (int) stack.Pop();<br>
When you cast between a value type and object, the CLR must perform some special<br>work to bridge the difference in semantics between value and reference types. This<br>process is called <i>boxing</i> and <i>unboxing</i>.<br>
In "Generics" on page 101, we'll describe how to improve our<br>Stack class to better handle stacks with same-typed elements.<br>
<b>The object Type | 85</b><br>
<hr>
<A name=106></a><b>Boxing and Unboxing<br></b>Boxing is the act of casting a value-type instance to a reference-type instance. The<br>reference type may be either the object class or an interface (which we will visit later<br>in the chapter).* In this example, we box an int into an object:<br>
int x = 9;<br>object obj = x;           // Box the int<br>
Unboxing reverses the operation, by casting the object back to the original value<br>type:<br>
int y = (int)obj;         // Unbox the int<br>
Unboxing requires an explicit cast. The runtime checks that the stated value type<br>matches the actual object type, and throws an InvalidCastException if the check<br>fails. For instance, the following throws an exception, because long does not exactly<br>match int:<br>
object obj = 9;           // 9 is inferred to be of type int<br>
long x = (long) obj;      // InvalidCastException<br>
The following succeeds, however:<br>
object obj = 9;<br>
long x = (int) obj;<br>
As does this:<br>
object obj = 3.5;              // 3.5 is inferred to be of type double<br>
int x = (int) (double) obj;    // x is now 3<br>
In  the  last  example,  (double)  performs  an  <i>unboxing</i>  and  then  (int)  performs  a<br><i>numeric conversion</i>.<br>
Boxing  conversions  are  crucial  in  providing  a  unified  type<br>system. The system is not perfect, however: we'll see in "Ge-<br>nerics" on page 101 that variance with arrays and generics sup-<br>ports only <i>reference conversions</i> and not <i>boxing conversions</i>:<br>
object[] a1 = new <b>string</b>[3];   // Legal<br>object[] a2 = new <b>int</b>[3];      // Error<br>
<b>Copying semantics of boxing and unboxing<br></b>Boxing <i>copies</i> the value-type instance into the new object, and unboxing <i>copies</i> the<br>contents of the object back into a value-type instance. In the following example,<br>changing the value of i doesn't change its previously boxed copy:<br>
int i = 3;<br>object boxed = i;<br>i = 5;<br>Console.WriteLine (boxed);    // 3<br>
* The reference type may also be System.ValueType or System.Enum (Chapter 6).<br>
<b>86 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=107></a><b>Static and Runtime Type Checking<br></b>C# checks types both statically (at compile time) and at runtime.<br>
Static type checking enables the compiler to verify the correctness of your program<br>without running it. The following code will fail because the compiler enforces static<br>typing:<br>
int x = &quot;5&quot;;<br>
Runtime type checking is performed by the CLR when you downcast via a reference<br>conversion or unboxing. For example:<br>
object y = &quot;5&quot;;<br>
int z = (int) y;          // Runtime error, downcast failed<br>
<b>Creating Types</b><br>
Runtime type checking is possible because each object on the heap internally stores<br>a little type token. This token can be retrieved by calling the GetType method of<br>object.<br>
<b>The GetType Method and typeof Operator<br></b>All types in C# are represented at runtime with an instance of System.Type. There<br>are two basic ways to get a System.Type object:<br>
· Call GetType on the instance.<br>· Use the typeof operator on a type name.<br>
GetType is evaluated at runtime; typeof is evaluated statically at compile time.<br>
System.Type has properties for such things as the type's name, assembly, base type,<br>and so on. For example:<br>
using System;<br>
public class Point { public int X, Y; }<br>
class Test<br>{<br>  static void Main()<br>  {<br>    Point p = new Point();<br>    Console.WriteLine (p.GetType().Name);             // Point<br>    Console.WriteLine (typeof (Point).Name);          // Point<br>    Console.WriteLine (p.GetType() == typeof(Point)); // True<br>    Console.WriteLine (p.X.GetType().Name);           // Int32<br>    Console.WriteLine (p.Y.GetType().FullName);       // System.Int32<br>  }<br>}<br>
System.Type also has methods that act as a gateway to the runtime's reflection model,<br>described in Chapter 17.<br>
<b>The object Type | 87</b><br>
<hr>
<A name=108></a><b>The ToString Method<br></b>The ToString method returns the default textual representation of a type instance.<br>This method is overridden by all built-in types. Here is an example of using the<br>int type's ToString method:<br>
int x = 1;<br>string s = x.ToString();     // s is &quot;1&quot;<br>
You can override the ToString method on custom types as follows:<br>
public class Panda<br>
{<br>  public string Name;<br>
  public override string ToString() { return Name; }<br>}<br>...<br>
Panda p = new Panda { Name = &quot;Petey&quot; };<br>
Console.WriteLine (p);   // Petey<br>
When you call an <i>overridden</i> object member such as ToString<br>directly on a value type, boxing doesn't occur. Boxing then oc-<br>curs only if you cast:<br>
int x = 1;<br>string s1 = x.ToString();    // Calling on nonboxed value<br>object box = x;<br>string s2 = box.ToString();  // Calling on boxed value<br>
<b>Object Member Listing<br></b>Here are all the members of object:<br>
public class Object<br>{<br>  public Object();<br>
  public extern Type GetType();<br>
  public virtual bool Equals (object obj);<br>  public static bool Equals  (object objA, object objB);<br>  public static bool ReferenceEquals (object objA, object objB);<br>
  public virtual int GetHashCode();<br>
  public virtual string ToString();<br>
  protected override void Finalize();<br>  protected extern object MemberwiseClone();<br>}<br>
We describe the Equals, ReferenceEquals, and GetHashCode methods in "Equality<br>Comparison" on page 245 in Chapter 6.<br>
<b>88 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=109></a><b>Structs<br></b>A <i>struct</i> is similar to a class, with the following key differences:<br>
· A struct is a value type, whereas a class is a reference type.<br>· A  struct  does  not  support  inheritance  (other  than  implicitly  deriving  from<br>
object, or more precisely, System.ValueType).<br>
A struct can have all the members a class can, except the following:<br>
· A parameterless constructor<br>· A finalizer<br>
<b>Creating Types</b><br>
· Virtual members<br>
A struct is used instead of a class when value-type semantics are desirable. Good<br>examples of structs are numeric types, where it is more natural for assignment to<br>copy a value rather than a reference. Because a struct is a value type, each instance<br>does not require instantiation of an object on the heap; this incurs a useful savings<br>when creating many instances of a type. For instance, creating an array of value type<br>requires only a single heap allocation.<br>
<b>Struct Construction Semantics<br></b>The construction semantics of a struct are as follows:<br>
· A parameterless constructor that you can't override implicitly exists. This per-<br>
forms a bitwise-zeroing of its fields.<br>
· When you define a struct constructor, you must explicitly assign every field.<br>· You can't have field initializers in a struct.<br>
Here is an example of declaring and calling struct constructors:<br>
public struct Point<br>{<br>  int x, y;<br>  public Point (int x, int y) { this.x = x; this.y = y; }<br>}<br>
...<br>Point p1 = new Point ();       // p1.x and p1.y will be 0<br>Point p2 = new Point (1, 1);   // p1.x and p1.y will be 1<br>
The next example generates three compile-time errors:<br>
public struct Point<br>{<br>  int x = 1;                          // Illegal: cannot initialize field<br>  int y;<br>  public Point() {}                   // Illegal: cannot have<br>                                      // parameterless constructor<br>
  public Point (int x) {this.x = x;}  // Illegal: must assign field y<br>}<br>
<b>Structs | 89</b><br>
<hr>
<A name=110></a>Changing struct to class makes this example legal.<br>
<b>Access Modifiers<br></b>To promote encapsulation, a type or type member may limit its <i>accessibility</i> to other<br>types and other assemblies by adding one of five <i>access modifiers</i> to the declaration:<br>
public<br>
Fully accessible; the implicit accessibility for members of an enum or interface<br>
internal<br>
Accessible only within containing assembly or friend assemblies; the default<br>accessibility for non-nested types<br>
private<br>
Visible only within containing type; the default accessibility members of a class<br>or struct<br>
protected<br>
Visible only within containing type or subclasses<br>
protected internal<br>
The <i>union</i> of protected and internal accessibility (this is <i>less</i> restrictive than<br>protected or internal alone)<br>
The CLR has the concept of the <i>intersection</i> of protected and<br>internal accessibility, but C# does not support this.<br>
<b>Examples<br></b>Class2 is accessible from outside its assembly; Class1 is not:<br>
class Class1 {}                  // Class1 is internal (default)<br><b>public</b> class Class2 {}<br>
ClassB exposes field x to other types in the same assembly; ClassA does not:<br>
class ClassA { int x;          } // x is private (default)<br>
class ClassB { <b>internal</b> int x; }<br>
Functions within Subclass can call Bar but not Foo:<br>
class BaseClass<br>{<br>  void Foo()           {}        // Foo is private (default)<br>  <b>protected</b> void Bar() {}<br>}<br>
class Subclass : BaseClass<br>{<br>   void Test1() { Foo(); }       // Error - cannot access Foo<br>   void Test2() { Bar(); }       // OK<br>}<br>
<b>90 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=111></a><b>Friend Assemblies<br></b>In advanced scenarios, you can expose internal members to other <i>friend</i> assemblies<br>by adding the System.Runtime.CompilerServices.InternalsVisibleTo assembly at-<br>tribute, specifying the name of the friend assembly as follows:<br>
[assembly: InternalsVisibleTo (&quot;Friend&quot;)]<br>
If the friend assembly has a strong name (see Chapter 17), you must specify its <i>full<br></i>160-byte public key:<br>
[assembly: InternalsVisibleTo (&quot;StrongFriend, PublicKey=0024f000048c...&quot;)]<br>
You can extract the full public key from a strongly named assembly with a LINQ<br>query (we explain LINQ in detail in Chapter 8):<br>
<b>Creating Types</b><br>
string key = string.Join (&quot;&quot;,<br>
   Assembly.GetExecutingAssembly().GetName().GetPublicKey()<br>  .Select (b =&gt; b.ToString (&quot;x2&quot;))<br>  .ToArray());<br>
The companion sample in LINQPad invites you to browse to<br>an assembly and then copies the assembly's full public key to<br>the clipboard.<br>
<b>Accessibility Capping<br></b>A type caps the accessibility of its declared members. The most common example<br>of capping is when you have an internal type with public members. For example:<br>
class C { public void Foo() {} }<br>
C's  (default)  internal  accessibility  caps  Foo's  accessibility,  effectively  making  Foo<br>internal. A common reason Foo would be marked public is to make for easier re-<br>factoring, should C later be changed to public.<br>
<b>Restrictions on Access Modifiers<br></b>When overriding a base class function, accessibility must be identical on the over-<br>ridden function. For example:<br>
class BaseClass             { protected virtual  void Foo() {} }<br>class Subclass1 : BaseClass { protected override void Foo() {} }  // OK<br>class Subclass2 : BaseClass { <b>public</b>    override void Foo() {} }  // Error<br>
The compiler prevents any inconsistent use of access modifiers. For example, a sub-<br>class itself can be less accessible than a base class, but not more:<br>
internal class A {}<br>public class B : A {}          // Error<br>
<b>Access Modifiers | 91</b><br>
<hr>
<A name=112></a><b>Interfaces<br></b>An interface is similar to a class, but it provides a specification rather than an im-<br>plementation for its members. An interface is special in the following ways:<br>
· A class can implement <i>multiple</i> interfaces. In contrast, a class can inherit from<br>
only a <i>single</i> class.<br>
· Interface members are <i>all implicitly abstract</i>. In contrast, a class can provide<br>
both abstract members and concrete members with implementations.<br>
· <i>Structs</i> can implement interfaces. In contrast, a struct cannot inherit from a<br>
class.<br>
An interface declaration is like a class declaration, but it provides no implementation<br>for its members, since all its members are implicitly abstract. These members will<br>be implemented by the classes and structs that implement the interface. An interface<br>can contain only methods, properties, events, and indexers, which noncoinciden-<br>tally are precisely the members of a class that can be abstract.<br>
Here is the definition of the IEnumerator interface, defined in System.Collections:<br>
public <b>interface</b> IEnumerator<br>
{<br>  bool MoveNext();<br>
  object Current { get; }<br>  void Reset();<br>
}<br>
Interface members are always implicitly public and cannot declare an access modi-<br>fier. Implementing an interface means providing a public implementation for all its<br>members:<br>
internal class Countdown : IEnumerator<br>{<br>  int count = 11;<br>  public bool MoveNext () { return count-- &gt; 0 ;               }<br>  public object Current   { get { return count; }              }<br>  public void Reset()     { throw new NotSupportedException(); }<br>}<br>
You can implicitly cast an object to any interface that it implements. For example:<br>
IEnumerator e = new Countdown();<br>while (e.MoveNext())<br>  Console.Write (e.Current);      // 109876543210<br>
Even  though  Countdown is an internal class, its members that<br>implement IEnumerator can be called publicly by casting an in-<br>stance of Countdown to IEnumerator. For instance, if a public type<br>in the same assembly defined a method as follows:<br>
public static class Util<br>{<br>  public static object GetCountDown()<br>  {<br>
<b>92 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=113></a>    return new CountDown();<br>
  }<br>
}<br>
a caller from another assembly could do this:<br>
IEnumerator e = (IEnumerator) Util.GetCountDown();<br>
e.MoveNext();<br>
If IEnumerator was itself defined as internal, this wouldn't be<br>possible.<br>
<b>Extending an Interface</b><br>
<b>Creating Types</b><br>
Interfaces may derive from other interfaces. For instance:<br>
public interface IUndoable             { void Undo(); }<br>
public interface IRedoable : IUndoable { void Redo(); }<br>
IRedoable inherits all the members of IUndoable.<br>
<b>Explicit Interface Implementation<br></b>Implementing multiple interfaces can sometimes result in a collision between mem-<br>ber signatures. You can resolve such collisions by <i>explicitly implementing</i> an interface<br>member. Consider the following example:<br>
interface I1 { void Foo(); }<br>interface I2 { int Foo(); }<br>
public class Widget : I1, I2<br>
{<br>  public void Foo ()<br>  {<br>    Console.WriteLine (&quot;Widget's implementation of I1.Foo&quot;);<br>  }<br>
  int <b>I2.Foo</b>()<br>  {<br>    Console.WriteLine (&quot;Widget's implementation of I2.Foo&quot;);<br>    return 42;<br>  }<br>}<br>
Because both I1 and I2 have conflicting Foo signatures, Widget explicitly implements<br>I2's Foo method. This lets the two methods coexist in one class. The only way to call<br>an explicitly implemented member is to cast to its interface:<br>
Widget w = new Widget();<br>w.Foo();                      // Widget's implementation of I1.Foo<br>((I1)w).Foo();                // Widget's implementation of I1.Foo<br>((I2)w).Foo();                // Widget's implementation of I2.Foo<br>
Another reason to explicitly implement interface members is to hide members that<br>are highly specialized and distracting to a type's normal use case. For example, a<br>
<b>Interfaces | 93</b><br>
<hr>
<A name=114></a>type  that  implements  ISerializable  would  typically  want  to  avoid  flaunting  its<br>ISerializable members unless explicitly cast to that interface.<br>
<b>Implementing Interface Members Virtually<br></b>An  implicitly  implemented  interface  member  is,  by  default,  sealed.  It  must  be<br>marked virtual or abstract in the base class in order to be overridden. For example:<br>
public interface IUndoable { void Undo(); }<br>
public class TextBox : IUndoable<br>
{<br>  public <b>virtual</b> void Undo()<br>
  {<br>
     Console.WriteLine (&quot;TextBox.Undo&quot;);<br>
  }<br>}<br>
public class RichTextBox : TextBox<br>
{<br>  public <b>override</b> void Undo()<br>  {<br>
    Console.WriteLine (&quot;RichTextBox.Undo&quot;);<br>
  }<br>
}<br>
Calling the interface member through either the base class or the interface calls the<br>subclass's implementation:<br>
RichTextBox r = new RichTextBox();<br>r.Undo();                          // RichTextBox.Undo<br>((IUndoable)r).Undo();             // RichTextBox.Undo<br>((TextBox)r).Undo();               // RichTextBox.Undo<br>
An explicitly implemented interface member cannot be marked virtual, nor can it<br>be overridden in the usual manner. It can, however, be <i>reimplemented</i>.<br>
<b>Reimplementing an Interface in a Subclass<br></b>A subclass can reimplement any interface member already implemented by a base<br>class. Reimplementation hijacks a member implementation (when called through<br>the interface) and works whether or not the member is virtual in the base class. It<br>also works whether a member is implemented implicitly or explicitly--although it<br>works best in the latter case, as we will demonstrate.<br>
In the following example, TextBox implements IUndoable.Undo explicitly, and so it<br>cannot be marked as virtual. In order to "override" it, RichTextBox must reimple-<br>ment IUndoable's Undo method:<br>
public interface IUndoable { void Undo(); }<br>
public class TextBox : IUndoable<br>{<br>  void IUndoable.Undo() { Console.WriteLine (&quot;TextBox.Undo&quot;); }<br>}<br>
<b>94 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=115></a>public class RichTextBox : TextBox<b>, IUndoable</b><br>
{<br>  public new void Undo() { Console.WriteLine (&quot;RichTextBox.Undo&quot;); }<br>}<br>
Calling  the  reimplemented  member  through  the  interface  calls  the  subclass's<br>implementation:<br>
RichTextBox r = new RichTextBox();<br>
r.Undo();                 // RichTextBox.Undo      Case 1<br>
((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2<br>
Assuming the same RichTextBox definition, suppose that TextBox implemented Undo<br><i>implicitly</i>:<br>
<b>Creating Types</b><br>
public class TextBox : IUndoable<br>
{<br>  public void Undo() { Console.WriteLine (&quot;TextBox.Undo&quot;); }<br>
}<br>
This would give us another way to call Undo, which would "break" the system, as<br>shown in Case 3:<br>
RichTextBox r = new RichTextBox();<br>
r.Undo();                 // RichTextBox.Undo      Case 1<br>
((IUndoable)r).Undo();    // RichTextBox.Undo      Case 2<br>
((TextBox)r).Undo();      // <b>TextBox.Undo</b>          Case 3<br>
Case 3 shows that reimplementation hijacking is effective only when a member is<br>called through the interface and not through the base class. This is usually undesir-<br>able, as it can mean inconsistent semantics. Reimplementation is most appropriate<br>as a strategy for overriding <i>explicitly</i> implemented interface members.<br>
<b>Alternatives to interface reimplementation<br></b>Even  with  explicit  member  implementation,  interface  reimplementation  is  prob-<br>lematic for a couple of reasons:<br>
· The subclass has no way to call the base class method.<br>· The base class author may not anticipate that a method be reimplemented and<br>
may not allow for the potential consequences.<br>
Reimplementation can be a good last resort when subclassing hasn't been anticipa-<br>ted. A better option, however, is to design a base class such that reimplementation<br>will never be required. There are two ways to achieve this:<br>
· When implicitly implementing a member, mark it virtual if appropriate.<br>· When explicitly implementing a member, use the following pattern if you an-<br>
ticipate that subclasses might need to override any logic:<br>
public class TextBox : IUndoable<br>{<br>  void IUndoable.Undo()         { Undo(); }   // Calls method below<br>  protected virtual void Undo() { Console.WriteLine (&quot;TextBox.Undo&quot;); }<br>}<br>
<b>Interfaces | 95</b><br>
<hr>
<A name=116></a>public class RichTextBox : TextBox<br>
{<br>  protected override void Undo() { Console.WriteLine(&quot;RichTextBox.Undo&quot;); }<br>}<br>
If you don't anticipate any subclassing, you can mark the class as sealed to preempt<br>interface reimplementation.<br>
<b>Interfaces and Boxing<br></b>Casting a struct to an interface causes boxing. Calling an implicitly implemented<br>member on a struct does not cause boxing:<br>
interface  I { void Foo();          }<br>
struct S : I { public void Foo() {} }<br>
...<br>
S s = new S();<br>
s.Foo();         // No boxing.<br>
I i = s;         // Box occurs when casting to interface.<br>
i.Foo();<br>
<b>Writing a Class Versus an Interface</b><br>
As a guideline:<br>
· Use classes and subclasses for types that naturally share an implementation.<br>· Use interfaces for types that have independent implementations.<br>
Consider the following classes:<br>
abstract class Animal {}<br>abstract class Bird           : Animal {}<br>abstract class Insect         : Animal {}<br>abstract class FlyingCreature : Animal {}<br>abstract class Carnivore      : Animal {}<br>
// Concrete classes:<br>
class Ostrich : Bird {}<br>class Eagle   : Bird, FlyingCreature, Carnivore {}  // Illegal<br>class Bee     : Insect, FlyingCreature {}           // Illegal<br>class Flea    : Insect, Carnivore {}                // Illegal<br>
The Eagle, Bee, and Flea classes do not compile because inheriting from multiple<br>classes is prohibited. To resolve this, we must convert some of the types to inter-<br>faces. The question then arises, which types? Following our general rule, we could<br>say that insects share an implementation, and birds share an implementation, so<br>they remain classes. In contrast, flying creatures have independent mechanisms<br>for flying, and carnivores have independent strategies for eating animals, so we<br>would convert FlyingCreature and Carnivore to interfaces:<br>
interface IFlyingCreature {}<br>interface ICarnivore      {}<br>
<b>96 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=117></a>In a typical scenario, Bird and Insect might correspond to a Windows control and<br>a web control; FlyingCreature and Carnivore might correspond to IPrintable and<br>IUndoable.<br>
<b>Enums<br></b>An enum is a special value type that lets you specify a group of named numeric<br>constants. For example:<br>
public enum BorderSide { Left, Right, Top, Bottom }<br>
We can use this enum type as follows:<br>
<b>Creating Types</b><br>
BorderSide topSide = BorderSide.Top;<br>bool isTop = (topSide == BorderSide.Top);   // true<br>
Each enum member has an underlying integral value. By default:<br>
· Underlying values are of type int.<br>· The constants 0, 1, 2... are automatically assigned, in the declaration order of<br>
the enum members.<br>
You may specify an alternative integral type, as follows:<br>
public enum BorderSide : <b>byte</b> { Left, Right, Top, Bottom }<br>
You may also specify an explicit underlying value for each enum member:<br>
public enum BorderSide : byte { Left=1, Right=2, Top=10, Bottom=11 }<br>
The compiler also lets you explicitly assign <i>some</i> of the enum<br>members. The unassigned enum members keep incrementing<br>from the last explicit value. The preceding example is equivalent<br>to the following:<br>
public enum BorderSide : byte<br> { Left=1, Right, Top=10, Bottom }<br>
<b>Enum Conversions<br></b>You can convert an enum instance to and from its underlying integral value with an<br>explicit cast:<br>
int i = (int) BorderSide.Left;<br>BorderSide side = (BorderSide) i;<br>bool leftOrRight = (int) side &lt;= 2;<br>
You can also explicitly cast one enum type to another. Suppose HorizontalAlign<br>ment is defined as follows:<br>
public enum HorizontalAlignment<br>{<br>  Left = BorderSide.Left,<br>  Right = BorderSide.Right,<br>
<b>Enums | 97</b><br>
<hr>
<A name=118></a>  Center<br>
}<br>
A translation between the enum types uses the underlying integral values:<br>
HorizontalAlignment h = (HorizontalAlignment) BorderSide.Right;<br>// same as:<br>HorizontalAlignment h = (HorizontalAlignment) (int) BorderSide.Right;<br>
The numeric literal 0 is treated specially by the compiler in an enum expression and<br>does not require an explicit cast:<br>
BorderSide b = 0;    // No cast required<br>if (b == 0) ...<br>
There are two reasons for the special treatment of 0:<br>
· The first member of an enum is often used as the "default" value.<br>· For <i>combined enum</i> types, 0 means "no flags."<br>
<b>Flags Enums<br></b>You can combine enum members. To prevent ambiguities, members of a combin-<br>able  enum  require  explicitly  assigned  values,  typically  in  powers  of  two.  For<br>example:<br>
[Flags]<br>
public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }<br>
To work with combined enum values, you use bitwise operators, such as | and &amp;.<br>These operate on the underlying integral values:<br>
BorderSides leftRight = BorderSides.Left | BorderSides.Right;<br>
if ((leftRight &amp; BorderSides.Left) != 0)<br>  Console.WriteLine (&quot;Includes Left&quot;);     // Includes Left<br>
string formatted = leftRight.ToString();   // &quot;Left, Right&quot;<br>
BorderSides s = BorderSides.Left;<br>s |= BorderSides.Right;<br>Console.WriteLine (s == leftRight);   // True<br>
s ^= BorderSides.Right;               // Toggles BorderSides.Right<br>Console.WriteLine (s);                // Left<br>
By convention, the Flags attribute should always be applied to an enum type when<br>its members are combinable. If you declare such an enum without the Flags attribute,<br>you can still combine members, but calling ToString on an enum instance will emit<br>a number rather than a series of names.<br>
By convention, a combinable enum type is given a plural rather than singular name.<br>
For convenience, you can include combination members within an enum declara-<br>tion itself:<br>
<b>98 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=119></a>[Flags]<br>
public enum BorderSides<br>{<br>  Left=1, Right=2, Top=4, Bottom=8,<br>
  <b>LeftRight = Left | Right,</b><br>
  <b>TopBottom = Top  | Bottom,<br></b>  <b>All       = LeftRight | TopBottom<br></b>}<br>
<b>Enum Operators<br></b>The operators that work with enums are:<br>
=   ==   !=   &lt;   &gt;   &lt;=   &gt;=   +   -   ^  &amp;  |   ~<br>
<b>Creating Types</b><br>
+=   -=   ++  -   sizeof<br>
The bitwise, arithmetic, and comparison operators return the result of processing<br>the underlying integral values. Addition is permitted between an enum and an in-<br>tegral type, but not between two enums.<br>
<b>Type-Safety Issues<br></b>Consider the following enum:<br>
public enum BorderSide { Left, Right, Top, Bottom }<br>
Since an enum can be cast to and from its underlying integral type, the actual value<br>it may have may fall outside the bounds of a legal enum member. For example:<br>
BorderSide b = (BorderSide) 12345;<br>Console.WriteLine (b);                // 12345<br>
The bitwise and arithmetic operators can produce similarly invalid values:<br>
BorderSide b = BorderSide.Bottom;<br>b++;                                  // No errors<br>
An invalid BorderSide would break the following code:<br>
void Draw (BorderSide side)<br>{<br>  if      (side == BorderSide.Left)  {...}<br>  else if (side == BorderSide.Right) {...}<br>  else if (side == BorderSide.Top)   {...}<br>  else                               {...} // Assume BorderSide.Bottom<br>}<br>
One solution is to add another else clause:<br>
  ...<br>  else if (side == BorderSide.Bottom) ...<br>  else throw new ArgumentException (&quot;Invalid BorderSide: &quot; + side, &quot;side&quot;);<br>
Another workaround is to explicitly check an enum value for validity. The static<br>Enum.IsDefined method does this job:<br>
BorderSide side = (BorderSide) 12345;<br>Console.WriteLine (Enum.IsDefined (typeof (BorderSide), side));   // False<br>
<b>Enums | 99</b><br>
<hr>
<A name=120></a>Unfortunately, Enum.IsDefined does not work for flagged enums. However, the fol-<br>lowing helper method (a trick dependent on the behavior of Enum.ToString()) re-<br>turns true if a given flagged enum is valid:<br>
static bool IsFlagDefined (Enum e)<br>
{<br>  decimal d;<br>
  return !decimal.TryParse(e.ToString(), out d);<br>
}<br>
[Flags]<br>public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }<br>
static void Main()<br>
{<br>  for (int i = 0; i &lt;= 16; i++)<br>  {<br>
    BorderSides side = (BorderSides)i;<br>
    Console.WriteLine (IsFlagDefined (side) + &quot; &quot; + side);<br>
  }<br>}<br>
<b>Nested Types<br></b>A <i>nested type</i> is declared within the scope of another type. For example:<br>
public class TopLevel<br>{<br>  public class Nested { }               // Nested class<br>  public enum Color { Red, Blue, Tan }  // Nested enum<br>}<br>
A nested type has the following features:<br>
· It can access the enclosing type's private members and everything else the en-<br>
closing type can access.<br>
· It  can  be  declared  with  the  full  range  of  access  modifiers,  rather  than  just<br>
public and internal.<br>
· The default visibility for a nested type is private rather than internal.<br>· Accessing a nested type from outside the enclosing type requires qualification<br>
with the enclosing type's name (like when accessing static members).<br>
For example, to access Color.Red from outside our TopLevel class, we'd have to do<br>this:<br>
TopLevel.Color color = TopLevel.Color.Red;<br>
All types can be nested; however, only classes and structs can <i>nest</i>.<br>
Here is an example of accessing a private member of a type from a nested type:<br>
<b>100 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=121></a>public class TopLevel<br>
{<br>  static int x;<br>  class Nested<br>
  {<br>
    static void Foo() { Console.WriteLine (TopLevel.x); }<br>  }<br>}<br>
Here is an example of applying the protected access modifier to a nested type:<br>
public class TopLevel<br>
{<br>  protected class Nested { }<br>}<br>
<b>Creating Types</b><br>
public class SubTopLevel : TopLevel<br>{<br>  static void Foo() { new TopLevel.Nested(); }<br>}<br>
Here is an example of referring to a nested type from outside the enclosing type:<br>
public class TopLevel<br>
{<br>  public class Nested { }<br>
}<br>
class Test<br>
{<br>  TopLevel.Nested n;<br>}<br>
Nested types are used heavily by the compiler itself when it generates private classes<br>that capture state for constructs such as iterators and anonymous methods.<br>
If the sole reason for using a nested type is to avoid cluttering a<br>namespace with too many types, consider using a nested name-<br>space instead. A nested type should be used because of its stron-<br>ger access control restrictions, or when the nested class must<br>access private members of the containing class.<br>
<b>Generics<br></b>C# has two separate mechanisms for writing code that is reusable across different<br>types:  <i>inheritance</i> and  <i>generics</i>. Whereas inheritance expresses reusability with a<br>base type, generics express reusability with a "template" that contains "placeholder"<br>types. Generics, when compared to inheritance, can <i>increase type safety</i> and <i>reduce<br>casting and boxing</i>.<br>
<b>Generics | 101</b><br>
<hr>
<A name=122></a>C# generics and C++ templates are similar concepts, but they<br>work differently. We explain this difference in "C# Generics<br>Versus C++ Templates" on page 113.<br>
<b>Generic Types<br></b>A generic type declares <i>type parameters</i>--placeholder types to be filled in by the<br>consumer of the generic type, which supplies the <i>type arguments</i>. Here is a generic<br>type Stack&lt;T&gt;, designed to stack instances of type T. Stack&lt;T&gt; declares a single type<br>parameter T:<br>
public class Stack<b>&lt;T&gt;</b><br>
{<br>  int position;<br>
  <b>T</b>[] data = new <b>T</b>[100];<br>
  public void Push (<b>T</b> obj)   { data[position++] = obj;  }<br>
  public <b>T</b> Pop()             { return data[--position]; }<br>
}<br>
We can use Stack&lt;T&gt; as follows:<br>
Stack<b>&lt;int&gt;</b> stack = new Stack<b>&lt;int&gt;</b>();<br>
stack.Push(5);<br>stack.Push(10);<br>int x = stack.Pop();        // x is 10<br>
int y = stack.Pop();        // y is 5<br>
Stack&lt;int&gt; fills in the type parameter T with the type argument int, implicitly cre-<br>ating a type on the fly (the synthesis occurs at runtime). Stack&lt;int&gt; effectively has<br>the following definition (substitutions appear in bold, with the class name hashed<br>out to avoid confusion):<br>
public class ###<br>{<br>  int position;<br>  <b>int</b>[] data;<br>  public void Push (<b>int</b> obj)   { data[position++] = obj;  }<br>  public <b>int</b> Pop()             { return data[--position]; }<br>}<br>
Technically, we say that Stack&lt;T&gt; is an <i>open type</i>, whereas Stack&lt;int&gt; is a <i>closed<br>type</i>. At runtime, all generic type instances are closed--with the placeholder types<br>filled in. This means that the following statement is illegal:<br>
var stack = new Stack&lt;T&gt;();   // Illegal: What is T?<br>
unless inside a class or method which itself defines T as a type parameter:<br>
public class Stack&lt;T&gt;<br>{<br>  ...<br>  public Stack&lt;T&gt; Clone()<br>  {<br>    Stack&lt;T&gt; clone = new Stack&lt;T&gt;();   // Legal<br>    ...<br>
<b>102 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=123></a>  }<br>
}<br>
<b>Why Generics Exist<br></b>Generics exist to write code that is reusable across different types. Suppose we nee-<br>ded a stack of integers, but we didn't have generic types. One solution would be to<br>hardcode  a  separate  version  of  the  class  for  every  required  element  type  (e.g.,<br>IntStack,  StringStack,  etc.).  Clearly,  this  would  cause  considerable  code<br>duplication. Another solution would be to write a stack that is generalized by using<br>object as the element type:<br>
public class ObjectStack<br>
<b>Creating Types</b><br>
{<br>  int position;<br>
  <b>object</b>[] data = new <b>object</b>[10];<br>
  public void Push (<b>object</b> obj) { data[position++] = obj;  }<br>
  public <b>object</b> Pop()           { return data[--position]; }<br>
}<br>
An ObjectStack, however, wouldn't work as well as a hardcoded IntStack for spe-<br>cifically stacking integers. Specifically, an ObjectStack would require boxing and<br>downcasting that could not be checked at compile time:<br>
// Suppose we just want to store integers here:<br>
ObjectStack stack = new ObjectStack();<br>
stack.Push (&quot;s&quot;);          // Wrong type, but no error!<br>
int i = (int)stack.Pop();  // Downcast - runtime error<br>
What we need is both a general implementation of a stack that works for all element<br>types, and a way to easily specialize that stack to a specific element type for increased<br>type safety and reduced casting and boxing. Generics give us precisely this, by al-<br>lowing  us  to  parameterize  the  element  type.  Stack&lt;T&gt;  has  the  benefits  of  both<br>ObjectStack and IntStack. Like ObjectStack, Stack&lt;T&gt; is written once to work <i>gen-<br>erally</i> across all types. Like IntStack, Stack&lt;T&gt; is <i>specialized</i> for a particular type--<br>the beauty is that this type is T, which we substitute on the fly.<br>
ObjectStack is functionally equivalent to Stack&lt;object&gt;.<br>
<b>Generic Methods<br></b>A generic method declares type parameters within the signature of a method.<br>
With  generic  methods,  many  fundamental  algorithms  can  be  implemented  in  a<br>general-purpose way only. Here is a generic method that swaps two values of any<br>type:<br>
<b>Generics | 103</b><br>
<hr>
<A name=124></a>static void Swap&lt;T&gt; (ref T a, ref T b)<br>
{<br>  T temp = a;<br>  a = b;<br>
  b = temp;<br>
}<br>
Swap&lt;T&gt; can be used as follows:<br>
int x = 5;<br>int y = 10;<br>Swap (ref x, ref y);<br>
Generally, there is no need to supply type arguments to a generic method, because<br>the compiler can implicitly infer the type. If there is ambiguity, generic methods can<br>be called with the type arguments as follows:<br>
Swap<b>&lt;int&gt;</b> (ref x, ref y);<br>
Within a generic <i>type</i>, a method is not classed as generic unless it <i>introduces</i> type<br>parameters (with the angle bracket syntax). The Pop method in our generic stack<br>merely uses the type's existing type parameter, T, and is not classed as a generic<br>method.<br>
Methods  and  types  are  the  only  constructs  that  can  introduce  type  parameters.<br>Properties, indexers, events, fields, constructors, operators, and so on cannot declare<br>type parameters, although they can partake in any type parameters already declared<br>by their enclosing type. In our generic stack example, for instance, we could write<br>an indexer that returns a generic item:<br>
public T this [int index] { get { return data [index]; } }<br>
Similarly, constructors can partake in existing type parameters, but not <i>introduce<br></i>them:<br>
public Stack&lt;T&gt;() { }   // Illegal<br>
<b>Declaring Type Parameters<br></b>Type parameters can be introduced in the declaration of classes, structs, interfaces,<br>delegates (covered in Chapter 4), and methods. Other constructs, such as properties,<br>cannot  <i>introduce</i>  a  type  parameter,  but  can  <i>use</i>  one.  For  example,  the  property<br>Value uses T:<br>
public struct Nullable<b>&lt;T&gt;<br></b>{<br>  public <b>T</b> Value { get; set; }<br>}<br>
A generic type or method can have multiple parameters. For example:<br>
class Dictionary&lt;TKey, TValue&gt; {...}<br>
To instantiate:<br>
Dictionary&lt;int,string&gt; myDic = new Dictionary&lt;int,string&gt;();<br>
<b>104 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=125></a>Or:<br>
var myDic = new Dictionary&lt;int,string&gt;();<br>
Generic type names and method names can be overloaded as long as the number of<br>type  parameters  is  different.  For  example,  the  following  two  type  names  do  not<br>conflict:<br>
class A&lt;T&gt; {}<br>
class A&lt;T1,T2&gt; {}<br>
By convention, generic types and methods with a <i>single</i> type<br>parameter typically name their parameter T, as long as the intent<br>of the parameter is clear. When using <i>multiple</i> type parameters,<br>
<b>Creating Types</b><br>
each parameter is prefixed with T, but has a more descriptive<br>name.<br>
<b>typeof and Unbound Generic Types<br></b>Open generic types do not exist at runtime: open generic types are closed as part of<br>compilation.  However,  it  is  possible  for  an  <i>unbound</i>  generic  type  to  exist  at<br>runtime--purely as a Type object. The only way to specify an unbound generic type<br>in C# is with the typeof operator:<br>
class A&lt;T&gt; {}<br>class A&lt;T1,T2&gt; {}<br>
...<br>
Type a1 = <b>typeof (A&lt;&gt;)</b>;   // <i>Unbound</i> type (notice no type arguments).<br>
Type a2 = <b>typeof (A&lt;,&gt;)</b>;  // Use commas to indicate multiple type args.<br>
You can also use the typeof operator to specify a closed type:<br>
Type a3 = typeof (A&lt;int,int&gt;);<br>
or an open type (which is closed at runtime):<br>
class B&lt;T&gt; { void X() { Type t = typeof (T); } }<br>
<b>The default Generic Value<br></b>The default keyword can be used to get the default value given a generic type pa-<br>rameter. The default value for a reference type is null, and the default value for a<br>value type is the result of bitwise-zeroing the value type's fields:<br>
static void Zap&lt;T&gt; (T[] array)<br>{<br>  for (int i = 0; i &lt; array.Length; i++)<br>    array[i] = default(T);<br>}<br>
<b>Generics | 105</b><br>
<hr>
<A name=126></a><b>Generic Constraints<br></b>By default, a type parameter can be substituted with any type whatsoever.  <i>Con-<br>straints</i> can be applied to a type parameter to require more specific type arguments.<br>These are the possible constraints:<br>
where <i>T</i> : <i>base-class</i>   // Base class constraint<br>where <i>T</i> : <i>interface</i>    // Interface constraint<br>
where <i>T</i> : class        // Reference-type constraint<br>
where <i>T</i> : struct       // Value-type constraint (excludes Nullable types)<br>
where <i>T</i> : new()        // Parameterless constructor constraint<br>
where <i>U</i> : <i>T</i>            // Naked type constraint<br>
In the following example, GenericClass&lt;T,U&gt; requires T to derive from SomeClass and<br>implement Interface1, and requires U to provide a parameterless constructor:<br>
class     SomeClass {}<br>interface Interface1 {}<br>
class GenericClass&lt;T&gt; where T : SomeClass, Interface1<br>
                      where U : new()<br>
{...}<br>
Constraints can be applied wherever type parameters are defined, in both methods<br>and type definitions.<br>
A <i>base class constraint</i> or <i>interface constraint</i> specifies that the type parameter must<br>subclass or implement a particular class or interface. This allows instances of that<br>type to be implicitly cast to that class or interface. For example, suppose we want<br>to write a generic Max method, which returns the maximum of two values. We can<br>take  advantage  of  the  generic  interface  defined  in  the  framework  called<br>IComparable&lt;T&gt;:<br>
public interface IComparable&lt;T&gt;   // Simplified version of interface<br>{<br>  int CompareTo (T other);<br>}<br>
CompareTo returns a positive number if other is greater than this. Using this interface<br>as a constraint, we can write a Max method as follows (to avoid distraction, null<br>checking is omitted):<br>
static T Max &lt;T&gt; (T a, T b) where T : IComparable&lt;T&gt;<br>{<br>  return a.CompareTo (b) &gt; 0 ? a : b;<br>}<br>
The Max method can accept arguments of any type implementing IComparable&lt;T&gt;<br>(which includes most built-in types such as int and string):<br>
int z = Max (5, 10);               // 10<br>string last = Max (&quot;ant&quot;, &quot;zoo&quot;);  // zoo<br>
<b>106 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=127></a>The <i>class constraint</i> and <i>struct constraint</i> specify that T must be a reference type or<br>(non-nullable) value type. A great example of the struct constraint is the System.Nul<br>lable&lt;T&gt;  struct  (we  will  discuss  this  class  in  depth  in  the  section  "Nullable<br>Types" on page 148 in Chapter 4):<br>
struct Nullable&lt;T&gt; where T : struct {...}<br>
The <i>parameterless constructor constraint</i> requires T to have a public parameterless<br>constructor. If this constraint is defined, you can call new() on T:<br>
static void Initialize&lt;T&gt; (T[] array) where T : new()<br>
{<br>  for (int i = 0; i &lt; array.Length; i++)<br>
    array[i] = new T();<br>
<b>Creating Types</b><br>
}<br>
The <i>naked type constraint</i> requires one type parameter to derive from <i>another type<br>parameter</i>. In this example, the method FilteredStack returns another Stack, con-<br>taining only the subset of elements where the type parameter T is of the type pa-<br>rameter U:<br>
class Stack&lt;T&gt;<br>{<br>  Stack&lt;U&gt; FilteredStack&lt;U&gt;() where U : T {...}<br>
}<br>
<b>Subclassing Generic Types<br></b>A generic class can be subclassed just like a nongeneric class. The subclass can leave<br>the base class's type parameters open, as in the following example:<br>
class Stack&lt;T&gt;                   {...}<br>class SpecialStack&lt;T&gt; : Stack&lt;T&gt; {...}<br>
Or the subclass can close the generic type parameters with a concrete type:<br>
class IntStack : Stack&lt;<b>int</b>&gt;  {...}<br>
A subtype can also introduce fresh type arguments:<br>
class List&lt;T&gt;                     {...}<br>class KeyedList&lt;T<b>,TKey</b>&gt; : List&lt;T&gt; {...}<br>
Technically,  <i>all</i>  type  arguments  on  a  subtype  are  fresh:  you<br>could say that a subtype closes and then reopens the base type<br>arguments. This means that a subclass can give new (and po-<br>tentially  more  meaningful)  names  to  the  type  arguments  it<br>reopens:<br>
class List&lt;T&gt; {...}<br>class KeyedList&lt;TElement,TKey&gt; : List&lt;TElement&gt; {...}<br>
<b>Generics | 107</b><br>
<hr>
<A name=128></a><b>Self-Referencing Generic Declarations<br></b>A type can name <i>itself</i> as the concrete type when closing a type argument:<br>
public interface IEquatable&lt;T&gt; { bool Equals (T obj); }<br>
public class <b>Balloon</b> : IEquatable&lt;<b>Balloon</b>&gt;<br>{<br>  public string Color { get; set; }<br>
  public int CC { get; set; }<br>
  public bool Equals (Balloon b)<br>  {<br>
    if (b == null) return false;<br>    return b.Color == Color &amp;&amp; b.CC == CC;<br>
  }<br>}<br>
The following are also legal:<br>
class Foo&lt;T&gt; where T : IComparable&lt;T&gt; { ... }<br>
class Bar&lt;T&gt; where T : Bar&lt;T&gt; { ... }<br>
<b>Static Data<br></b>Static data is unique for each closed type:<br>
class Bob&lt;T&gt; { public static int Count; }<br>
class Test<br>{<br>  static void Main()<br>  {<br>    Console.WriteLine (++Bob&lt;int&gt;.Count);     // 1<br>    Console.WriteLine (++Bob&lt;int&gt;.Count);     // 2<br>    Console.WriteLine (++Bob&lt;string&gt;.Count);  // 1<br>    Console.WriteLine (++Bob&lt;object&gt;.Count);  // 1<br>  }<br>}<br>
<b>Type Parameters and Conversions<br></b>C#'s cast operator can perform several kinds of conversion, including:<br>
· Numeric conversion<br>· Reference conversion<br>· Boxing/unboxing conversion<br>· Custom conversion (via operator overloading; see Chapter 4)<br>
The  decision  as  to  which  kind  of  conversion  will  take  place  happens  at  <i>compile<br>time</i>, based on the known types of the operands. This creates an interesting scenario<br>with generic type parameters, because the precise operand types are unknown at<br>compile time. If this leads to ambiguity, the compiler generates an error.<br>
<b>108 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=129></a>The most common scenario is when you want to perform a reference conversion:<br>
StringBuilder Foo&lt;T&gt; (T arg)<br>
{<br>  if (arg is StringBuilder)<br>    return <b>(StringBuilder) arg</b>;   // Will not compile<br>  ...<br>
}<br>
Without knowledge of T's actual type, the compiler is concerned that you might<br>have intended this to be a <i>custom conversion</i>. The simplest solution is to instead use<br>the  as  operator,  which  is  unambiguous  because  it  cannot  perform  custom<br>conversions:<br>
StringBuilder Foo&lt;T&gt; (T arg)<br>
<b>Creating Types</b><br>
{<br>  StringBuilder sb = <b>arg as StringBuilder</b>;<br>
  if (sb != null) return sb;<br>
  ...<br>
}<br>
A more general solution is to first cast to object. This works because conversions<br>to/from object are assumed not to be custom conversions, but reference or boxing/<br>unboxing conversions. In this case, StringBuilder is a reference type, so it has to be<br>a reference conversion:<br>
  return <b>(StringBuilder) (object) arg</b>;<br>
Unboxing conversions can also introduce ambiguities. The following could be an<br>unboxing, numeric, or custom conversion:<br>
int Foo&lt;T&gt; (T x) {   return <b>(int) x</b>; }    // Compile-time error<br>
The solution, again, is to first cast to object and then to int (which then unambig-<br>uously signals an unboxing conversion in this case):<br>
int Foo&lt;T&gt; (T x) {   return <b>(int) (object) x</b>; }<br>
<b>Covariance<br></b>Assuming S subclasses B, type X is <i>covariant</i> if X&lt;S&gt; allows a reference conversion to<br>X&lt;B&gt;.<br>
In other words, type IFoo&lt;T&gt; is covariant if the following is legal:<br>
IFoo&lt;string&gt; b = ...;<br><b>IFoo&lt;object&gt; s = b;</b><br>
As of C# 4.0, generic interfaces permit covariance (as do generic delegates--see<br>Chapter 4), but generic classes do not. Arrays also support covariance (S[] can be<br>cast to B[] if S subclasses B), and are discussed here for comparison.<br>
<b>Generics | 109</b><br>
<hr>
<A name=130></a>Covariance  and  contravariance  (or  simply  "variance")  are<br>advanced  concepts.  The  motivation  behind  introducing  and<br>enhancing variance in C# was to allow generic interface and<br>generic types (in particular, those defined in the Framework,<br>such as IEnumerable&lt;T&gt;) to work <i>more as you'd expect</i>. You can<br>benefit from this without understanding the details behind co-<br>variance and contravariance.<br>
<b>Classes<br></b>Generic classes are not covariant, to ensure static type safety. Consider the following:<br>
class Animal {}<br>
class Bear : Animal {}<br>
class Camel : Animal {}<br>
public class Stack&lt;T&gt;   // A simple Stack implementation<br>
{<br>  int position;<br>
  T[] data = new T[100];<br>
  public void Push (T obj)   { data[position++] = obj;  }<br>
  public T Pop()             { return data[--position]; }<br>
}<br>
The following fails to compile:<br>
Stack&lt;Bear&gt; bears = new Stack&lt;Bear&gt;();<br><b>Stack&lt;Animal&gt; animals = bears;            // Compile-time error</b><br>
That restriction prevents the possibility of runtime failure with the following code:<br>
animals.Push (new Camel());      // Trying to add Camel to bears<br>
Lack of covariance, however, can hinder reusability. Suppose, for instance, we wan-<br>ted to write a method to Wash a stack of animals:<br>
public class ZooCleaner<br>{<br>  public static void Wash (Stack&lt;Animal&gt; animals) {...}<br>}<br>
Calling Wash with a stack of bears would generate a compile-time error. One work-<br>around is to redefine the Wash method with a constraint:<br>
class ZooCleaner<br>{<br>  public static void Wash&lt;T&gt; (Stack&lt;T&gt; animals) <b>where T : Animal</b> { ... }<br>}<br>
We can now call Wash as follows:<br>
Stack&lt;Bear&gt; bears = new Stack&lt;Bear&gt;();<br>ZooCleaner.Wash (bears);<br>
Another solution is to have Stack&lt;T&gt; implement a covariant generic interface, as we'll<br>see shortly.<br>
<b>110 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=131></a><b>Arrays<br></b>For historical reasons, array types are covariant. This means that B[] can be cast to<br>A[] if B subclasses A (and both are reference types). For example:<br>
Bear[] bears = new Bear[3];<br>
Animal[] animals = bears;     // OK<br>
The downside of this reusability is that element assignments can fail at runtime:<br>
animals[0] = new Camel();     // Runtime error<br>
<b>Interfaces<br></b>As of C# 4.0, generic interfaces support covariance for type parameters marked with<br>
<b>Creating Types</b><br>
the out modifier. This modifier ensures that, unlike with arrays, covariance with<br>interfaces is fully type-safe. To illustrate, suppose that our Stack class implements<br>the following interface:<br>
public interface IPoppable&lt;<b>out</b> T&gt; { T Pop(); }<br>
The out modifier on T is new to C# 4.0 and indicates that T is used only in <i>output<br>positions</i> (e.g., return types for methods). The out modifier flags the interface as<br><i>covariant</i> and allows us to do this:<br>
var bears = new Stack&lt;Bear&gt;();<br>bears.Push (new Bear());<br>
// Bears implements IPoppable&lt;Bear&gt;. We can convert to IPoppable&lt;Animal&gt;:<br>
<b>IPoppable&lt;Animal&gt; animals = bears;   // Legal<br></b>Animal a = animals.Pop();<br>
The cast from bears to animals is permitted by the compiler--by virtue of the in-<br>terface being covariant. This is type-safe because the case the compiler is trying to<br>avoid--pushing a Camel onto the stack--can't occur as there's no way to feed a Camel<br><i>in</i>to an interface where T can appear only in <i>out</i>put positions.<br>
Covariance (and contravariance) in interfaces is something that<br>you typically <i>consume</i>: it's less common that you need to <i>write<br></i>variant interfaces.<br>
Curiously, method parameters marked as out are not eligible for<br>covariance, due to a limitation in the CLR.<br>
We can leverage the ability to cast covariantly to solve the reusability problem de-<br>scribed earlier:<br>
public class ZooCleaner<br>
{<br>  public static void Wash (<b>IPoppable&lt;Animal&gt;</b> animals) { ... }<br>}<br>
<b>Generics | 111</b><br>
<hr>
<A name=132></a>The IEnumerator&lt;T&gt; and IEnumerable&lt;T&gt; interfaces described in<br>Chapter 7 are marked as covariant from Framework 4.0. This<br>allows  you  to  cast  IEnumerable&lt;string&gt;  to  IEnumera<br>ble&lt;object&gt;, for instance.<br>
The  compiler  will  generate  an  error  if  you  use  a  covariant  type  parameter  in  an<br><i>input</i> position (e.g., a parameter to a method or a writable property).<br>
With both generic types and arrays, covariance (and contravar-<br>iance) is valid only for elements with <i>reference conversions</i>--not<br><i>boxing conversions</i>. So, if you wrote a method that accepted a<br>parameter  of  type  IPoppable&lt;object&gt;,  you  could  call  it  with<br>IPoppable&lt;string&gt;, but not IPoppable&lt;int&gt;.<br>
<b>Contravariance<br></b>We previously saw that a type X is covariant if X&lt;S&gt; allows a reference conversion to<br>X&lt;B&gt; where S subclasses B. A type is <i>contravariant</i> when you can convert in the reverse<br>direction--from X&lt;B&gt; to X&lt;S&gt;. This is supported in C# 4.0 with generic interfaces--<br>when the generic type parameter only appears in <i>input</i> positions, designated with<br>the in modifier. Extending our previous example, if the Stack&lt;T&gt; class implements<br>the following interface:<br>
public interface IPushable&lt;<b>in</b> T&gt; { void Push (T obj); }<br>
we can legally do this:<br>
IPushable&lt;Animal&gt; animals = new Stack&lt;Animal&gt;();<br><b>IPushable&lt;Bear&gt; bears = animals;    // Legal</b><br>
bears.Push (new Bear());<br>
No member in IPushable <i>outputs</i> a T, so we can't get into trouble by casting animals to<br>bears (there's no way to Pop, for instance, through that interface).<br>
Our  Stack&lt;T&gt;  class  can  implement  both  IPushable&lt;T&gt;  and<br>IPoppable&lt;T&gt;--despite T having opposing variance annotations<br>in the two interfaces! This works because you can exercise var-<br>iance only through an interface; therefore, you must commit to<br>the lens of either IPoppable or IPushable before performing a<br>variant conversion. This lens then restricts you to the operations<br>that are legal under the appropriate variance rules.<br>
This also illustrates why it would make no sense for <i>classes</i> (such<br>as Stack&lt;T&gt;) to be variant.<br>
<b>112 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=133></a>To  give  another  example,  consider  the  following  interface,  defined  as  part  of<br>the .NET Framework:<br>
public interface IComparer&lt;<b>in</b> T&gt;<br>{<br>  // Returns a value indicating the relative ordering of a and b<br>
  int Compare (T a, T b);<br>}<br>
Because the interface is contravariant, we can use an IComparer&lt;<b>object</b>&gt; to compare<br>two <i>strings</i>:<br>
var objectComparer = Comparer&lt;object&gt;.Default;<br>
// objectComparer implements IComparer&lt;object&gt;<br>
IComparer&lt;string&gt; stringComparer = objectComparer;<br>
<b>Creating Types</b><br>
int result = stringComparer.Compare (&quot;Brett&quot;, &quot;Jemaine&quot;);<br>
Mirroring covariance, the compiler will report an error if you try to use a contra-<br>variant parameter in an output position (e.g., as a return value, or in a readable<br>property).<br>
<b>C# Generics Versus C++ Templates<br></b>C# generics are similar in application to C++ templates, but they work very differ-<br>ently. In both cases, a synthesis between the producer and consumer must take place,<br>where the placeholder types of the producer are filled in by the consumer. However,<br>with C# generics, producer types (i.e., open types such as List&lt;T&gt;) can be compiled<br>into a library (such as <i>mscorlib.dll</i>). This works because the synthesis between the<br>producer and the consumer that produces closed types doesn't actually happen until<br>runtime. With C++ templates, this synthesis is performed at compile time. This<br>means that in C++ you don't deploy template libraries as <i>.dll</i>s--they exist only as<br>source code. It also makes it difficult to dynamically inspect, let alone create, para-<br>meterized types on the fly.<br>
To dig deeper into why this is the case, consider the Max method in C#, once more:<br>
static T Max &lt;T&gt; (T a, T b) where T : IComparable&lt;T&gt;<br>{<br>  return a.CompareTo (b) &gt; 0 ? a : b;<br>}<br>
Why couldn't we have implemented it like this?<br>
static T Max &lt;T&gt; (T a, T b)<br>{<br>  return a &gt; b ? a : b;             // Compile error<br>}<br>
<b>Generics | 113</b><br>
<hr>
<A name=134></a>The reason is that Max needs to be compiled once and work for all possible values of<br>T. Compilation cannot succeed, because there is no single meaning for &gt; across all<br>values of T--in fact, not every T even has a &gt; operator. In contrast, the following code<br>shows the same Max method written with C++ templates. This code will be compiled<br>separately for each value of T, taking on whatever semantics &gt; has for a particular<br>T, failing to compile if a particular T does not support the &gt; operator:<br>
template &lt;class T&gt; T Max (T a, T b)<br>
{<br>  return a &gt; b ? a : b;<br>
}<br>
<b>114 | Chapter 3:</b><b>Creating Types in C#</b><br>
<hr>
<A name=135></a><b>4</b><br>
<b>Advanced C#</b><br>
In this chapter, we cover advanced C# topics that build on concepts explored in<br>previous chapters. You should read the first four sections sequentially; you can read<br>the remaining sections in any order.<br>
<b>Delegates<br></b>A delegate dynamically wires up a method caller to its target method. There are two<br>aspects to a delegate: <i>type</i> and <i>instance</i>. A <i>delegate type</i> defines a <i>protocol</i> to which<br>the caller and target will conform, comprising a list of parameter types and a return<br>type. A <i>delegate instance</i> is an object that refers to one (or more) target methods<br>conforming to that protocol.<br>
A delegate instance literally acts as a delegate for the caller: the caller invokes the<br>delegate, and then the delegate calls the target method. This indirection decouples<br>the caller from the target method.<br>
A delegate type declaration is preceded by the keyword delegate, but otherwise it<br>resembles an (abstract) method declaration. For example:<br>
delegate int Transformer (int x);<br>
To create a delegate instance, you can assign a method to a delegate variable:<br>
class Test<br>{<br>  static void Main()<br>  {<br>    <b>Transformer t = Square;</b>          // Create delegate instance<br>    int result = <b>t(3);</b>               // Invoke delegate<br>    Console.WriteLine (result);      // 9<br>  }<br>  static int Square (int x) { return x * x; }<br>}<br>
<b>115</b><br>
<hr>
<A name=136></a>Technically, we are specifying a <i>method group</i> when we refer to<br>Square without brackets or arguments. If the method is over-<br>loaded, C# will pick the correct overload based on the signature<br>of the delegate to which it's being assigned.<br>
Invoking a delegate is just like invoking a method (since the delegate's purpose is<br>merely to provide a level of indirection):<br>
t(3);<br>
The statement:<br>
Transformer t = Square;<br>
is shorthand for:<br>
Transformer t = new Transformer (Square);<br>
and:<br>
t(3)<br>
is shorthand for:<br>
t.Invoke (3);<br>
A delegate is similar to a <i>callback</i>, a general term that captures<br>constructs such as C function pointers.<br>
<b>Writing Plug-in Methods with Delegates<br></b>A delegatevariable is assigned a method <i>dynamically</i>. This is useful for writing plug-<br>in methods. In this example, we have a utility method named Transform that applies<br>a transform to each element in an integer array. The Transform method has a delegate<br>parameter, for specifying a plug-in transform.<br>
public delegate int Transformer (int x);<br>
class Util<br>
{<br>  public static void Transform (int[] values, <b>Transformer t</b>)<br>  {<br>    for (int i = 0; i &lt; values.Length; i++)<br>      values[i] = t (values[i]);<br>  }<br>}<br>
class Test<br>
{<br>  static void Main()<br>  {<br>    int[] values = { 1, 2, 3 };<br>    Util.Transform (values, Square);      // Dynamically hook in Square<br>
<b>116 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=137></a>    foreach (int i in values)<br>
      Console.Write (i + &quot;  &quot;);           // 1   4   9<br>  }<br>
  static int Square (int x) { return x * x; }<br>
}<br>
<b>Multicast Delegates<br></b>All delegate instances have <i>multicast</i> capability. This means that a delegate instance<br>can reference not just a single target method, but also a list of target methods. The<br>+ and += operators combine delegate instances. For example:<br>
SomeDelegate d = SomeMethod1;<br>
d += SomeMethod2;<br>
The last line is functionally the same as:<br>
d = d + SomeMethod2;<br>
Invoking d will now call both SomeMethod1 and SomeMethod2. Delegates are invoked<br>in the order they are added.<br>
<b>Advanced C#</b><br>
The - and -= operators remove the right delegate operand from the left delegate<br>operand. For example:<br>
d -= SomeMethod1;<br>
Invoking d will now cause only SomeMethod2 to be invoked.<br>Calling + or += on a delegate variable with a null value works, and it is equivalent to<br>assigning the variable to a new value:<br>
SomeDelegate d = null;<br>d += SomeMethod1;       // Equivalent (when d is null) to d = SomeMethod1;<br>
Similarly, calling -= on a delegate variable with a single target is equivalent to as-<br>signing null to that variable.<br>
Delegates are <i>immutable</i>, so when you call += or -=, you're in<br>fact creating a <i>new</i> delegate instance and assigning it to the ex-<br>isting variable.<br>
If a multicast delegate has a nonvoid return type, the caller receives the return value<br>from the last method to be invoked. The preceding methods are still called, but their<br>return values are discarded. In most scenarios in which multicast delegates are used,<br>they have void return types, so this subtlety does not arise.<br>
All delegate types implicitly derive from System.MulticastDele<br>gate, which inherits from System.Delegate. C# compiles +, -,<br>+=, and -= operations made on a delegate to the static Combine<br>and Remove methods of the System.Delegate class.<br>
<b>Delegates | 117</b><br>
<hr>
<A name=138></a><b>Multicast delegate example<br></b>Suppose you wrote a routine that took a long time to execute. That routine could<br>regularly report progress to its caller by invoking a delegate. In this example, the<br>HardWork routine has a ProgressReporter delegate parameter, which it invokes to<br>indicate progress:<br>
public delegate void ProgressReporter (int percentComplete);<br>
public class Util<br>{<br>  public static void HardWork (ProgressReporter p)<br>
  {<br>
    for (int i = 0; i &lt; 10; i++)<br>
    {<br>
      p (i * 10);                           // Invoke delegate<br>      System.Threading.Thread.Sleep (100);  // Simulate hard work<br>
    }<br>
  }<br>
}<br>
To monitor progress, the Main method creates a multicast delegate instance p, such<br>that progress is monitored by two independent methods:<br>
class Test<br>
{<br>  static void Main()<br>  {<br>
    ProgressReporter p = WriteProgressToConsole;<br>    p += WriteProgressToFile;<br>
    Util.HardWork (p);<br>  }<br>
  static void WriteProgressToConsole (int percentComplete)<br>  {<br>    Console.WriteLine (percentComplete);<br>  }<br>
  static void WriteProgressToFile (int percentComplete)<br>  {<br>    System.IO.File.WriteAllText (&quot;progress.txt&quot;,<br>                                  percentComplete.ToString());<br>  }<br>}<br>
<b>Instance Versus Static Method Targets<br></b>When a delegate object is assigned to an <i>instance</i> method, the delegate object must<br>maintain a reference not only to the method, but also to the <i>instance</i> to which the<br>method  belongs.  The  System.Delegate  class's  Target  property  represents  this  in-<br>stance (and will be null for a delegate referencing a static method). For example:<br>
<b>118 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=139></a>public delegate void ProgressReporter (int percentComplete);<br>
class Test<br>{<br>  static void Main()<br>
  {<br>    X x = new X();<br>    ProgressReporter p = x.InstanceProgress;<br>
    p(99);                                 // 99<br>
    Console.WriteLine (p.Target == x);     // True<br>    Console.WriteLine (p.Method);          // Void InstanceProgress(Int32)<br>  }<br>
}<br>
class X<br>{<br>  public void InstanceProgress (int percentComplete)<br>  {<br>
    Console.WriteLine (percentComplete);<br>  }<br>
}<br>
<b>Advanced C#</b><br>
<b>Generic Delegate Types<br></b>A delegate type may contain generic type parameters. For example:<br>
public delegate T Transformer&lt;T&gt; (T arg);<br>
With this definition, we can write a generalized Transform utility method that works<br>on any type:<br>
public class Util<br>{<br>  public static void Transform&lt;T&gt; (T[] values, <b>Transformer&lt;T&gt; t</b>)<br>  {<br>    for (int i = 0; i &lt; values.Length; i++)<br>      values[i] = t (values[i]);<br>  }<br>}<br>
class Test<br>{<br>  static void Main()<br>  {<br>    int[] values = { 1, 2, 3 };<br>    Util.Transform (values, Square);      // Dynamically hook in Square<br>    foreach (int i in values)<br>      Console.Write (i + &quot;  &quot;);           // 1   4   9<br>  }<br>
  static int Square (int x) { return x * x; }<br>}<br>
<b>Delegates | 119</b><br>
<hr>
<A name=140></a><b>The Func and Action Delegates<br></b>With generic delegates, it becomes possible to write a small set of delegate types that<br>are so general they can work for methods of any return type and any (reasonable)<br>number of arguments. These delegates are the Func and Action delegates, defined in<br>the System namespace (the in and out annotations indicate <i>variance</i>, which we will<br>cover shortly):<br>
delegate TResult Func &lt;out TResult&gt;                ();<br>
delegate TResult Func &lt;in T, out TResult&gt;          (T arg);<br>delegate TResult Func &lt;in T1, in T2, out TResult&gt;  (T1 arg1, T2 arg2);<br>
<i>... and so on, up to T16</i><br>
delegate void Action                 ();<br>
delegate void Action &lt;in T&gt;          (T arg);<br>delegate void Action &lt;in T1, in T2&gt;  (T1 arg1, T2 arg2);<br>
<i>... and so on, up to T16</i><br>
These delegates are extremely general. The Transformer delegate in our previous<br>example can be replaced with a Func delegate that takes a single argument of type<br>T and returns a same-typed value:<br>
public static void Transform&lt;T&gt; (T[] values, <b>Func&lt;T,T&gt; transformer</b>)<br>{<br>  for (int i = 0; i &lt; values.Length; i++)<br>
    values[i] = transformer (values[i]);<br>
}<br>
The only practical scenarios not covered by these delegates are ref/out and pointer<br>parameters.<br>
<b>Delegates Versus Interfaces<br></b>A  problem  that  can  be  solved  with  a  delegate  can  also  be  solved  with  an<br>interface. For instance, the following explains how to solve our filter problem using<br>an ITransformer interface:<br>
public interface ITransformer<br>{<br>  int Transform (int x);<br>}<br>
public class Util<br>{<br> public static void TransformAll (int[] values, ITransformer t)<br> {<br>   for (int i = 0; i &lt; values.Length; i++)<br>     values[i] = t.Transform (values[i]);<br> }<br>}<br>
class Squarer : ITransformer<br>{<br>  public int Transform (int x) { return x * x; }<br>}<br>
<b>120 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=141></a>...<br>
static void Main()<br>{<br>  int[] values = { 1, 2, 3 };<br>
  Util.TransformAll (values, new Squarer());<br>  foreach (int i in values)<br>    Console.WriteLine (i);<br>
}<br>
A delegate design may be a better choice than an interface design if one or more of<br>these conditions are true:<br>
· The interface defines only a single method.<br>· Multicast capability is needed.<br>· The subscriber needs to implement the interface multiple times.<br>
In the ITransformer example, we don't need to multicast. However, the interface<br>defines only a single method. Furthermore, our subscriber may need to implement<br>ITransformer multiple times, to support different transforms, such as square or cube.<br>
<b>Advanced C#</b><br>
With interfaces, we're forced into writing a separate type per transform, since Test<br>can implement ITransformer only once. This is quite cumbersome:<br>
class Squarer : ITransformer<br>
{<br>  public int Transform (int x) { return x * x; }<br>}<br>
class Cuber : ITransformer<br>{<br>  public int Transform (int x) {return x * x * x; }<br>}<br>...<br>
static void Main()<br>{<br>  int[] values = { 1, 2, 3 };<br>  Util.TransformAll (values, new Cuber());<br>  foreach (int i in values)<br>    Console.WriteLine (i);<br>}<br>
<b>Delegate Compatibility</b><br>
<b>Type compatibility<br></b>Delegate types are all incompatible with each other, even if their signatures are the<br>same:<br>
delegate void D1();<br>delegate void D2();<br>...<br>
D1 d1 = Method1;<br>D2 d2 = d1;                           // Compile-time error<br>
<b>Delegates | 121</b><br>
<hr>
<A name=142></a>The following, however, is permitted:<br>
D2 d2 = <b>new</b> D2 (d1);<br>
Delegate instances are considered equal if they have the same method targets:<br>
delegate void D();<br>...<br>
D d1 = Method1;<br>D d2 = Method1;<br>
Console.WriteLine (d1 == d2);         // True<br>
Multicast delegates are considered equal if they reference the same methods <i>in the<br>same order</i>.<br>
<b>Parameter compatibility<br></b>When you call a method, you can supply arguments that have more specific types<br>than the parameters of that method. This is ordinary polymorphic behavior. For<br>exactly the same reason, a delegate can have more specific parameter types than its<br>method target. This is called <i>contravariance</i>.<br>
Here's an example:<br>
delegate void StringAction (string s);<br>
class Test<br>{<br>  static void Main()<br>  {<br>    StringAction sa = new StringAction (ActOnObject);<br>    sa (&quot;hello&quot;);<br>  }<br>
  static void ActOnObject (object o)<br>  {<br>    Console.WriteLine (o);   // hello<br>  }<br>}<br>
A  delegate  merely  calls  a  method  on  someone  else's  behalf.  In  this  case,  the<br>StringAction is invoked with an argument of type string. When the argument is<br>then relayed to the target method, the argument gets implicitly upcast to an object.<br>
The  standard  event  pattern  is  designed  to  help  you  leverage<br>contravariance through its use of the common EventArgs base<br>class. For example, you can have a single method invoked by<br>two different delegates, one passing a MouseEventArgs and the<br>other passing a KeyEventArgs.<br>
<b>122 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=143></a><b>Return type compatibility<br></b>If you call a method, you may get back a type that is more specific than what you<br>asked for. This is ordinary polymorphic behavior. For exactly the same reason, the<br>return type of a delegate can be less specific than the return type of its target method.<br>This is called <i>covariance</i>. For example:<br>
delegate object ObjectRetriever();<br>
class Test<br>{<br>  static void Main()<br>
  {<br>
    ObjectRetriever o = new ObjectRetriever (RetriveString);<br>
    object result = o();<br>
    Console.WriteLine (result);      // hello<br>  }<br>
  static string RetriveString() { return &quot;hello&quot;; }<br>
}<br>
The ObjectRetriever expects to get back an object, but an object subclass will also<br>
<b>Advanced C#</b><br>
do: delegate return types are <i>covariant</i>.<br>
<b>Generic delegate type parameter variance (C# 4.0)<br></b>In Chapter 3 we saw how generic interfaces support covariant and contravariant<br>type parameters. The same capability exists for delegates, too.<br>
If you're defining a generic delegate type, it's good practice to:<br>
· Mark a type parameter used only on the return value as covariant (out).<br>· Mark any type parameters used only on parameters as contravariant (in).<br>
Doing so allows conversions to work naturally by respecting inheritance relation-<br>ships between types.<br>
The following delegate (defined in the System namespace) supports covariance:<br>
delegate TResult Func&lt;out TResult&gt;();<br>
allowing:<br>
Func&lt;string&gt; x = ...;<br>Func&lt;object&gt; y = x;<br>
The following delegate (defined in the System namespace) supports contravariance:<br>
delegate void Action&lt;in T&gt; (T arg);<br>
allowing:<br>
Action&lt;object&gt; x = ...;<br>Action&lt;string&gt; y = x;<br>
<b>Delegates | 123</b><br>
<hr>
<A name=144></a><b>Events<br></b>When  using  delegates,  two  emergent  roles  commonly  appear:  <i>broadcaster</i>  and<br><i>subscriber</i>.<br>
The <i>broadcaster</i> is a type that contains a delegate field. The broadcaster decides<br>when to broadcast, by invoking the delegate.<br>
The <i>subscribers</i> are the method target recipients. A subscriber decides when to start<br>and stop listening, by calling += and -= on the broadcaster's delegate. A subscriber<br>does not know about, or interfere with, other subscribers.<br>
Events are a language feature that formalizes this pattern. An event is a construct<br>that  exposes  just  the  subset  of  delegate  features  required  for  the  broadcaster/<br>subscriber model. The main purpose of events is to <i>prevent subscribers from inter-<br>fering with each other</i>.<br>
The easiest way to declare an event is to put the event keyword in front of a delegate<br>member:<br>
public class Broadcaster<br>
{<br>  public <b>event</b> ProgressReporter Progress;<br>}<br>
Code within the Broadcaster type has full access to Progress and can treat it as a<br>delegate. Code outside of Broadcaster can only perform += and -= operations on the<br>Progress event.<br>
<b>How Do Events Work on the Inside?</b><br>
Three things happen under the covers when you declare an event as follows:<br>
public class Broadcaster<br>{<br>  public <b>event</b> ProgressReporter Progress;<br>}<br>
First, the compiler translates the event declaration into something close to the<br>following:<br>
EventHandler _priceChanged;   // private delegate<br>public event EventHandler PriceChanged<br>
{<br>  add    { _priceChanged += value; }<br>  remove { _priceChanged -= value; }<br>}<br>
The add and remove keywords denote explicit <i>event accessors</i>--which act rather<br>like property accessors. We'll describe how to write these later.<br>
Second,  the  compiler  looks  <i>within</i>  the  Broadcaster  class  for  references  to<br>PriceChanged that perform operations other than += or -=, and redirects them to<br>the underlying _priceChanged delegate field.<br>
<b>124 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=145></a>Third, the compiler translates += and -= operations on the event to calls to the<br>event's add and remove accessors. Interestingly, this makes the behavior of += and<br>-=  unique  when  applied  to  events:  unlike  in  other  scenarios,  it's  not  simply  a<br>shortcut for + and - followed by an assignment.<br>
Consider the following example. The Stock class fires its PriceChanged event every<br>time the Price of the Stock changes:<br>
public delegate void PriceChangedHandler (decimal oldPrice,<br>
                                          decimal newPrice);<br>
public class Stock<br>
{<br>  string symbol;<br>
  decimal price;<br>
  public Stock (string symbol) { this.symbol = symbol; }<br>
  <b>public event PriceChangedHandler PriceChanged;</b><br>
<b>Advanced C#</b><br>
  public decimal Price<br>
  {<br>
    get { return price; }<br>    set<br>
    {<br>
      if (price == value) return;      // Exit if nothing has changed<br>
      if (PriceChanged != null)        // If invocation list not empty,<br>        <b>PriceChanged (price, value);</b>   // fire event.<br>      price = value;<br>
    }<br>  }<br>}<br>
If we remove the event keyword from our example so that PriceChanged becomes an<br>ordinary delegate field, our example would give the same results. However, Stock<br>would be less robust, in that subscribers could do the following things to interfere<br>with each other:<br>
· Replace other subscribers by reassigning PriceChanged (instead of using the +=<br>
operator).<br>
· Clear all subscribers (by setting PriceChanged to null).<br>· Broadcast to other subscribers by invoking the delegate.<br>
<b>Standard Event Pattern<br></b>The .NET Framework defines a standard pattern for writing events. Its purpose is<br>to provide consistency across both Framework and user code. At the core of the<br>standard event pattern is System.EventArgs: a predefined Framework class with no<br>members (other than the static Empty property). EventArgs is a base class for con-<br>veying  information  for  an  event.  In  our  Stock  example,  we  would  subclass<br>EventArgs to convey the old and new prices when a PriceChanged event is fired:<br>
<b>Events | 125</b><br>
<hr>
<A name=146></a>public class PriceChangedEventArgs : System.EventArgs<br>
{<br>  public readonly decimal LastPrice;<br>  public readonly decimal NewPrice;<br>
 <br>  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)<br>  {<br>
    LastPrice = lastPrice;<br>
    NewPrice = newPrice;<br>  }<br>}<br>
For  reusability,  the  EventArgs  subclass  is  named  according  to  the  information  it<br>contains (rather than the event for which it will be used). It typically exposes data<br>as properties or as read-only fields.<br>
With an EventArgs subclass in place, the next step is to choose or define a delegate<br>for the event. There are three rules:<br>
· It must have a void return type.<br>· It must accept two arguments: the first of type object, and the second a subclass<br>
of EventArgs. The first argument indicates the event broadcaster, and the second<br>argument contains the extra information to convey.<br>
· Its name must end with <i>EventHandler</i>.<br>
The Framework defines a generic delegate called System.EventHandler&lt;&gt; that satis-<br>fies these rules:<br>
public delegate void EventHandler&lt;TEventArgs&gt;<br>
  (object source, TEventArgs e) where TEventArgs : EventArgs;<br>
Before generics existed in the language (prior to C# 2.0), we<br>would have had to instead write a custom delegate as follows:<br>
public delegate void PriceChangedHandler<br>
  (object sender, PriceChangedEventArgs e);<br>
For historical reasons, most events within the Framework use<br>delegates defined in this way.<br>
The next step is to define an event of the chosen delegate type. Here, we use the<br>generic EventHandler delegate:<br>
public class Stock<br>{<br>  ...<br>  <b>public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;<br></b>}<br>
Finally, the pattern requires that you write a protected virtual method that fires the<br>event. The name must match the name of the event, prefixed with the word <i>On</i>, and<br>then accept a single EventArgs argument:<br>
<b>126 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=147></a>public class Stock<br>
{<br>  ...<br>
  public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;<br>
  <b>protected virtual void OnPriceChanged (PriceChangedEventArgs e)<br></b>  <b>{</b><br>
    <b>if (PriceChanged != null) PriceChanged (this, e);</b><br>
  <b>}<br></b>}<br>
In multithreaded scenarios (Chapter 21), you need to assign the<br>delegate to a temporary variable before testing and invoking it<br>in order to be thread-safe:<br>
var temp = PriceChanged;<br>if (temp != null) temp (this, e);<br>
This provides a central point from which subclasses can invoke or override the event<br>
<b>Advanced C#</b><br>
(assuming the class is not sealed). Here's the complete example:<br>
using System;<br>
public class PriceChangedEventArgs : EventArgs<br>
{<br>  public readonly decimal LastPrice;<br>  public readonly decimal NewPrice;<br>
  public PriceChangedEventArgs (decimal lastPrice, decimal newPrice)<br>
  {<br>    LastPrice = lastPrice; NewPrice = newPrice;<br>  }<br>
}<br>
public class Stock<br>{<br>  string symbol;<br>  decimal price;<br>
  public Stock (string symbol) {this.symbol = symbol;}<br>
  public event EventHandler&lt;PriceChangedEventArgs&gt; PriceChanged;<br>
  <b>protected virtual void OnPriceChanged (PriceChangedEventArgs e)<br></b>  <b>{<br></b>    <b>if (PriceChanged != null) PriceChanged (this, e);<br></b>  <b>}</b><br>
  public decimal Price<br>  {<br>    get { return price; }<br>    set<br>    {<br>
<b>Events | 127</b><br>
<hr>
<A name=148></a>      if (price == value) return;<br>
      OnPriceChanged (new PriceChangedEventArgs (price, value));<br>      price = value;<br>    }<br>
  }<br>
}<br>
class Test<br>
{<br>  static void Main()<br>  {<br>    Stock stock = new Stock (&quot;THPW&quot;);<br>
    stock.Price = 27.10M;<br>
    // Register with the PriceChanged event<br>    stock.PriceChanged += stock_PriceChanged;<br>    stock.Price = 31.59M;<br>
  }<br>
  static void stock_PriceChanged (object sender, PriceChangedEventArgs e)<br>  {<br>
    if ((e.NewPrice - e.LastPrice) / e.LastPrice &gt; 0.1M)<br>      Console.WriteLine (&quot;Alert, 10% stock price increase!&quot;);<br>
  }<br>}<br>
The predefined nongeneric EventHandler delegate can be used when an event doesn't<br>carry  extra  information.  In  this  example,  we  rewrite  Stock  such  that  the  Price<br>Changed event is fired after the price changes, and no information about the event is<br>necessary, other than it happened. We also make use of the EventArgs.Empty prop-<br>erty, in order to avoid unnecessarily instantiating an instance of EventArgs.<br>
public class Stock<br>{<br>  string symbol;<br>  decimal price;<br>
  public Stock (string symbol) { this.symbol = symbol; }<br>
  public event <b>EventHandler</b> PriceChanged;<br>
  <b>protected virtual void OnPriceChanged (EventArgs e)<br></b>  <b>{<br></b>    <b>if (PriceChanged != null) PriceChanged (this, e);<br></b>  <b>}</b><br>
  public decimal Price<br>  {<br>    get { return price; }<br>    set<br>    {<br>      if (price == value) return;<br>      price = value;<br>      OnPriceChanged (<b>EventArgs.Empty</b>);<br>    }<br>  }<br>}<br>
<b>128 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=149></a><b>Event Accessors<br></b>An event's <i>accessors</i> are the implementations of its += and -= functions. By default,<br>accessors  are  implemented  implicitly  by  the  compiler.  Consider  this  event<br>declaration:<br>
public event EventHandler PriceChanged;<br>
The compiler converts this to the following:<br>
· A private delegate field<br>· A public pair of event accessor functions, whose implementations forward the<br>
+= and -= operations to the private delegate field<br>
You can take over this process by defining <i>explicit</i> event accessors. Here's a manual<br>implementation of the PriceChanged event from our previous example:<br>
private EventHandler _priceChanged;         // Declare a private delegate<br>
public event EventHandler PriceChanged<br>
{<br>
<b>Advanced C#</b><br>
  <b>add    { _priceChanged += value; }<br></b>  <b>remove { _priceChanged -= value; }</b><br>
}<br>
This example is functionally identical to C#'s default accessor implementation (ex-<br>cept that C# also ensures thread safety around updating the delegate--see Chap-<br>ter 21). By defining event accessors ourselves, we instruct C# not to generate default<br>field and accessor logic.<br>
Before C# 4.0, the compiler ensured thread safety by locking<br>the containing type or instance around updating the delegate.<br>This  is  a  crude  mechanism  (as  we'll  see  in  "Thread<br>Safety"  on  page  543  in  Chapter  21),  and  it  resulted  in  some<br>people using explicit event accessors purely to work around this.<br>The good news is that from C# 4.0, the compiler implements<br>thread safety through a superior lock-free compare-and-swap<br>algorithm.<br>
With explicit event accessors, you can apply more complex strategies to the storage<br>and access of the underlying delegate. There are three scenarios where this is useful:<br>
· When the event accessors are merely relays for another class that is broadcasting<br>
the event.<br>
· When the class exposes a large number of events, where most of the time very<br>
few subscribers exist, such as a Windows control. In such cases, it is better to<br>store the subscriber's delegate instances in a dictionary, since a dictionary will<br>contain less storage overhead than dozens of null delegate field references.<br>
· When explicitly implementing an interface that declares an event.<br>
<b>Events | 129</b><br>
<hr>
<A name=150></a>Here is an example that illustrates the last point:<br>
public interface IFoo { event EventHandler Ev; }<br>
class Foo : IFoo<br>{<br>  private EventHandler ev;<br>
  event EventHandler IFoo.Ev<br>  {<br>    add    { ev += value; }<br>
    remove { ev -= value; }<br>
  }<br>}<br>
The add and remove parts of an event are compiled to add_<i>XXX<br></i>and remove_<i>XXX</i> methods.<br>
The += and -= operations on an event are compiled to calls to<br>the add_<i>XXX</i> and remove_<i>XXX</i> methods.<br>
<b>Event Modifiers<br></b>Like methods, events can be virtual, overridden, abstract, or sealed. Events can also<br>be static:<br>
public class Foo<br>
{<br>  public static event EventHandler&lt;EventArgs&gt; StaticEvent;<br>
  public virtual event EventHandler&lt;EventArgs&gt; VirtualEvent;<br>}<br>
<b>Lambda Expressions<br></b>A lambda expression is an unnamed method written in place of a delegate instance.<br>The compiler immediately converts the lambda expression to either:<br>
· A delegate instance.<br>· An <i>expression tree</i>, of type Expression&lt;TDelegate&gt;, representing the code inside<br>
the lambda expression in a traversable object model. This allows the lambda<br>expression  to  be  interpreted  later  at  runtime  (see  "Building  Query  Expres-<br>sions" on page 361 in Chapter 8).<br>
Given the following delegate type:<br>
delegate int Transformer (int i);<br>
we could assign and invoke the lambda expression x =&gt; x * x as follows:<br>
Transformer sqr = <b>x =&gt; x * x</b>;<br>Console.WriteLine (sqr(3));    // 9<br>
<b>130 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=151></a>Internally, the compiler resolves lambda expressions of this type<br>by writing a private method, and moving the expression's code<br>into that method.<br>
A lambda expression has the following form:<br>
(<i>parameters</i>) =&gt; <i>expression-or-statement-block</i><br>
For convenience, you can omit the parentheses if and only if there is exactly one<br>parameter of an inferable type.<br>
In our example, there is a single parameter, x, and the expression is x * x:<br>
x =&gt; x * x;<br>
Each parameter of the lambda expression corresponds to a delegate parameter, and<br>the type of the expression (which may be void) corresponds to the return type of the<br>delegate.<br>
In our example, x corresponds to parameter i, and the expression x * x corresponds<br>
<b>Advanced C#</b><br>
to the return type int, therefore being compatible with the Transformer delegate:<br>
delegate int Transformer (int i);<br>
A lambda expression's code can be a <i>statement block</i> instead of an expression. We<br>can rewrite our example as follows:<br>
x =&gt; { return x * x; };<br>
Lambda expressions are used most commonly with the Func and Action delegates,<br>so you will most often see our earlier expression written as follows:<br>
Func&lt;int,int&gt; sqr = x =&gt; x * x;<br>
Here's an example of an expression that accepts two parameters:<br>
Func&lt;string,string,int&gt; totalLength = (s1, s2) =&gt; s1.Length + s2.Length;<br>int total = totalLength (&quot;hello&quot;, &quot;world&quot;);   // total is 10;<br>
Lambda expressions were introduced in C# 3.0.<br>
<b>Explicitly Specifying Lambda Parameter Types<br></b>The compiler can usually <i>infer</i> the type of lambda parameters contextually. When<br>this is not the case, you must specify the type of each parameter explicitly. Consider<br>the following expression:<br>
Func&lt;int,int&gt; sqr = x =&gt; x * x;<br>
The compiler uses <i>type inference</i> to infer that x is an int.<br>We could explicitly specify x's type as follows:<br>
Func&lt;int,int&gt; sqr = (<b>int</b> x) =&gt; x * x;<br>
<b>Lambda Expressions | 131</b><br>
<hr>
<A name=152></a><b>Capturing Outer Variables<br></b>A lambda expression can reference the local variables and parameters of the method<br>in which it's defined (<i>outer variables</i>). For example:<br>
static void Main()<br>
{<br>  int factor = 2;<br>
  Func&lt;int, int&gt; multiplier = n =&gt; n * <b>factor</b>;<br>  Console.WriteLine (multiplier (3));           // 6<br>
}<br>
Outer variables referenced by a lambda expression are called <i>captured variables</i>. A<br>lambda expression that captures variables is called a <i>closure</i>.<br>
Captured variables are evaluated when the delegate is actually <i>invoked</i>, not when<br>the variables were <i>captured</i>:<br>
int factor = 2;<br>
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;<br>
<b>factor = 10;</b><br>
Console.WriteLine (multiplier (3));           // 30<br>
Lambda expressions can themselves update captured variables:<br>
int seed = 0;<br>Func&lt;int&gt; natural = () =&gt; seed++;<br>
Console.WriteLine (natural());           // 0<br>
Console.WriteLine (natural());           // 1<br>Console.WriteLine (seed);                // 2<br>
Captured variables have their lifetimes extended to that of the delegate. In the fol-<br>lowing example, the local variable seed would ordinarily disappear from scope when<br>Natural finished executing. But because seed has been <i>captured</i>, its lifetime is ex-<br>tended to that of the capturing delegate, natural:<br>
static Func&lt;int&gt; Natural()<br>{<br>  int seed = 0;<br>  return () =&gt; seed++;      // Returns a <i>closure<br></i>}<br>
static void Main()<br>{<br>  Func&lt;int&gt; natural = Natural();<br>  Console.WriteLine (natural());      // 0<br>  Console.WriteLine (natural());      // 1<br>}<br>
A local variable <i>instantiated</i> within a lambda expression is unique per invocation of<br>the  delegate  instance.  If  we  refactor  our  previous  example  to  instantiate  seed<br><i>within</i> the lambda expression, we get a different (in this case, undesirable) result:<br>
static Func&lt;int&gt; Natural()<br>{<br>  return() =&gt; { int seed = 0; return seed++; };<br>
}<br>
<b>132 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=153></a>static void Main()<br>
{<br>  Func&lt;int&gt; natural = Natural();<br>  Console.WriteLine (natural());           // 0<br>
  Console.WriteLine (natural());           // 0<br>
}<br>
Capturing is internally implemented by "hoisting" the captured<br>variables  into  fields  of  a  private  class.  When  the  method  is<br>called, the class is instantiated and lifetime-bound to the dele-<br>gate instance.<br>
<b>Capturing iteration variables<br></b>When you capture iteration variables in for and foreach statements, C# treats those<br>iteration variables as though they were declared <i>outside</i> the loop. This means that<br>the <i>same</i> variable is captured in each iteration. The following program writes 333<br>instead of writing 012:<br>
<b>Advanced C#</b><br>
Action[] actions = new Action[3];<br>
for (int i = 0; i &lt; 3; i++)<br>
  actions [i] = () =&gt; <b>Console.Write (i)</b>;<br>
foreach (Action a in actions) a();     // 333<br>
Each closure (shown in boldface) captures the same variable, i. When the delegates<br>are later invoked, each delegate sees i's value at the time of <i>invocation</i>--which is 3.<br>We can illustrate this better by expanding the for loop as follows:<br>
Action[] actions = new Action[3];<br>
int i = 0;<br>actions[0] = () =&gt; Console.Write (i);<br>i = 1;<br>actions[1] = () =&gt; Console.Write (i);<br>i = 2;<br>actions[2] = () =&gt; Console.Write (i);<br>i = 3;<br>foreach (Action a in actions) a();    // 333<br>
The solution, if we want to write 012, is to assign the iteration variable to a local<br>variable that's scoped <i>inside</i> the loop:<br>
Action[] actions = new Action[3];<br>for (int i = 0; i &lt; 3; i++)<br>{<br>  int <b>loopScopedi = i</b>;<br>  actions [i] = () =&gt; Console.Write (<b>loopScopedi</b>);<br>}<br>foreach (Action a in actions) a();     // 012<br>
This then causes the closure to capture a <i>different</i> variable on each iteration.<br>
<b>Lambda Expressions | 133</b><br>
<hr>
<A name=154></a><b>Anonymous Methods<br></b>Anonymous  methods  are  a  C#  2.0  feature  that  has  been  subsumed  largely  by<br>C# 3.0 lambda expressions. An anonymous method is like a lambda expression, but<br>it lacks the following features:<br>
· Implicitly typed parameters<br>· Expression syntax (an anonymous method must always be a statement block)<br>· The ability to compile to an expression tree, by assigning to Expression&lt;T&gt;<br>
To write an anonymous method, you include the delegate keyword followed (op-<br>tionally) by a parameter declaration and then a method body. For example, given<br>this delegate:<br>
delegate int Transformer (int i);<br>
we could write and call an anonymous method as follows:<br>
Transformer sqr = <b>delegate (int x) {return x * x;}</b>;<br>
Console.WriteLine (sqr(3));                            // 9<br>
The first line is semantically equivalent to the following lambda expression:<br>
Transformer sqr =       <b>(int x) =&gt; {return x * x;}</b>;<br>
Or simply:<br>
Transformer sqr =            <b>x  =&gt; x * x</b>;<br>
A unique feature of anonymous methods is that you can omit the parameter decla-<br>ration entirely--even if the delegate expects them. This can be useful in declaring<br>events with a default empty handler:<br>
public event EventHandler Clicked = delegate { };<br>
This avoids the need for a null check before firing the event. The following is also<br>legal:<br>
Clicked += delegate { Console.WriteLine (&quot;clicked&quot;); };  // No parameters<br>
Anonymous methods capture outer variables in the same way lambda expressions<br>do.<br>
<b>try Statements and Exceptions<br></b>A try statement specifies a code block subject to error-handling or cleanup code.<br>The try <i>block</i> must be followed by a catch <i>block</i>, a finally <i>block</i>, or both. The<br>catch block executes when an error occurs in the try block. The finally block ex-<br>ecutes after execution leaves the try block (or if present, the catch block), to perform<br>cleanup code, whether or not an error occurred.<br>
A catch block has access to an Exception object that contains information about the<br>error. You use a catch block to either compensate for the error or <i>rethrow</i> the ex-<br>ception. You rethrow an exception if you merely want to log the problem, or if you<br>want to rethrow a new, higher-level exception type.<br>
<b>134 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=155></a>A finally block adds determinism to your program, by always executing no matter<br>what. It's useful for cleanup tasks such as closing network connections.<br>
A try statement looks like this:<br>
try<br>
{<br>  ... // exception may get thrown within execution of this block<br>
}<br>catch (ExceptionA ex)<br>
{<br>  ... // handle exception of type ExceptionA<br>}<br>catch (ExceptionB ex)<br>{<br>  ... // handle exception of type ExceptionB<br>}<br>finally<br>
{<br>  ... // cleanup code<br>
}<br>
<b>Advanced C#</b><br>
Consider the following program:<br>
class Test<br>{<br>  static int Calc (int x) { return 10 / x; }<br>
  static void Main()<br>  {<br>    int y = Calc (0);<br>    Console.WriteLine (y);<br>  }<br>}<br>
Because x is zero, the runtime throws a DivideByZeroException, and our program<br>terminates. We can prevent this by catching the exception as follows:<br>
class Test<br>{<br>  static int Calc (int x) { return 10 / x; }<br>
  static void Main()<br>  {<br>    <b>try<br></b>    <b>{<br></b>      int y = Calc (0);<br>      Console.WriteLine (y);<br>    <b>}<br></b>    <b>catch (DivideByZeroException ex)<br></b>    <b>{<br></b>      Console.WriteLine (&quot;x cannot be zero&quot;);<br>    <b>}<br></b>    Console.WriteLine (&quot;program completed&quot;);<br>  }<br>}<br>
<b>try Statements and Exceptions | 135</b><br>
<hr>
<A name=156></a>OUTPUT:<br>
x cannot be zero<br>program completed<br>
This is a simple example to illustrate exception handling. We<br>could  deal  with  this  particular  scenario  better  in  practice  by<br>checking explicitly for the divisor being zero before calling Calc.<br>
Exceptions are relatively expensive to handle, taking hundreds<br>of clock cycles.<br>
When an exception is thrown, the CLR performs a test:<br>
<i>Is execution currently within a</i> try <i>statement that can catch the exception?</i><br>
· If so, execution is passed to the compatible catch block. If the catch block suc-<br>
cessfully finishes executing, execution moves to the next statement after the<br>try statement (if present, executing the finally block first).<br>
· If not, execution jumps back to the caller of the function, and the test is repeated<br>
(after executing any finally blocks that wrap the statement).<br>
If no function takes responsibility for the exception, an error dialog is displayed to<br>the user, and the program terminates.<br>
<b>The catch Clause<br></b>A  catch  clause  specifies  what  type  of  exception  to  catch.  This  must  either  be<br>System.Exception or a subclass of System.Exception.<br>
Catching System.Exception catches all possible errors. This is useful when:<br>
· Your program can potentially recover regardless of the specific exception type.<br>· You plan to rethrow the exception (perhaps after logging it).<br>· Your error handler is the last resort, prior to termination of the program.<br>
More typically, though, you catch <i>specific exception types</i>, in order to avoid having<br>to  deal  with  circumstances  for  which  your  handler  wasn't  designed  (e.g.,  an<br>OutOfMemoryException).<br>
You can handle multiple exception types with multiple catch clauses (again, this<br>example could be written with explicit argument checking rather than exception<br>handling):<br>
class Test<br>{<br>  static void Main (string[] args)<br>  {<br>    try<br>    {<br>      byte b = byte.Parse (args[0]);<br>      Console.WriteLine (b);<br>    }<br>
<b>136 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=157></a>    catch (IndexOutOfRangeException ex)<br>
    {<br>      Console.WriteLine (&quot;Please provide at least one argument&quot;);<br>    }<br>
    catch (FormatException ex)<br>
    {<br>      Console.WriteLine (&quot;That's not a number!&quot;);<br>    }<br>
    catch (OverflowException ex)<br>
    {<br>      Console.WriteLine (&quot;You've given me more than a byte!&quot;);<br>    }<br>
  }<br>
}<br>
Only one catch clause executes for a given exception. If you want to include a safety<br>net to catch more general exceptions (such as System.Exception), you must put the<br>more specific handlers <i>first</i>.<br>
An exception can be caught without specifying a variable if you don't need to access<br>its properties:<br>
<b>Advanced C#</b><br>
catch (StackOverflowException)   // no variable<br>
{<br>  ...<br>}<br>
Furthermore, you can omit both the variable and the type (meaning that all excep-<br>tions will be caught):<br>
catch { ... }<br>
In  languages  other  than  C#,  it  is  possible  (though  not<br>recommended) to throw an object that does not derive from<br>Exception.  The  CLR  automatically  wraps  that  object  in  a<br>RuntimeWrappedException  class  (which  does  derive  from<br>Exception).<br>
<b>The finally Block<br></b>A  finally  block  always  executes--whether  or  not  an  exception  is  thrown  and<br>whether or not the try block runs to completion. finally blocks are typically used<br>for cleanup code.<br>
A finally block executes either:<br>
· After a catch block finishes<br>· After control leaves the try block because of a jump statement (e.g., return or<br>
goto)<br>
· After the try block ends<br>
A finally block helps add determinism to a program. In the following example, the<br>file that we open <i>always</i> gets closed, regardless of whether:<br>
<b>try Statements and Exceptions | 137</b><br>
<hr>
<A name=158></a>· The try block finishes normally.<br>· Execution returns early because the file is empty (EndOfStream).<br>· An IOException is thrown while reading the file.<br>
static void ReadFile()<br>
{<br>  StreamReader reader = null;    // In System.IO namespace<br>
  try<br>
  {<br>
    reader = File.OpenText (&quot;file.txt&quot;);<br>
    if (reader.EndOfStream) <b>return</b>;<br>    Console.WriteLine (reader.ReadToEnd());<br>
  }<br>  finally<br>
  {<br>    if (reader != null) reader.Dispose();<br>  }<br>
}<br>
In this example, we closed the file by calling Dispose on the StreamReader. Calling<br>Dispose on an object, within a finally block, is a standard convention throughout<br>the .NET Framework and is supported explicitly in C# through the using statement.<br>
<b>The using statement<br></b>Many  classes  encapsulate  unmanaged  resources,  such  as  file  handles,  graphics<br>handles,  or  database  connections.  These  classes  implement  System.IDisposable,<br>which defines a single parameterless method named Dispose to clean up these re-<br>sources. The using statement provides an elegant syntax for calling Dispose on an<br>IDisposable object within a finally block.<br>
The following:<br>
<b>using</b> (StreamReader reader = File.OpenText (&quot;file.txt&quot;))<br>{<br>  ...<br>}<br>
is precisely equivalent to:<br>
StreamReader reader = File.OpenText (&quot;file.txt&quot;);<br>try<br>{<br>  ...<br>}<br>finally<br>{<br>  if (reader != null)<br>   ((IDisposable)reader).Dispose();<br>}<br>
We cover the disposal pattern in more detail in Chapter 12.<br>
<b>138 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=159></a><b>Throwing Exceptions<br></b>Exceptions can be thrown either by the runtime or in user code. In this example,<br>Display throws a System.ArgumentNullException:<br>
class Test<br>
{<br>  static void Display (string name)<br>
  {<br>    if (name == null)<br>
      <b>throw new ArgumentNullException (&quot;name&quot;);</b><br>
    Console.WriteLine (name);<br>
  }<br>
  static void Main()<br>
  {<br>
    try { Display (null); }<br>
    catch (ArgumentNullException ex)<br>
    {<br>
      Console.WriteLine (&quot;Caught the exception&quot;);<br>
<b>Advanced C#</b><br>
    }<br>
  }<br>
}<br>
<b>Rethrowing an exception<br></b>You can capture and rethrow an exception as follows:<br>
try {  ...  }<br>catch (Exception ex)<br>
{<br>  // Log error<br>  ...<br>  <b>throw;          // Rethrow same exception<br></b>}<br>
Rethrowing in this manner lets you log an error without <i>swallowing</i> it. It also lets<br>you back out of handling an exception should circumstances turn out to be outside<br>what you expected:<br>
using System.Net;       // (See Chapter 14)<br>...<br>
string s = null;<br>using (WebClient wc = new WebClient())<br>  try { s = wc.DownloadString (&quot;http://www.albahari.com/nutshell/&quot;);  }<br>  catch (WebException ex)<br>  {<br>    if (ex.Status == WebExceptionStatus.NameResolutionFailure)<br>      Console.WriteLine (&quot;Bad domain name&quot;);<br>    else<br>      <b>throw;     // Can't handle other sorts of WebException, so rethrow<br></b>  }<br>
<b>try Statements and Exceptions | 139</b><br>
<hr>
<A name=160></a>The  other  common  scenario  is  to  rethrow  a  more  specific  exception  type.  For<br>example:<br>
try<br>{<br>  ... // Parse a DateTime from XML element data<br>
}<br>catch (FormatException ex)<br>{<br>  throw new XmlException (&quot;Invalid DateTime&quot;, ex);<br>
}<br>
Rethrowing  an  exception  does  not  affect  the  StackTrace  property  of  the<br>exception (see the next section). When rethrowing a different exception, you can<br>set the InnerException property with the original exception if doing so could aid<br>debugging. Nearly all types of exceptions provide a constructor for this purpose.<br>
<b>Key Properties of System.Exception<br></b>The most important properties of System.Exception are the following:<br>
StackTrace<br>
A string representing all the methods that are called from the origin of the ex-<br>ception to the catch block.<br>
Message<br>
A string with a description of the error.<br>
InnerException<br>
The inner exception (if any) that caused the outer exception. This, itself, may<br>have another InnerException.<br>
All exceptions in C# are runtime exceptions--there is no equiv-<br>alent to Java's compile-time checked exceptions.<br>
<b>Common Exception Types<br></b>The  following  exception  types  are  used  widely  throughout  the  CLR  and  .NET<br>Framework. You can throw these yourself or use them as base classes for deriving<br>custom exception types:<br>
System.ArgumentException<br>
Thrown when a function is called with a bogus argument. This generally indi-<br>cates a program bug.<br>
System.ArgumentNullException<br>
Subclass of ArgumentException that's thrown when a function argument is (un-<br>expectedly) null.<br>
<b>140 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=161></a>System.ArgumentOutOfRangeException<br>
Subclass of ArgumentException that's thrown when a (usually numeric) argu-<br>ment is too big or too small. For example, this is thrown when passing a negative<br>number into a function that accepts only positive values.<br>
System.InvalidOperationException<br>
Thrown when the state of an object is unsuitable for a method to successfully<br>execute, regardless of any particular argument values. Examples include reading<br>an unopened file or getting the next element from an enumerator where the<br>underlying list has been modified partway through the iteration.<br>
System.NotSupportedException<br>
Thrown  to  indicate  that  a  particular  functionality  is  not  supported.  A  good<br>example is calling the Add method on a collection for which IsReadOnly returns<br>true.<br>
System.NotImplementedException<br>
Thrown to indicate that a function has not yet been implemented.<br>
System.ObjectDisposedException<br>
Thrown when the object upon which the function is called has been disposed.<br>
<b>Advanced C#</b><br>
<b>Common Patterns</b><br>
<b>The TryXXX method pattern<br></b>When writing a method, you have a choice, when something goes wrong, to return<br>some kind of failure code or throw an exception. In general, you throw an exception<br>when the error is outside the normal workflow--or if you expect that the immediate<br>caller won't be able to cope with it. Occasionally, though, it can be best to offer both<br>choices  to  the  consumer.  An  example  of  this  is  the  int type, which defines two<br>versions of its Parse method:<br>
public int Parse     (string input);<br>public bool TryParse (string input, out int returnValue);<br>
If parsing fails, Parse throws an exception; TryParse returns false.<br>You can implement this pattern by having the <i>XXX</i> method call the Try<i>XXX</i> method<br>as follows:<br>
public <i>return-type XXX</i> (<i>input-type</i> input)<br>{<br>  <i>return-type</i> returnValue;<br>  if (!Try<i>XXX</i> (input, out returnValue))<br>    throw new <i>YYY</i>Exception (...)<br>  return returnValue;<br>}<br>
<b>The atomicity pattern<br></b>It can be desirable for an operation to be <i>atomic</i>, where it either successfully com-<br>pletes or fails without affecting state. An object becomes unusable when it enters an<br>
<b>try Statements and Exceptions | 141</b><br>
<hr>
<A name=162></a>indeterminate state that is the result of a half-finished operation. finally blocks<br>facilitate writing atomic operations.<br>
In  the  following  example,  we  use  an  Accumulator  class  that  has  an  Add  method<br>that  adds  an  array  of  integers  to  its  field  Total.  The  Add  method  will  cause  an<br>OverflowException if Total exceeds the maximum value for an int. The Add method<br>is atomic, either successfully updating Total or failing, which leaves Total with its<br>former value:<br>
class Test<br>
{<br>  static void Main()<br>
  {<br>
    Accumulator a = new Accumulator();<br>
    try<br>    {<br>
      a.Add (4, 5);             // a.Total is now 9<br>
      a.Add (1, int.MaxValue);  // Will cause OverflowException<br>
    }<br>    catch (OverflowException)<br>    {<br>
      Console.WriteLine (a.Total);  // a.Total is still 9<br>
    }<br>
  }<br>}<br>
In the implementation of Accumulator, the Add method affects the Total field as it<br>executes. However, if <i>anything goes wrong</i> during the method (e.g., a numeric over-<br>flow, a stack overflow, etc.), Total is restored to its initial value at the start of the<br>method.<br>
public class Accumulator<br>{<br>  public int Total { get; private set; }<br>
  public void Add (params int[] ints)<br>  {<br>    bool success = false;<br>    int totalSnapshot = Total;<br>    try<br>    {<br>      foreach (int i in ints)<br>      {<br>        checked { Total += i; }<br>      }<br>      success = true;<br>    }<br>    finally<br>    {<br>      if (! success)<br>        Total = totalSnapshot;<br>    }<br>  }<br>}<br>
<b>142 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=163></a><b>Alternatives to exceptions<br></b>As with int.TryParse, a function can communicate failure by sending an error code<br>back to the calling function via a return type or parameter. Although this can work<br>with simple and predictable failures, it becomes clumsy when extended to all errors,<br>polluting method signatures and creating unnecessary complexity and clutter. It also<br>cannot generalize to functions that are not methods, such as operators (e.g., the<br>division operator) or properties. An alternative is to place the error in a common<br>place where all functions in the call stack can see it (e.g., a static method that stores<br>the current error per thread). This, though, requires each function to participate in<br>an error-propagation pattern that is cumbersome and, ironically, itself error-prone.<br>
<b>Enumeration and Iterators<br>Enumeration<br></b>An <i>enumerator</i> is a read-only, forward-only cursor over a <i>sequence of values</i>. An<br>enumerator is an object that implements either of the following interfaces:<br>
<b>Advanced C#</b><br>
· System.Collections.IEnumerator<br>· System.Collections.Generic.IEnumerator&lt;T&gt;<br>
Technically, any object that has a method named MoveNext and<br>a property called Current is treated as an enumerator; this re-<br>laxation exists to allow enumeration of value type elements in<br>C# 1.0 without a boxing/unboxing overhead. This optimiza-<br>tion is now obsolete with generics, and is, in fact, unsupported<br>with C# 4.0's dynamic binding.<br>
The foreach statement iterates over an <i>enumerable</i> object. An enumerable object is<br>the logical representation of a sequence. It is not itself a cursor, but an object that<br>produces cursors over itself. An enumerable object either:<br>
· Implements IEnumerable or IEnumerable&lt;T&gt;<br>· Has a method named GetEnumerator that returns an <i>enumerator</i><br>
IEnumerator  and  IEnumerable  are  defined  in  System.Collec<br>tions.  IEnumerator&lt;T&gt;  and  IEnumerable&lt;T&gt;  are  defined  in<br>System.Collections.Generic.<br>
The enumeration pattern is as follows:<br>
class <i>Enumerator</i>   // Typically implements IEnumerator or IEnumerator&lt;T&gt;<br>{<br>  public <i>IteratorVariableType</i> Current { get {...} }<br>  public bool MoveNext() {...}<br>}<br>
<b>Enumeration and Iterators | 143</b><br>
<hr>
<A name=164></a>class <i>Enumerable</i>   // Typically implements IEnumerable or IEnumerable&lt;T&gt;<br>
{<br>  public <i>Enumerator</i> GetEnumerator() {...}<br>}<br>
Here is the high-level way of iterating through the characters in the word <i>beer</i> using<br>a foreach statement:<br>
foreach (char c in &quot;beer&quot;)<br>
  Console.WriteLine (c);<br>
Here is the low-level way of iterating through the characters in <i>beer</i> without using a<br>foreach statement:<br>
using (var enumerator = &quot;beer&quot;.<b>GetEnumerator()</b>)<br>  while (enumerator.<b>MoveNext()</b>)<br>
  {<br>
    var element = enumerator.<b>Current</b>;<br>
    Console.WriteLine (element);<br>
  }<br>
If  the  enumerator  implements  IDisposable,  the  foreach  statement  also  acts  as  a<br>using statement, implicitly disposing the enumerator object as in the earlier example.<br>
Chapter 7 explains the enumeration interfaces in further detail.<br>
<b>Collection Initializers<br></b>You can instantiate and populate an enumerable object in a single step. For example:<br>
using System.Collections.Generic;<br>...<br>
List&lt;int&gt; list = new List&lt;int&gt; <b>{1, 2, 3}</b>;<br>
The compiler translates this to the following:<br>
using System.Collections.Generic;<br>...<br>
List&lt;int&gt; list = new List&lt;int&gt;();<br>list.Add (1);<br>list.Add (2);<br>
list.Add (3);<br>
This requires that the enumerable object implements the System.Collections.IEnu<br>merable interface, and that it has an Add method that has the appropriate number of<br>parameters for the call.<br>
<b>144 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=165></a><b>Iterators<br></b>Whereas a foreach statement is a <i>consumer</i> of an enumerator, an iterator is a <i>pro-<br>ducer</i> of an enumerator. In this example, we use an iterator to return a sequence of<br>Fibonacci numbers (where each number is the sum of the previous two):<br>
using System;<br>using System.Collections.Generic;<br>
class Test<br>
{<br>  static void Main()<br>
  {<br>
    foreach (int fib in Fibs(6))<br>
      Console.Write (fib + &quot;  &quot;);<br>
  }<br>
  static IEnumerable&lt;int&gt; Fibs (int fibCount)<br>  {<br>
    for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)<br>
    {<br>
<b>Advanced C#</b><br>
      <b>yield return prevFib;<br></b>      int newFib = prevFib+curFib;<br>      prevFib = curFib;<br>
      curFib = newFib;<br>
    }<br>
  }<br>}<br>
OUTPUT: 1  1  2  3  5  8<br>
Whereas a return statement expresses "Here's the value you asked me to return from<br>this method," a  yield return statement expresses "Here's the next element you<br>asked me to yield from this enumerator." On each yield statement, control is re-<br>turned  to  the  caller,  but  the  callee's  state  is  maintained  so  that  the  method  can<br>continue executing as soon as the caller enumerates the next element. The lifetime<br>of this state is bound to the enumerator, such that the state can be released when<br>the caller has finished enumerating.<br>
The compiler converts iterator methods into private classes that<br>implement  IEnumerable&lt;T&gt;  and/or  IEnumerator&lt;T&gt;.  The  logic<br>within  the  iterator  block  is  "inverted"  and  spliced  into  the<br>MoveNext method and Current property on the compiler-written<br>enumerator  class.  This  means  that  when  you  call  an  iterator<br>method, all you're doing is instantiating the compiler-written<br>class;  none  of  your  code  actually  runs!  Your  code  runs  only<br>when you start enumerating over the resultant sequence, typi-<br>cally with a foreach statement.<br>
<b>Enumeration and Iterators | 145</b><br>
<hr>
<A name=166></a><b>Iterator Semantics<br></b>An iterator is a method, property, or indexer that contains one or more yield state-<br>ments. An iterator must return one of the following four interfaces (otherwise, the<br>compiler will generate an error):<br>
// Enumerable interfaces<br>System.Collections.IEnumerable<br>
System.Collections.Generic.IEnumerable&lt;T&gt;<br>
// Enumerator interfaces<br>System.Collections.IEnumerator<br>
System.Collections.Generic.IEnumerator&lt;T&gt;<br>
An iterator has different semantics, depending on whether it returns an <i>enumera-<br>ble</i> interface or an <i>enumerator</i> interface. We describe this in Chapter 7.<br>
<i>Multiple yield statements</i> are permitted. For example:<br>
class Test<br>{<br>  static void Main()<br>
  {<br>
    foreach (string s in Foo())<br>
      Console.WriteLine(s);         // Prints &quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;<br>
  }<br>
  static IEnumerable&lt;string&gt; Foo()<br>
  {<br>    <b>yield return</b> &quot;One&quot;;<br>    <b>yield return</b> &quot;Two&quot;;<br>    <b>yield return</b> &quot;Three&quot;;<br>  }<br>}<br>
<b>yield break<br></b>The yield break statement indicates that the iterator block should exit early, without<br>returning more elements. We can modify Foo as follows to demonstrate:<br>
static IEnumerable&lt;string&gt; Foo (bool breakEarly)<br>{<br>  yield return &quot;One&quot;;<br>  yield return &quot;Two&quot;;<br>
  if (breakEarly)<br>    <b>yield break;</b><br>
  yield return &quot;Three&quot;;<br>}<br>
A return statement is illegal in an iterator block--you must use<br>a yield break instead.<br>
<b>146 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=167></a><b>Iterators and try/catch/finally blocks<br></b>A yield return statement cannot appear in a try block that has a catch clause:<br>
IEnumerable&lt;string&gt; Foo()<br>{<br>  try { yield return &quot;One&quot;; }    // Illegal<br>
  catch { ... }<br>}<br>
Nor can yield return appear in a catch or finally block. These restrictions are due<br>to  the  fact  that  the  compiler  must  translate  iterators  into  ordinary  classes  with<br>MoveNext, Current, and Dispose members, and translating exception handling blocks<br>would create excessive complexity.<br>
You can, however, yield within a try block that has (only) a finally block:<br>
IEnumerable&lt;string&gt; Foo()<br>
{<br>  try { yield return &quot;One&quot;; }    // OK<br>
  finally { ... }<br>
}<br>
<b>Advanced C#</b><br>
The code in the finally block executes when the consuming enumerator reaches<br>the end of the sequence or is disposed. A foreach statement implicitly disposes the<br>enumerator if you break early, making this a safe way to consume enumerators.<br>When working with enumerators explicitly, a trap is to abandon enumeration early<br>without disposing it, circumventing the finally block. You can avoid this risk by<br>wrapping explicit use of enumerators in a using statement:<br>
string firstElement = null;<br>var sequence = Foo();<br>using (var enumerator = sequence.GetEnumerator())<br>  if (enumerator.MoveNext())<br>    firstElement = enumerator.Current;<br>
<b>Composing Sequences<br></b>Iterators are highly composable. We can extend our example, this time to output<br>even Fibonacci numbers only:<br>
using System;<br>using System.Collections.Generic;<br>
class Test<br>{<br>  static void Main()<br>  {<br>    foreach (int fib in EvenNumbersOnly (Fibs(6)))<br>      Console.WriteLine (fib);<br>  }<br>
  static IEnumerable&lt;int&gt; Fibs (int fibCount)<br>  {<br>    for (int i = 0, prevFib = 1, curFib = 1; i &lt; fibCount; i++)<br>
    {<br>
<b>Enumeration and Iterators | 147</b><br>
<hr>
<A name=168></a>      <b>yield return prevFib;</b><br>
      int newFib = prevFib+curFib;<br>      prevFib = curFib;<br>      curFib = newFib;<br>
    }<br>
  }<br>
  static IEnumerable&lt;int&gt; EvenNumbersOnly (IEnumerable&lt;int&gt; sequence)<br>
  {<br>
    foreach (int x in sequence)<br>      if ((x % 2) == 0)<br>        yield return x;<br>
  }<br>
}<br>
Each  element  is  not  calculated  until  the  last  moment--when  requested  by  a<br>MoveNext() operation. Figure 4-1 shows the data requests and data output over time.<br>
<i>Figure 4-1. Composing sequences</i><br>
The composability of the iterator pattern is extremely useful in LINQ; we will discuss<br>the subject again in Chapter 8.<br>
<b>Nullable Types<br></b>Reference types can represent a nonexistent value with a null reference. Value types,<br>however, cannot ordinarily represent null values. For example:<br>
string s = null;       // OK, Reference Type<br>int i = null;          // Compile Error, Value Type cannot be null<br>
<b>148 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=169></a>To represent null in a value type, you must use a special construct called a <i>nullable<br>type</i>. A nullable type is denoted with a value type followed by the ? symbol:<br>
int<b>?</b> i = null;                     // OK, Nullable Type<br>Console.WriteLine (i == null);     // True<br>
<b>Nullable&lt;T&gt; Struct<br></b>T? translates into System.Nullable&lt;T&gt;. Nullable&lt;T&gt; is a lightweight immutable struc-<br>ture,  having  only  two  fields,  to  represent  Value  and  HasValue.  The  essence  of<br>System.Nullable&lt;T&gt; is very simple:<br>
public struct Nullable&lt;T&gt; where T : struct<br>
{<br>  public T Value {get;}<br>
  public bool HasValue {get;}<br>
  public T GetValueOrDefault();<br>
  public T GetValueOrDefault (T defaultValue);<br>
  ...<br>}<br>
<b>Advanced C#</b><br>
The code:<br>
int? i = null;<br>
Console.WriteLine (i == null);              // True<br>
translates to:<br>
Nullable&lt;int&gt; i = new Nullable&lt;int&gt;();<br>Console.WriteLine (! i.HasValue);           // True<br>
Attempting to retrieve Value when HasValue is false throws an InvalidOperationEx<br>ception. GetValueOrDefault() returns Value if HasValue is true; otherwise, it returns<br>new T() or a specified custom default value.<br>
The default value of T? is null.<br>
<b>Implicit and Explicit Nullable Conversions<br></b>The conversion from T to T? is implicit, and from T? to T is explicit. For example:<br>
int? x = 5;        // implicit<br>int y = (int)x;    // explicit<br>
The explicit cast is directly equivalent to calling the nullable object's Value property.<br>Hence, an InvalidOperationException is thrown if HasValue is false.<br>
<b>Boxing and Unboxing Nullable Values<br></b>When T? is boxed, the boxed value on the heap contains T, not T?. This optimization<br>is possible because a boxed value is a reference type that can already express null.<br>
C# also permits the unboxing of nullable types with the as operator. The result will<br>be null if the cast fails:<br>
<b>Nullable Types | 149</b><br>
<hr>
<A name=170></a>object o = &quot;string&quot;;<br>
int? x = o as int?;<br>Console.WriteLine (x.HasValue);   // False<br>
<b>Operator Lifting<br></b>The Nullable&lt;T&gt; struct does not define operators such as &lt;, &gt;, or even ==. Despite<br>this, the following code compiles and executes correctly:<br>
int? x = 5;<br>
int? y = 10;<br>bool b = x &lt; y;      // true<br>
This works because the compiler steals or "lifts" the less-than operator from the<br>underlying value type. Semantically, it translates the preceding comparison expres-<br>sion into this:<br>
bool b = (x.HasValue &amp;&amp; y.HasValue) ? (x.Value &lt; y.Value) : false;<br>
In other words, if both x and y have values, it compares via int's less-than operator;<br>otherwise, it returns false.<br>Operator lifting means you can implicitly use T's operators on T?. You can define<br>operators for T? in order to provide special-purpose null behavior, but in the vast<br>majority of cases, it's best to rely on the compiler automatically applying systematic<br>nullable logic for you. Here are some examples:<br>
int? x = 5;<br>int? y = null;<br>
// Equality operator examples<br>
Console.WriteLine (x == y);    // False<br>Console.WriteLine (x == null); // False<br>Console.WriteLine (x == 5);    // True<br>Console.WriteLine (y == null); // True<br>Console.WriteLine (y == 5);    // False<br>Console.WriteLine (y != 5);    // True<br>
// Relational operator examples<br>Console.WriteLine (x &lt; 6);     // True<br>Console.WriteLine (y &lt; 6);     // False<br>Console.WriteLine (y &gt; 6);     // False<br>
// All other operator examples<br>Console.WriteLine (x + 5);     // 10<br>Console.WriteLine (x + y);     // <i>null</i> (prints empty line)<br>
The compiler performs null logic differently depending on the category of operator.<br>The following sections explain these different rules.<br>
<b>Equality operators (==   !=)<br></b>Lifted equality operators handle nulls just like reference types do. This means two<br>null values are equal:<br>
Console.WriteLine (       <b>null</b> ==        <b>null</b>);   // True<br>Console.WriteLine ((bool?)<b>null</b> == (bool?)<b>null</b>);   // True<br>
<b>150 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=171></a>Further:<br>
· If exactly one operand is null, the operands are unequal.<br>· If both operands are non-null, their Values are compared.<br>
<b>Relational operators (&lt;   &lt;=   &gt;=   &gt;)<br></b>The relational operators work on the principle that it is meaningless to compare null<br>operands. This means comparing a null value to either a null or a non-null value<br>returns false.<br>
bool b = x &lt; y;    // Translation:<br>
bool b = (x == null || y == null) ? false : (x.Value &lt; y.Value);<br>
// b is false (assuming x is 5 and y is null)<br>
<b>All other operators (+   -   *   /   %   &amp;   |   ^   &lt;&lt;   &gt;&gt;   +   ++   --   !   ~)<br></b>These operators return null when any of the operands are null. This pattern should<br>be familiar to SQL users.<br>
<b>Advanced C#</b><br>
int? c = x + y;   // Translation:<br>
int? c = (x == null || y == null)<br>         ? null<br>
         : (int?) (x.Value + y.Value);<br>
// c is null (assuming x is 5 and y is null)<br>
An exception is when the &amp; and | operators are applied to bool?, which we will<br>discuss shortly.<br>
<b>Mixing nullable and non-nullable operators<br></b>You can mix and match nullable and non-nullable types (this works because there<br>is an implicit conversion from T to T?):<br>
int? a = null;<br>int b = 2;<br>int? c = a + b;   // c is null - equivalent to a + (int?)b<br>
<b>bool? with &amp; and | Operators<br></b>When supplied operands of type bool?, the &amp; and | operators treat null as an <i>un-<br>known value</i>. So, null | true is true, because:<br>
· If the unknown value is false, the result would be true.<br>· If the unknown value is true, the result would be true.<br>
Similarly, null &amp; false is false. This behavior would be familiar to SQL users. The<br>following example enumerates other combinations:<br>
bool? n = null;<br>bool? f = false;<br>bool? t = true;<br>Console.WriteLine (n | n);    // <i>(null)</i><br>
<b>Nullable Types | 151</b><br>
<hr>
<A name=172></a>Console.WriteLine (n | f);    // <i>(null)</i><br>
Console.WriteLine (n | t);    // True<br>Console.WriteLine (n &amp; n);    // <i>(null)<br></i>Console.WriteLine (n &amp; f);    // False<br>
Console.WriteLine (n &amp; t);    // <i>(null)</i><br>
<b>Null Coalescing Operator<br></b>The ?? operator is the null coalescing operator, and it can be used with both nullable<br>types and reference types. It says, "If the operand is non-null, give it to me; otherwise,<br>give me a default value." For example:<br>
int? x = null;<br>
int y = x ?? 5;        // y is 5<br>
int? a = null, b = 1, c = 2;<br>
Console.WriteLine (a ?? b ?? c);  // 1 <i>(first non-null value)</i><br>
The ?? operator is equivalent to calling GetValueOrDefault with an explicit default<br>value, except that the expression passed to GetValueOrDefault is never evaluated if<br>the variable is not null.<br>
<b>Scenarios for Nullable Types<br></b>One of the most common scenarios for nullable types is to represent unknown val-<br>ues. This frequently occurs in database programming, where a class is mapped to a<br>table with nullable columns. If these columns are strings (e.g., an EmailAddress<br>column on a Customer table), there is no problem, as string is a reference type in<br>the CLR, which can be null. However, most other SQL column types map to CLR<br>struct types, making nullable types very useful when mapping SQL to the CLR. For<br>example:<br>
// Maps to a Customer table in a database<br>public class Customer<br>{<br>  ...<br>  public decimal? AccountBalance;<br>}<br>
A nullable type can also be used to represent the backing field of what's sometimes<br>called an <i>ambient property</i>. An ambient property, if null, returns the value of its<br>parent. For example:<br>
public class Row<br>{<br>  ...<br>  Grid parent;<br>  Color? color;<br>
  public Color Color<br>  {<br>    get { return color ?? parent.Color; }<br>    set { color = Color == parent.Color ? (Color?)null : value; }<br>  }<br>}<br>
<b>152 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=173></a><b>Alternatives to Nullable Types<br></b>Before nullable types were part of the C# language (i.e., before C# 2.0), there were<br>many strategies to deal with nullable value types, examples of which still appear in<br>the .NET Framework for historical reasons. One of these strategies is to designate a<br>particular non-null value as the "null value"; an example is in the string and array<br>classes. String.IndexOf returns the magic value of -1 when the character is not found:<br>
int i = &quot;Pink&quot;.IndexOf ('b');<br>
Console.WriteLine (s);         // -1<br>
However, Array.IndexOf returns -1 only if the index is 0-bounded. The more general<br>formula is that IndexOf returns 1 less than the lower bound of the array. In the next<br>example, IndexOf returns 0 when an element is not found:<br>
// Create an array whose lower bound is 1 instead of 0:<br>
Array a = Array.CreateInstance (typeof (string),<br>                                new int[] {2}, new int[] {1});<br>
a.SetValue (&quot;a&quot;, 1);<br>
a.SetValue (&quot;b&quot;, 2);<br>
<b>Advanced C#</b><br>
Console.WriteLine (Array.IndexOf (a, &quot;c&quot;));  // 0<br>
Nominating a "magic value" is problematic for several reasons:<br>
· It means that each value type has a different representation of null. In contrast,<br>
nullable types provide one common pattern that works for all value types.<br>
· There may be no reasonable designated value. In the previous example, -1 could<br>
not always be used. The same is true for our earlier examples representing an<br>unknown account balance and an unknown temperature.<br>
· Forgetting to test for the magic value results in an incorrect value that may go<br>
unnoticed until later in execution--when it pulls an unintended magic trick.<br>Forgetting to test HasValue on a null value, however, throws an InvalidOpera<br>tionException on the spot.<br>
· The ability for a value to be null is not captured in the <i>type</i>. Types communicate<br>
the intention of a program, allow the compiler to check for correctness, and<br>enable a consistent set of rules enforced by the compiler.<br>
<b>Operator Overloading<br></b>Operators can be overloaded to provide more natural syntax for custom types. Op-<br>erator overloading is most appropriately used for implementing custom structs that<br>represent fairly primitive data types. For example, a custom numeric type is an ex-<br>cellent candidate for operator overloading.<br>
The following symbolic operators can be overloaded:<br>
+ (unary)<br>
- (unary)<br>
!<br>
~<br>
++<br>
--<br>
+<br>
-<br>
*<br>
/<br>
%<br>
&amp;<br>
|<br>
^<br>
&lt;&lt;<br>
<b>Operator Overloading | 153</b><br>
<hr>
<A name=174></a>&gt;&gt;<br>
==<br>
!=<br>
&gt;<br>
&lt;<br>
&gt;=<br>
&lt;=<br>
 <br>
 <br>
 <br>
The following operators are also overloadable:<br>
· Implicit and explicit conversions (with the implicit and explicit keywords)<br>· The literals true and false<br>
The following operators are indirectly overloaded:<br>
· The compound assignment operators (e.g., +=, /=) are implicitly overridden by<br>
overriding the noncompound operators (e.g., +, /).<br>
· The conditional operators &amp;&amp; and || are implicitly overridden by overriding the<br>
bitwise operators &amp; and |.<br>
<b>Operator Functions<br></b>An operator is overloaded by declaring an <i>operator function</i>. An operator function<br>has the following rules:<br>
· The name of the function is specified with the operator keyword followed by<br>
an operator symbol.<br>
· The operator function must be marked static.<br>· The parameters of the operator function represent the operands.<br>· The return type of an operator function represents the result of an expression.<br>· At least one of the operands must be the type in which the operator function is<br>
declared.<br>
In the following example, we define a struct called Note representing a musical note,<br>and then overload the + operator:<br>
public struct Note<br>{<br>  int value;<br>  public Note (int semitonesFromA) { value = semitonesFromA; }<br>  <b>public static Note operator + (Note x, int semitones)<br></b>  {<br>    return new Note (x.value + semitones);<br>  }<br>}<br>
This overload allows us to add an int to a Note:<br>
Note B = new Note (2);<br>Note CSharp = B + 2;<br>
Overloading  an  assignment  operator  automatically  supports  the  corresponding<br>compound assignment operator. In our example, since we overrode +, we can use<br>+= too:<br>
CSharp += 2;<br>
<b>154 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=175></a><b>Overloading Equality and Comparison Operators<br></b>Equality and comparison operators are sometimes overridden when writing structs,<br>and  in  rare  cases  when  writing  classes.  Special  rules  and  obligations  come  with<br>overloading  the  equality  and  comparison  operators,  which  we  explain  in  Chap-<br>ter 6. A summary of these rules is as follows:<br>
<i>Pairing</i><br>
The C# compiler enforces operators that are logical pairs to both be defined.<br>These operators are (== !=), (&lt; &gt;), and (&lt;= &gt;=).<br>
Equals<i> and </i>GetHashCode<br>
In most cases, if you overload (==) and (!=), you will usually need to override<br>the Equals and GetHashCode methods defined on object in order to get mean-<br>ingful behavior. The C# compiler will give a warning if you do not do this. (See<br>"Equality Comparison" on page 245 in Chapter 6 for more details.)<br>
IComparable<i> and </i>IComparable&lt;T&gt;<br>
If  you  overload  (&lt; &gt;)  and  (&lt;= &gt;=),  you  should  implement  IComparable  and<br>IComparable&lt;T&gt;.<br>
<b>Advanced C#</b><br>
<b>Custom Implicit and Explicit Conversions<br></b>Implicit and explicit conversions are overloadable operators. These conversions are<br>typically overloaded to make converting between strongly related types (such as<br>numeric types) concise and natural.<br>
To convert between weakly related types, the following strategies are more suitable:<br>
· Write a constructor that has a parameter of the type to convert from.<br>· Write To<i>XXX</i> and (static) From<i>XXX</i> methods to convert between types.<br>
As explained in the discussion on types, the rationale behind implicit conversions<br>is that they are guaranteed to succeed and do not lose information during the con-<br>version. Conversely, an explicit conversion should be required either when runtime<br>circumstances will determine whether the conversion will succeed or if information<br>may be lost during the conversion.<br>
In this example, we define conversions between our musical Note type and a double<br>(which represents the frequency in hertz of that note):<br>
...<br>// Convert to hertz<br>public static implicit operator double (Note x)<br>{<br>  return 440 * Math.Pow (2, (double) x.value / 12 );<br>}<br>
// Convert from hertz (accurate to the nearest semitone)<br>public static explicit operator Note (double x)<br>{<br>  return new Note ((int) (0.5 + 12 * (Math.Log (x/440) / Math.Log(2) ) ));<br>}<br>...<br>
<b>Operator Overloading | 155</b><br>
<hr>
<A name=176></a>Note n = (Note)554.37;  // explicit conversion<br>
double x = n;           // implicit conversion<br>
Following  our  own  guidelines,  this  example  might  be<br>better  implemented  with  a  ToFrequency method (and a static<br>FromFrequency  method)  instead  of  implicit  and  explicit<br>operators.<br>
Custom conversions are ignored by the as and is operators:<br>
Console.WriteLine (554.37 is Note);   // False<br>
Note n = 554.37 as Note;              // <i>Error</i><br>
<b>Overloading true and false<br></b>The true and false operators are overloaded in the extremely rare case of types that<br>are boolean "in spirit," but do not have a conversion to bool. An example is a type<br>that implements three-state logic: by overloading true and false, such a type can<br>work seamlessly with conditional statements and operators--namely, if, do, while,<br>for, &amp;&amp;, ||, and ?:. The System.Data.SqlTypes.SqlBoolean struct provides this func-<br>tionality. For example:<br>
SqlBoolean a = SqlBoolean.Null;<br>
if (a)<br>  Console.WriteLine (&quot;True&quot;);<br>else if (!a)<br>
  Console.WriteLine (&quot;False&quot;);<br>else<br>  Console.WriteLine (&quot;Null&quot;);<br>
OUTPUT:<br>Null<br>
The following code is a reimplementation of the parts of SqlBoolean necessary to<br>demonstrate the true and false operators:<br>
public struct SqlBoolean<br>{<br>  public static bool operator <b>true</b> (SqlBoolean x)<br>  {<br>    return x.m_value == True.m_value;<br>  }<br>
  public static bool operator <b>false</b> (SqlBoolean x)<br>  {<br>    return x.m_value == False.m_value;<br>  }<br> <br>
   public static SqlBoolean operator <b>!</b> (SqlBoolean x)<br>  {<br>    if (x.m_value == Null.m_value)  return Null;<br>
<b>156 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=177></a>    if (x.m_value == False.m_value) return True;<br>
    return False;<br>  }<br>
  public static readonly SqlBoolean Null =  new SqlBoolean(0);<br>
  public static readonly SqlBoolean False = new SqlBoolean(1);<br>  public static readonly SqlBoolean True =  new SqlBoolean(2);<br>
  private SqlBoolean (byte value) { m_value = value; }<br>
  private byte m_value;<br>}<br>
<b>Extension Methods<br></b>Extension methods allow an existing type to be extended with new methods without<br>altering the definition of the original type. An extension method is a static method<br>of a static class, where the this modifier is applied to the first parameter. The type<br>of the first parameter will be the type that is extended. For example:<br>
public static class StringHelper<br>
<b>Advanced C#</b><br>
{<br>  public static bool IsCapitalized (this string s)<br>
  {<br>    if (string.IsNullOrEmpty(s)) return false;<br>
    return char.IsUpper (s[0]);<br>
  }<br>
}<br>
The IsCapitalized extension method can be called as though it were an instance<br>method on a string, as follows:<br>
Console.WriteLine (&quot;Perth&quot;.IsCapitalized());<br>
An extension method call, when compiled, is translated back into an ordinary static<br>method call:<br>
Console.WriteLine (StringHelper.IsCapitalized (&quot;Perth&quot;));<br>
The translation works as follows:<br>
arg0.Method (arg1, arg2, ...);              // Extension method call<br>StaticClass.Method (arg0, arg1, arg2, ...); // Static method call<br>
Interfaces can be extended too:<br>
public static T First&lt;T&gt; (this <b>IEnumerable&lt;T&gt;</b> sequence)<br>{<br>  foreach (T element in sequence)<br>    return element;<br>
  throw new InvalidOperationException (&quot;No elements!&quot;);<br>}<br>...<br>Console.WriteLine (&quot;Seattle&quot;.First());   // S<br>
Extension methods were added in C# 3.0.<br>
<b>Extension Methods | 157</b><br>
<hr>
<A name=178></a><b>Extension Method Chaining<br></b>Extension methods, like instance methods, provide a tidy way to chain functions.<br>Consider the following two functions:<br>
public static class StringHelper<br>
{<br>  public static string Pluralize (this string s) {...}<br>
  public static string Capitalize (this string s) {...}<br>}<br>
x and y are equivalent and both evaluate to &quot;Sausages&quot;, but x uses extension methods,<br>whereas y uses static methods:<br>
string x = &quot;sausage&quot;.Pluralize().Capitalize();<br>string y = StringHelper.Capitalize (StringHelper.Pluralize (&quot;sausage&quot;));<br>
<b>Ambiguity and Resolution</b><br>
<b>Namespaces<br></b>An extension method cannot be accessed unless the namespace is in scope. Consider<br>the extension method IsCapitalized in the following example:<br>
using System;<br>
namespace Utils<br>{<br>  public static class StringHelper<br>  {<br>
    public static bool <b>IsCapitalized</b> (this string s)<br>    {<br>      if (string.IsNullOrEmpty(s)) return false;<br>      return char.IsUpper (s[0]);<br>    }<br>  }<br>}<br>
To use IsCapitalized, the following application must import Utils, in order to avoid<br>a compile-time error:<br>
namespace MyApp<br>{<br>  <b>using Utils;</b><br>
  class Test<br>  {<br>    static void Main()<br>    {<br>      Console.WriteLine (&quot;Perth&quot;.IsCapitalized());<br>    }<br>  }<br>}<br>
<b>158 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=179></a><b>Extension methods versus instance methods<br></b>Any  compatible  instance  method  will  always  take  precedence  over  an  extension<br>method. In the following example, Test's Foo method will always take precedence--<br>even when called with an argument x of type int:<br>
class Test<br>{<br>  public void Foo (<b>object</b> x) { }    // This method always wins<br>}<br>
static class Extensions<br>
{<br>  public static void Foo (this Test t, <b>int</b> x) { }<br>
}<br>
The only way to call the extension method in this case is via normal static syntax;<br>in other words, Extensions.Foo(...).<br>
<b>Extension methods versus extension methods</b><br>
<b>Advanced C#</b><br>
If two extension methods have the same signature, the extension method must be<br>called as an ordinary static method to disambiguate the method to call. If one ex-<br>tension method has more specific arguments, however, the more specific method<br>takes precedence.<br>
To illustrate, consider the following two classes:<br>
static class StringHelper<br>{<br>  public static bool IsCapitalized (this <b>string</b> s) {...}<br>
}<br>static class ObjectHelper<br>{<br>  public static bool IsCapitalized (this <b>object</b> s) {...}<br>}<br>
The following code calls StringHelper's IsCapitalized method:<br>
bool test1 = &quot;Perth&quot;.IsCapitalized();<br>
To call ObjectHelper's IsCapitalized method, we must specify it explicitly:<br>
bool test2 = (ObjectHelper.IsCapitalized (&quot;Perth&quot;));<br>
Concrete types are considered more specific than interfaces.<br>
<b>Extension Methods on Interfaces<br></b>Extension methods can apply to interfaces:<br>
using System;<br>using System.Collections.Generic;<br>
static class Test<br>{<br> <br>
<b>Extension Methods | 159</b><br>
<hr>
<A name=180></a>  static void Main()<br>
  {<br>    string[] strings = { &quot;a&quot;, &quot;b&quot;, null, &quot;c&quot;};<br>    foreach (string s in strings.StripNulls())<br>
      Console.WriteLine (s);<br>
  }<br>
  static IEnumerable&lt;T&gt; StripNulls&lt;T&gt; (this IEnumerable&lt;T&gt; seq)<br>
  {<br>
    foreach (T t in seq)<br>      if (t != null)<br>        yield return t;<br>
  }<br>
}<br>
<b>Anonymous Types<br></b>An anonymous type is a simple class created by the compiler on the fly to store a set<br>of values. To create an anonymous type, use the new keyword followed by an object<br>initializer, specifying the properties and values the type will contain. For example:<br>
var dude = new { Name = &quot;Bob&quot;, Age = 1 };<br>
The compiler translates this to (approximately) the following:<br>
internal class AnonymousGeneratedTypeName<br>
{<br>  private string name;  // Actual field name is irrelevant<br>
  private int    age;   // Actual field name is irrelevant<br>
  public AnonymousGeneratedTypeName (string name, int age)<br>  {<br>    this.name = name; this.age = age;<br>  }<br>
  public string  Name { get { return name; } }<br>  public int     Age  { get { return age;  } }<br>
  // The Equals and GetHashCode methods are overridden (see Chapter 6).<br>  // The ToString method is also overridden.<br>}<br>...<br>
var dude = new AnonymousGeneratedTypeName (&quot;Bob&quot;, 1);<br>
You must use the var keyword to reference an anonymous type, because the name<br>of the type is compiler-generated.<br>
The property name of an anonymous type can be inferred from an expression that<br>is itself an identifier (or ends with one). For example:<br>
int <b>Age</b> = 23;<br>var dude = new { Name = &quot;Bob&quot;, <b>Age,</b> Age.ToString().<b>Length</b> };<br>
is equivalent to:<br>
var dude = new { Name = &quot;Bob&quot;, <b>Age =</b> Age<b>, Length =</b> Age.ToString().Length };<br>
<b>160 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=181></a>Two anonymous type instances will have the same underlying type if their elements<br>are same-typed and they're declared within the same assembly:<br>
var a1 = new { X = 2, Y = 4 };<br>var a2 = new { X = 2, Y = 4 };<br>
Console.WriteLine (a1.GetType() == a2.GetType());   // True<br>
Additionally, the Equals method is overridden to perform equality comparisons:<br>
Console.WriteLine (a1 == a2);         // False<br>
Console.WriteLine (a1.Equals (a2));   // True<br>
Anonymous types are used primarily when writing LINQ queries (see Chapter 8),<br>and were added in C# 3.0.<br>
<b>Dynamic Binding<br></b><i>Dynamic  binding</i>  defers  <i>binding</i>--the  process  of  resolving  types,  members,  and<br>operations--from  compile  time  to  runtime.  Dynamic  binding  is  useful  when  at<br>compile time <i>you</i> know that a certain function, member, or operation exists, but the<br><i>compiler</i> does not. This commonly occurs when you are interoperating with dynamic<br>
<b>Advanced C#</b><br>
languages (such as IronPython) and COM and in scenarios when you might other-<br>wise use reflection.<br>
A dynamic type is declared with the contextual keyword dynamic:<br>
dynamic d = GetSomeObject();<br>d.Quack();<br>
A dynamic type tells the compiler to relax. We expect the runtime type of d to have<br>a Quack method. We just can't prove it statically. Since d is dynamic, the compiler<br>defers binding Quack to d until runtime. To understand what this means requires<br>distinguishing between <i>static binding</i> and <i>dynamic binding</i>.<br>
<b>Static Binding Versus Dynamic Binding<br></b>The  canonical  binding  example  is  mapping  a  name  to  a  specific  function  when<br>compiling an expression. To compile the following expression, the compiler needs<br>to find the implementation of the method named Quack:<br>
d.Quack();<br>
Let's suppose the static type of d is Duck:<br>
Duck d = ...<br>d.Quack();<br>
In the simplest case, the compiler does the binding by looking for a parameterless<br>method named Quack on Duck. Failing that, the compiler extends its search to meth-<br>ods  taking  optional  parameters,  methods  on  base  classes  of  Duck, and extension<br>methods that take Duck as its first parameter. If no match is found, you'll get a com-<br>pilation error. Regardless of what method gets bound, the bottom line is that the<br>binding  is  done  by  the  compiler,  and  the  binding  utterly  depends  on  statically<br>knowing the types of the operands (in this case, d). This makes it <i>static binding</i>.<br>
<b>Dynamic Binding | 161</b><br>
<hr>
<A name=182></a>Now let's change the static type of d to object:<br>
object d = ...<br>
d.Quack();<br>
Calling Quack gives us a compilation error, because although the value stored in d<br>can contain a method called Quack, the compiler cannot know it since the only in-<br>formation it has is the type of the variable, which in this case is object. But let's now<br>change the static type of d to dynamic:<br>
dynamic d = ...<br>d.Quack();<br>
A dynamic type is like object--it's equally nondescriptive about a type. The differ-<br>ence is that it lets you use it in ways that aren't known at compile time. A dynamic<br>object binds at runtime based on its runtime type, not its compile-time type. When<br>the compiler sees a dynamically bound expression (which in general is an expression<br>that contains any value of type dynamic), it merely packages up the expression such<br>that the binding can be done later at runtime.<br>
At runtime, if a dynamic object implements IDynamicMetaObjectProvider, that in-<br>terface is used to perform the binding. If not, binding occurs in almost the same way<br>as it would have had the compiler known the dynamic object's runtime type. These<br>two alternatives are called <i>custom binding</i> and <i>language binding</i>.<br>
COM interop can be considered to use a third kind of binding<br>(see Chapter 25).<br>
<b>Custom Binding<br></b>Custom binding occurs when a dynamic object implements IDynamicMetaObjectPro<br>vider (IDMOP). Although you can implement IDMOP on types that you write in<br>C#, and that is useful to do, the more common case is that you have acquired an<br>IDMOP object from a dynamic language that is implemented in .NET on the DLR,<br>such as IronPython or IronRuby. Objects from those languages implicitly implement<br>IDMOP as a means by which to directly control the meanings of operations per-<br>formed on them.<br>
We will discuss custom binders in greater detail in Chapter 19, but we will write a<br>simple one now to demonstrate the feature:<br>
using System;<br>using System.Dynamic;<br>
public class Test<br>{<br>  static void Main()<br>
  {<br>    dynamic d = new Duck();<br>    d.Quack();                  // Quack method was called<br>    d.Waddle();                 // Waddle method was called<br>
<b>162 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=183></a>  }<br>
}<br>
public class Duck : DynamicObject<br>
{<br>  public override bool TryInvokeMember (<br>    InvokeMemberBinder binder, object[] args, out object result)<br>  {<br>
    Console.WriteLine (binder.Name + &quot; method was called&quot;);<br>
    result = null;<br>    return true;<br>  }<br>
}<br>
The Duck class doesn't actually have a Quack method. Instead, it uses custom binding<br>to intercept and interpret all method calls.<br>
<b>Language Binding<br></b>Language  binding  occurs  when  a  dynamic  object  does  not  implement<br>IDynamicMetaObjectProvider. Language binding is useful when working around im-<br>
<b>Advanced C#</b><br>
perfectly designed types or inherent limitations in the .NET type system (we'll ex-<br>plore more scenarios in Chapter 19). A typical problem when using numeric types<br>is that they have no common interface. We have seen that methods can be bound<br>dynamically; the same is true for operators:<br>
static dynamic Mean (dynamic x, dynamic y)<br>
{<br>  return (x + y) / 2;<br>
}<br>
static void Main()<br>{<br>  int x = 3, y = 4;<br>  Console.WriteLine (Mean (x, y));<br>}<br>
The benefit is obvious--you don't have to duplicate code for each numeric type.<br>However, you lose static type safety, risking runtime exceptions rather than compile-<br>time errors.<br>
Dynamic binding circumvents static type safety, but not run-<br>time type safety. Unlike with reflection (Chapter 18), you can't<br>circumvent member accessibility rules with dynamic binding.<br>
By design, language runtime binding behaves as similarly as possible to static bind-<br>ing, had the runtime types of the dynamic objects been known at compile time. In<br>our previous example, the behavior of our program would be identical if we hard-<br>coded Mean to work with the int type. The most notable exception in parity between<br>static and dynamic binding is for extension methods, which we discuss in "Uncal-<br>lable Functions" on page 168.<br>
<b>Dynamic Binding | 163</b><br>
<hr>
<A name=184></a>Dynamic binding also incurs a performance hit. Because of the<br>DLR's caching mechanisms, however, repeated calls to the same<br>dynamic expression are optimized--allowing you to efficiently<br>call dynamic expressions in a loop. This optimization brings the<br>typical overhead for a simple dynamic expression on today's<br>hardware down to less than 100 ns.<br>
<b>RuntimeBinderException<br></b>If a member fails to bind, a RuntimeBinderException is thrown. You can think of this<br>like a compile-time error at runtime:<br>
dynamic d = 5;<br>
d.Hello();                  // throws RuntimeBinderException<br>
The exception is thrown because the int type has no Hello method.<br>
<b>Runtime Representation of Dynamic<br></b>There is a deep equivalence between the dynamic and object types. The runtime<br>treats the following expression as true:<br>
typeof (dynamic) == typeof (object)<br>
This principle extends to constructed types and array types:<br>
typeof (List&lt;dynamic&gt;) == typeof (List&lt;object&gt;)<br>typeof (dynamic[]) == typeof (object[])<br>
Like an object reference, a dynamic reference can point to an object of any type<br>(except pointer types):<br>
dynamic x = &quot;hello&quot;;<br>Console.WriteLine (x.GetType().Name);  // String<br>
x = 123;  // No error (despite same variable)<br>Console.WriteLine (x.GetType().Name);  // Int32<br>
Structurally, there is no difference between an object reference and a dynamic ref-<br>erence. A dynamic reference simply enables dynamic operations on the object it<br>points to. You can convert from object to dynamic to perform any dynamic operation<br>you want on an object:<br>
object o = new System.Text.StringBuilder();<br>dynamic d = o;<br>d.Append (&quot;hello&quot;);<br>Console.WriteLine (o);   // hello<br>
<b>164 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=185></a>Reflecting on a type exposing (public) dynamic members reveals<br>that those members are represented as annotated objects. For<br>example:<br>
public class Test<br>{<br>  public dynamic Foo;<br>
}<br>
is equivalent to:<br>
public class Test<br>
{<br>  [System.Runtime.CompilerServices.DynamicAttribute]<br>
  public object Foo;<br>}<br>
This allows consumers of that type to know that Foo should be<br>treated as dynamic, while allowing languages that don't support<br>dynamic binding to fall back to object.<br>
<b>Advanced C#</b><br>
<b>Dynamic Conversions<br></b>The dynamic type has implicit conversions to and from all other types:*<br>
int i = 7;<br>
dynamic d = i;<br>
int j = d;        // No cast required (implicit conversion)<br>
For  the  conversion  to  succeed,  the  runtime  type  of  the  dynamic  object  must  be<br>implicitly convertible to the target static type. The preceding example worked be-<br>cause an int is implicitly convertible to a long.<br>The following example throws a RuntimeBinderException because an int is not im-<br>plicitly convertible to a short:<br>
int i = 7;<br>dynamic d = i;<br>short j = d;      // throws RuntimeBinderException<br>
<b>var Versus dynamic<br></b>The var and dynamic types bear a superficial resemblance, but the difference is deep:<br>
· var says, "Let the <i>compiler</i> figure out the type."<br>· dynamic says, "Let the <i>runtime</i> figure out the type."<br>
dynamic x = &quot;hello&quot;;  // Static type is <b>dynamic</b>, runtime type is string<br>var y = &quot;hello&quot;;      // Static type is <b>string</b>, runtime type is string<br>int i = x;            // Runtime error<br>int j = y;            // Compile-time error<br>
* Technically, the conversion from dynamic to other types is not an <i>implicit conversion</i>, but an<br>
<i>assignment  conversion</i>.  An  assignment  conversion  is  more  restrictive  in  situations  that  might<br>otherwise create ambiguities, such as overload resolution.<br>
<b>Dynamic Binding | 165</b><br>
<hr>
<A name=186></a>The static type of a variable declared with var can be dynamic:<br>
dynamic x = &quot;hello&quot;;<br>
var y = x;            // Static type of y is dynamic<br>
int z = y;            // Runtime error<br>
<b>Dynamic Expressions<br></b>Fields, properties, methods, events, constructors, indexers, operators, and conver-<br>sions can all be called dynamically.<br>
Trying to consume the result of a dynamic expression with a void return type is<br>prohibited--just as with a statically typed expression. The difference is that the error<br>occurs at runtime:<br>
dynamic list = new List&lt;int&gt;();<br>
var result = list.Add (5);         // RuntimeBinderException thrown<br>
Expressions involving dynamic operands are typically themselves dynamic, since the<br>effect of absent type information is cascading:<br>
dynamic x = 2;<br>
var y = x * 3;       // Static type of y is dynamic<br>
There are a couple of obvious exceptions to this rule. First, casting a dynamic ex-<br>pression to a static type yields a static expression:<br>
dynamic x = 2;<br>var y = (int)2;      // Static type of y is int<br>
Second, constructor invocations always yield static expressions--even when called<br>with dynamic arguments. In this example, x is statically typed to a StringBuilder:<br>
dynamic capacity = 10;<br>var x = new System.Text.StringBuilder (capacity);<br>
In addition, there are a few edge cases where an expression containing a dynamic<br>argument  is  static,  including  passing  an  index  to  an  array  and  delegate  creation<br>expressions.<br>
<b>Dynamic Calls Without Dynamic Receivers<br></b>The canonical use case for dynamic involves a dynamic <i>receiver</i>. This means that a<br>dynamic object is the receiver of a dynamic function call:<br>
dynamic x = ...;<br>x.Foo();          // x is the receiver<br>
However, you can also call statically known functions with dynamic arguments.<br>Such calls are subject to dynamic overload resolution, and can include:<br>
· Static methods<br>· Instance constructors<br>· Instance methods on receivers with a statically known type<br>
<b>166 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=187></a>In the following example, the particular Foo that gets dynamically bound is depend-<br>ent on the runtime type of the dynamic argument:<br>
class Program<br>{<br>  static void Foo (int x)    { Console.WriteLine (&quot;1&quot;); }<br>
  static void Foo (string x) { Console.WriteLine (&quot;2&quot;); }<br>
  static void Main()<br>  {<br>
    dynamic x = 5;<br>
    dynamic y = &quot;watermelon&quot;;<br>
    Foo (x);                // 1<br>    Foo (y);                // 2<br>
  }<br>
}<br>
Because a dynamic receiver is not involved, the compiler can statically perform a<br>basic check to see whether the dynamic call will succeed. It checks that a function<br>with the right name and number of parameters exists. If no candidate is found, you<br>
<b>Advanced C#</b><br>
get a compile-time error. For example:<br>
class Program<br>
{<br>  static void Foo (int x)    { Console.WriteLine (&quot;1&quot;); }<br>
  static void Foo (string x) { Console.WriteLine (&quot;2&quot;); }<br>
  static void Main()<br>
  {<br>    dynamic x = 5;<br>
    Foo (x, x);          // Compiler error - wrong number of parameters<br>    Fook (x);            // Compiler error - no such method name<br>  }<br>}<br>
<b>Static Types in Dynamic Expressions<br></b>It's obvious that dynamic types are used in dynamic binding. It's not so obvious that<br>static types are also used--wherever possible--in dynamic binding. Consider the<br>following:<br>
class Program<br>{<br>  static void Foo (object x, object y) { Console.WriteLine (&quot;oo&quot;); }<br>  static void Foo (object x, string y) { Console.WriteLine (&quot;os&quot;); }<br>  static void Foo (string x, object y) { Console.WriteLine (&quot;so&quot;); }<br>  static void Foo (string x, string y) { Console.WriteLine (&quot;ss&quot;); }<br>
  static void Main()<br>  {<br>    object o = &quot;hello&quot;;<br>    dynamic d = &quot;goodbye&quot;;<br>    Foo (o, d);               // os<br>  }<br>}<br>
<b>Dynamic Binding | 167</b><br>
<hr>
<A name=188></a>The  call  to  Foo(o,d)  is  dynamically  bound  because  one  of  its  arguments,  d,  is<br>dynamic.  But  since  o  is  statically  known,  the  binding--even  though  it  occurs<br>dynamically--will make use of that. In this case, overload resolution will pick the<br>second implementation of Foo due to the static type of o and the runtime type of d.<br>In other words, the compiler is "as static as it can possibly be."<br>
<b>Uncallable Functions<br></b>Some functions cannot be called dynamically. You cannot call:<br>
· Extension methods (via extension method syntax)<br>· Any member of an interface<br>· Base members hidden by a subclass<br>
Understanding why this is so is useful in understanding dynamic binding.<br>
Dynamic binding requires two pieces of information: the name of the function to<br>call, and the object upon which to call the function. However, in each of the three<br>uncallable scenarios, an <i>additional type</i> is involved, which is known only at compile<br>time. As of C# 4.0, there's no way to specify these additional types dynamically.<br>
When calling extension methods, that additional type is implicit. It's the static class<br>on which the extension method is defined. The compiler searches for it given the<br>using directives in your source code. This makes extension methods compile-time-<br>only concepts, since using directives melt away upon compilation (after they've done<br>their job in the binding process in mapping simple names to namespace-qualified<br>names).<br>
When calling members via an interface, you specify that additional type via an im-<br>plicit or explicit cast. There are two scenarios where you might want to do this: when<br>calling  explicitly  implemented  interface  members,  and  when  calling  interface<br>members implemented in a type internal to another assembly. We can illustrate the<br>former with the following two types:<br>
interface IFoo   { void Test();        }<br>class Foo : IFoo { void IFoo.Test() {} }<br>
To call the Test method, we must cast to the IFoo interface. This is easy with static<br>typing:<br>
IFoo f = new Foo();   // Implicit cast to interface<br>f.Test();<br>
Now consider the situation with dynamic typing:<br>
<b>IFoo</b> f = new Foo();<br>dynamic d = f;<br>d.Test();             // Exception thrown<br>
The implicit cast shown in bold tells the <i>compiler</i> to bind subsequent member calls<br>on f to IFoo rather than Foo--in other words, to view that object through the lens<br>of the IFoo interface. However, that lens is lost at runtime, so the DLR cannot com-<br>plete the binding. The loss is illustrated as follows:<br>
<b>168 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=189></a>Console.WriteLine (f.GetType().Name);    // Foo<br>
A similar situation arises when calling a hidden base member: you must specify an<br>additional type via either a cast or the base keyword--and that additional type is<br>lost at runtime.<br>
<b>Attributes<br></b>You're already familiar with the notion of attributing code elements of a program<br>with modifiers, such as virtual or ref. These constructs are built into the language.<br><i>Attributes</i> are an extensible mechanism for adding custom information to code ele-<br>ments (assemblies, types, members, return values, and parameters). This extensi-<br>bility  is  useful  for  services  that  integrate  deeply  into  the  type  system,  without<br>requiring special keywords or constructs in the C# language.<br>
A good scenario for attributes is serialization--the process of converting arbitrary<br>objects to and from a particular format. In this scenario, an attribute on a field can<br>specify the translation between C#'s representation of the field and the format's<br>representation of the field.<br>
<b>Advanced C#</b><br>
<b>Attribute Classes<br></b>An attribute is defined by a class that inherits (directly or indirectly) from the abstract<br>class System.Attribute. To attach an attribute to a code element, specify the attrib-<br>ute's type name in square brackets, before the code element. For example, the fol-<br>lowing attaches the ObsoleteAttribute to the Foo class:<br>
<b>[ObsoleteAttribute]<br></b>public class Foo {...}<br>
This attribute is recognized by the compiler and will cause compiler warnings if a<br>type or member marked obsolete is referenced. By convention, all attribute types<br>end in the word <i>Attribute</i>. C# recognizes this and allows you to omit the suffix when<br>attaching an attribute:<br>
<b>[Obsolete]<br></b>public class Foo {...}<br>
ObsoleteAttribute is a type declared in the System namespace as follows (simplified<br>for brevity):<br>
public sealed class ObsoleteAttribute : Attribute {...}<br>
The C# language and the .NET Framework include a number of predefined attrib-<br>utes. We describe how to write your own attributes in Chapter 17.<br>
<b>Named and Positional Attribute Parameters<br></b>Attributes may have parameters. In the following example, we apply XmlElementAt<br>tribute  to  a  class.  This  attribute  tells  XML  serializer  (in  System.Xml.Serializa<br>tion)  how  an  object  is  represented  in  XML  and  accepts  several  <i>attribute</i><br>
<b>Attributes | 169</b><br>
<hr>
<A name=190></a><i>parameters</i>. The following attribute maps the CustomerEntity class to an XML ele-<br>ment named Customer, belonging to the <i>http://oreilly.com</i> namespace:<br>
<b>[XmlElement (&quot;Customer&quot;, Namespace=&quot;http://oreilly.com&quot;)]<br></b>public class CustomerEntity { ... }<br>
Attribute parameters fall into one of two categories: positional or named. In the<br>preceding  example,  the  first  argument  is  a  <i>positional  parameter</i>;  the  second  is  a<br><i>named parameter</i>. Positional parameters correspond to parameters of the attribute<br>type's public constructors. Named parameters correspond to public fields or public<br>properties on the attribute type.<br>
When specifying an attribute, you must include positional parameters that corre-<br>spond to one of the attribute's constructors. Named parameters are optional.<br>
In Chapter 18, we describe the valid parameter types and rules for their evaluation.<br>
<b>Attribute Targets<br></b>Implicitly, the target of an attribute is the code element it immediately precedes,<br>which is typically a type or type member. However, you can also attach attributes<br>to an assembly. This requires that you explicitly specify the attribute's target.<br>
Here is an example of using the CLSCompliant attribute to specify CLS compliance<br>for an entire assembly:<br>
[<b>assembly:</b>CLSCompliant(true)]<br>
<b>Specifying Multiple Attributes<br></b>Multiple attributes can be specified for a single code element. Each attribute can be<br>listed either within the same pair of square brackets (separated by a comma) or in<br>separate pairs of square brackets (or a combination of the two). The following three<br>examples are semantically identical:<br>
[Serializable, Obsolete, CLSCompliant(false)]<br>public class Bar {...}<br>
[Serializable] [Obsolete] [CLSCompliant(false)]<br>public class Bar {...}<br>
[Serializable, Obsolete]<br>[CLSCompliant(false)]<br>public class Bar {...}<br>
<b>Unsafe Code and Pointers<br></b>C# supports direct memory manipulation via pointers within blocks of code marked<br>unsafe and compiled with the /unsafe compiler option. Pointer types are primarily<br>useful for interoperability with C APIs, but may also be used for accessing memory<br>outside the managed heap or for performance-critical hotspots.<br>
<b>170 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=191></a><b>Pointer Basics<br></b>For every value type or pointer type <i>V</i>, there is a corresponding pointer type <i>V*</i>. A<br>pointer instance holds the address of a value. This is considered to be of type <i>V</i>, but<br>pointer types can be (unsafely) cast to any other pointer type. The main pointer<br>operators are:<br>
<b>Operator</b><br>
<b>Meaning</b><br>
&amp;<br>
The address-of operator returns a pointer to the address of a value<br>
*<br>
The dereference operator returns the value at the address of a pointer<br>
-&gt;<br>
The pointer-to-member operator is a syntactic shortcut, in which x-&gt;y is equivalent to (*x).y<br>
<b>Unsafe Code<br></b>By marking a type, type member, or statement block with the unsafe keyword, you're<br>permitted to use pointer types and perform C++ style pointer operations on memory<br>within that scope. Here is an example of using pointers to quickly process a bitmap:<br>
<b>Advanced C#</b><br>
unsafe void BlueFilter (int[,] bitmap)<br>
{<br>  int length = bitmap.Length;<br>
  fixed (int* b = bitmap)<br>
  {<br>
    int* p = b;<br>    for (int i = 0; i &lt; length; i++)<br>
      *p++ &amp;= 0xFF;<br>  }<br>
}<br>
Unsafe  code  can  run  faster  than  a  corresponding  safe  implementation.  In  this<br>case, the code would have required a nested loop with array indexing and bounds<br>checking. An unsafe C# method may also be faster than calling an external C func-<br>tion,  since  there  is  no  overhead  associated  with  leaving  the  managed  execution<br>environment.<br>
<b>The fixed Statement<br></b>The fixed statement is required to pin a managed object, such as the bitmap in the<br>previous example. During the execution of a program, many objects are allocated<br>and deallocated from the heap. In order to avoid unnecessary waste or fragmentation<br>of memory, the garbage collector moves objects around. Pointing to an object is<br>futile if its address could change while referencing it, so the fixed statement tells the<br>garbage collector to "pin" the object and not move it around. This may have an<br>impact on the efficiency of the runtime, so fixed blocks should be used only briefly,<br>and heap allocation should be avoided within the fixed block.<br>
Within a fixed statement, you can get a pointer to any value type, an array of value<br>types, or a string. In the case of arrays and strings, the pointer will actually point to<br>the first element, which is a value type.<br>
<b>Unsafe Code and Pointers | 171</b><br>
<hr>
<A name=192></a>Value types declared inline within reference types require the reference type to be<br>pinned, as follows:<br>
class Test<br>{<br>  int x;<br>
  static void Main()<br>  {<br>    Test test = new Test();<br>
    unsafe<br>
    {<br>       fixed (int* p = &amp;test.x)   // Pins test<br>       {<br>
         *p = 9;<br>
       }<br>       System.Console.WriteLine (test.x);<br>    }<br>
  }<br>
}<br>
We describe the fixed statement further in "Mapping a Struct to Unmanaged Mem-<br>ory" on page 965 in Chapter 25.<br>
<b>The Pointer-to-Member Operator<br></b>In addition to the &amp; and * operators, C# also provides the C++ style -&gt; operator,<br>which can be used on structs:<br>
struct Test<br>{<br>  int x;<br>  unsafe static void Main()<br>  {<br>    Test test = new Test();<br>    Test* p = &amp;test;<br>    p-&gt;x = 9;<br>    System.Console.WriteLine (test.x);<br>  }<br>}<br>
<b>Arrays</b><br>
<b>The stackalloc keyword<br></b>Memory can be allocated in a block on the stack explicitly using the stackalloc<br>keyword. Since it is allocated on the stack, its lifetime is limited to the execution of<br>the method, just as with any other local variable. The block may use the [] opera-<br>tor to index into memory:<br>
int* a = stackalloc int [10];<br>for (int i = 0; i &lt; 10; ++i)<br>   Console.WriteLine (a[i]);   // Print raw memory<br>
<b>172 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=193></a><b>Fixed-size buffers<br></b>Memory can be allocated in a block within a struct using the fixed keyword:<br>
unsafe struct UnsafeUnicodeString<br>{<br>  public short Length;<br>
  public <b>fixed</b> byte Buffer[30];<br>}<br>
unsafe class UnsafeClass<br>{<br>  UnsafeUnicodeString uus;<br>
  public UnsafeClass (string s)<br>
  {<br>
    uus.Length = (short)s.Length;<br>    fixed (byte* p = uus.Buffer)<br>      for (int i = 0; i &lt; s.Length; i++)<br>
        p[i] = (byte) s[i];<br>
  }<br>}<br>
<b>Advanced C#</b><br>
class Test<br>
{<br>  static void Main() { new UnsafeClass (&quot;Christian Troy&quot;); }<br>}<br>
The fixed keyword is also used in this example to pin the object on the heap that<br>contains the buffer (which will be the instance of UnsafeClass).<br>
<b>void*<br></b>A <i>void pointer</i> (void*) makes no assumptions about the type of the underlying data<br>and is useful for functions that deal with raw memory. An implicit conversion exists<br>from  any  pointer  type  to  void*. A void* cannot be dereferenced, and arithmetic<br>operations cannot be performed on void pointers. For example:<br>
class Test<br>{<br>  unsafe static void Main()<br>  {<br>    short[ ] a = {1,1,2,3,5,8,13,21,34,55};<br>      fixed (short* p = a)<br>      {<br>        //sizeof returns size of value-type in bytes<br>        Zap (p, a.Length * sizeof (short));<br>      }<br>    foreach (short x in a)<br>      System.Console.WriteLine (x);   // Prints all zeros<br>  }<br>
  unsafe static void Zap (void* memory, int byteCount)<br>  {<br>    byte* b = (byte*) memory;<br>      for (int i = 0; i &lt; byteCount; i++)<br>        *b++ = 0;<br>
<b>Unsafe Code and Pointers | 173</b><br>
<hr>
<A name=194></a>  }<br>
}<br>
<b>Pointers to Unmanaged Code<br></b>Pointers are also useful for accessing data outside the managed heap (such as when<br>interacting  with  C  DLLs  or  COM),  or  when  dealing  with  data  not  in  the  main<br>memory (such as graphics memory or a storage medium on an embedded device).<br>
<b>Preprocessor Directives<br></b>Preprocessor directives supply the compiler with additional information about re-<br>gions of code. The most common preprocessor directives are the conditional direc-<br>tives, which provide a way to include or exclude regions of code from compilation.<br>For example:<br>
<b>#define DEBUG</b><br>
class MyClass<br>
{<br>  int x;<br>
  void Foo()<br>
  {<br>    <b># if DEBUG</b><br>
    Console.WriteLine (&quot;Testing: x = {0}&quot;, x);<br>
    <b># endif</b><br>
  <b>}<br></b>  ...<br>
}<br>
In this class, the statement in Foo is compiled as conditionally dependent upon the<br>presence of the DEBUG symbol. If we remove the DEBUG symbol, the statement is not<br>compiled.  Preprocessor  symbols  can  be  defined  within  a  source  file  (as  we  have<br>done), and they can be passed to the compiler with the /define:<i>symbol</i> command-<br>line option.<br>
With the #if and #elif directives, you can use the ||, &amp;&amp;, and ! operators to perform<br><i>or</i>, <i>and</i>, and <i>not</i> operations on multiple symbols. The following directive instructs<br>the compiler to include the code that follows if the TESTMODE symbol is defined and<br>the DEBUG symbol is not defined:<br>
#if TESTMODE &amp;&amp; !DEBUG<br>  ...<br>
Bear in mind, however, that you're not building an ordinary C# expression, and the<br>symbols upon which you operate have absolutely no connection to <i>variables</i>--static<br>or otherwise.<br>
The #error and #warning symbols prevent accidental misuse of conditional directives<br>by  making  the  compiler  generate  a  warning  or  error  given  an  undesirable  set  of<br>compilation symbols. Table 4-1 lists the preprocessor directives.<br>
<b>174 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=195></a><i>Table 4-1. Preprocessor directives</i><br>
<b>Preprocessor directive</b><br>
<b>Action</b><br>
#define <i>symbol</i><br>
Defines <i>symbol</i><br>
#undef <i>symbol</i><br>
Undefines <i>symbol</i><br>
#if <i>symbol</i> [<i>operator</i> <i>symbol2</i>]...<br>
<i>symbol</i> to test; <i>operator</i>s are ==, !=, &amp;&amp;, and || followed by<br>#else, #elif, and #endif<br>
#else<br>
Executes code to subsequent #endif<br>
#elif <i>symbol</i> [<i>operator</i> <i>symbol2</i>]<br>
Combines #else branch and #if test<br>
#endif<br>
Ends conditional directives<br>
#warning <i>text</i><br>
<i>text</i> of the warning to appear in compiler output<br>
#error <i>text</i><br>
<i>text</i> of the error to appear in compiler output<br>
#line [ <i>number</i> [&quot;<i>file</i>&quot;] | hidden]<br>
<i>number</i> specifies the line in source code; <i>file</i> is the filename to<br>
appear in computer output; hidden instructs debuggers to skip over<br>
code from this point until the next #line directive<br>
#region <i>name</i><br>
Marks the beginning of an outline<br>
<b>Advanced C#</b><br>
#end <i>region</i><br>
Ends an outline region<br>
<b>Conditional Attributes<br></b>An attribute decorated with the Conditional attribute will be compiled only if a given<br>preprocessor symbol is present. For example:<br>
// file1.cs<br>#define DEBUG<br>
using System;<br>using System.Diagnostics;<br><b>[Conditional(&quot;DEBUG&quot;)]<br></b>public class TestAttribute : Attribute {}<br>
// file2.cs<br><b>#define DEBUG<br></b>[Test]<br>class Foo<br>{<br>  [Test]<br>
  string s;<br>}<br>
The compiler will not incorporate the [Test] attributes if the DEBUG symbol is in<br>scope for <i>file2.cs</i>.<br>
<b>Pragma Warning<br></b>The compiler generates a warning when it spots something in your code that seems<br>unintentional.  Unlike  errors,  warnings  don't  ordinarily  prevent  your  application<br>from compiling.<br>
<b>Preprocessor Directives | 175</b><br>
<hr>
<A name=196></a>Compiler warnings can be extremely valuable in spotting bugs. Their usefulness,<br>however, is undermined when you get <i>false</i> warnings. In a large application, main-<br>taining  a  good  signal-to-noise  ratio  is  essential  if  the  "real"  warnings  are  to  get<br>noticed.<br>
To this effect, the compiler allows you to selectively suppress warnings with the<br>#pragma warning directive. In this example, we instruct the compiler not to warn us<br>about the field Message not being used:<br>
public class Foo<br>
{<br>  static void Main() { }<br>
  <b>#pragma warning disable 414</b><br>
  static string Message = &quot;Hello&quot;;<br>  <b>#pragma warning restore 414</b><br>
}<br>
Omitting the number in the #pragma warning directive disables or restores all warning<br>codes.<br>
If  you  are  thorough  in  applying  this  directive,  you  can  compile  with<br>the /warnaserror switch--this tells the compiler to treat any residual warnings as<br>errors.<br>
<b>XML Documentation<br></b>A <i>documentation comment</i> is a piece of embedded XML that documents a type or<br>member. A documentation comment comes immediately before a type or member<br>declaration, and starts with three slashes:<br>
<b>/// &lt;summary&gt;Cancels a running query.&lt;/summary&gt;<br></b>public void Cancel() { ... }<br>
Multiline comments can be done either like this:<br>
/// &lt;summary&gt;<br>/// Cancels a running query<br>/// &lt;/summary&gt;<br>public void Cancel() { ... }<br>
or like this (notice the extra star at the start):<br>
<b>/**<br></b>    &lt;summary&gt; Cancels a running query. &lt;/summary&gt;<br><b>*/<br></b>public void Cancel() { ... }<br>
If you compile with the /doc directive, the compiler extracts and collates documen-<br>tation comments into a single XML file. This has two main uses:<br>
· If placed in the same folder as the compiled assembly, Visual Studio automat-<br>
ically  reads  the  XML  file  and  uses  the  information  to  provide  IntelliSense<br>member listings to consumers of the assembly of the same name.<br>
<b>176 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=197></a>· Third-party tools (such as Sandcastle and NDoc) can transform XML file into<br>
an HTML help file.<br>
<b>Standard XML Documentation Tags<br></b>Here are the standard XML tags that Visual Studio and documentation generators<br>recognize:<br>
&lt;summary&gt;<br>
&lt;summary&gt;<i>...</i>&lt;/summary&gt;<br>
Indicates the tool tip that IntelliSense should display for the type or member;<br>typically a single phrase or sentence.<br>
&lt;remarks&gt;<br>
&lt;remarks&gt;<i>...</i>&lt;/remarks&gt;<br>
Additional text that describes the type or member. Documentation generators<br>pick this up and merge it into the bulk of a type or member's description.<br>
<b>Advanced C#</b><br>
&lt;param&gt;<br>
&lt;param name=&quot;<i>name</i>&quot;&gt;<i>...</i>&lt;/param&gt;<br>
Explains a parameter on a method.<br>
&lt;returns&gt;<br>
&lt;returns&gt;<i>...</i>&lt;/returns&gt;<br>
Explains the return value for a method.<br>
&lt;exception&gt;<br>
&lt;exception [cref=&quot;<i>type</i>&quot;]&gt;<i>...</i>&lt;/exception&gt;<br>
Lists an exception that a method may throw (cref refers to the exception type).<br>
&lt;permission&gt;<br>
&lt;permission [cref=&quot;<i>type</i>&quot;]&gt;<i>...</i>&lt;/permission&gt;<br>
Indicates an IPermission type required by the documented type or member.<br>
&lt;example&gt;<br>
&lt;example&gt;<i>...</i>&lt;/example&gt;<br>
Denotes an example (used by documentation generators). This usually contains<br>both description text and source code (source code is typically within a &lt;c&gt; or<br>&lt;code&gt; tag).<br>
&lt;c&gt;<br>
&lt;c&gt;<i>...</i>&lt;/c&gt;<br>
Indicates an inline code snippet. This tag is usually used inside an &lt;example&gt;<br>block.<br>
<b>XML Documentation | 177</b><br>
<hr>
<A name=198></a>&lt;code&gt;<br>
&lt;code&gt;<i>...</i>&lt;/code&gt;<br>
Indicates a multiline code sample. This tag is usually used inside an &lt;example&gt;<br>block.<br>
&lt;see&gt;<br>
&lt;see cref=&quot;<i>member</i>&quot;&gt;<i>...</i>&lt;/see&gt;<br>
Inserts an inline cross-reference to another type or member. HTML documen-<br>tation generators typically convert this to a hyperlink. The compiler emits a<br>warning if the type or member name is invalid. To refer to generic types, use<br>curly braces; for example, cref=&quot;Foo{T,U}&quot;.<br>
&lt;seealso&gt;<br>
&lt;seealso cref=&quot;<i>member</i>&quot;&gt;<i>...</i>&lt;/seealso&gt;<br>
Cross-references another type or member. Documentation generators typically<br>write this into a separate "See Also" section at the bottom of the page.<br>
&lt;paramref&gt;<br>
&lt;paramref name=&quot;<i>name</i>&quot;/&gt;<br>
References a parameter from within a &lt;summary&gt; or &lt;remarks&gt; tag.<br>
&lt;list&gt;<br>
&lt;list type=[ bullet | number | table ]&gt;<br>
  &lt;listheader&gt;<br>    &lt;term&gt;<i>...</i>&lt;/term&gt;<br>
    &lt;description&gt;<i>...</i>&lt;/description&gt;<br>  &lt;/listheader&gt;<br>  &lt;item&gt;<br>    &lt;term&gt;<i>...</i>&lt;/term&gt;<br>    &lt;description&gt;<i>...</i>&lt;/description&gt;<br>  &lt;/item&gt;<br>&lt;/list&gt;<br>
Instructs documentation generators to emit a bulleted, numbered, or table-style<br>list.<br>
&lt;para&gt;<br>
&lt;para&gt;<i>...</i>&lt;/para&gt;<br>
Instructs  documentation  generators  to  format  the  contents  into  a  separate<br>paragraph.<br>
&lt;include&gt;<br>
Merges an external XML file that contains documentation. The path attribute<br>denotes an XPath query to a specific element in that file.<br>
<b>User-Defined Tags<br></b>Little is special about the predefined XML tags recognized by the C# compiler, and<br>you are free to define your own. The only special processing done by the compiler<br>
<b>178 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=199></a>is on the &lt;param&gt; tag (in which it verifies the parameter name and that all the pa-<br>rameters on the method are documented) and the cref attribute (in which it verifies<br>that the attribute refers to a real type or member and expands it to a fully qualified<br>type or member ID). The cref attribute can also be used in your own tags and is<br>verified  and  expanded  just  as  it  is  in  the  predefined  &lt;exception&gt;,  &lt;permission&gt;,<br>&lt;see&gt;, and &lt;seealso&gt; tags.<br>
<b>Type or Member Cross-References<br></b>Type  names  and  type  or  member  cross-references  are  translated  into  IDs  that<br>uniquely define the type or member. These names are composed of a prefix that<br>defines what the ID represents and a signature of the type or member. The member<br>prefixes are:<br>
<b>XML type prefix</b><br>
<b>ID prefixes applied to...</b><br>
N<br>
Namespace<br>
T<br>
Type (class, struct, enum, interface, delegate)<br>
<b>Advanced C#</b><br>
F<br>
Field<br>
P<br>
Property (includes indexers)<br>
M<br>
Method (includes special methods)<br>
E<br>
Event<br>
!<br>
Error<br>
The  rules  describing  how  the  signatures  are  generated  are  well  documented,  al-<br>though fairly complex.<br>
Here is an example of a type and the IDs that are generated:<br>
// Namespaces do not have independent signatures<br>namespace NS<br>
{<br>  /// T:NS.MyClass<br>  class MyClass<br>  {<br>    /// F:NS.MyClass.aField<br>    string aField;<br>
    /// P:NS.MyClass.aProperty<br>    short aProperty {get {...} set {...}}<br>
    /// T:NS.MyClass.NestedType<br>    class NestedType {...};<br>
    /// M:NS.MyClass.X()<br>    void X() {...}<br>
 <br>    /// M:NS.MyClass.Y(System.Int32,System.Double@,System.Decimal@)<br>    void Y(int p1, ref double p2, out decimal p3) {...}<br>
<b>XML Documentation | 179</b><br>
<hr>
<A name=200></a>    /// M:NS.MyClass.Z(System.Char[ ],System.Single[0:,0:])<br>
    void Z(char[ ] 1, float[,] p2) {...}<br>
    /// M:NS.MyClass.op_Addition(NS.MyClass,NS.MyClass)<br>
    public static MyClass operator+(MyClass c1, MyClass c2) {...}<br>
    /// M:NS.MyClass.op_Implicit(NS.MyClass)~System.Int32<br>    public static implicit operator int(MyClass c) {...}<br>
    /// M:NS.MyClass.#ctor<br>    MyClass() {...}<br>
    /// M:NS.MyClass.Finalize<br>    ~MyClass() {...}<br>
    /// M:NS.MyClass.#cctor<br>    static MyClass() {...}<br>
  }<br>
}<br>
<b>180 | Chapter 4:</b><b>Advanced C#</b><br>
<hr>
<A name=201></a><b>5</b><br>
<b>Framework Overview</b><br>
Almost all the capabilities of the .NET Framework are exposed via a vast set of<br>managed types. These types are organized into hierarchical namespaces and pack-<br>aged into a set of assemblies, which, together with the CLR, comprise the .NET<br>platform.<br>
Some of the .NET types are used directly by the CLR and are essential for the man-<br>aged hosting environment. These types reside in an assembly called <i>mscorlib.dll</i> and<br>include C#'s built-in types, as well as the basic collection classes, types for stream<br>processing, serialization, reflection, threading, and native interoperability.<br>
At a level above this are additional types that "flesh out" the CLR-level functionality,<br>providing features such as XML, networking, and LINQ. These reside in <i>System.dll</i>,<br><i>System.Xml.dll</i>, and <i>System.Core.dll</i>, and together with <i>mscorlib</i> they provide a rich<br>programming environment upon which the rest of the Framework is built. This "core<br>framework" largely defines the scope of the rest of this book.<br>
The remainder of the .NET Framework consists of applied APIs, most of which cover<br>three areas of functionality:<br>
· User interface technologies<br>· Backend technologies<br>· Distributed system technologies<br>
Table 5-1 shows the history of compatibility between each version of C#, the CLR,<br>and the .NET Framework. Interestingly, C# 3.0 targeted a new Framework version<br>while using the same CLR version as its predecessor. With C# 4.0, the numbers<br>align cleanly again.<br>
<b>181</b><br>
<hr>
<A name=202></a><i>Table 5-1. C#, CLR, and .NET Framework versions</i><br>
<b>C# version</b><br>
<b>CLR version</b><br>
<b>Framework versions</b><br>
1.0<br>
1.0<br>
1.0<br>
1.2<br>
1.1<br>
1.1<br>
2.0<br>
2.0<br>
2.0, 3.0<br>
3.0<br>
2.0 (SP1)<br>
3.5<br>
4.0<br>
4.0<br>
4.0<br>
This chapter skims all key areas of the .NET Framework--starting with the core<br>types  covered  in  this  book  and  finishing  with  an  overview  of  the  applied<br>technologies.<br>
Assemblies and namespaces in the .NET Framework <i>cross-cut</i>.<br>The  most  extreme  examples  are  <i>System.Core.dll</i>  and<br><i>mscorlib.dll</i>, both defining types in dozens of namespaces, none<br>of which is prefixed with <i>mscorlib</i> or <i>System.Core</i>. The less ob-<br>vious cases are the more confusing ones, however, such as the<br>types  in  System.Security.Cryptography.  Most  types  in  this<br>namespace  reside  in  <i>System.dll</i>,  except  for  a  handful,  which<br>reside  in  <i>System.Security.dll</i>.  This  book's  companion  website<br>has  a  complete  mapping  of  Framework  namespaces  to<br>assemblies.<br>
<b>What's New in .NET Framework 4.0</b><br>
Framework 4.0 adds the following new features:<br>
· New core types: BigInteger (for arbitrarily large numbers), Complex (complex<br>
numbers), and tuples (Chapter 6)<br>
· A new SortedSet collection (Chapter 7)<br>· <i>Code contracts</i>, for enabling methods to interact more reliably through mu-<br>
tual obligations and responsibilities (Chapter 13)<br>
· Direct support for memory-mapped files (Chapter 14)<br>· Lazy file- and directory-I/O methods that return IEnumerable&lt;T&gt; instead of<br>
arrays (Chapter 14)<br>
· The  <i>Dynamic  Language  Runtime</i>  (DLR),  which  is  now  part  of  the  .NET<br>
Framework (Chapter 19)<br>
· <i>Security transparency</i>, which makes it easier to secure libraries in partially<br>
trusted environments (Chapter 20)<br>
· New threading constructs, including a more robust Monitor.Enter overload,<br>
Thread.Yield, new signaling classes (Barrier and CountdownEvent), and lazy<br>initialization primitives (Chapter 21)<br>
· <i>Parallel  programming</i>  APIs  for  leveraging  multicore  processors,  including<br>
Parallel  LINQ  (PLINQ),  imperative  data  and  task  parallelism  constructs,<br>
<b>182 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=203></a>concurrent collections, and low-latency synchronization and spinning prim-<br>itives (Chapter 22)<br>
· Methods for application domain resource monitoring (Chapter 24)<br>
Framework  4.0  also  includes  enhancements  to  ASP.NET,  including  the  MVC<br>framework and Dynamic Data, and enhancements to Entity Framework, WPF,<br>WCF,  and  Workflow.  In  addition,  it  includes  the  new  <i>Managed  Extensibility<br>Framework</i> library, to assist with runtime composition, discovery, and depend-<br>ency injection.<br>
Many  of  the  core  types  are  defined  in  the  following  assemblies:  <i>mscorlib.dll</i>,<br><i>System.dll</i>, and <i>System.Core.dll</i>. The first of these, <i>mscorlib.dll</i>, comprises the types<br>required by the runtime environment itself; <i>System.dll</i> and <i>System.Core.dll</i> contain<br>additional core types required by you as a programmer. The reason the latter two<br>are separate is historical: when the Microsoft team introduced Framework 3.5, they<br>made it <i>additive</i> insofar as it ran over the existing CLR 2.0. Therefore, almost all new<br>core types (such as the classes supporting LINQ) went into a new assembly which<br>Microsoft called <i>System.Core.dll</i>. With Framework 4.0, separation was maintained<br>to avoid breaking existing applications.<br>
A notable exception is the following types, which in Framework<br>4.0 have moved from <i>System.Core.dll</i> to <i>mscorlib.dll</i>:<br>
<b>FW Overview</b><br>
· The Action and Func delegates<br>· TimeZoneInfo and associated types<br>· System.Threading.LockRecursionException<br>
Redirections have been set up on these types, so if you ask the<br>reflection API for the "TimeZoneInfo" type in <i>System.Core.dll</i>,<br>you'll be given the type in <i>mscorlib.dll</i> instead.<br>
<b>The CLR and Core Framework<br>System Types<br></b>The most fundamental types live directly in the System namespace. These include<br>C#'s built-in types, the Exception base class, the Enum, Array, and Delegate base<br>classes, and Nullable, Type, DateTime, TimeSpan, and Guid. The System namespace<br>also  includes  types  for  performing  mathematical  functions  (Math),  generating<br>random  numbers  (Random),  and  converting  between  various  types  (Convert  and<br>BitConverter).<br>
Chapter  6  describes  these  types--as  well  as  the  interfaces  that  define  standard<br>protocols  used  across  the  .NET  Framework  for  such  tasks  as  formatting<br>(IFormattable) and order comparison (IComparable).<br>The System namespace also defines the IDisposable interface and the GC class for<br>interacting with the garbage collector. These topics are saved for Chapter 12.<br>
<b>The CLR and Core Framework | 183</b><br>
<hr>
<A name=204></a><b>Text Processing<br></b>The System.Text namespace contains the StringBuilder class (the editable or <i>mu-<br>table</i> cousin of string), and the types for working with text encodings, such as UTF-8<br>(Encoding and its subtypes). We cover this in Chapter 6.<br>The  System.Text.RegularExpressions  namespace  contains  types  that  perform<br>advanced pattern-based search and replace operations; these are described in Chap-<br>ter 26.<br>
<b>Collections<br></b>The .NET Framework offers a variety of classes for managing collections of items.<br>These include both list- and dictionary-based structures, and work in conjunction<br>with a set of standard interfaces that unify their common characteristics. All collec-<br>tion types are defined in the following namespaces, covered in Chapter 7:<br>
System.Collections                 // Nongeneric collections<br>
System.Collections.Generic         // Generic collections<br>System.Collections.Specialized     // Strongly typed collections<br>System.Collections.ObjectModel     // Bases for your own collections<br>
System.Collections.Concurrent      // Thread-safe collection (Chapter 20)<br>
<b>Queries<br></b>Language Integrated Query (LINQ) was added in Framework 3.5. LINQ allows you<br>to perform type-safe queries over local and remote collections (e.g., SQL Server ta-<br>bles) and is described in Chapters 8 through 10. A big advantage of LINQ is that it<br>presents a consistent querying API across a variety of domains. The types for re-<br>solving LINQ queries reside in these namespaces:<br>
System.Linq                  // LINQ to Objects and PLINQ<br>System.Xml.Linq              // LINQ to XML<br>System.Data.Linq             // LINQ to SQL<br>System.Data.Entity           // LINQ to Entities (Entity Framework)<br>System.Linq.Expressions      // For building expressions manually<br>
The LINQ to SQL and Entity Framework APIs leverage lower-level ADO.NET types<br>in the System.Data namespace.<br>
<b>XML<br></b>XML is used widely within the .NET Framework, and so is supported extensively.<br>Chapter 10 focuses entirely on LINQ to XML--a lightweight XML document object<br>model that can be constructed and queried through LINQ. Chapter 11 describes the<br>older W3C DOM, as well as the performant low-level reader/writer classes and the<br>Framework's support for XML schemas, stylesheets, and XPath. The XML name-<br>spaces are:<br>
System.Xml                // XmlReader, XmlWriter + the old W3C DOM<br>System.Xml.Linq           // The LINQ to XML DOM<br>System.Xml.Schema         // Support for XSD<br>System.Xml.XPath          // XPath query language<br>
<b>184 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=205></a>System.Xml.Xsl            // Stylesheet support<br>
System.Xml.Serialization  // Declarative XML serialization for .NET types<br>
<b>Diagnostics and Code Contracts<br></b>In Chapter 13, we cover .NET's logging and assertion facilities and the new code<br>contracts system in Framework 4.0. We also describe how to interact with other<br>processes, write to the Windows event log, and use performance counters for mon-<br>itoring. The types for this are defined in and under System.Diagnostics.<br>
<b>Streams and I/O<br></b>The Framework provides a stream-based model for low-level input/output. Streams<br>are typically used to read and write directly to files and network connections, and<br>can be chained or wrapped in decorator streams to add compression or encryption<br>functionality. Chapter 14 describes .NET's stream architecture, as well as the spe-<br>cific support for working with files and directories, compression, isolated storage,<br>pipes, and memory-mapped files. The Stream and I/O types are defined in and under<br>the System.IO namespace.<br>
<b>Networking<br></b>You can directly access standard network protocols such as HTTP, FTP, TCP/IP,<br>and SMTP via the types in System.Net. In Chapter 15, we demonstrate how to com-<br>municate using each of these protocols, starting with simple tasks such as down-<br>
<b>FW Overview</b><br>
loading from a web page, and finishing with using TCP/IP directly to retrieve POP3<br>email. Here are the namespaces we cover:<br>
System.Net<br>System.Net.Mail          // For sending mail via SMTP<br>System.Net.Sockets       // TCP, UDP, and IP<br>
<b>Serialization<br></b>The Framework provides several systems for saving and restoring objects to a binary<br>or text representation. Such systems are required for distributed application tech-<br>nologies, such as WCF, Web Services, and Remoting, and also to save and restore<br>objects to a file. In Chapter 16, we cover all three serialization engines: the data<br>contract serializer, the binary serializer, and the XML serializer. The types for seri-<br>alization reside in the following namespaces:<br>
System.Runtime.Serialization<br>System.Runtime.Serialization.Formatters.Binary<br>System.Runtime.Serialization.Formatters.SOAP<br>System.Xml.Serialization<br>
<b>Assemblies, Reflection, and Attributes<br></b>The  assemblies  into  which  C#  programs  compile  comprise  executable<br>instructions (stored as intermediate language or IL) and metadata, which describes<br>the program's types, members, and attributes. Through reflection, you can inspect<br>
<b>The CLR and Core Framework | 185</b><br>
<hr>
<A name=206></a>this metadata at runtime, and do such things as dynamically invoke methods. With<br>Reflection.Emit, you can construct new code on the fly.<br>
In Chapter 17, we describe the makeup of assemblies and how to sign them, use the<br>global assembly cache and resources, and resolve file references. In Chapter 18, we<br>cover reflection and attributes--describing how to inspect metadata, dynamically<br>invoke functions, write custom attributes, emit new types, and parse raw IL. The<br>types  for  using  reflection  and  working  with  assemblies  reside  in  the  following<br>namespaces:<br>
System<br>System.Reflection<br>
System.Reflection.Emit<br>
<b>Dynamic Programming<br></b>In  Chapter  19,  we  look  at  some  of  the  patterns  for  dynamic  programming  and<br>leveraging  the  Dynamic  Language  Runtime,  which  is  now  part  of  the  CLR.  We<br>describe how to implement the Visitor pattern, write custom dynamic objects, and<br>interoperate  with  IronPython.  The  types  for  dynamic  programming  are  in<br>System.Dynamic.<br>
<b>Security<br></b>The .NET Framework provides its own security layer, allowing you to both sandbox<br>other assemblies and be sandboxed yourself. In Chapter 20, we cover code access,<br>role, and identity security, and the new transparency model in CLR 4.0. We then<br>describe cryptography in the Framework, covering encryption, hashing, and data<br>protection. The types for this are defined in:<br>
System.Security<br>System.Security.Permissions<br>System.Security.Policy<br>System.Security.Cryptography<br>
<b>Threading and Parallel Programming<br></b>Multithreading allows you to execute code in parallel. Chapter 21 explores this sub-<br>ject in detail, describing both the Framework's support for multithreading and the<br>strategies for writing multithreaded applications. In Chapter 22, we cover Frame-<br>work 4.0's new constructs for leveraging multicore processors, and in Chapter 23,<br>we describe how to use asynchronous methods to write highly concurrent server<br>applications.<br>
All types for threading are in and under the System.Threading namespace.<br>
<b>Application Domains<br></b>The CLR provides an additional level of isolation within a process, called an <i>appli-<br>cation domain</i>. In Chapter 24, we examine the properties of an application domain<br>with which you can interact, and demonstrate how to create and use additional<br>application domains within the same process for such purposes as unit testing. We<br>
<b>186 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=207></a>also describe how to use Remoting to communicate with these application domains.<br>The AppDomain type is defined in the System namespace.<br>
<b>Native and COM Interoperability<br></b>You can interoperate with both native and COM code. Native interoperability allows<br>you to call functions in unmanaged DLLs, register callbacks, map data structures,<br>and interoperate with native data types. COM interoperability allows you to call<br>COM types and expose .NET types to COM. The types that support these functions<br>are in System.Runtime.InteropServices, and we cover them in Chapter 25.<br>
<b>Applied Technologies<br>User Interface Technologies<br></b>The .NET Framework provides four APIs for user-interface-based applications:<br>
<i>ASP.NET (</i>System.Web.UI<i>)</i><br>
For writing thin client applications that run over a standard web browser<br>
<i>Silverlight</i><br>
For providing a rich user interface inside a web browser<br>
<i>Windows Presentation Foundation (</i>System.Windows<i>)</i><br>
For writing rich client applications<br>
<b>FW Overview</b><br>
<i>Windows Forms (</i>System.Windows.Forms<i>)</i><br>
For maintaining legacy rich client applications<br>
In general, a thin client application amounts to a website; a rich client application<br>is a program the end user must download or install on the client computer.<br>
<b>ASP.NET<br></b>Applications written using ASP.NET host under Windows IIS and can be accessed<br>from almost any web browser. Here are the advantages of ASP.NET over rich client<br>technologies:<br>
· There is zero deployment at the client end.<br>· Clients can run a non-Windows platform.<br>· Updates are easily deployed.<br>
Further, because most of what you write in an ASP.NET application runs on the<br>server, you design your data access layer to run in the same application domain--<br>without limiting security or scalability. In contrast, a rich client that does the same<br>is not generally as secure or scalable. (The solution, with the rich client, is to insert<br>a <i>middle tier</i> between the client and database. The middle tier runs on a remote<br>application server [often alongside the database server] and communicates with the<br>rich clients via WCF, Web Services, or Remoting.)<br>
In  writing  your  web  pages,  you  can  choose  between  the  traditional  Web  Forms<br>and  the  new  MVC  (Model-View-Controller)  API.  Both  build  on  the  ASP.NET<br>
<b>Applied Technologies | 187</b><br>
<hr>
<A name=208></a>infrastructure. Web Forms has been part of the Framework since its inception; MVC<br>was written much later in response to the success of Ruby on Rails and MonoRail.<br>Although  debuting  in  Framework  4.0,  the  MVC  framework  has  benefited  from<br>having matured for some time as a public beta. It provides, in general, a better pro-<br>gramming abstraction than Web Forms; it also allows more control over the gener-<br>ated HTML. What you lose over Web Forms is a designer. This makes Web Forms<br>still a good choice for web pages with predominately static content.<br>
The limitations of ASP.NET are largely a reflection of the limitations of thin client<br>systems in general:<br>
· A web browser interface significantly restricts what you can do.<br>· Maintaining state on the client--or on behalf of the client--is cumbersome.<br>
You can improve the interactivity and responsiveness, however, through client-side<br>scripting or technologies such as AJAX: a good resource for this is <i>http://ajax.asp<br>.net</i>. Use of AJAX is simplified through the use of libraries such as jQuery.<br>
The types for writing ASP.NET applications are in the System.Web.UI namespace<br>and its subnamespaces, and are packed in the <i>System.Web.dll</i> assembly.<br>
<b>Silverlight<br></b>Silverlight  is  not  technically  part  of  the  main  .NET  Framework:  it's  a  separate<br>Framework that includes a subset of the Framework's core features--plus the ability<br>to run as a web browser plug-in. Its graphics model is essentially a subset of WPF<br>and this allows you to leverage existing knowledge in developing Silverlight appli-<br>cations.  Silverlight  is  available  as  a  small  cross-platform  download  for  web<br>browsers--much like Macromedia's Flash.<br>
Flash has a far bigger installation base and so dominates in this area. For this reason,<br>Silverlight tends to be used in fringe scenarios--corporate intranets, for example.<br>
<b>Windows Presentation Foundation (WPF)<br></b>WPF  was  introduced  in  Framework  3.0  for  writing  rich  client  applications.  The<br>benefits of WPF over its predecessor, Windows Forms, are as follows:<br>
· It  supports  sophisticated  graphics,  such  as  arbitrary  transformations,  3D<br>
rendering, and true transparency.<br>
· Its  primary  measurement  unit  is  not  pixel-based,  so  applications  display<br>
correctly at any DPI (dots per inch) setting.<br>
· It  has  extensive  dynamic  layout  support,  which  means  you  can  localize  an<br>
application without danger of elements overlapping.<br>
· Rendering uses DirectX and is fast, taking good advantage of graphics hardware<br>
acceleration.<br>
· User interfaces can be described declaratively in XAML files that can be main-<br>
tained  independently  of  the  "code-behind"  files--this  helps  to  separate  ap-<br>pearance from functionality.<br>
<b>188 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=209></a>WPF's size and complexity, however, make for a steep learning curve.<br>
The types for writing WPF applications are in the System.Windows namespace and<br>all subnamespaces except for System.Windows.Forms.<br>
<b>Windows Forms<br></b>Windows Forms is a rich client API that's as old as the .NET Framework. Compared<br>to WPF, Windows Forms is a relatively simple technology that provides most of the<br>features you need in writing a typical Windows application. It also has significant<br>relevancy in maintaining legacy applications. It has a number of drawbacks, though,<br>compared to WPF:<br>
· Controls are positioned and sized in pixels, making it easy to write applications<br>
that break on clients whose DPI settings differ from the developer's.<br>
· The API for drawing nonstandard controls is GDI+, which, although reasonably<br>
flexible, is slow in rendering large areas (and without double buffering, flickers<br>horribly).<br>
· Controls lack true transparency.<br>· Dynamic layout is difficult to get right reliably.<br>
The last point is an excellent reason to favor WPF over Windows Forms--even if<br>you're writing a business application that needs just a user interface and not a "user<br>experience." The layout elements in WPF, such as Grid, make it easy to assemble<br>labels and text boxes such that they always align--even after language changing<br>
<b>FW Overview</b><br>
localization--without messy logic and without any flickering. Further, you don't<br>have to bow to the lowest common denominator in screen resolution--WPF layout<br>elements have been designed from the outset to adapt properly to resizing.<br>
On the subject of speed, it was originally thought that graphics card manufacturers<br>would incorporate GDI+ hardware accelerators. This never happened; their focus<br>was instead on DirectX. Consequently, GDI+ is considerably slower than even its<br>predecessor, GDI, let alone WPF.<br>
On the positive side, Windows Forms is relatively simple to learn and has a wealth<br>of support in third-party controls.<br>
The  Windows  Forms  types  are  in  the  namespaces  System.Windows.Forms  (in<br><i>System.Windows.Forms.dll</i>) and System.Drawing (in <i>System.Drawing.dll</i>). The latter<br>also contains the GDI+ types for drawing custom controls.<br>
<b>Backend Technologies</b><br>
<b>ADO.NET<br></b>ADO.NET is the managed data access API. Although the name is derived from the<br>1990s-era  ADO  (ActiveX  Data  Objects),  the  technology  is  completely  different.<br>ADO.NET contains two major low-level components:<br>
<b>Applied Technologies | 189</b><br>
<hr>
<A name=210></a><i>Provider layer</i><br>
The provider model defines common classes and interfaces for low-level access<br>to  database  providers.  These  interfaces  comprise  connections,  commands,<br>adapters, and readers (forward-only, read-only cursors over a database). The<br>Framework ships with native support for Microsoft SQL Server and Oracle and<br>has OLE-DB and ODBC providers.<br>
<i>DataSet model</i><br>
A DataSet is a structured cache of data. It resembles a primitive in-memory<br>database, which defines SQL constructs such as tables, rows, columns, rela-<br>tionships, constraints, and views. By programming against a cache of data, you<br>can reduce the number of trips to the server, increasing server scalability and<br>the responsiveness of a rich-client user interface. DataSets are serializable and<br>are designed to be sent across the wire between client and server applications.<br>
Sitting above the provider layer are two APIs that offer the ability to query databases<br>via LINQ:<br>
· LINQ to SQL (introduced in Framework 3.5)<br>· Entity Framework (introduced in Framework 3.5 SP1)<br>
Both technologies include <i>object/relational mappers</i> (ORMs), meaning they auto-<br>matically map objects (based on classes that you define) to rows in the database.<br>This allows you to query those objects via LINQ (instead of writing SQL select<br>statements)--and  update  them  without  manually  writing  SQL  insert/delete/<br>update statements. This cuts the volume of code in an application's data access layer<br>(particularly  the  "plumbing"  code)  and  provides  strong  static  type  safety.  These<br>technologies  also  avoid  the  need  for  DataSets  as  receptacles  of  data--although<br>DataSets still provide the unique ability to store and serialize state changes (some-<br>thing particularly useful in multitier applications). You can use LINQ to SQL or<br>Entity Framework in conjunction with DataSets, although the process is somewhat<br>clumsy and DataSets are inherently ungainly. In other words, there's no straight-<br>forward  out-of-the-box  solution  for  writing  <i>n</i>-tier  applications  with  Microsoft's<br>ORMs as yet.<br>
LINQ to SQL is simpler and faster than Entity Framework, and tends to produce<br>better SQL. Entity Framework is more flexible in that you can create elaborate map-<br>pings between the database and the classes that you query. Entity Framework also<br>has third-party support for databases other than SQL Server.<br>
<b>Windows Workflow<br></b>Windows Workflow is a framework for modeling and managing potentially long-<br>running business processes. Workflow targets a standard runtime library, providing<br>consistency and interoperability. Workflow also helps reduce coding for dynami-<br>cally controlled decision-making trees.<br>
Windows Workflow is not strictly a backend technology--you can use it anywhere<br>(an example is page flow, in the UI).<br>
<b>190 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=211></a>Workflow came originally with .NET Framework 3.0, with its types defined in the<br>System.WorkFlow namespace. Workflow has been substantially revised in Framework<br>4.0; the new types live in and under the System.Activities namespace.<br>
<b>COM+ and MSMQ<br></b>The Framework allows you to interoperate with COM+ for services such as distrib-<br>uted transactions, via types in the System.EnterpriseServices namespace. It also<br>supports MSMQ (Microsoft Message Queuing) for asynchronous, one-way mes-<br>saging through types in System.Messaging.<br>
<b>Distributed System Technologies</b><br>
<b>Windows Communication Foundation (WCF)<br></b>WCF is a sophisticated communications infrastructure introduced in Framework<br>3.0. WCF is flexible and configurable enough to make both of its predecessors--<br>Remoting and (.ASMX) Web Services--<i>mostly</i> redundant.<br>
WCF, Remoting, and Web Services are all alike in that they implement the following<br>basic model in allowing a client and server application to communicate:<br>
· On the server, you indicate what methods you'd like remote client applications<br>
to be able to call.<br>
· On the client, you specify or infer the <i>signatures</i> of the server methods you'd<br>
<b>FW Overview</b><br>
like to call.<br>
· On both the server and the client, you choose a transport and communication<br>
protocol (in WCF, this is done through a <i>binding</i>).<br>
· The client establishes a connection to the server.<br>· The client calls a remote method, which executes transparently on the server.<br>
WCF further decouples the client and server through service contracts and data<br>contracts. Conceptually, the client sends an (XML or binary) message to an endpoint<br>on a remote <i>service</i>, rather than directly invoking a remote <i>method</i>. One of the ben-<br>efits of this decoupling is that clients have no dependency on the .NET platform or<br>on any proprietary communication protocols.<br>
WCF is highly configurable and provides the most extensive support for standar-<br>dized messaging protocols, including WS-*. This lets you communicate with parties<br>running different software--possibly on different platforms--while still supporting<br>advanced  features  such  as  encryption.  Another  benefit  of  WCF  is  that  you  can<br>change protocols without needing to change other aspects of your client or server<br>applications.<br>
The types for communicating with WCF are in, and are below, the System.Service<br>Model namespace.<br>
<b>Applied Technologies | 191</b><br>
<hr>
<A name=212></a><b>Remoting and Web Services<br></b>Remoting and .ASMX Web Services are WCF's predecessors and are almost redun-<br>dant in WCF's wake--although Remoting still has a niche in communicating be-<br>tween application domains within the same process (see Chapter 24).<br>
Remoting's functionality is geared toward tightly coupled applications. A typical<br>example is when the client and server are both .NET applications written by the<br>same company (or companies sharing common assemblies). Communication typi-<br>cally involves exchanging potentially complex custom .NET objects that the Re-<br>moting infrastructure serializes and deserializes without needing intervention.<br>
The functionality of Web Services is geared toward loosely coupled or SOA-style<br>applications. A typical example is a server designed to accept simple SOAP-based<br>messages that originate from clients running a variety of software--on a variety of<br>platforms. Web Services can only use HTTP and SOAP as transport and formatting<br>protocols, and applications are normally hosted under IIS. The benefits of intero-<br>perability  come  at  a  performance  cost--a  Web  Services  application  is  typically<br>slower, in both execution and development time, than a well-designed Remoting<br>application.<br>
The types for Remoting are in or under System.Runtime.Remoting; the types for Web<br>Services are under System.Web.Services.<br>
<b>CardSpace<br></b>CardSpace is a token-based authentication and identity management protocol de-<br>signed to simplify password management for end users. The technology has received<br>little  attention  because  of  the  difficulty  in  porting  tokens  across  machines<br>(<i>OpenID</i> is a popular alternative that avoids this problem).<br>
CardSpace builds on open XML standards, and parties can participate independ-<br>ently of Microsoft. A user can hold multiple identities, which are maintained by a<br>third party (the <i>identity provider</i>). When a user wants to access a resource at site X,<br>the user authenticates to the identity provider, which then issues a token to site X.<br>This avoids having to provide a password directly to site X and reduces the number<br>of identities that the user needs to maintain.<br>
WCF allows you to specify a CardSpace identity when connecting through a secure<br>HTTP channel, through types in the System.IdentityModel.Claims and System.Iden<br>tityModel.Policy namespaces.<br>
<b>192 | Chapter 5:</b><b>Framework Overview</b><br>
<hr>
<A name=213></a><b>6</b><br>
<b>Framework Fundamentals</b><br>
Many of the core facilities that you need when programming are provided not by<br>the C# language, but by types in the .NET Framework. In this chapter, we cover<br>the Framework's role in fundamental programming tasks, such as virtual equality<br>comparison, order comparison, and type conversion. We also cover the basic Frame-<br>work types, such as String, DateTime, and Enum.<br>The  types  in  this  section  reside  in  the  System  namespace,  with  the  following<br>exceptions:<br>
· StringBuilder is defined in System.Text, as are the types for <i>text encodings</i>.<br>· CultureInfo and associated types are defined in System.Globalization.<br>· XmlConvert is defined in System.Xml.<br>
<b>String and Text Handling<br>Char<br></b>A C# char represents a single Unicode character and aliases the System.Char struct.<br>In Chapter 2, we described how to express char literals. For example:<br>
char c = 'A';<br>char newLine = '\n';<br>
System.Char  defines  a  range  of  static  methods  for  working  with  characters,  such<br>as  ToUpper,  ToLower,  and  IsWhiteSpace.  You  can  call  these  through  either  the<br>System.Char type or its char alias:<br>
Console.WriteLine (System.Char.ToUpper ('c'));    // C<br>Console.WriteLine (char.IsWhiteSpace ('\t'));     // True<br>
ToUpper and ToLower honor the end user's locale, which can lead to subtle bugs. The<br>following expression evaluates to false in Turkey:<br>
char.ToUpper ('i') == 'I'<br>
<b>193</b><br>
<hr>
<A name=214></a>because in Turkey, char.ToUpper ('i') is '' (notice the dot on top!). To avoid this<br>problem, System.Char (and System.String) also provides culture-invariant versions<br>of ToUpper and ToLower ending with the word <i>Invariant</i>. These always apply English<br>culture rules:<br>
Console.WriteLine (char.ToUpperInvariant ('i'));    // I<br>
This is a shortcut for:<br>
Console.WriteLine (char.ToUpper ('i', CultureInfo.InvariantCulture))<br>
For more on locales and culture, see "Formatting and parsing" on page 212.<br>
Most of char's remaining static methods are related to categorizing characters and<br>are listed in Table 6-1.<br>
<i>Table 6-1. Static methods for categorizing characters</i><br>
<b>Static method</b><br>
<b>Characters included</b><br>
<b>Unicode categories included</b><br>
IsLetter<br>
A­Z, a­z, and letters of other alphabets<br>
UpperCaseLetter<br>
LowerCaseLetter<br>
TitleCaseLetter<br>
ModifierLetter<br>
OtherLetter<br>
IsUpper<br>
Uppercase letters<br>
UpperCaseLetter<br>
IsLower<br>
Lowercase letters<br>
LowerCaseLetter<br>
IsDigit<br>
0­9 plus digits of other alphabets<br>
DecimalDigitNumber<br>
IsLetterOrDigit<br>
Letters plus digits<br>
Sum of IsLetter and IsDigit<br>
IsNumber<br>
All digits plus Unicode fractions and Roman numeral<br>
DecimalDigitNumber<br>
symbols<br>
LetterNumber<br>
OtherNumber<br>
IsSeparator<br>
Space plus all Unicode separator characters<br>
LineSeparator<br>
ParagraphSeparator<br>
IsWhiteSpace<br>
All separators plus \n, \r, \t, \f, and \v<br>
LineSeparator<br>
ParagraphSeparator<br>
IsPunctuation<br>
Symbols used for punctuation in Western and other<br>
DashPunctuation<br>
alphabets<br>
ConnectorPunctuation<br>
InitialQuotePunctuation<br>
FinalQuotePunctuation<br>
IsSymbol<br>
Most other printable symbols<br>
MathSymbol<br>
ModifierSymbol<br>
OtherSymbol<br>
<b>194 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=215></a><b>Static method</b><br>
<b>Characters included</b><br>
<b>Unicode categories included</b><br>
IsControl<br>
Nonprintable "control" characters below 0x20, such as<br>
(None)<br>
\r, \n, \t, \0, and characters between 0x7F and 0x9A<br>
For more granular categorization, char provides a static method called GetUnicode<br>Category; this returns a UnicodeCategory enumeration whose members are shown in<br>the rightmost column of Table 6-1.<br>
By explicitly casting from an integer, it's possible to produce a<br>char  outside  the  allocated  Unicode  set.  To  test  a  character's<br>validity, call char.GetUnicodeCategory: if the result is UnicodeCa<br>tegory.OtherNotAssigned, the character is invalid.<br>
A char is 16 bits wide--enough to represent any Unicode character in the <i>Basic<br>Multilingual Plane</i>. To go outside this, you must use surrogate pairs: we describe the<br>methods for doing this in "Text Encodings and Unicode" on page 203.<br>
<b>String<br></b>A C# string (== System.String) is an immutable (unchangeable) sequence of char-<br>acters. In Chapter 2, we described how to express string literals, perform equality<br>comparisons, and concatenate two strings. This section covers the remaining func-<br>tions for working with strings, exposed through the static and instance members of<br>the System.String class.<br>
<b>Constructing strings<br></b>The simplest way to construct a string is to assign a literal, as we saw in Chapter 2:<br>
<b>FW Fundamentals</b><br>
string s1 = &quot;Hello&quot;;<br>string s2 = &quot;First Line\r\nSecond Line&quot;;<br>string s3 = @&quot;\\server\fileshare\helloworld.cs&quot;;<br>
To create a repeating sequence of characters you can use string's constructor:<br>
Console.Write (new string ('*', 10));      // **********<br>
You can also construct a string from a char array. The ToCharArray method does the<br>reverse:<br>
char[] ca = &quot;Hello&quot;.ToCharArray();<br>string s = new string (ca);              // s = &quot;Hello&quot;<br>
string's constructor is also overloaded to accept various (unsafe) pointer types, in<br>order to create strings from types such as char*.<br>
<b>Null and empty strings<br></b>An empty string has a length of zero. To create an empty string, you can use either<br>a literal or the static string.Empty field; to test for an empty string, you can either<br>perform an equality comparison or test its Length property:<br>
<b>String and Text Handling | 195</b><br>
<hr>
<A name=216></a>string empty = &quot;&quot;;<br>
Console.WriteLine (empty == &quot;&quot;);              // True<br>Console.WriteLine (empty == string.Empty);    // True<br>Console.WriteLine (empty.Length == 0);        // True<br>
Because strings are reference types, they can also be null:<br>
string nullString = null;<br>
Console.WriteLine (nullString == null);        // True<br>
Console.WriteLine (nullString == &quot;&quot;);          // False<br>Console.WriteLine (nullString.Length == 0);    // NullReferenceException<br>
The static string.IsNullOrEmpty method is a useful shortcut for testing whether a<br>given string is either null or empty.<br>
<b>Accessing characters within a string<br></b>A string's indexer returns a single character at the given index. As with all functions<br>that operate on strings, this is zero-indexed:<br>
string str  = &quot;abcde&quot;;<br>char letter = str[1];        // letter == 'b'<br>
string also implements IEnumerable&lt;char&gt;, so you can foreach over its characters:<br>
foreach (char c in &quot;123&quot;) Console.Write (c + &quot;,&quot;);    // 1,2,3,<br>
<b>Searching within strings<br></b>The simplest methods for searching within strings are Contains, StartsWith, and<br>EndsWith. These all return true or false:<br>
Console.WriteLine (&quot;quick brown fox&quot;.Contains (&quot;brown&quot;));    // True<br>
Console.WriteLine (&quot;quick brown fox&quot;.EndsWith (&quot;fox&quot;));      // True<br>
IndexOf is more powerful: it returns the first position of a given character or substring<br>(or -1 if the substring isn't found):<br>
Console.WriteLine (&quot;abcde&quot;.IndexOf (&quot;cd&quot;));   // 2<br>
IndexOf  is  overloaded  to  accept  a  startPosition  (an  index  from  which  to  begin<br>searching) and a StringComparison enum. The latter allows you to perform case-<br>insensitive searches:<br>
Console.WriteLine (&quot;abcde&quot;.IndexOf (&quot;CD&quot;,<br>                   StringComparison.CurrentCultureIgnoreCase));    // 2<br>
LastIndexOf is like IndexOf, but works backward through the string.<br>
IndexOfAny returns the first matching position of any one of a set of characters:<br>
Console.Write (&quot;ab,cd ef&quot;.IndexOfAny (new char[] {' ', ','} ));       // 2<br>Console.Write (&quot;pas5w0rd&quot;.IndexOfAny (&quot;0123456789&quot;.ToCharArray() ));  // 3<br>
LastIndexOfAny does the same in the reverse direction.<br>
<b>196 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=217></a><b>Manipulating strings<br></b>Because String is immutable, all the methods that "manipulate" a string return a<br>new one, leaving the original untouched (the same goes for when you reassign a<br>string variable).<br>
Substring extracts a portion of a string:<br>
string left3 = &quot;12345&quot;.Substring (0, 3);     // left3 = &quot;123&quot;;<br>
string mid3  = &quot;12345&quot;.Substring (1, 3);     // mid3 = &quot;234&quot;;<br>
If you omit the length, you get the remainder of the string:<br>
string end3  = &quot;12345&quot;.Substring (2);        // end3 = &quot;345&quot;;<br>
Insert and Remove insert or remove characters at a specified position:<br>
string s1 = &quot;helloworld&quot;.Insert (5, &quot;, &quot;);    // s1 = &quot;hello, world&quot;<br>
string s2 = s1.Remove (5, 2);                 // s2 = &quot;helloworld&quot;;<br>
PadLeft and PadRight pad a string to a given length with a specified character (or a<br>space if unspecified):<br>
Console.WriteLine (&quot;12345&quot;.PadLeft (9, '*'));  // ****12345<br>
Console.WriteLine (&quot;12345&quot;.PadLeft (9));       //     12345<br>
If the input string is longer than the padding length, the original string is returned<br>unchanged.<br>
TrimStart and TrimEnd remove specified characters from the beginning or end of a<br>string; Trim does both. By default, these functions remove whitespace characters<br>(including spaces, tabs, new lines, and Unicode variations of these):<br>
Console.WriteLine (&quot;  abc \t\r\n &quot;.Trim().Length);   // 3<br>
Replace replaces all occurrences of a particular character or substring:<br>
<b>FW Fundamentals</b><br>
Console.WriteLine (&quot;to be done&quot;.Replace (&quot; &quot;, &quot; | &quot;) );  // to | be | done<br>Console.WriteLine (&quot;to be done&quot;.Replace (&quot; &quot;, &quot;&quot;)    );  // tobedone<br>
ToUpper and ToLower return upper- and lowercase versions of the input string. By<br>default,  they  honor  the  user's  current  language  settings;  ToUpperInvariant  and<br>ToLowerInvariant always apply English alphabet rules.<br>
<b>Splitting and joining strings<br></b>Split takes a sentence and returns an array of words:<br>
string[] words = &quot;The quick brown fox&quot;.Split();<br>
foreach (string word in words)<br>  Console.Write (word + &quot;|&quot;);    // The|quick|brown|fox|<br>
By default, Split uses whitespace characters as delimiters; it's also overloaded to<br>accept a params array of char or string delimiters. Split also optionally accepts a<br>StringSplitOptions  enum,  which  has  an  option  to  remove  empty  entries:  this  is<br>useful when words are separated by several delimiters in a row.<br>
<b>String and Text Handling | 197</b><br>
<hr>
<A name=218></a>The static Join method does the reverse of Split. It requires a delimiter and string<br>array:<br>
string[] words = &quot;The quick brown fox&quot;.Split();<br>string together = string.Join (&quot; &quot;, words);      // The quick brown fox<br>
The static Concat method is similar to Join but accepts only a params string array and<br>applies no separator. Concat is exactly equivalent to the + operator (the compiler, in<br>fact, translates + to Concat):<br>
string sentence     = string.Concat (&quot;The&quot;, &quot; quick&quot;, &quot; brown&quot;, &quot; fox&quot;);<br>string sameSentence = &quot;The&quot; + &quot; quick&quot; + &quot; brown&quot; + &quot; fox&quot;;<br>
<b>String.Format and composite format strings<br></b>The static Format method provides a convenient way to build strings that embed<br>variables.  The  embedded  variables  can  be  of  any  type;  the  Format  simply  calls<br>ToString on them.<br>
The master string that includes the embedded variables is called a <i>composite format<br>string</i>. When calling String.Format, you provide a composite format string followed<br>by each of the embedded variables. For example:<br>
string composite = &quot;It's {0} degrees in {1} on this {2} morning&quot;;<br>string s = string.Format (composite, 35, &quot;Perth&quot;, DateTime.Now.DayOfWeek);<br>
// s == &quot;It's 35 degrees in Perth on this Friday morning&quot;<br>
(And that's Celsius!)<br>
Each number in curly braces is called a <i>format item</i>. The number corresponds to the<br>argument position and is optionally followed by:<br>
· A comma and a <i>minimum width</i> to apply<br>· A colon and a <i>format string</i><br>
The minimum width is useful for aligning columns. If the value is negative, the data<br>is left-aligned; otherwise, it's right-aligned. For example:<br>
string composite = &quot;Name=<b>{0,-20}</b> Credit Limit=<b>{1,15:C}</b>&quot;;<br>
Console.WriteLine (string.Format (composite, &quot;Mary&quot;, 500));<br>Console.WriteLine (string.Format (composite, &quot;Elizabeth&quot;, 20000));<br>
Here's the result:<br>
Name=Mary                 Credit Limit=        $500.00<br>Name=Elizabeth            Credit Limit=     $20,000.00<br>
The equivalent without using string.Format is this:<br>
string s = &quot;Name=&quot; + &quot;Mary&quot;.PadRight (20) +<br>           &quot; Credit Limit=&quot; + 500.ToString (&quot;C&quot;).PadLeft (15);<br>
The credit limit is formatted as currency by virtue of the &quot;C&quot; format string. We de-<br>scribe format strings in detail in "Formatting and parsing" on page 212.<br>
<b>198 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=219></a>A disadvantage of composite format strings is that it's easier to<br>make  a  mistake  that  goes  unnoticed  until  runtime--such  as<br>having greater or fewer format items than values. Such a mistake<br>is harder to make when the format items and values are together.<br>
<b>Comparing Strings<br></b>In comparing two values, the .NET Framework differentiates the concepts of <i>equal-<br>ity comparison</i> and <i>order comparison</i>. Equality comparison tests whether two in-<br>stances  are  semantically  the  same;  order  comparison  tests  which  of  two  (if  any)<br>instances comes first when arranging them in ascending or descending sequence.<br>
Equality comparison is not a <i>subset</i> of order comparison; the<br>two systems have different purposes. It's legal, for instance, to<br>have two unequal values in the same ordering position. We re-<br>sume this topic in "Equality Comparison" on page 245.<br>
For  string  equality  comparison,  you  can  use  the  ==  operator  or  one  of  string's<br>Equals  methods.  The  latter  are  more  versatile  because  they  allow  you  to  specify<br>options such as case-insensitivity.<br>
Another difference is that == does not work reliably on strings<br>if the variables are cast to the object type. We explain why this<br>is so in "Equality Comparison" on page 245.<br>
For string order comparison, you can use either the CompareTo instance method or<br>the static <br>
<b>FW Fundamentals</b><br>
Compare and CompareOrdinal methods: these return a positive or negative<br>
number--or  zero--depending  on  whether  the  first  value  comes  before,  after,  or<br>alongside the second.<br>
Before going into the details of each, we need to examine .NET's underlying string<br>comparison algorithms.<br>
<b>Ordinal versus culture comparison<br></b>There are two basic algorithms for string comparison: <i>ordinal</i> and <i>culture-sensitive</i>.<br>Ordinal  comparisons  interpret  characters  simply  as  numbers  (according  to  their<br>numeric  Unicode  value);  culture-sensitive  comparisons  interpret  characters  with<br>reference to a particular alphabet. There are two special cultures: the "current cul-<br>ture," which is based on settings picked up from the computer's control panel, and<br>the "invariant culture," which is the same on every computer (and closely maps<br>American culture).<br>
For equality comparison, both ordinal and culture-specific algorithms are useful.<br>For ordering, however, culture-specific comparison is nearly always preferable: to<br>order strings alphabetically, you need an alphabet. Ordinal relies on the numeric<br>Unicode  point  values,  which  happen  to  put  English  characters  in  alphabetical<br>
<b>String and Text Handling | 199</b><br>
<hr>
<A name=220></a>order--but even then not exactly as you might expect. For example, assuming case-<br>sensitivity, consider the strings "Atom", "atom", and "Zamia". The invariant culture<br>puts them in the following order:<br>
&quot;Atom&quot;, &quot;atom&quot;, &quot;Zamia&quot;<br>
Ordinal arranges them instead as follows:<br>
&quot;Atom&quot;, &quot;Zamia&quot;, &quot;atom&quot;<br>
This is because the invariant culture encapsulates an alphabet, which considers up-<br>percase characters adjacent to their lowercase counterparts (AaBbCcDd...). The or-<br>dinal  algorithm,  however,  puts  all  the  uppercase  characters  first,  and  then  all<br>lowercase characters (A..Z, a..z). This is essentially a throwback to the ASCII char-<br>acter set invented in the 1960s.<br>
<b>String equality comparison<br></b>Despite  ordinal's  limitations,  string's  ==  operator  always  performs  <i>ordinal  case-<br>sensitive</i> comparison. The same goes for the instance version of string.Equals when<br>called without arguments; this defines the "default" equality comparison behavior<br>for the string type.<br>
The ordinal algorithm was chosen for string's == and Equals<br>functions  because  it's  both  highly  efficient  and  <i>deterministic</i>.<br>String  equality  comparison  is  considered  fundamental  and  is<br>performed far more frequently than order comparison.<br>
A "strict" notion of equality is also consistent with the general<br>use of the == operator.<br>
The following methods allow culture-aware or case-insensitive comparisons:<br>
public bool Equals(string value, StringComparison comparisonType);<br>
public static bool Equals (string a, string b,<br>                           StringComparison comparisonType);<br>
The static version is advantageous in that it still works if one or both of the strings<br>are null. StringComparison is an enum defined as follows:<br>
public enum StringComparison<br>{<br>  CurrentCulture,               // Case-sensitive<br>  CurrentCultureIgnoreCase,<br>  InvariantCulture,             // Case-sensitive<br>  InvariantCultureIgnoreCase,<br>  Ordinal,                      // Case-sensitive<br>  OrdinalIgnoreCase<br>}<br>
<b>200 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=221></a>For example:<br>
Console.WriteLine (string.Equals (&quot;foo&quot;, &quot;FOO&quot;,<br>
                   StringComparison.OrdinalIgnoreCase));   // True<br>
Console.WriteLine (&quot;&quot; == &quot;&quot;);                            // False<br>
Console.WriteLine (string.Equals (&quot;&quot;, &quot;&quot;,<br>
                   StringComparison.CurrentCulture));      // <i>?</i><br>
(The result of the final comparison is determined by the computer's current language<br>settings.)<br>
<b>String order comparison<br></b>String's CompareTo instance method performs <i>culture-sensitive</i>, <i>case-sensitive</i> order<br>comparison. Unlike the == operator, CompareTo does not use ordinal comparison: for<br>ordering, a culture-sensitive algorithm is much more useful.<br>
Here's the method's definition:<br>
public int CompareTo (string strB);<br>
The  CompareTo  instance  method  implements  the  generic<br>IComparable  interface,  a  standard  comparison  protocol  used<br>across  the  .NET  Framework.  This  means  string's  CompareTo<br>defines the default ordering behavior strings, in such applica-<br>tions as sorted collections, for instance. For more information<br>on IComparable, see "Order Comparison" on page 255.<br>
For other kinds of comparison, you can call the static Compare and CompareOrdinal<br>methods:<br>
<b>FW Fundamentals</b><br>
public static int Compare (string strA, string strB,<br>                           StringComparison comparisonType);<br>
public static int Compare (string strA, string strB, bool ignoreCase,<br>                           CultureInfo culture);<br>
public static int Compare (string strA, string strB, bool ignoreCase);<br>
public static int CompareOrdinal (string strA, string strB);<br>
The last two methods are simply shortcuts for calling the first two methods.<br>
All of the order comparison methods return a positive number, a negative number,<br>or zero, depending on whether the first value comes after, before, or alongside the<br>second value:<br>
Console.WriteLine (&quot;Boston&quot;.CompareTo (&quot;Austin&quot;));    // 1<br>Console.WriteLine (&quot;Boston&quot;.CompareTo (&quot;Boston&quot;));    // 0<br>Console.WriteLine (&quot;Boston&quot;.CompareTo (&quot;Chicago&quot;));   // -1<br>Console.WriteLine (&quot;&quot;.CompareTo (&quot;&quot;));              // 0<br>Console.WriteLine (&quot;foo&quot;.CompareTo (&quot;FOO&quot;));          // -1<br>
<b>String and Text Handling | 201</b><br>
<hr>
<A name=222></a>The following performs a case-insensitive comparison using the current culture:<br>
Console.WriteLine (string.Compare (&quot;foo&quot;, &quot;FOO&quot;, true));   // 0<br>
By supplying a CultureInfo object, you can plug in any alphabet:<br>
// CultureInfo is defined in the System.Globalization namespace<br>
CultureInfo german = CultureInfo.GetCultureInfo (&quot;de-DE&quot;);<br>int i = string.Compare (&quot;Müller&quot;, &quot;Muller&quot;, false, german);<br>
<b>StringBuilder<br></b>The StringBuilder class (System.Text namespace) represents a mutable (editable)<br>string. With a StringBuilder, you can Append, Insert, Remove, and Replace substrings<br>without replacing the whole StringBuilder.<br>
StringBuilder's constructor optionally accepts an initial string value, as well as a<br>starting size for its internal capacity (default is 16 characters). If you go above this,<br>StringBuilder  automatically  resizes  its  internal  structures  to  accommodate  (at  a<br>slight performance cost) up to its maximum capacity (default is int.MaxValue).<br>A popular use of StringBuilder is to build up a long string by repeatedly calling <br>Append. This approach is much more efficient than repeatedly concatenating ordi-<br>nary string types:<br>
StringBuilder sb = new StringBuilder();<br>
for (int i = 0; i &lt; 50; i++) <b>sb.Append</b> (i + &quot;,&quot;);<br>
To get the final result, call ToString():<br>
Console.WriteLine (sb.ToString());<br>
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,<br>27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,<br>
In our example, the expression i + &quot;,&quot; means that we're still<br>repeatedly concatenating strings. However, this incurs only a<br>small performance cost in that the strings in question are small<br>and don't grow with each loop iteration. For maximum per-<br>formance, however, we could change the loop body to this:<br>
{ sb.Append (i.ToString()); sb.Append (&quot;,&quot;); }<br>
AppendLine performs an Append that adds a new line sequence (&quot;\r\n&quot; in Windows).<br>AppendFormat accepts a composite format string, just like String.Format.<br>
As  well  as  the  Insert,  Remove,  and  Replace  methods  (Replace  functions  such  as<br>string's Replace), StringBuilder defines a Length property and a writable indexer for<br>getting/setting individual characters.<br>
To  clear  the  contents  of  a  StringBuilder,  either  instantiate  a  new  one  or  set  its<br>Length to zero.<br>
<b>202 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=223></a>Setting a StringBuilder's Length to zero doesn't shrink its <i>in-<br>ternal</i> capacity. So, if the StringBuilder previously contained 1<br>million characters, it will continue to occupy around 2 MB of<br>memory after zeroing its Length. If you want to release the mem-<br>ory, you must create a new StringBuilder and allow the old one<br>to drop out of scope (and be garbage-collected).<br>
<b>Text Encodings and Unicode<br></b>A  <i>character  set</i>  is  an  allocation  of  characters,  each  with  a  numeric  code  or  <i>code<br>point</i>. There are two character sets in common use: Unicode and ASCII. Unicode<br>has an address space of approximately 1 million characters, of which about 100,000<br>are currently allocated. Unicode covers most spoken world languages, as well as<br>some historical languages and special symbols. The ASCII set is simply the first 127<br>characters of the Unicode set, which covers most of what you see on a U.S.-style<br>keyboard. ASCII predates Unicode by 30 years and is still sometimes used for its<br>simplicity and efficiency: each character is represented by one byte.<br>
The .NET type system is designed to work with the Unicode character set. ASCII is<br>implicitly supported, though, by virtue of being a subset of Unicode.<br>
A <i>text encoding</i> maps characters from their numeric code point to a binary repre-<br>sentation. In .NET, text encodings come into play primarily when dealing with text<br>files or streams. When you read a text file into a string, a <i>text encoder</i> translates the<br>file  data  from  binary  into  the  internal  Unicode  representation  that  the  char  and<br>string types expect. A text encoding can restrict what characters can be represented,<br>as well as impacting storage efficiency.<br>
There are two categories of text encoding in .NET:<br>
· Those that map Unicode characters to another character set<br>
<b>FW Fundamentals</b><br>
· Those that use standard Unicode encoding schemes<br>
The first category contains legacy encodings such as IBM's EBCDIC and 8-bit char-<br>acter sets with extended characters in the upper-128 region that were popular prior<br>to Unicode (identified by a code page). The ASCII encoding is also in this category:<br>it encodes the first 128 characters and drops everything else. This category contains<br>the <i>nonlegacy</i> GB18030 as well, which is the mandatory standard for applications<br>written in China--or sold to China--since 2000.<br>
In the second category are UTF-8, UTF-16, and UTF-32 (and the obsolete UTF-7).<br>Each differs in space efficiency. UTF-8 is the most space-efficient for most kinds of<br>text: it uses <i>between one and four bytes</i> to represent each character. The first 128<br>characters require only a single byte, making it compatible with ASCII. UTF-8 is the<br>most popular encoding for text files and streams (particularly on the Internet), and<br>it is the default for stream I/O in .NET (in fact, it's the default for almost everything<br>that implicitly uses an encoding).<br>
UTF-16 uses one or two 16-bit words to represent each character, and is what .NET<br>uses internally to represent characters and strings. Some programs also write files in<br>UTF-16.<br>
<b>String and Text Handling | 203</b><br>
<hr>
<A name=224></a>UTF-32 is the least space-efficient: it maps each code point directly to 32 bits, so<br>every character consumes four bytes. UTF-32 is rarely used for this reason. It does,<br>however,  make  random  access  very  easy  because  every  character  takes  an  equal<br>number of bytes.<br>
<b>Obtaining an Encoding object<br></b>The Encoding class in System.Text is the common base type for classes that encap-<br>sulate text encodings. There are several subclasses--their purpose is to encapsulate<br>families of encodings with similar features. The easiest way to instantiate a correctly<br>configured class is to call Encoding.GetEncoding with a standard IANA name:<br>
Encoding utf8 = Encoding.GetEncoding (&quot;utf-8&quot;);<br>Encoding chinese = Encoding.GetEncoding (&quot;GB18030&quot;);<br>
The most common encodings can also be obtained through dedicated static prop-<br>erties on Encoding:<br>
<b>Encoding name</b><br>
<b>Static property on Encoding</b><br>
UTF-8<br>
Encoding.UTF8<br>
UTF-16<br>
Encoding.Unicode (not UTF16)<br>
UTF-32<br>
Encoding.UTF32<br>
ASCII<br>
Encoding.ASCII<br>
The static GetEncodings method returns a list of all supported encodings, with their<br>standard IANA names:<br>
foreach (EncodingInfo info in Encoding.GetEncodings())<br>  Console.WriteLine (info.Name);<br>
The other way to obtain an encoding is to directly instantiate an encoding class.<br>Doing so allows you to set various options via constructor arguments, including:<br>
· Whether to throw an exception if an invalid byte sequence is encountered when<br>
decoding. The default is false.<br>
· Whether to encode/decode UTF-16/UTF-32 with the most significant bytes<br>
first (<i>big endian</i>) or the least significant bytes first (<i>little endian</i>). The default is <br><i>little endian</i>, the standard on the Windows operating system.<br>
· Whether to emit a byte-order mark (a prefix that indicates <i>endianness</i>).<br>
<b>Encoding for file and stream I/O<br></b>The most common application for an Encoding object is to control how text is read<br>and written to a file or stream. For example, the following writes "Testing..." to a<br>file called <i>data.txt</i> in UTF-16 encoding:<br>
System.IO.File.WriteAllText (&quot;data.txt&quot;, &quot;Testing...&quot;, Encoding.Unicode);<br>
If you omit the final argument, WriteAllText applies the ubiquitous UTF-8 encoding.<br>
<b>204 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=225></a>UTF-8 is the default text encoding for all file and stream I/O.<br>
We resume this subject in Chapter 14, in "Stream Adapters" on page 552.<br>
<b>Encoding to byte arrays<br></b>You can also use an Encoding object to go to and from a byte array. The GetBytes<br>method converts from string to byte[] with the given encoding; GetString converts<br>from byte[] to string:<br>
byte[] utf8Bytes  = System.Text.Encoding.UTF8.GetBytes    (&quot;0123456789&quot;);<br>
byte[] utf16Bytes = System.Text.Encoding.Unicode.GetBytes (&quot;0123456789&quot;);<br>byte[] utf32Bytes = System.Text.Encoding.UTF32.GetBytes   (&quot;0123456789&quot;);<br>
Console.WriteLine (utf8Bytes.Length);    // 10<br>
Console.WriteLine (utf16Bytes.Length);   // 20<br>Console.WriteLine (utf32Bytes.Length);   // 40<br>
string original1 = System.Text.Encoding.UTF8.GetString    (utf8Bytes);<br>
string original2 = System.Text.Encoding.Unicode.GetString (utf16Bytes);<br>
string original3 = System.Text.Encoding.UTF32.GetString   (utf32Bytes);<br>
Console.WriteLine (original1);          // 0123456789<br>
Console.WriteLine (original2);          // 0123456789<br>Console.WriteLine (original3);          // 0123456789<br>
<b>UTF-16 and surrogate pairs<br></b>Recall  that  .NET  stores  characters  and  strings  in  UTF-16.  Because  UTF-16<br>
<b>FW Fundamentals</b><br>
requires one or two 16-bit words per character, and a char is only 16 bits in length,<br>some  Unicode  characters  require  two  chars  to  represent.  This  has  a  couple  of<br>consequences:<br>
· A string's Length property may be greater than its real character count.<br>· A single char is not always enough to fully represent a Unicode character.<br>
Most applications ignore this, because nearly all commonly used characters fit into<br>a section of Unicode called the <i>Basic Multilingual Plane</i> (BMP), which requires only<br>one 16-bit word in UTF-16. The BMP covers several dozen world languages and<br>includes more than 30,000 Chinese characters. Excluded are characters of some<br>ancient languages, symbols for musical notation, and some less common Chinese<br>characters.<br>
If you need to support two-word characters, the following static methods in char<br>convert a 32-bit code point to a string of two chars, and back again:<br>
string ConvertFromUtf32 (int utf32)<br>int    ConvertToUtf32   (char highSurrogate, char lowSurrogate)<br>
<b>String and Text Handling | 205</b><br>
<hr>
<A name=226></a>Two-word characters are called <i>surrogates</i>. They are easy to spot because each word<br>is in the range 0xD800 to 0xDFFF. You can use the following static methods in<br>char to assist:<br>
bool IsSurrogate     (char c)<br>
bool IsHighSurrogate (char c)<br>bool IsLowSurrogate  (char c)<br>
bool IsSurrogatePair (char highSurrogate, char lowSurrogate)<br>
The StringInfo class in the System.Globalization namespace also provides a range<br>of methods and properties for working with two-word characters.<br>
Characters outside the BMP typically require special fonts and have limited operat-<br>ing system support.<br>
<b>Dates and Times<br></b>Three immutable structs in the System namespace do the job of representing dates<br>and times: DateTime, DateTimeOffset, and TimeSpan. C# doesn't define any special<br>keywords that map to these types.<br>
<b>TimeSpan<br></b>A TimeSpan represents an interval of time--or a time of the day. In the latter role, it's<br>simply the "clock" time (without the date), which is equivalent to the time since<br>midnight, assuming no daylight saving transition. A TimeSpan has a resolution of 100<br>ns, has a maximum value of about 10 million days, and can be positive or negative.<br>
There are three ways to construct a TimeSpan:<br>
· Through one of the constructors<br>· By calling one of the static From... methods<br>· By subtracting one DateTime from another<br>
Here are the constructors:<br>
public TimeSpan (int hours, int minutes, int seconds);<br>public TimeSpan (int days, int hours, int minutes, int seconds);<br>public TimeSpan (int days, int hours, int minutes, int seconds,<br>                                                   int milliseconds);<br>public TimeSpan (long ticks);   // Each tick = 100ns<br>
The static From... methods are more convenient when you want to specify an interval<br>in just a single unit, such as minutes, hours, and so on:<br>
public static TimeSpan FromDays (double value);<br>public static TimeSpan FromHours (double value);<br>public static TimeSpan FromMinutes (double value);<br>public static TimeSpan FromSeconds (double value);<br>public static TimeSpan FromMilliseconds (double value);<br>
<b>206 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=227></a>For example:<br>
Console.WriteLine (new TimeSpan (2, 30, 0));     // 02:30:00<br>
Console.WriteLine (TimeSpan.FromHours (2.5));    // 02:30:00<br>
Console.WriteLine (TimeSpan.FromHours (-2.5));   // -02:30:00<br>
TimeSpan  overloads  the  &lt;  and  &gt;  operators,  as  well  as  the  +  and  -  operators.  The<br>following expression evaluates to a TimeSpan of 2.5 hours:<br>
TimeSpan.FromHours(2) + TimeSpan.FromMinutes(30);<br>
The next expression evaluates to one second short of 10 days:<br>
TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);   // 9.23:59:59<br>
Using this expression, we can illustrate the integer properties Days, Hours, Minutes,<br>Seconds, and Milliseconds:<br>
TimeSpan nearlyTenDays = TimeSpan.FromDays(10) - TimeSpan.FromSeconds(1);<br>
Console.WriteLine (nearlyTenDays.Days);          // 9<br>
Console.WriteLine (nearlyTenDays.Hours);         // 23<br>Console.WriteLine (nearlyTenDays.Minutes);       // 59<br>Console.WriteLine (nearlyTenDays.Seconds);       // 59<br>
Console.WriteLine (nearlyTenDays.Milliseconds);  // 0<br>
In contrast, the Total... properties return values of type double describing the entire<br>time span:<br>
Console.WriteLine (nearlyTenDays.TotalDays);          // 9.99998842592593<br>
Console.WriteLine (nearlyTenDays.TotalHours);         // 239.999722222222<br>Console.WriteLine (nearlyTenDays.TotalMinutes);       // 14399.9833333333<br>Console.WriteLine (nearlyTenDays.TotalSeconds);       // 863999<br>Console.WriteLine (nearlyTenDays.TotalMilliseconds);  // 863999000<br>
The  static  Parse  method  does  the  opposite  of  ToString,  converting  a  string  to  a<br>
<b>FW Fundamentals</b><br>
TimeSpan. TryParse does the same, but returns false rather than throwing an excep-<br>tion if the conversion fails. The XmlConvert class also provides TimeSpan/string con-<br>version methods that follow standard XML formatting protocols.<br>
The default value for a TimeSpan is TimeSpan.Zero.<br>
TimeSpan can also be used to represent the time of the day (the elapsed time since<br>midnight). To obtain the current time of day, call DateTime.Now.TimeOfDay.<br>
<b>DateTime and DateTimeOffset<br></b>DateTime and DateTimeOffset are immutable structs for representing a date, and op-<br>tionally, a time. They have a resolution of 100 ns, and a range covering the years<br>0001 through 9999.<br>
DateTimeOffset  was  added  in  Framework  3.5  and  is  functionally  similar  to<br>DateTime. Its distinguishing feature is that it also stores a UTC offset; this allows<br>more meaningful results when comparing values across different time zones.<br>
<b>Dates and Times | 207</b><br>
<hr>
<A name=228></a>An excellent article on the rationale behind the introduction of<br>DateTimeOffset is available on the MSDN BCL blogs. The title<br>is "A Brief History of DateTime," by Anthony Moore.<br>
<b>Choosing between DateTime and DateTimeOffset<br></b>DateTime and DateTimeOffset differ in how they handle time zones. A DateTime in-<br>corporates a three-state flag indicating whether the DateTime is relative to:<br>
· The local time on the current computer<br>· UTC (the modern equivalent of Greenwich Mean Time)<br>· Unspecified<br>
A DateTimeOffset is more specific--it stores the offset from UTC as a TimeSpan:<br>
July 01 2007 03:00:00 <b>-06:00</b><br>
This influences equality comparisons, which is the main factor in choosing between<br>DateTime and DateTimeOffset. Specifically:<br>
· DateTime ignores the three-state flag in comparisons and considers two values<br>
equal if they have the same year, month, day, hour, minute, and so on.<br>
· DateTimeOffset considers two values equal if they refer to the <i>same point in time</i>.<br>
Daylight saving time can make this distinction important even<br>if your application doesn't need to handle multiple geographic<br>time zones.<br>
So, DateTime considers the following two values different, whereas DateTimeOffset<br>considers them equal:<br>
July 01 2007 09:00:00 +00:00 (GMT)<br>July 01 2007 03:00:00 -06:00 (local time, Central America)<br>
In most cases, DateTimeOffset's equality logic is preferable. For example, in calcu-<br>lating which of two international events is more recent, a DateTimeOffset implicitly<br>gives the right answer. Similarly, a hacker plotting a distributed denial of service<br>attack would reach for a DateTimeOffset! To do the same with DateTime requires<br>standardizing on a single time zone (typically UTC) throughout your application.<br>This is problematic for two reasons:<br>
· To be friendly to the end user, UTC DateTimes require explicit conversion to<br>
local time prior to formatting.<br>
· It's easy to forget and incorporate a local DateTime.<br>
DateTime is better, though, at specifying a value relative to the local computer at<br>runtime--for example, if you want to schedule an archive at each of your interna-<br>tional offices for next Sunday, at 3 A.M. local time (when there's least activity). Here,<br>DateTime would be more suitable because it would respect each site's local time.<br>
<b>208 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=229></a>Internally, DateTimeOffset uses a short integer to store the UTC<br>offset in minutes. It doesn't store any regional information, so<br>there's nothing present to indicate whether an offset of +08:00,<br>for instance, refers to Singapore time or Perth time.<br>
We revisit time zones and equality comparison in more depth in "Dates and Time<br>Zones" on page 213.<br>
SQL Server 2008 introduces direct support for DateTimeOffset<br>through a new data type of the same name.<br>
<b>Constructing a DateTime<br></b>DateTime defines constructors that accept integers for the year, month, and day--<br>and optionally, the hour, minute, second, and millisecond:<br>
public DateTime (int year, int month, int day);<br>
public DateTime (int year, int month, int day,<br>
                 int hour, int minute, int second, int millisecond);<br>
If you specify only a date, the time is implicitly set to midnight (0:00).<br>
The DateTime constructors also allow you to specify a DateTimeKind--an enum with<br>the following values:<br>
Unspecified, Local, Utc<br>
This  corresponds  to  the  three-state  flag  described  in  the  preceding  section.<br>
<b>FW Fundamentals</b><br>
Unspecified  is  the  default  and  it  means  that  the  DateTime  is  time-zone-agnostic.<br>Local means relative to the local time zone on the current computer. A local Date<br>Time does not include information about <i>which particular time zone</i> it refers to, nor,<br>unlike DateTimeOffset, the numeric offset from UTC.<br>A DateTime's Kind property returns its DateTimeKind.<br>
DateTime's constructors are also overloaded to accept a Calendar object as well--<br>this allows you to specify a date using any of the Calendar subclasses defined in<br>System.Globalization. For example:<br>
DateTime d = new DateTime (5767, 1, 1,<br>                          new System.Globalization.HebrewCalendar());<br>
Console.WriteLine (d);    // 12/12/2006 12:00:00 AM<br>
(The formatting of the date in this example depends on your computer's control<br>panel settings.) A DateTime always uses the default Gregorian calendar--this exam-<br>ple, a one-time conversion, takes place during construction. To perform computa-<br>tions using another calendar, you must use the methods on the Calendar subclass<br>itself.<br>
<b>Dates and Times | 209</b><br>
<hr>
<A name=230></a>You  can  also  construct  a  DateTime  with  a  single  <i>ticks</i>  value  of  type  long,  where<br><i>ticks</i> is the number of 100 ns intervals from midnight 01/01/0001.<br>
For  interoperability,  DateTime  provides  the  static  FromFileTime  and  FromFileTi<br>meUtc methods for converting from a Windows file time (specified as a long) and<br>FromOADate for converting from an OLE automation date/time (specified as a double).<br>
To construct a DateTime from a string, call the static Parse or ParseExact method.<br>Both methods accept optional flags and format providers; ParseExact also accepts<br>a  format  string.  We  discuss  parsing  in  greater  detail  in  "Formatting  and  pars-<br>ing" on page 212.<br>
<b>Constructing a DateTimeOffset<br></b>DateTimeOffset  has  a  similar  set  of  constructors.  The  difference  is  that  you  also<br>specify a UTC offset as a TimeSpan:<br>
public DateTimeOffset (int year, int month, int day,<br>
                       int hour, int minute, int second,<br>
                       <b>TimeSpan offset</b>);<br>
public DateTimeOffset (int year, int month, int day,<br>
                       int hour, int minute, int second, int millisecond,<br>                       <b>TimeSpan offset</b>);<br>
The TimeSpan must amount to a whole number of minutes, or an exception is thrown.<br>
DateTimeOffset also has constructors that accept a Calendar object, a long <i>ticks</i> value,<br>and static Parse and ParseExact methods that accept a string.<br>You can construct a DateTimeOffset from an existing DateTime either by using these<br>constructors:<br>
public DateTimeOffset (DateTime dateTime);<br>public DateTimeOffset (DateTime dateTime, TimeSpan offset);<br>
or with an implicit cast:<br>
DateTimeOffset dt = new DateTime (2000, 2, 3);<br>
The implicit cast from DateTime to DateTimeOffset is handy be-<br>cause  most  of  the  .NET  Framework  supports  DateTime--not<br>DateTimeOffset.<br>
If you don't specify an offset, it's inferred from the DateTime value using these rules:<br>
· If the DateTime has a DateTimeKind of Utc, the offset is zero.<br>· If the DateTime has a DateTimeKind of Local or Unspecified (the default), the<br>
offset is taken from the current local time zone.<br>
To convert in the other direction, DateTimeOffset provides three properties that re-<br>turn values of type DateTime:<br>
· The UtcDateTime property returns a DateTime in UTC time.<br>
<b>210 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=231></a>· The LocalDateTime property returns a DateTime in the current local time zone<br>
(converting it if necessary).<br>
· The DateTime property returns a DateTime in whatever zone it was specified, with<br>
a Kind of Unspecified (i.e., it returns the UTC time plus the offset).<br>
<b>The current DateTime/DateTimeOffset<br></b>Both DateTime and DateTimeOffset have a static Now property that returns the current<br>date and time:<br>
Console.WriteLine (DateTime.Now);         // 11/11/2007 1:23:45 PM<br>
Console.WriteLine (DateTimeOffset.Now);   // 11/11/2007 1:23:45 PM -06:00<br>
DateTime also provides a Today property that returns just the date portion:<br>
Console.WriteLine (DateTime.Today);       // 11/11/2007 12:00:00 AM<br>
The static UtcNow property returns the current date and time in UTC:<br>
Console.WriteLine (DateTime.UtcNow);        // 11/11/2007 7:23:45 AM<br>
Console.WriteLine (DateTimeOffset.UtcNow);  // 11/11/2007 7:23:45 AM +00:00<br>
The precision of all these methods depends on the operating system and is typically<br>in the 10­20 ms region.<br>
<b>Working with dates and times<br></b>DateTime and DateTimeOffset provide a similar set of instance properties that return<br>various date/time elements:<br>
DateTime dt = new DateTime (2000, 2, 3,<br>
                            10, 20, 30);<br>
Console.WriteLine (dt.Year);         // 2000<br>Console.WriteLine (dt.Month);        // 2<br>
<b>FW Fundamentals</b><br>
Console.WriteLine (dt.Day);          // 3<br>Console.WriteLine (dt.DayOfWeek);    // Thursday<br>Console.WriteLine (dt.DayOfYear);    // 34<br>
Console.WriteLine (dt.Hour);         // 10<br>Console.WriteLine (dt.Minute);       // 20<br>Console.WriteLine (dt.Second);       // 30<br>Console.WriteLine (dt.Millisecond);  // 0<br>Console.WriteLine (dt.Ticks);        // 630851700300000000<br>Console.WriteLine (dt.TimeOfDay);    // 10:20:30  (returns a TimeSpan)<br>
DateTimeOffset also has an Offset property of type TimeSpan.<br>
Both types provide the following instance methods to perform computations (most<br>accept an argument of type double or int):<br>
AddYears  AddMonths   AddDays<br>AddHours  AddMinutes  AddSeconds  AddMilliseconds  AddTicks<br>
These all return a new DateTime or DateTimeOffset, and they take into account such<br>things as leap years. You can pass in a negative value to subtract.<br>
<b>Dates and Times | 211</b><br>
<hr>
<A name=232></a>The Add method adds a TimeSpan to a DateTime or DateTimeOffset. The + operator is<br>overloaded to do the same job:<br>
TimeSpan ts = TimeSpan.FromMinutes (90);<br>Console.WriteLine (dt.Add (ts));         // 3/02/2000 11:50:30 AM<br>
Console.WriteLine (dt + ts);             // 3/02/2000 11:50:30 AM<br>
You can also subtract a TimeSpan from a DateTime/DateTimeOffset and subtract one<br>DateTime/DateTimeOffset from another. The latter gives you a TimeSpan:<br>
DateTime thisYear = new DateTime (2007, 1, 1);<br>
DateTime nextYear = thisYear.AddYears (1);<br>
TimeSpan oneYear = nextYear - thisYear;<br>
<b>Formatting and parsing<br></b>Calling ToString on a DateTime formats the result as a <i>short date</i> (all numbers) fol-<br>lowed by a <i>long time</i> (including seconds). For example:<br>
13/02/2000 11:50:30 AM<br>
The operating system's control panel, by default, determines such things as whether<br>the day, month, or year comes first, the use of leading zeros, and whether 12- or 24-<br>hour time is used.<br>
Calling ToString on a DateTimeOffset is the same, except that the offset is returned<br>also:<br>
3/02/2000 11:50:30 AM -06:00<br>
The ToShortDateString and ToLongDateString methods return just the date portion.<br>The long date format is also determined by the control panel; an example is "Sat-<br>urday, 17 February 2007". ToShortTimeString and ToLongTimeString return just the<br>time portion, such as 17:10:10 (the former excludes seconds).<br>
These four methods just described are actually shortcuts to four different <i>format<br>strings</i>. ToString is overloaded to accept a format string and provider, allowing you<br>to specify a wide range of options and control how regional settings are applied.<br>
DateTimes and DateTimeOffsets can be misparsed if the culture<br>settings differ from those in force when formatting takes place.<br>You can avoid this problem by using ToString in conjunction<br>with a format string that ignores culture settings (such as "o"):<br>
DateTime dt1 = DateTime.Now;<br>string cannotBeMisparsed = dt1.<b>ToString (&quot;o&quot;)</b>;<br>
DateTime dt2 = DateTime.Parse (cannotBeMisparsed);<br>
The static Parse and ParseExact methods do the reverse of ToString, converting a<br>string to a DateTime or DateTimeOffset. The Parse method is also overloaded to accept<br>a format provider.<br>
<b>212 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=233></a><b>Null DateTime and DateTimeOffset values<br></b>Because DateTime and DateTimeOffset are structs, they are not intrinsically nullable.<br>When you need nullability, there are two ways around this:<br>
· Use a Nullable type (i.e., DateTime? or DateTimeOffset?).<br>· Use the static field DateTime.MinValue or DateTimeOffset.MinValue (the <i>default</i><br>
<i>values</i> for these types).<br>
A nullable type is usually the best approach because the compiler helps to prevent<br>mistakes. DateTime.MinValue is useful for backward compatibility with code written<br>prior to C# 2.0 (when nullable types were introduced).<br>
Calling  ToUniversalTime  or  ToLocalTime  on  a  DateTime.Min<br>Value can result in it no longer being  DateTime.MinValue (de-<br>pending on which side of GMT you are on). If you're right on<br>GMT  (England,  outside  daylight  saving),  the  problem  won't<br>arise at all because local and UTC times are the same. This is<br>your compensation for the English winter!<br>
<b>Dates and Time Zones<br></b>In this section, we examine in more detail how time zones influence DateTime and<br>DateTimeOffset. We also look at the TimeZone and TimeZoneInfo types, which provide<br>information on time zone offsets and daylight saving time.<br>
<b>DateTime and Time Zones<br></b>DateTime is simplistic in its handling of time zones. Internally, it stores a DateTime<br>using two pieces of information:<br>
<b>FW Fundamentals</b><br>
· A 62-bit number, indicating the number of ticks since 1/1/0001<br>· A 2-bit enum, indicating the DateTimeKind (Unspecified, Local, or Utc)<br>
When you compare two DateTime instances, only their <i>ticks</i> values are compared;<br>their DateTimeKinds are ignored:<br>
DateTime dt1 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Local);<br>DateTime dt2 = new DateTime (2000, 1, 1, 10, 20, 30, DateTimeKind.Utc);<br>Console.WriteLine (dt1 == dt2);          // True<br>DateTime local = DateTime.Now;<br>DateTime utc = local.ToUniversalTime();<br>Console.WriteLine (local == utc);        // False<br>
The instance methods ToUniversalTime/ToLocalTime convert to universal/local time.<br>These apply the computer's current time zone settings and return a new DateTime<br>with a DateTimeKind of Utc or Local. No conversion happens if you call ToUniversal<br>Time on a DateTime that's already Utc, or ToLocalTime on a DateTime that's already<br>Local.  You  will  get  a  conversion,  however,  if  you  call  ToUniversalTime  or<br>ToLocalTime on a DateTime that's Unspecified.<br>
<b>Dates and Time Zones | 213</b><br>
<hr>
<A name=234></a>You can construct a DateTime that differs from another only in Kind with the static<br>DateTime.SpecifyKind method:<br>
DateTime d = new DateTime (2000, 12, 12);  // Unspecified<br>DateTime utc = DateTime.SpecifyKind (d, DateTimeKind.Utc);<br>
Console.WriteLine (utc);            // 12/12/2000 12:00:00 AM<br>
<b>DateTimeOffset and Time Zones<br></b>Internally, DateTimeOffset comprises a DateTime field whose value is always in UTC,<br>and a 16-bit integer field for the UTC offset in minutes. Comparisons look only at<br>the (UTC) DateTime; the Offset is used primarily for formatting.<br>The ToUniversalTime/ToLocalTime methods return a DateTimeOffset representing the<br>same point in time, but with a UTC or local offset. Unlike with DateTime, these<br>methods don't affect the underlying date/time value, only the offset:<br>
DateTimeOffset local = DateTimeOffset.Now;<br>
DateTimeOffset utc   = local.ToUniversalTime();<br>
Console.WriteLine (local.Offset);   // -06:00:00 (in Central America)<br>Console.WriteLine (utc.Offset);     // 00:00:00<br>
Console.WriteLine (local == utc);                 // True<br>
To include the Offset in the comparison, you must use the EqualsExact method:<br>
Console.WriteLine (local.EqualsExact (utc));      // False<br>
<b>TimeZone and TimeZoneInfo<br></b>The TimeZone and TimeZoneInfo classes provide information on time zone names,<br>UTC offsets, and daylight saving time rules. TimeZoneInfo is the more powerful of<br>the two and was new to Framework 3.5.<br>
The biggest difference between the two types is that TimeZone lets you access only<br>the current local time zone, whereas TimeZoneInfo provides access to all the world's<br>time zones. Further, TimeZoneInfo exposes a richer (although at times, more awk-<br>ward) rules-based model for describing daylight saving time.<br>
<b>TimeZone<br></b>The static TimeZone.CurrentTimeZone method returns a TimeZone object based on the<br>current  local  settings.  The  following  demonstrates  the  result  if  run  in  Western<br>Australia:<br>
TimeZone zone = TimeZone.CurrentTimeZone;<br>Console.WriteLine (zone.StandardName);      // W. Australia Standard Time<br>Console.WriteLine (zone.DaylightName);      // W. Australia Daylight Time<br>
The IsDaylightSavingTime and GetUtcOffset methods work as follows:<br>
DateTime dt1 = new DateTime (2008, 1, 1);<br>DateTime dt2 = new DateTime (2008, 6, 1);<br>Console.WriteLine (zone.IsDaylightSavingTime (dt1));       // True<br>Console.WriteLine (zone.IsDaylightSavingTime (dt2));       // False<br>
<b>214 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=235></a>Console.WriteLine (zone.GetUtcOffset (dt1));               // 09:00:00<br>
Console.WriteLine (zone.GetUtcOffset (dt2));               // 08:00:00<br>
The GetDaylightChanges method returns specific daylight saving time information<br>for a given year:<br>
DaylightTime day = zone.GetDaylightChanges (2008);<br>
Console.WriteLine (day.Start);   // 26/10/2008 2:00:00 AM  <i>(Note D/M/Y)<br></i>Console.WriteLine (day.End);     // 30/03/2008 3:00:00 AM<br>
Console.WriteLine (day.Delta);   // 01:00:00<br>
<b>TimeZoneInfo<br></b>The TimeZoneInfo class works in a similar manner. TimeZoneInfo.Local returns the<br>current local time zone:<br>
TimeZoneInfo zone = TimeZoneInfo.Local;<br>Console.WriteLine (zone.StandardName);      // W. Australia Standard Time<br>
Console.WriteLine (zone.DaylightName);      // W. Australia Daylight Time<br>
TimeZoneInfo also provides IsDaylightSavingTime and GetUtcOffset methods--the<br>difference is that they accept either a DateTime or a DateTimeOffset.<br>You  can  obtain  a  TimeZoneInfo  for  any  of  the  world's  time  zones  by  calling<br>FindSystemTimeZoneById with the zone ID. This feature is unique to TimeZoneInfo,<br>as is everything else that we demonstrate from this point on. We'll stick with Western<br>Australia for reasons that will soon become clear:<br>
TimeZoneInfo wa = TimeZoneInfo.FindSystemTimeZoneById<br>                  (&quot;W. Australia Standard Time&quot;);<br>
Console.WriteLine (wa.Id);                   // W. Australia Standard Time<br>Console.WriteLine (wa.DisplayName);          // (GMT+08:00) Perth<br>Console.WriteLine (wa.BaseUtcOffset);        // 08:00:00<br>Console.WriteLine (wa.SupportsDaylightSavingTime);     // True<br>
<b>FW Fundamentals</b><br>
The Id property corresponds to the value passed to FindSystemTimeZoneById. The<br>static GetSystemTimeZones method returns all world time zones; hence, you can list<br>all valid zone ID strings as follows:<br>
foreach (TimeZoneInfo z in TimeZoneInfo.GetSystemTimeZones())<br>  Console.WriteLine (z.Id);<br>
You  can  also  create  a  custom  time  zone  by  calling<br>TimeZoneInfo.CreateCustomTimeZone.  Because  TimeZoneInfo  is<br>immutable, you must pass in all the relevant data as method<br>arguments.<br>
You can serialize a predefined or custom time zone to a (semi)<br>human-readable string by calling ToSerializedString--and de-<br>serialize it by calling TimeZoneInfo.FromSerializedString.<br>
The static ConvertTime method converts a DateTime or DateTimeOffset from one time<br>zone to another. You can include either just a destination TimeZoneInfo, or both<br>
<b>Dates and Time Zones | 215</b><br>
<hr>
<A name=236></a>source and destination TimeZoneInfo objects. You can also convert directly from or<br>to UTC with the methods ConvertTimeFromUtc and ConvertTimeToUtc.<br>For working with daylight saving time, TimeZoneInfo provides the following addi-<br>tional methods:<br>
· IsInvalidTime  returns  true  if  a  DateTime  is  within  the  hour  (or  delta)  that's<br>
skipped when the clocks move forward.<br>
· IsAmbiguousTime returns true if a DateTime or DateTimeOffset is within the hour<br>
(or delta) that's repeated when the clocks move back.<br>
· GetAmbiguousTimeOffsets returns an array of TimeSpans representing the valid<br>
offset choices for an ambiguous DateTime or DateTimeOffset.<br>
Unlike with TimeZone, you can't obtain simple dates from a DateZoneInfo indicating<br>the  start  and  end  of  daylight  saving  time.  Instead,  you  must  call  GetAdjustmen<br>tRules, which returns a declarative summary of all daylight saving rules that apply<br>to all years. Each rule has a DateStart and DateEnd indicating the date range within<br>which the rule is valid:<br>
foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())<br>
  Console.WriteLine (&quot;Rule: applies from &quot; + rule.DateStart +<br>                                    &quot; to &quot; + rule.DateEnd);<br>
Western Australia first introduced daylight saving time in 2006, <i>midseason</i> (and then<br>rescinded it in 2009). This required a special rule for the first year; hence, there are<br>two rules:<br>
Rule: applies from 1/01/2006 12:00:00 AM to 31/12/2006 12:00:00 AM<br>
Rule: applies from 1/01/2007 12:00:00 AM to 31/12/2009 12:00:00 AM<br>
Each AdjustmentRule has a DaylightDelta property of type TimeSpan (this is one hour<br>in almost every case) and properties called DaylightTransitionStart and Daylight<br>TransitionEnd. The latter two are of type TimeZoneInfo.TransitionTime, which has<br>the following properties:<br>
public bool IsFixedDateRule { get; }<br>public DayOfWeek DayOfWeek { get; }<br>public int Week { get; }<br>public int Day { get; }<br>public int Month { get; }<br>public DateTime TimeOfDay { get; }<br>
A transition time is somewhat complicated in that it needs to represent both fixed<br>and floating dates. An example of a floating date is "the last Sunday in March." Here<br>are the rules for interpreting a transition time:<br>
1. If,  for  an  end  transition,  IsFixedDateRule  is  true,  Day  is  1,  Month  is  1,  and<br>
TimeOfDay is DateTime.MinValue, there is no end to daylight saving time in that<br>year (this can happen only in the southern hemisphere, upon the initial intro-<br>duction of daylight saving time to a region).<br>
2. Otherwise, if IsFixedDateRule is true, the Month, Day, and TimeOfDay properties<br>
determine the start or end of the adjustment rule.<br>
<b>216 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=237></a>3. Otherwise,  if  IsFixedDateRule  is  false,  the  Month,  DayOfWeek,  Week,  and<br>
TimeOfDay properties determine the start or end of the adjustment rule.<br>
In the last case, Week refers to the week of the month, with "5" meaning the last week.<br>We can demonstrate this by enumerating the adjustment rules for our wa time zone:<br>
foreach (TimeZoneInfo.AdjustmentRule rule in wa.GetAdjustmentRules())<br>{<br>  Console.WriteLine (&quot;Rule: applies from &quot; + rule.DateStart +<br>                                    &quot; to &quot; + rule.DateEnd);<br>
  Console.WriteLine (&quot;   Delta: &quot; + rule.DaylightDelta);<br>
  Console.WriteLine (&quot;   Start: &quot; + FormatTransitionTime<br>                                   (rule.DaylightTransitionStart, false));<br>
  Console.WriteLine (&quot;   End:   &quot; + FormatTransitionTime<br>
                                   (rule.DaylightTransitionEnd, true));<br>  Console.WriteLine();<br>}<br>
In FormatTransitionTime, we honor the rules just described:<br>
static string FormatTransitionTime (TimeZoneInfo.TransitionTime tt,<br>
                                    bool endTime)<br>
{<br>  if (endTime &amp;&amp; tt.IsFixedDateRule<br>
              &amp;&amp; tt.Day == 1 &amp;&amp; tt.Month == 1<br>              &amp;&amp; tt.TimeOfDay == DateTime.MinValue)<br>
    return &quot;-&quot;;<br>
  string s;<br>  if (tt.IsFixedDateRule)<br>    s = tt.Day.ToString();<br>
<b>FW Fundamentals</b><br>
  else<br>    s = &quot;The &quot; +<br>        &quot;first second third fourth last&quot;.Split() [tt.Week - 1] +<br>        &quot; &quot; + tt.DayOfWeek + &quot; in&quot;;<br>
  return s + &quot; &quot; + DateTimeFormatInfo.CurrentInfo.MonthNames [tt.Month-1]<br>           + &quot; at &quot; + tt.TimeOfDay.TimeOfDay;<br>}<br>
The result with Western Australia is interesting in that it demonstrates both fixed<br>and floating date rules--as well as an absent end date:<br>
Rule: applies from 1/01/2006 12:00:00 AM to 31/12/2006 12:00:00 AM<br>   Delta: 01:00:00<br>   Start: 3 December at 02:00:00<br>   End:   -<br>
Rule: applies from 1/01/2007 12:00:00 AM to 31/12/2009 12:00:00 AM<br>   Delta: 01:00:00<br>   Start: The last Sunday in October at 02:00:00<br>   End:   The last Sunday in March at 03:00:00<br>
<b>Dates and Time Zones | 217</b><br>
<hr>
<A name=238></a>Western Australia is actually unique in this regard. Here's how<br>we found it:<br>
from zone in TimeZoneInfo.GetSystemTimeZones()<br>let rules = zone.GetAdjustmentRules()<br>
where<br>
  rules.Any<br>
   (r =&gt; r.DaylightTransitionEnd.IsFixedDateRule) &amp;&amp;<br>
  rules.Any<br>   (r =&gt; !r.DaylightTransitionEnd.IsFixedDateRule)<br>select zone<br>
<b>Daylight Saving Time and DateTime<br></b>If  you use a DateTimeOffset or a UTC DateTime, equality comparisons are unimpeded<br>by the effects of daylight saving time. But with local DateTimes, daylight saving can<br>be problematic.<br>
The rules can be summarized as follows:<br>
· Daylight saving impacts local time but not UTC time.<br>· When the clocks turn back, comparisons that rely on time moving forward will<br>
break if (and only if) they use local DateTimes.<br>
· You can always reliably round-trip between UTC and local times (on the same<br>
computer)--even as the clocks turn back.<br>
The IsDaylightSavingTime tells you whether a given local DateTime is subject to day-<br>light saving time. UTC times always return false:<br>
Console.Write (DateTime.Now.IsDaylightSavingTime());     // True or False<br>Console.Write (DateTime.UtcNow.IsDaylightSavingTime());  // Always False<br>
Assuming dto is a DateTimeOffset, the following expression does the same:<br>
dto.LocalDateTime.IsDaylightSavingTime<br>
The end of daylight saving time presents a particular complication for algorithms<br>that use local time. When the clocks go back, the same hour (or more precisely,<br>Delta) repeats itself. We can demonstrate this by instantiating a DateTime right in<br>the "twilight zone" on your computer, and then subtracting Delta (this example<br>requires that you practice daylight saving time to be interesting!):<br>
DaylightTime changes = TimeZone.CurrentTimeZone.GetDaylightChanges (2010);<br>TimeSpan halfDelta = new TimeSpan (changes.Delta.Ticks / 2);<br>DateTime utc1 = changes.End.ToUniversalTime() - halfDelta;<br>DateTime utc2 = utc1 - changes.Delta;<br>
Converting these variables to local times demonstrates why you should use UTC<br>and not local time if your code relies on time moving forward:<br>
DateTime loc1 = utc1.ToLocalTime();  // (Pacific Standard Time)<br>DateTime loc2 = utc2.ToLocalTime();<br>Console.WriteLine (loc1);            // 2/11/2010 1:30:00 AM<br>Console.WriteLine (loc2);            // 2/11/2010 1:30:00 AM<br>Console.WriteLine (loc1 == loc2);    // <b>True</b><br>
<b>218 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=239></a>Despite loc1 and loc2 reporting as equal, they are different inside. DateTime reserves<br>a special bit for indicating on which side of the twilight zone an ambiguous local<br>date lies! This bit is ignored in comparison--as we just saw--but comes into play<br>when you format the DateTime unambiguously:<br>
Console.Write (loc1.ToString (&quot;o&quot;));  // 2010-11-02T02:30:00.0000000-<b>08:00<br></b>Console.Write (loc2.ToString (&quot;o&quot;));  // 2010-11-02T02:30:00.0000000-<b>07:00</b><br>
This bit also is read when you convert back to UTC, ensuring perfect round-tripping<br>between local and UTC times:<br>
Console.WriteLine (loc1.ToUniversalTime() == utc1);   // True<br>
Console.WriteLine (loc2.ToUniversalTime() == utc2);   // True<br>
You  can  reliably  compare  any  two  DateTimes  by  first  calling<br>ToUniversalTime on each. This strategy fails if (and only if) ex-<br>actly one of them has a DateTimeKind of Unspecified. This po-<br>tential for failure is another reason for favoring DateTimeOffset.<br>
<b>Formatting and Parsing<br></b>Formatting means converting <i>to</i> a string; parsing means converting <i>from</i> a string.<br>The need to format or parse arises frequently in programming, in a variety of situa-<br>tions. Hence, the .NET Framework provides a variety of mechanisms:<br>
ToString<i> and </i>Parse<br>
These methods provide default functionality for many types.<br>
<i>Format providers</i><br>
These manifest as additional ToString (and Parse) methods that accept a <i>format<br>string</i> and/or a <i>format provider</i>. Format providers are highly flexible and culture-<br>
<b>FW Fundamentals</b><br>
aware. The .NET Framework includes format providers for the numeric types<br>and DateTime/DateTimeOffset.<br>
XmlConvert<br>
This is a static class with methods that format and parse while honoring XML<br>standards. XmlConvert is also useful for general-purpose conversion when you<br>need  culture  independence  or  you  want  to  preempt  misparsing.  XmlConvert<br>supports the numeric types, bool, DateTime, DateTimeOffset, TimeSpan, and Guid.<br>
<i>Type converters</i><br>
These target designers and XAML parsers.<br>
In this section, we discuss the first two mechanisms, focusing particularly on format<br>providers. In the section following, we describe XmlConvert and type converters, as<br>well as other conversion mechanisms.<br>
<b>Formatting and Parsing | 219</b><br>
<hr>
<A name=240></a><b>ToString and Parse<br></b>The simplest formatting mechanism is the ToString method. It gives meaningful<br>output on all simple value types (bool, DateTime, DateTimeOffset, TimeSpan, Guid,<br>and all the numeric types). For the reverse operation, each of these types defines a<br>static Parse method. For example:<br>
string s = true.ToString();     // s = &quot;True&quot;<br>bool b = bool.Parse (s);        // b = true<br>
If the parsing fails, a FormatException is thrown. Many types also define a TryParse <br>method,  which  returns  false  if  the  conversion  fails,  rather  than  throwing  an<br>exception:<br>
int i;<br>
bool failure = int.TryParse (&quot;qwerty&quot;, out i);<br>bool success = int.TryParse (&quot;123&quot;, out i);<br>
If you anticipate an error, calling TryParse is faster and more elegant than calling<br>Parse in an exception handling block.<br>
The Parse and TryParse methods on DateTime(Offset) and the numeric types respect<br>local culture settings; you can change this by specifying a CultureInfo object. Spec-<br>ifying invariant culture is often a good idea. For instance, parsing "1.234" into a<br>double gives us 1234 in Germany:<br>
Console.WriteLine (double.Parse (&quot;1.234&quot;));   // 1234  (In Germany)<br>
This is because in Germany, the period indicates a thousands separator rather than<br>a decimal point. Specifying <i>invariant culture</i> fixes this:<br>
double x = double.Parse (&quot;1.234&quot;, <b>CultureInfo.InvariantCulture</b>);<br>
The same applies when calling ToString():<br>
string x = 1.234.ToString (CultureInfo.InvariantCulture);<br>
<b>Format Providers<br></b>Sometimes  you  need  more  control  over  how  formatting  and  parsing  take  place.<br>There are dozens of ways to format a DateTime(Offset), for instance. Format pro-<br>viders allow extensive control over formatting and parsing, and are supported for<br>numeric types and date/times. Format providers are also used by user interface con-<br>trols for formatting and parsing.<br>
The gateway to using a format provider is IFormattable. All numeric types--and<br>DateTime(Offset)--implement this interface:<br>
public interface IFormattable<br>{<br>  string ToString (string format, IFormatProvider formatProvider);<br>}<br>
The first argument is the <i>format string</i>; the second is the <i>format provider</i>. The format<br>string provides instructions; the format provider determines how the instructions<br>are translated. For example:<br>
<b>220 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=241></a>NumberFormatInfo f = new NumberFormatInfo();<br>
f.CurrencySymbol = &quot;$$&quot;;<br>Console.WriteLine (3.ToString (&quot;C&quot;, f));          // $$ 3.00<br>
Here, &quot;C&quot; is a format string that indicates <i>currency</i>, and the NumberFormatInfo object<br>is  a  format  provider  that  determines  how  currency--and  other  numeric<br>representations--are rendered. This mechanism allows for globalization.<br>
All format strings for numbers and dates are listed in "Standard<br>Format Strings and Parsing Flags" on page 225.<br>
If you specify a null format string or provider, a default is applied. The default format<br>provider is CultureInfo.CurrentCulture, which, unless reassigned, reflects the com-<br>puter's runtime control panel settings. For example, on this computer:<br>
Console.WriteLine (10.3.ToString (&quot;C&quot;, null));  // $10.30<br>
For  convenience,  most  types  overload  ToString  such  that  you  can  omit  a  null<br>provider:<br>
Console.WriteLine (10.3.ToString (&quot;C&quot;));     // $10.30<br>
Console.WriteLine (10.3.ToString (&quot;F4&quot;));    // 10.3000 (Fix to 4 D.P.)<br>
Calling  ToString  on  a  DateTime(Offset)  or  a  numeric  type  with  no  arguments  is<br>equivalent to using a default format provider, with an empty format string.<br>
The  .NET  Framework  defines  three  format  providers  (all  of  which  implement<br>IFormatProvider):<br>
NumberFormatInfo<br>DateTimeFormatInfo<br>
<b>FW Fundamentals</b><br>
CultureInfo<br>
All enum types are also formattable, though there's no special<br>IFormatProvider class.<br>
<b>Format providers and CultureInfo<br></b>Within the context of format providers, CultureInfo acts as an indirection mecha-<br>nism for the other two format providers, returning a NumberFormatInfo or DateTime<br>FormatInfo object applicable to the culture's regional settings.<br>
In the following example, we request a specific culture (<i>en</i>glish language in <i>G</i>reat<br><i>B</i>ritain):<br>
CultureInfo uk = CultureInfo.GetCultureInfo (&quot;en-GB&quot;);<br>Console.WriteLine (3.ToString (&quot;C&quot;, uk));      // £3.00<br>
This executes using the default NumberFormatInfo object applicable to the en-GB<br>culture.<br>
<b>Formatting and Parsing | 221</b><br>
<hr>
<A name=242></a>The next example formats a DateTime with invariant culture. Invariant culture is<br>always the same, regardless of the computer's settings:<br>
DateTime dt = new DateTime (2000, 1, 2);<br>CultureInfo iv = CultureInfo.InvariantCulture;<br>
Console.WriteLine (dt.ToString (iv));            // 01/02/2000 00:00:00<br>
Console.WriteLine (dt.ToString (&quot;d&quot;, iv));       // 01/02/2000<br>
Invariant  culture  is  based  on  American  culture,  with  the  fol-<br>lowing differences:<br>
· The currency symbol is  instead of $.<br>· Dates and times are formatted with leading zeros (though<br>
still with the month first).<br>
· Time  uses  the  24-hour  format  rather  than  an  AM/PM<br>
designator.<br>
<b>Using NumberFormatInfo or DateTimeFormatInfo<br></b>In the next example, we instantiate a NumberFormatInfo and change the group sep-<br>arator from a comma to a space. We then use it to format a number to three decimal<br>places:<br>
NumberFormatInfo f = new NumberFormatInfo ();<br>
f.NumberGroupSeparator = &quot; &quot;;<br>
Console.WriteLine (12345.6789.ToString (&quot;N3&quot;, f));   // 12 345.679<br>
The initial settings for a NumberFormatInfo or DateTimeFormatInfo are based on the<br>invariant culture. Sometimes, however, it's more useful to choose a different starting<br>point. To do this, you can Clone an existing format provider:<br>
NumberFormatInfo f = (NumberFormatInfo)<br>                      CultureInfo.CurrentCulture.NumberFormat.Clone();<br>
A cloned format provider is always writable--even if the original was read-only.<br>
<b>Composite formatting<br></b>Composite format strings allow you to combine variable substitution with format<br>strings. The static string.Format method accepts a composite format string--we<br>illustrated this in "String and Text Handling" on page 193:<br>
string composite = &quot;Credit=<b>{0:C}</b>&quot;;<br>Console.WriteLine (string.Format (composite, 500));   // Credit=$500.00<br>
The Console class itself overloads its Write and WriteLine methods to accept com-<br>posite format strings, allowing us to shorten this example slightly:<br>
Console.WriteLine (&quot;Credit={0:C}&quot;, 500);   // Credit=$500.00<br>
You  can  also  append  a  composite  format  string  to  a  StringBuilder  (via<br>AppendFormat), and to a TextWriter for I/O (see Chapter 14).<br>
<b>222 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=243></a>string.Format accepts an optional format provider. A simple application for this is<br>to  call  ToString  on  an  arbitrary  object  while  passing  in  a  format  provider.  For<br>example:<br>
string s = string.Format (CultureInfo.InvariantCulture, &quot;{0}&quot;, someObject);<br>
This is equivalent to:<br>
string s;<br>
if (someObject is IFormattable)<br>  s = ((IFormattable)someObject).ToString (null,<br>
                                           CultureInfo.InvariantCulture);<br>
else if (someObject == null)<br>
  s = &quot;&quot;;<br>else<br>  s = someObject.ToString();<br>
<b>Parsing with format providers<br></b>There's no standard interface for parsing through a format provider. Instead, each<br>participating type overloads its static Parse (and TryParse) method to accept a format<br>provider, and optionally, a NumberStyles or DateTimeStyles enum.<br>
NumberStyles and DateTimeStyles control how parsing work: they let you specify<br>such things as whether parentheses or a currency symbol can appear in the input<br>string. (By default, the answer to both of these questions is <i>no</i>.) For example:<br>
int error = int.Parse (&quot;(2)&quot;);   // Exception thrown<br>
int minusTwo = int.Parse (&quot;(2)&quot;, NumberStyles.Integer |<br>
                                 NumberStyles.AllowParentheses);   // OK<br>
decimal fivePointTwo = decimal.Parse (&quot;£5.20&quot;, NumberStyles.Currency,<br>
                       CultureInfo.GetCultureInfo (&quot;en-GB&quot;));<br>
<b>FW Fundamentals</b><br>
The next section lists all NumberStyles and DateTimeStyles members--as well as the<br>default parsing rules for each type.<br>
<b>IFormatProvider and ICustomFormatter<br></b>All format providers implement IFormatProvider:<br>
public interface IFormatProvider { object GetFormat (Type formatType); }<br>
The  purpose  of  this  method  is  to  provide  indirection--this  is  what  allows<br>CultureInfo to defer to an appropriate NumberFormatInfo or DateTimeInfo object to<br>do the work.<br>
By  implementing  IFormatProvider--along  with  ICustomFormatter--you  can  also<br>write  your  own  format  provider  that  works  in  conjunction  with  existing  types.<br>ICustomFormatter defines a single method as follows:<br>
string Format (string format, object arg, IFormatProvider formatProvider);<br>
<b>Formatting and Parsing | 223</b><br>
<hr>
<A name=244></a>The following custom format provider writes numbers as words:<br>
// Program can be downloaded from http://www.albahari.com/nutshell/<br>
public class WordyFormatProvider : IFormatProvider, ICustomFormatter<br>{<br>  static readonly string[] _numberWords =<br>
   &quot;zero one two three four five six seven eight nine minus point&quot;.Split();<br>
  IFormatProvider _parent;   // Allows consumers to chain format providers<br>
  public WordyFormatProvider () : this (CultureInfo.CurrentCulture) { }<br>  public WordyFormatProvider (IFormatProvider parent)<br>
  {<br>    _parent = parent;<br>
  }<br>
  public object GetFormat (Type formatType)<br>  {<br>    if (formatType == typeof (ICustomFormatter)) return this;<br>
    return null;<br>
  }<br>
  public string Format (string format, object arg, IFormatProvider prov)<br>
  {<br>    // If it's not our format string, defer to the parent provider:<br>
    if (arg == null || format != &quot;W&quot;)<br>      return string.Format (_parent, &quot;{0:&quot; + format + &quot;}&quot;, arg);<br>
    StringBuilder result = new StringBuilder();<br>    string digitList = string.Format (CultureInfo.InvariantCulture,<br>                                      &quot;{0}&quot;, arg);<br>    foreach (char digit in digitList)<br>    {<br>      int i = &quot;0123456789-.&quot;.IndexOf (digit);<br>      if (i == -1) continue;<br>      if (result.Length &gt; 0) result.Append (' ');<br>      result.Append (_numberWords[i]);<br>    }<br>
    return result.ToString();<br>  }<br>}<br>
Notice that in the Format method we used string.Format to convert the input number<br>to a string--with InvariantCulture. It would have been much simpler just to call<br>ToString()  on  arg,  but  then  CurrentCulture  would  have  been  used  instead.  The<br>reason for needing the invariant culture is evident a few lines later:<br>
int i = &quot;0123456789-.&quot;.IndexOf (digit);<br>
It's critical here that the number string comprises only the characters 0123456789-.<br>and not any internationalized versions of these.<br>
Here's an example of using WordyFormatProvider:<br>
double n = -123.45;<br>IFormatProvider fp = new WordyFormatProvider();<br>
<b>224 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=245></a>Console.WriteLine (string.Format (fp, &quot;{0:C} in words is {0:W}&quot;, n));<br>
// -$123.45 in words is one two three point four five<br>
Custom format providers can be used only in composite format strings.<br>
<b>Standard Format Strings and Parsing Flags<br></b>The standard format strings control how a numeric type or DateTime/DateTimeOff<br>set is converted to a string. There are two kinds of format strings:<br>
<i>Standard format strings</i><br>
With these, you provide general guidance. A standard format string consists of<br>a single letter, followed, optionally, by a digit (whose meaning depends on the<br>letter). An example is &quot;C&quot; or &quot;F2&quot;.<br>
<i>Custom format strings</i><br>
With these, you micromanage every character with a template. An example is<br>&quot;0:#.000E+00&quot;.<br>
Custom format strings are unrelated to custom format providers.<br>
<b>Numeric Format Strings<br></b>Table 6-2 lists all standard numeric format strings.<br>
<i>Table 6-2. Standard numeric format strings</i><br>
<b>Letter</b><br>
<b>Meaning</b><br>
<b>Sample input</b><br>
<b>Result</b><br>
<b>Notes</b><br>
G or g<br>
"General"<br>
1.2345, &quot;G&quot;<br>
1.2345<br>
Switches to exponential notation for<br>small or large numbers.<br>
0.00001, &quot;G&quot;<br>
1E-05<br>
<b>FW Fundamentals</b><br>
G3 limits precision to three digits in<br>
0.00001, &quot;g&quot;<br>
1e-05<br>
total (before + after point).<br>
1.2345, &quot;G3&quot;<br>
1.23<br>
12345, &quot;G3&quot;<br>
1.23E04<br>
F<br>
Fixed point<br>
2345.678, &quot;F2&quot;<br>
2345.68<br>
F2 rounds to two decimal places.<br>
2345.6, &quot;F2&quot;<br>
2345.60<br>
N<br>
Fixed point with<br>
2345.678, &quot;N2&quot;<br>
2,345.68<br>
As above, with group (1,000s) sepa-<br>
group separator<br>
rator (details from format provider).<br>
("Numeric")<br>
2345.6, &quot;N2&quot;<br>
2,345.60<br>
D<br>
Pad with leading<br>
123, &quot;D5&quot;<br>
00123<br>
For integral types only.<br>
zeros<br>
123, &quot;D1&quot;<br>
123<br>
D5 pads left to five digits; does not<br>
truncate.<br>
E or e<br>
Force exponential<br>
56789, &quot;E&quot;<br>
5.678900E+004<br>
Six-digit default precision.<br>
notation<br>
56789, &quot;e&quot;<br>
5.678900e+004<br>
56789, &quot;E2&quot;<br>
5.68E+004<br>
<b>Standard Format Strings and Parsing Flags | 225</b><br>
<hr>
<A name=246></a><b>Letter</b><br>
<b>Meaning</b><br>
<b>Sample input</b><br>
<b>Result</b><br>
<b>Notes</b><br>
C<br>
Currency<br>
1.2, &quot;C&quot;<br>
$1.20<br>
C with no digit uses default number<br>
of D.P. from format provider.<br>
1.2, &quot;C4&quot;<br>
$1.2000<br>
P<br>
Percent<br>
.503, &quot;P&quot;<br>
50.30 %<br>
Uses symbol and layout from format<br>provider.<br>
.503, &quot;P0&quot;<br>
50 %<br>
Decimal places can optionally be<br>overridden.<br>
X or x<br>
Hexadecimal<br>
47, &quot;X&quot;<br>
2F<br>
X for uppercase hex digits; x for<br>
lowercase hex digits.<br>
47, &quot;x&quot;<br>
2f<br>
Integrals only.<br>
47, &quot;X4&quot;<br>
002F<br>
R<br>
Round-trip<br>
1f / 3f, &quot;R&quot;<br>
0.3333333<b>43</b><br>
For the float and double types,<br>R squeezes out all digits to ensure ex-<br>
act round-tripping.<br>
Supplying no numeric format string (or a null or blank string) is equivalent to using<br>the  &quot;G&quot;  standard  format  string  followed  by  no  digit.  This  exhibits  the  following<br>behavior:<br>
· Numbers smaller than 10-4 or larger than the type's precision are expressed in<br>
exponential (scientific) notation.<br>
· The two decimal places at the limit of float or double's precision are rounded<br>
away to mask the inaccuracies inherent in conversion to decimal from their<br>underlying binary form.<br>
The automatic rounding just described is usually beneficial and<br>goes unnoticed. However, it can cause trouble if you need to<br>round-trip a number; in other words, convert it to a string and<br>back again (maybe repeatedly) while preserving value equality.<br>For this reason, the &quot;R&quot; format string exists to circumvent this<br>implicit rounding.<br>
Table 6-3 lists custom numeric format strings.<br>
<i>Table 6-3. Custom numeric format strings</i><br>
<b>Specifier</b><br>
<b>Meaning</b><br>
<b>Sample input</b><br>
<b>Result</b><br>
<b>Notes</b><br>
#<br>
Digit placeholder<br>
12.345, &quot;.##&quot;<br>
12.35<br>
Limits digits after D.P.<br>
12.345, &quot;.####&quot;<br>
12.345<br>
0<br>
Zero placeholder<br>
12.345, &quot;.00&quot;<br>
12.35<br>
As above, but also pads with<br>zeros before and after D.P.<br>
12.345, &quot;.0000&quot;<br>
12.3500<br>
99, &quot;000.00&quot;<br>
099.00<br>
.<br>
Decimal point<br>
 <br>
 <br>
Indicates D.P.<br>
<b>226 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=247></a><b>Specifier</b><br>
<b>Meaning</b><br>
<b>Sample input</b><br>
<b>Result</b><br>
<b>Notes<br></b>Actual symbol comes from<br>NumberFormatInfo.<br>
,<br>
Group separator<br>
1234, &quot;#,###,###&quot;<br>
1,234<br>
Symbol comes from Number<br>FormatInfo.<br>
1234, &quot;0,000,000&quot;<br>
0,001,234<br>
,<br>
Multiplier<br>
1000000, &quot;#,&quot;<br>
1000<br>
If comma is at end or before<br>
(as above)<br>
D.P., it acts as a multiplier--<br>
1000000, &quot;#,,<br>
1<br>
dividing result by 1,000,<br>1,000,000, etc.<br>
 <br>
Percent notation<br>
0.6, &quot;00%&quot;<br>
60%<br>
First multiplies by 100 and<br>then substitutes percent sym-<br>bol obtained from Number<br>FormatInfo.<br>
E0, e0, E<br>
Exponent<br>
1234, &quot;0E0&quot;<br>
1E0<br>
 <br>
+0, e+0<br>
notation<br>
1234, &quot;0E+0&quot;<br>
1E+3<br>
E-0, e-0<br>
1234, &quot;0.00E00&quot;<br>
1.25E03<br>
1234, &quot;0.00e00&quot;<br>
1.25e03<br>
\<br>
Literal character<br>
50, @&quot;\#0&quot;<br>
#50<br>
Use in conjunction with an @<br>
quote<br>
prefix on the string--or use<br>\\.<br>
'xx''xx'<br>
Literal string<br>
50, &quot;0 '...'&quot;<br>
50 ...<br>
 <br>
quote<br>
;<br>
Section separator<br>
15, &quot;#;(#);zero&quot;<br>
15<br>
(If positive).<br>
 <br>
 <br>
-5, &quot;#;(#);zero&quot;<br>
-5<br>
(If negative).<br>
 <br>
 <br>
0, &quot;#;(#);zero&quot;<br>
zero<br>
(If zero).<br>
<b>FW Fundamentals</b><br>
Any other char<br>
Literal<br>
35.2, &quot;$0 . 00c&quot;<br>
$35 . 00c<br>
 <br>
<b>NumberStyles<br></b>Each numeric type defines a static Parse method that accepts a NumberStyles argu-<br>ment. NumberStyles is a flags enum that lets you determine how the string is read as<br>it's converted to a numeric type. It has the following combinable members:<br>
AllowLeadingWhite    AllowTrailingWhite<br>AllowLeadingSign     AllowTrailingSign<br>AllowParentheses     AllowDecimalPoint<br>AllowThousands       AllowExponent<br>
AllowCurrencySymbol  AllowHexSpecifier<br>
NumberStyles also defines these composite members:<br>
None  Integer  Float  Number  HexNumber  Currency  Any<br>
Except for None, all composite values include AllowLeadingWhite and AllowTrailing<br>White. Their remaining makeup is shown in Figure 6-1, with the most useful three<br>emphasized.<br>
<b>Standard Format Strings and Parsing Flags | 227</b><br>
<hr>
<A name=248></a><i>Figure 6-1. Composite NumberStyles</i><br>
When you call Parse without specifying any flags, the defaults in Figure 6-2 are<br>applied.<br>
If  you  don't  want  the  defaults  shown  in  Figure  6-2,  you  must  explicitly  specify<br>NumberStyles:<br>
int thousand = int.Parse (&quot;3E8&quot;, NumberStyles.HexNumber);<br>int minusTwo = int.Parse (&quot;(2)&quot;, NumberStyles.Integer |<br>                                 NumberStyles.AllowParentheses);<br>
double aMillion = double.Parse (&quot;1,000,000&quot;, NumberStyles.Any);<br>
decimal threeMillion = decimal.Parse (&quot;3e6&quot;, NumberStyles.Any);<br>decimal fivePointTwo = decimal.Parse (&quot;$5.20&quot;, NumberStyles.Currency);<br>
<i>Figure 6-2. Default parsing flags for numeric types</i><br>
Because we didn't specify a format provider, this example works with your local<br>currency symbol, group separator, decimal point, and so on. The next example is<br>hardcoded to work with the euro sign and a blank group separator for currencies:<br>
<b>228 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=249></a>NumberFormatInfo ni = new NumberFormatInfo();<br>
ni.CurrencySymbol = &quot;&quot;;<br>ni.CurrencyGroupSeparator = &quot; &quot;;<br>double million = double.Parse (&quot;1 000 000&quot;, NumberStyles.Currency, ni);<br>
<b>Date/Time Format Strings<br></b>Format strings for DateTime/DateTimeOffset can be divided into two groups, based<br>on whether they honor culture and format provider settings. Those that do are listed<br>in Table 6-4; those that don't are listed in Table 6-5. The sample output comes from<br>formatting the following DateTime (with <i>invariant culture</i>, in the case of Table 6-4):<br>
new DateTime (2000, 1, 2,  17, 18, 19);<br>
<i>Table 6-4. Culture-sensitive date/time format strings</i><br>
<b>Format string</b><br>
<b>Meaning</b><br>
<b>Sample output</b><br>
d<br>
Short date<br>
01/02/2000<br>
D<br>
Long date<br>
Sunday, 02 January 2000<br>
t<br>
Short time<br>
17:18<br>
T<br>
Long time<br>
17:18:19<br>
f<br>
Long date + short time<br>
Sunday, 02 January 2000 17:18<br>
F<br>
Long date + long time<br>
Sunday, 02 January 2000 17:18:19<br>
g<br>
Short date + short time<br>
01/02/2000 17:18<br>
G (default)<br>
Short date + long time<br>
01/02/2000 17:18:19<br>
m, M<br>
Month and day<br>
January 02<br>
y, Y<br>
Year and month<br>
2000 January<br>
<b>FW Fundamentals</b><br>
<i>Table 6-5. Culture-insensitive date/time format strings</i><br>
<b>Format string</b><br>
<b>Meaning</b><br>
<b>Sample output</b><br>
<b>Notes</b><br>
o<br>
Round-trippable<br>
2000-01-02T17:18:19.0000000<br>
Will append time zone<br>information unless<br>DateTimeKind is<br>Unspecified<br>
r, R<br>
RFC 1123 standard<br>
Sun, 02 Jan 2000 17:18:19 GMT<br>
You must explicitly con-<br>vert to UTC with Date<br>Time.ToUniversal<br>Time<br>
s<br>
Sortable; ISO 8601<br>
2000-01-02T17:18:19<br>
Compatible with text-<br>based sorting<br>
u<br>
"Universal" Sortable<br>
2000-01-02 17:18:19Z<br>
Similar to above; must<br>explicitly convert to UTC<br>
U<br>
UTC<br>
Sunday, 02 January 2000 17:18:19<br>
Long date + short time,<br>converted to UTC<br>
<b>Standard Format Strings and Parsing Flags | 229</b><br>
<hr>
<A name=250></a>The format strings &quot;r&quot;, &quot;R&quot;, and &quot;u&quot; emit a suffix that implies UTC; yet they don't<br>automatically convert a local to a UTC DateTime (so you must do the conversion<br>yourself). Ironically, &quot;U&quot; automatically converts to UTC, but doesn't write a time<br>zone suffix! In fact, &quot;o&quot; is the only format specifier in the group that can write an<br>unambiguous DateTime without intervention.<br>
DateTimeFormatInfo also supports custom format strings: these are analogous to nu-<br>meric custom format strings. The list is fairly exhaustive and you can find it in the<br>MSDN. An example of a custom format string is:<br>
yyyy-MM-dd HH:mm:ss<br>
<b>Parsing and misparsing DateTimes<br></b>Strings that put the month or day first are ambiguous and can easily be misparsed--<br>particularly if you or any of your customers live outside the United States and Can-<br>ada. This is not a problem in user interface controls because the same settings are<br>in force when parsing as when formatting. But when writing to a file, for instance,<br>day/month misparsing can be a real problem. There are two solutions:<br>
· Always state the same explicit culture when formatting and parsing (e.g., in-<br>
variant culture).<br>
· Format DateTime and DateTimeOffsets in a manner <i>independent</i> of culture.<br>
The second approach is more robust--particularly if you choose a format that puts<br>the four-digit year first: such strings are much harder to misparse by another party.<br>Further,  strings  formatted  with  a  <i>standards-compliant</i>  year-first  format  (such  as<br>&quot;o&quot;) can parse correctly alongside locally formatted strings--rather like a "universal<br>donor." (Dates formatted with &quot;s&quot; or &quot;u&quot; have the further benefit of being sortable.)<br>To illustrate, suppose we generate a culture-insensitive DateTime string s as follows:<br>
string s = DateTime.Now.ToString (&quot;o&quot;);<br>
The &quot;o&quot; format string includes milliseconds in the output. The<br>following custom format string gives the same result as &quot;o&quot;, but<br>without milliseconds:<br>
yyyy-MM-ddTHH:mm:ss K<br>
We can reparse this in two ways. ParseExact demands strict compliance with the<br>specified format string:<br>
DateTime dt1 = DateTime.ParseExact (s, &quot;o&quot;, null);<br>
(You  can  achieve  a  similar  result  with  XmlConvert's  ToString  and  ToDateTime<br>methods.)<br>
Parse,  however,  implicitly  accepts  both  the  &quot;o&quot;  format  and  the  CurrentCulture<br>format:<br>
DateTime dt2 = DateTime.Parse (s);<br>
This works with both DateTime and DateTimeOffset.<br>
<b>230 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=251></a>ParseExact is usually preferable if you know the format of the<br>string that you're parsing. It means that if the string is incorrectly<br>formatted, an exception will be thrown--which is usually better<br>than risking a misparsed date.<br>
<b>DateTimeStyles<br></b>DateTimeStyles is a flags enum that provides additional instructions when calling <br>Parse on a DateTime(Offset). Here are its members:<br>
None,<br>
AllowLeadingWhite, AllowTrailingWhite, AllowInnerWhite,<br>
AssumeLocal, AssumeUniversal, AdjustToUniversal,<br>
NoCurrentDateDefault, RoundTripKind<br>
There is also a composite member, AllowWhiteSpaces:<br>
AllowWhiteSpaces = AllowLeadingWhite | AllowTrailingWhite | AllowInnerWhite<br>
The default is None. This means that extra whitespace is normally prohibited (white-<br>space that's part of a standard DateTime pattern is exempt).<br>
AssumeLocal and AssumeUniversal apply if the string doesn't have a time zone suffix<br>(such as Z or +9:00). AdjustToUniversal still honors time zone suffixes, but then<br>converts to UTC using the current regional settings.<br>
If you parse a string comprising a time but no date, today's date is applied by default.<br>If  you  apply  the  NoCurrentDateDefault  flag,  however,  it  instead  uses  1st  January<br>0001.<br>
<b>Enum Format Strings</b><br>
<b>FW Fundamentals</b><br>
In "Enums" on page 240 in Chapter 3, we describe formatting and parsing enum<br>values. Table 6-6 lists each format string and the result of applying it to the following<br>expression:<br>
Console.WriteLine (System.ConsoleColor.Red.ToString (formatString));<br>
<i>Table 6-6. Enum format strings</i><br>
<b>Format string</b><br>
<b>Meaning</b><br>
<b>Sample output</b><br>
<b>Notes</b><br>
G or g<br>
"General"<br>
Red<br>
Default<br>
F or f<br>
Treat as though Flags<br>
Red<br>
Works on combined members even if enum<br>
attribute were present<br>
has no Flags attribute<br>
D or d<br>
Decimal value<br>
12<br>
Retrieves underlying integral value<br>
X or x<br>
Hexadecimal value<br>
0000000C<br>
Retrieves underlying integral value<br>
<b>Standard Format Strings and Parsing Flags | 231</b><br>
<hr>
<A name=252></a><b>Other Conversion Mechanisms<br></b>In the previous two sections, we covered format providers--.NET's primary mech-<br>anism  for  formatting  and  parsing.  Other  important  conversion  mechanisms  are<br>scattered  through  various  types  and  namespaces.  Some  convert  to  and  from<br>string,  and  some  do  other  kinds  of  conversions.  In  this  section,  we  discuss  the<br>following topics:<br>
· The Convert class and its functions:<br>
-- Real to integral conversions that round rather than truncate<br>-- Parsing numbers in base 2, 8, and 16<br>-- Dynamic conversions<br>-- Base 64 translations<br>
· XmlConvert and its role in formatting and parsing for XML<br>· Type  converters  and  their  role  in  formatting  and  parsing  for  designers  and<br>
XAML<br>
· BitConverter, for binary conversions<br>
<b>Convert<br></b>The .NET Framework calls the following types <i>base types</i>:<br>
· bool, char, string, System.DateTime, and System.DateTimeOffset<br>· All of the C# numeric types<br>
The static Convert class defines methods for converting every base type to every other<br>base type. Unfortunately, most of these methods are useless: either they throw ex-<br>ceptions or they are redundant alongside implicit casts. Among the clutter, however,<br>are some useful methods, listed in the following sections.<br>
All base types (explicitly) implement IConvertible, which de-<br>fines methods for converting to every other base type. In most<br>cases, the implementation of each of these methods simply calls<br>a method in Convert. On rare occasions, it can be useful to write<br>a method that accepts an argument of type IConvertible.<br>
<b>Rounding real to integral conversions<br></b>In Chapter 2, we saw how implicit and explicit casts allow you to convert between<br>numeric types. In summary:<br>
· Implicit casts work for nonlossy conversions (e.g., int to double).<br>· Explicit casts are required for lossy conversions (e.g., double to int).<br>
Casts are optimized for efficiency; hence, they <i>truncate</i> data that won't fit. This can<br>be a problem when converting from a real number to an integer, because often you<br>
<b>232 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=253></a>want to <i>round</i> rather than truncate. Convert's numerical conversion methods address<br>just this issue; they always <i>round</i>:<br>
double d = 3.9;<br>int i = <b>Convert.ToInt32</b> (d);    // i == 4<br>
Convert uses banker's rounding, which snaps midpoint values to even integers (this<br>avoids  positive  or  negative  bias).  If  banker's  rounding  is  a  problem,  first  call<br>Math.Round on the real number; this accepts an additional argument that allows you<br>to control midpoint rounding.<br>
<b>Parsing numbers in base 2, 8, and 16<br></b>Hidden among the To(<i>integral-type</i>) methods are overloads that parse numbers in<br>another base:<br>
int thirty = Convert.ToInt32  (&quot;1E&quot;, 16);    // Parse in hexadecimal<br>
uint five  = Convert.ToUInt32 (&quot;101&quot;, 2);    // Parse in binary<br>
The second argument specifies the base. It can be any base you like--as long as it's<br>2, 8, 10, or 16!<br>
<b>Dynamic conversions<br></b>Occasionally, you need to convert from one type to another--but you don't know<br>what the types are until runtime. For this, the Convert class provides a ChangeType<br>method:<br>
public static object ChangeType (object value, Type conversionType);<br>
The source and target types must be one of the "base" types. ChangeType also accepts<br>an optional IFormatProvider argument. Here's an example:<br>
Type targetType = typeof (int);<br>
<b>FW Fundamentals</b><br>
object source = &quot;42&quot;;<br>
object result = Convert.ChangeType (source, targetType);<br>
Console.WriteLine (result);             // 42<br>Console.WriteLine (result.GetType());   // System.Int32<br>
An example of when this might be useful is in writing a deserializer that can work<br>with  multiple  types.  It  can  also  convert  any  enum  to  its  integral  type  (see<br>"Enums" on page 240).<br>
A limitation of ChangeType is that you cannot specify a format string or parsing flag.<br>
<b>Base 64 conversions<br></b>Sometimes you need to include binary data such as a bitmap within a text document<br>such as an XML file or email message. Base 64 is a ubiquitous means of encoding<br>binary data as readable characters, using 64 characters from the ASCII set.<br>
Convert's  ToBase64String  method  converts  from  a  byte  array  to  base  64;<br>FromBase64String does the reverse.<br>
<b>Other Conversion Mechanisms | 233</b><br>
<hr>
<A name=254></a><b>XmlConvert<br></b>If  you're  dealing  with  data  that's  originated  from  or  destined  for  an  XML  file,<br>XmlConvert (the System.Xml namespace) provides the most suitable methods for for-<br>matting  and  parsing.  The  methods  in  XmlConvert  handle  the  nuances  of  XML<br>formatting  without  needing  special  format  strings.  For  instance,  true  in  XML  is<br>"true" and not "True". The .NET Framework internally uses XmlConvert extensively.<br>XmlConvert is also good for general-purpose culture-independent serialization.<br>
The  formatting  methods  in  XmlConvert  are  all  provided  as  overloaded  ToString<br>methods;  the  parsing  methods  are  called  ToBoolean,  ToDateTime,  and  so  on.  For<br>example:<br>
string s = XmlConvert.ToString (true);         // s = &quot;true&quot;<br>bool isTrue = XmlConvert.ToBoolean (s);<br>
The methods that convert to and from DateTime accept an XmlDateTimeSerializa<br>tionMode argument. This is an enum with the following values:<br>
Unspecified, Local, Utc, RoundtripKind<br>
Local and Utc cause a conversion to take place when formatting (if the DateTime is<br>not already in that time zone). The time zone is then appended to the string:<br>
2010-02-22T14:08:30.9375           // Unspecified<br>
2010-02-22T14:07:30.9375+09:00     // Local<br>2010-02-22T05:08:30.9375Z          // Utc<br>
Unspecified  strips  away  any  time  zone  information  embedded  in  the  DateTime<br>(i.e.,  DateTimeKind)  before  formatting.  RoundtripKind  honors  the  DateTime's<br>DateTimeKind--so when it's reparsed, the resultant DateTime struct will be exactly as<br>it was originally.<br>
<b>Type Converters<br></b>Type  converters  are  designed  to  format  and  parse  in  design-time  environments.<br>They  also  parse  values  in  XAML  (Extensible  Application  Markup  Language)<br>documents--as  used  in  Windows  Presentation  Foundation  and  Workflow<br>Foundation.<br>
In the .NET Framework, there are more than 100 type converters--covering such<br>things as colors, images, and URIs. In contrast, format providers are implemented<br>for only a handful of simple value types.<br>
Type converters typically parse strings in a variety of ways--without needing hints.<br>For instance, in an ASP.NET application in Visual Studio, if you assign a control a<br>BackColor by typing <b>&quot;Beige&quot;</b> into the property window, Color's type converter figures<br>out that you're referring to a color name and not an RGB string or system color. This<br>flexibility can sometimes make type converters useful in contexts outside of design-<br>ers and XAML documents.<br>
All  type  converters  subclass  TypeConverter  in  System.ComponentModel.  To  obtain<br>a  TypeConverter,  call  TypeDescriptor.GetConverter.  The  following  obtains  a<br>
<b>234 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=255></a>TypeConverter for the Color type (in the System.Drawing namespace, <i>System.Draw-<br>ing.dll</i>):<br>
TypeConverter cc = TypeDescriptor.GetConverter (typeof (Color));<br>
Among many other methods, TypeConverter defines methods to ConvertToString<br>and ConvertFromString. We can call these as follows:<br>
Color beige  = (Color) cc.ConvertFromString (&quot;Beige&quot;);<br>
Color purple = (Color) cc.ConvertFromString (&quot;#800080&quot;);<br>Color window = (Color) cc.ConvertFromString (&quot;Window&quot;);<br>
By convention, type converters have names ending in <i>Converter</i> and are usually in<br>the same namespace as the type they're converting. A type links to its converter via<br>a TypeConverterAttribute, allowing designers to pick up converters automatically.<br>Type converters can also provide design-time services such as generating standard<br>value  lists  for  populating  a  drop-down  list  in  a  designer  or  assisting  with  code<br>serialization.<br>
<b>BitConverter<br></b>Most base types can be converted to a byte array, by calling BitConverter.GetBytes:<br>
foreach (byte b in BitConverter.GetBytes (3.5))<br>
  Console.Write (b + &quot; &quot;);                          // 0 0 0 0 0 0 12 64<br>
BitConverter also provides methods for converting in the other direction, such as<br>ToDouble.<br>
The decimal and DateTime(Offset) types are not supported by BitConverter. You<br>can, however, convert a decimal to an int array by calling decimal.GetBits. To go<br>the other way around, decimal provides a constructor that accepts an int array.<br>
<b>FW Fundamentals</b><br>
In the case of DateTime, you can call ToBinary on an instance--this returns a long<br>(upon  which  you  can  then  use  BitConverter).  The  static  DateTime.FromBinary<br>method does the reverse.<br>
<b>Globalization<br></b>There  are  two  aspects  to  <i>internationalizing</i>  an  application:  <i>globalization</i>  and <br><i>localization</i>.<br>
<i>Globalization</i> is concerned with three tasks (in decreasing order of importance):<br>
1. Making sure that your program doesn't <i>break</i> when run in another culture<br>2. Respecting a local culture's formatting rules--for instance, when displaying<br>
dates<br>
3. Designing your program so that it picks up culture-specific data and strings<br>
from satellite assemblies that you can later write and deploy<br>
<i>Localization</i> means concluding that last task by writing satellite assemblies for spe-<br>cific cultures. This can be done <i>after</i> writing your program--we cover the details in<br>"Resources and Satellite Assemblies" on page 663 in Chapter 17.<br>
<b>Globalization | 235</b><br>
<hr>
<A name=256></a>The .NET Framework helps you with the second task by applying culture-specific<br>rules by default. We've already seen how calling ToString on a DateTime or number<br>respects local formatting rules. Unfortunately, this makes it easy to fail the first task<br>and have your program break because you're expecting dates or numbers to be for-<br>matted according to an assumed culture. The solution, as we've seen, is either to<br>specify a culture (such as the invariant culture) when formatting and parsing, or to<br>use culture-independent methods such as those in XmlConvert.<br>
<b>Globalization Checklist<br></b>We've already covered the important points in this chapter. Here's a summary of<br>the essential work required:<br>
· Understand  Unicode  and  text  encodings  (see  "Text  Encodings  and  Uni-<br>
code" on page 203).<br>
· Be mindful that methods such as ToUpper and ToLower on char and string are<br>
culture-sensitive:  use  ToUpperInvariant/ToLowerInvariant  unless  you  want<br>culture-sensitivity.<br>
· Favor culture-independent formatting and parsing mechanisms for  DateTime<br>
and DateTimeOffsets such as ToString(&quot;o&quot;) and XmlConvert.<br>
· Otherwise, specify a culture when formatting/parsing numbers or date/times<br>
(unless you <i>want</i> local-culture behavior).<br>
<b>Testing<br></b>You can test against different cultures by reassigning Thread's CurrentCulture prop-<br>erty (in System.Threading). The following changes the current culture to Turkey:<br>
Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo (&quot;tr-TR&quot;);<br>
Turkey is a particularly good test case because:<br>
· &quot;i&quot;.ToUpper() != &quot;I&quot; and &quot;I&quot;.ToLower() != &quot;i&quot;.<br>· Dates are formatted as day/month/year, and with a period separator.<br>· The decimal point indicator is a comma instead of a period.<br>
You  can  also  experiment  by  changing  the  number  and  date  formatting  settings<br>in  the  Windows  Control  Panel:  these  are  reflected  in  the  default  culture<br>(CultureInfo.CurrentCulture).<br>
CultureInfo.GetCultures() returns an array of all available cultures.<br>
Thread and CultureInfo also support a CurrentUICulture prop-<br>erty. This is concerned more about localization: we cover this<br>in Chapter 17.<br>
<b>236 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=257></a><b>Working with Numbers<br>Conversions<br></b>We covered numeric conversions in previous chapters and sections; Table 6-7 sum-<br>marizes all the options.<br>
<i>Table 6-7. Summary of numeric conversions</i><br>
<b>Task</b><br>
<b>Functions</b><br>
<b>Examples</b><br>
Parsing base 10 numbers<br>
Parse<br>
double d = double.Parse (&quot;3.5&quot;);<br>
TryParse<br>
int i;<br>
bool ok = int.TryParse (&quot;3&quot;, out i);<br>
Parsing from base 2, 8, or 16<br>
Convert.To<i>Integral</i><br>
int i = Convert.ToInt32 (&quot;1E&quot;, 16);<br>
Formatting to hexadecimal<br>
ToString (&quot;X&quot;)<br>
string hex = 45.ToString (&quot;X&quot;);<br>
Lossless numeric conversion<br>
Implicit cast<br>
int i = 23;<br>
double d = d;<br>
Truncating numeric conversion<br>
Explicit cast<br>
double d = 23.5;<br>
int i = (int) d;<br>
Rounding numeric conversion<br>
Convert.To<i>Integral</i><br>
double d = 23.5;<br>
(real to integral)<br>
int i = Convert.ToInt32 (d);<br>
<b>Math<br></b>Table 6-8 lists the members of the static Math class. The trigonometric functions<br>
<b>FW Fundamentals</b><br>
accept arguments of type double; other methods such as Max are overloaded to op-<br>erate on all numeric types. The Math class also defines the mathematical constants<br>E (<i>e</i>) and PI.<br>
<i>Table 6-8. Methods in the static Math class</i><br>
<b>Category</b><br>
<b>Methods</b><br>
Rounding<br>
Round, Truncate, Floor, Ceiling<br>
Maximum/minimum<br>
Max, Min<br>
Absolute value and sign<br>
Abs, Sign<br>
Square root<br>
Sqrt<br>
Raising to a power<br>
Pow, Exp<br>
Logarithm<br>
Log, Log10<br>
Trigonometric<br>
Sin, Cos, Tan<br>
Sinh, Cosh, Tanh<br>
Asin, Acos, Atan<br>
<b>Working with Numbers | 237</b><br>
<hr>
<A name=258></a>The  Round  method  lets  you  specify  the  number  of  decimal  places  with  which  to<br>round, as well as how to handle midpoints (away from zero, or with banker's round-<br>ing). Floor and Ceiling round to the nearest integer: Floor always rounds down and<br>Ceiling always rounds up--even with negative numbers.<br>
Max and Min accept only two arguments. If you have an array or sequence of numbers,<br>use the Max and Min extension methods in System.Linq.Enumerable.<br>
<b>BigInteger<br></b>The BigInteger struct is a specialized numeric type new to .NET Framework 4.0. It<br>lives in the new System.Numerics namespace in <i>System.Numerics.dll</i> and allows you<br>to represent an arbitrarily large integer without any loss of precision.<br>
C# doesn't provide native support for BigInteger, so there's no way to represent<br>BigInteger literals. You can, however, implicitly cast from any other integral type<br>to a BigInteger. For instance:<br>
BigInteger twentyFive = 25;      // implicit cast from integer<br>
To  represent  a  bigger  number,  such  as  one  googol  (10100),  you  can  use  one  of<br>BigInteger's static methods, such as PoW (raise to the power):<br>
BigInteger googol = BigInteger.Pow (10, 100);<br>
Alternatively, you can Parse a string:<br>
BigInteger googol = BigInteger.Parse (&quot;1&quot;.PadRight (100, '0'));<br>
Calling ToString() on this prints every digit:<br>
Console.WriteLine (googol.<b>ToString()</b>); // 10000000000000000000000000000<br>00000000000000000000000000000000000000000000000000000000000000000000000<br>
You can implicitly cast a BigInteger to a standard numeric type and explicitly cast<br>in the other direction. For instance:<br>
double g1 = 1e100;                  // implicit cast<br>BigInteger g2 = (BigInteger) g1;    // explicit cast<br>Console.WriteLine (g2);<br>
You  lose  precision  when  converting  a  large  BigInteger  to  another  type,  such  as<br>double. The output of the preceding example demonstrates this:<br>
1000000000000000015902891109759918046836080856394528138978132755774...<br>
BigInteger overloads all the arithmetic operators, as well as the comparison, equal-<br>ity, modulus (%), and negation operators.<br>You  can  also  construct  a  BigInteger  from  a  byte  array.  The  following  code<br>generates a 32-byte random number suitable for cryptography and then assigns it to<br>a BigInteger:<br>
// This uses the System.Security.Cryptography namespace:<br>RandomNumberGenerator rand = RandomNumberGenerator.Create();<br>byte[] bytes = new byte [32];<br>rand.GetBytes (bytes);<br>var bigRandomNumber = new BigInteger (bytes);   // Convert to BigInteger<br>
<b>238 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=259></a>The advantage of storing such a number in a BigInteger over a byte array is that you<br>get value-type semantics. Calling ToByteArray converts a BigInteger back to a byte<br>array.<br>
<b>Complex<br></b>The Complex struct is another specialized numeric type new to Framework 4.0, and<br>is for representing complex numbers with real and imaginary components of type<br>double. Complex resides in the <i>System.Numerics.dll</i> assembly (along with BigInteger).<br>
To use Complex, instantiate the struct, specifying the real and imaginary values:<br>
var c1 = new Complex (2, 3.5);<br>
var c2 = new Complex (3, 0);<br>
There are also implicit conversions from the standard numeric types.<br>
The Complex struct exposes properties for the real and imaginary values, as well as<br>the phase and magnitude:<br>
Console.WriteLine (c1.Real);       // 2<br>
Console.WriteLine (c1.Imaginary);  // 3.5<br>Console.WriteLine (c1.Phase);      // 1.05165021254837<br>
Console.WriteLine (c1.Magnitude);  // 4.03112887414927<br>
You can also construct a Complex number by specifying magnitude and phase:<br>
Complex c3 = Complex.FromPolarCoordinates (1.3, 5);<br>
The standard arithmetic operators are overloaded to work on Complex numbers:<br>
Console.WriteLine (c1 + c2);    // (5, 3.5)<br>Console.WriteLine (c1 * c2);    // (6, 10.5)<br>
The Complex struct exposes static methods for more advanced functions, including:<br>
<b>FW Fundamentals</b><br>
· Trigonometric (Sin, Asin, Sinh, Tan, etc.)<br>· Logarithms and exponentiations<br>· Conjugate<br>
<b>Random<br></b>The Random class generates a pseudorandom sequence of random bytes, integers, or<br>doubles.<br>
To use Random, you first instantiate it, optionally providing a seed to initiate the<br>random number series. Using the same seed guarantees the same series of numbers,<br>which is sometimes useful when you want reproducibility:<br>
Random r1 = new Random (1);<br>Random r2 = new Random (1);<br>Console.WriteLine (r1.Next (100) + &quot;, &quot; + r1.Next (100));      // 24, 11<br>Console.WriteLine (r2.Next (100) + &quot;, &quot; + r2.Next (100));      // 24, 11<br>
<b>Working with Numbers | 239</b><br>
<hr>
<A name=260></a>If you don't want reproducibility, you can construct Random with no seed--then it<br>uses the current system time to make one up.<br>
Because the system clock has limited granularity, two Random<br>instances  created  close  together  (typically  within  10  ms)  will<br>yield the same sequence of values. A common trap is to instan-<br>tiate a new Random object every time you need a random number,<br>rather than reusing the <i>same</i> object.<br>
A good pattern is to declare a single static Random instance. In<br>multithreaded scenarios, however, this can cause trouble be-<br>cause Random objects are not thread-safe. We describe a work-<br>around in "Thread-Local Storage" on page 862 in Chapter 21.<br>
Calling Next(<i>n</i>) generates a random integer between 0 and <i>n</i>-1. NextDouble generates<br>a random double between 0 and 1. NextBytes fills a byte array with random values.<br>
Random  is  not  considered  random  enough  for  high-security  applications,  such  as<br>cryptography. For this, the .NET Framework provides a <i>cryptographically strong<br></i>random number generator, in the System.Security.Cryptography namespace. Here's<br>how it's used:<br>
var rand = System.Security.Cryptography.RandomNumberGenerator.Create();<br>
byte[] bytes = new byte [32];<br>
rand.GetBytes (bytes);       // Fill the byte array with random numbers.<br>
The downside is that it's less flexible: filling a byte array is the only means of ob-<br>taining random numbers. To obtain an integer, you must use BitConverter:<br>
byte[] bytes = new byte [4];<br>rand.GetBytes (bytes);<br>int i = BitConverter.ToInt32 (bytes, 0);<br>
<b>Enums<br></b>In Chapter 3, we described C#'s enum type, and showed how to combine members,<br>test equality, use logical operators, and perform conversions. The Framework ex-<br>tends C#'s support for enums through the System.Enum type. This type has two roles:<br>providing type unification for all enum types and defining static utility methods.<br><i>Type unification</i> means you can implicitly cast any enum member to a System.Enum<br>instance:<br>
enum Nut  { Walnut, Hazelnut, Macadamia }<br>enum Size { Small, Medium, Large }<br>
static void Main()<br>{<br>  Display (Nut.Macadamia);     // Nut.Macadamia<br>  Display (Size.Large);        // Size.Large<br>}<br> <br>
<b>240 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=261></a>static void Display (Enum value)<br>
{<br>  Console.WriteLine (value.GetType().Name + &quot;.&quot; + value.ToString());<br>}<br>
The static utility methods on System.Enum are primarily related to performing con-<br>versions and obtaining lists of members.<br>
<b>Enum Conversions<br></b>There are three ways to represent an enum value:<br>
· As an enum member<br>· As its underlying integral value<br>· As a string<br>
In this section, we describe how to convert between each.<br>
<b>Enum to integral conversions<br></b>Recall that an explicit cast converts between an enum member and its integral value.<br>An explicit cast is the correct approach if you know the enum type at compile time:<br>
[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }<br>
...<br>
int i = <b>(int)</b> BorderSides.Top;            // i == 4<br>
BorderSides side = <b>(BorderSides)</b> i;       // side == BorderSides.Top<br>
You can cast a System.Enum instance to its integral type in the same way. The trick<br>is to first cast to an object, and then the integral type:<br>
static int GetIntegralValue (Enum anyEnum)<br>
<b>FW Fundamentals</b><br>
{<br>  return (int) (object) anyEnum;<br>}<br>
This relies on you knowing the integral type: the method we just wrote would crash<br>if passed an enum whose integral type was long. To write a method that works with<br>an enum of any integral type, you can take one of three approaches. The first is to call<br>Convert.ToDecimal:<br>
static decimal GetAnyIntegralValue (Enum anyEnum)<br>{<br>  return Convert.ToDecimal (anyEnum);<br>}<br>
This works because every integral type (including ulong) can be converted to decimal<br>without  loss  of  information.  The  second  approach  is  to  call  Enum.GetUnderlying<br>Type in order to obtain the enum's integral type, and then call Convert.ChangeType:<br>
<b>Enums | 241</b><br>
<hr>
<A name=262></a>static object GetBoxedIntegralValue (Enum anyEnum)<br>
{<br>  Type integralType = Enum.GetUnderlyingType (anyEnum.GetType());<br>  return Convert.ChangeType (anyEnum, integralType);<br>
}<br>
This preserves the original integral type, as the following example shows:<br>
object result = GetBoxedIntegralValue (BorderSides.Top);<br>
Console.WriteLine (result);                               // 4<br>Console.WriteLine (result.GetType());                     // System.Int32<br>
Our  GetBoxedIntegralType  method  in  fact  performs  no  value<br>conversion; rather, it <i>reboxes</i> the same value in another type. It<br>translates an integral value in <i>enum-type</i> clothing to an integral<br>value in <i>integral-type</i> clothing. We describe this further in "How<br>Enums Work" on page 243.<br>
The third approach is to call Format or ToString specifying the &quot;d&quot; or &quot;D&quot; format<br>string. This gives you the enum's integral value as a string, and it is useful when writing<br>custom serialization formatters:<br>
static string GetIntegralValueAsString (Enum anyEnum)<br>
{<br>  return anyEnum.ToString (&quot;D&quot;);      // returns something like &quot;4&quot;<br>}<br>
<b>Integral to enum conversions<br></b>Enum.ToObject converts an integral value to an enum instance of the given type:<br>
object bs = Enum.ToObject (typeof (BorderSides), 3);<br>Console.WriteLine (bs);                              // Left, Right<br>
This is the dynamic equivalent of this:<br>
BorderSides bs = (BorderSides) 3;<br>
ToObject is overloaded to accept all integral types, as well as object. (The latter works<br>with any boxed integral type.)<br>
<b>String conversions<br></b>To convert an enum to a string, you can either call the static Enum.Format method or<br>call ToString on the instance. Each method accepts a format string, which can be<br>&quot;G&quot; for default formatting behavior, &quot;D&quot; to emit the underlying integral value as a<br>string, &quot;X&quot; for the same in hexadecimal, or &quot;F&quot; to format combined members of an<br>enum without the Flags attribute. We listed examples of these in "Standard Format<br>Strings and Parsing Flags" on page 225.<br>
Enum.Parse converts a string to an enum. It accepts the enum type and a string that can<br>include multiple members:<br>
BorderSides leftRight = (BorderSides) Enum.Parse (typeof (BorderSides),<br>                                                  &quot;Left, Right&quot;);<br>
<b>242 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=263></a>An  optional  third  argument  lets  you  perform  case-insensitive  parsing.  A<br>FormatException is thrown if the member is not found.<br>
<b>Enumerating Enum Values<br></b>Enum.GetValues returns an array comprising all members of a particular enum type:<br>
foreach (Enum value in Enum.GetValues (typeof (BorderSides)))<br>  Console.WriteLine (value);<br>
Composite members such as LeftRight = Left | Right are included, too.<br>
Enum.GetNames performs the same function, but returns an array of <i>strings</i>.<br>
Internally, the CLR implements GetValues and GetNames by re-<br>flecting over the fields in the enum's type. The results are cached<br>for efficiency.<br>
<b>How Enums Work<br></b>The semantics of enums are enforced largely by the compiler. In the CLR, there's no<br>runtime difference between an enum instance (when unboxed) and its underlying<br>integral  value.  Further,  an  enum  definition  in  the  CLR  is  merely  a  subtype  of<br>System.Enum with static integral-type fields for each member. This makes the ordi-<br>nary use of an enum highly efficient, with a runtime cost matching that of integral<br>constants.<br>
The downside of this strategy is that enums can provide <i>static</i> but not <i>strong</i> type<br>safety. We saw an example of this in Chapter 3:<br>
<b>FW Fundamentals</b><br>
public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }<br>...<br>BorderSides b = BorderSides.Left;<br>b += 1234;                          // No error!<br>
When the compiler is unable to perform validation (as in this example), there's no<br>backup from the runtime to throw an exception.<br>
What we said about there being no runtime difference between an enum instance and<br>its integral value might seem at odds with the following:<br>
[Flags] public enum BorderSides { Left=1, Right=2, Top=4, Bottom=8 }<br>...<br>Console.WriteLine (BorderSides.Right.ToString());        // Right<br>Console.WriteLine (BorderSides.Right.GetType().Name);    // BorderSides<br>
Given the nature of an enum instance at runtime, you'd expect this to print 2 and<br>Int32!  The  reason  for  its  behavior  is  down  to  some  more  compile-time  trickery.<br>C#  explicitly  <i>boxes</i>  an  enum instance before calling its virtual methods--such as<br>ToString or GetType. And when an enum instance is boxed, it gains a runtime wrap-<br>ping that references its enum type.<br>
<b>Enums | 243</b><br>
<hr>
<A name=264></a><b>Tuples<br></b>Framework 4.0 provides a new set of generic classes for holding a set of differently<br>typed elements. These are called <i>tuples</i>:<br>
public class Tuple &lt;T1&gt;<br>public class Tuple &lt;T1, T2&gt;<br>public class Tuple &lt;T1, T2, T3&gt;<br>
public class Tuple &lt;T1, T2, T3, T4&gt;<br>
public class Tuple &lt;T1, T2, T3, T4, T5&gt;<br>
public class Tuple &lt;T1, T2, T3, T4, T5, T6&gt;<br>public class Tuple &lt;T1, T2, T3, T4, T5, T6, T7&gt;<br>
public class Tuple &lt;T1, T2, T3, T4, T5, T6, T7, TRest&gt;<br>
Each  has  read-only  properties  called  Item1,  Item2,  and  so  on  (one  for  each  type<br>parameter).<br>
You can instantiate a tuple either via its constructor:<br>
var t = new Tuple&lt;int,string&gt; (123, &quot;Hello&quot;);<br>
or via the static helper method Tuple.Create:<br>
Tuple&lt;int,string&gt; t = Tuple.Create (123, &quot;Hello&quot;);<br>
The  latter  leverages  generic  type  inference.  You  can  combine  this  with  implicit<br>typing:<br>
var t = Tuple.Create (123, &quot;Hello&quot;);<br>
You can then access the properties as follows (notice that each is statically typed):<br>
Console.WriteLine (t.Item1 * 2);         // 246<br>
Console.WriteLine (t.Item2.ToUpper());   // HELLO<br>
Tuples are convenient in returning more than one value from a method--or creating<br>collections of value <i>pairs</i> (we'll cover collections in the following chapter).<br>
An alternative to tuples is to use an object array. However, you then lose static type<br>safety, incur the cost of boxing/unboxing for value types, and require clumsy casts<br>that cannot be validated by the compiler:<br>
object[] items = { 123, &quot;Hello&quot; };<br>Console.WriteLine ( ((int)    items[0]) * 2       );   // 246<br>Console.WriteLine ( ((string) items[1]).ToUpper() );   // HELLO<br>
<b>Comparing Tuples<br></b>Tuples are classes (and therefore reference types). In keeping with this, comparing<br>two  distinct  instances  with  the  equality  operator  returns  false.  However,  the<br>Equals method is overridden to compare each individual element instead:<br>
var t1 = Tuple.Create (123, &quot;Hello&quot;);<br>var t2 = Tuple.Create (123, &quot;Hello&quot;);<br>Console.WriteLine (t1 == t2);           // False<br>Console.WriteLine (t1.Equals (t2));     // True<br>
<b>244 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=265></a>You can also pass in a custom equality comparer (by virtue of tuples implementing<br>IStructuralEquatable).  We  cover  equality  and  order  comparison  later  in  this<br>chapter.<br>
<b>The Guid Struct<br></b>The Guid struct represents a globally unique identifier: a 16-byte value that, if ran-<br>domly generated, will almost certainly be unique in the world. Guids are often used<br>for keys of various sorts--in applications and databases. There are 2128 or 3.4 ×<br>1038 unique Guids.<br>To create a new random Guid, call the static Guid.NewGuid method:<br>
Guid g = Guid.NewGuid ();<br>
Console.WriteLine (g.ToString());  // 0d57629c-7d6e-4847-97cb-9e2fc25083fe<br>
To instantiate an existing value, use one of the constructors. The two most useful<br>constructors are:<br>
public Guid (byte[] b);    // Accepts a 16-byte array<br>
public Guid (string g);    // Accepts a formatted string<br>
When represented as a string, a Guid is formatted as a 32-digit hexadecimal number,<br>with optional hyphens after the 8th, 12th, 16th, and 20th digits. The whole string<br>can also be optionally wrapped in brackets or braces:<br>
Guid g1 = new Guid (&quot;{0d57629c-7d6e-4847-97cb-9e2fc25083fe}&quot;);<br>
Guid g2 = new Guid (&quot;0d57629c7d6e484797cb9e2fc25083fe&quot;);<br>Console.WriteLine (g1 == g2);  // True<br>
Being  a  struct,  a  Guid  honors  value-type  semantics;  hence,  the  equality  operator<br>works in the preceding example.<br>
The <br>
<b>FW Fundamentals</b><br>
ToByteArray method converts a Guid to a byte array.<br>
The static Guid.Empty property returns an empty Guid (all zeros). This is often used<br>in place of null.<br>
<b>Equality Comparison<br></b>Until now, we've assumed that the == and != operators are all there is to equality<br>comparison. The issue of equality, however, is more complex and subtler, sometimes<br>requiring the use of additional methods and interfaces. This section explores the<br>standard  C#  and  .NET  protocols  for  equality,  focusing  particularly  on  two<br>questions:<br>
· When are == and != adequate--and inadequate--for equality comparison, and<br>
what are the alternatives?<br>
· How and when should you customize a type's equality logic?<br>
But before exploring the details of equality protocols and how to customize them,<br>we must first look at the preliminary concept of value versus referential equality.<br>
<b>Equality Comparison | 245</b><br>
<hr>
<A name=266></a><b>Value Versus Referential Equality<br></b>There are two kinds of equality:<br>
<i>Value equality</i><br>
Two values are <i>equivalent</i> in some sense.<br>
<i>Referential equality</i><br>
Two references refer to <i>exactly the same object</i>.<br>
By default:<br>
· Value types use <i>value equality</i>.<br>· Reference types use <i>referential equality</i>.<br>
Value types, in fact, can <i>only</i> use value equality (unless boxed). A simple demon-<br>stration of value equality is to compare two numbers:<br>
int x = 5, y = 5;<br>
Console.WriteLine (x == y);   // True <i>(by virtue of value equality)</i><br>
A more elaborate demonstration is to compare two DateTimeOffset structs. The fol-<br>lowing prints True because the two DateTimeOffsets refer to the <i>same point in time<br></i>and so are considered equivalent:<br>
var dt1 = new DateTimeOffset (2010, 1, 1, <b>1</b>, 1, 1, TimeSpan.FromHours(<b>8</b>));<br>
var dt2 = new DateTimeOffset (2010, 1, 1, <b>2</b>, 1, 1, TimeSpan.FromHours(<b>9</b>));<br>
Console.WriteLine (dt1 == dt2);   // True<br>
DateTimeOffset is a struct whose equality semantics have been<br>tweaked.  By  default,  structs  exhibit  a  special  kind  of  value<br>equality called <i>structural equality</i>, where two values are consid-<br>ered equal if all of their members are equal. (You can see this by<br>creating a struct and calling its Equals method; more on this<br>later.)<br>
Reference types exhibit referential equality by default. In the following example,<br>f1 and f2 are not equal--despite their objects having identical content:<br>
class Foo { public int X; }<br>...<br>Foo f1 = new Foo { X = 5 };<br>Foo f2 = new Foo { X = 5 };<br>Console.WriteLine (f1 == f2);   // False<br>
In contrast, f3 and f1 are equal because they reference the same object:<br>
Foo f3 = f1;<br>Console.WriteLine (f1 == f3);   // True<br>
We'll explain later in this section how reference types can be <i>customized</i> to exhibit<br>value equality. An example of this is the Uri class in the System namespace:<br>
<b>246 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=267></a>Uri uri1 = new Uri (&quot;http://www.linqpad.net&quot;);<br>
Uri uri2 = new Uri (&quot;http://www.linqpad.net&quot;);<br>Console.WriteLine (uri1 == uri2);              // True<br>
<b>Standard Equality Protocols<br></b>There are three standard protocols types can implement for equality comparison:<br>
· The == and != operators<br>· The virtual Equals method in object<br>· The IEquatable&lt;T&gt; interface<br>
In addition, there are the <i>pluggable</i> protocols and the IStructuralEquatable interface<br>which we describe in Chapter 7.<br>
<b>== and !=<br></b>We've already seen in many examples how the standard == and != operators perform<br>equality/inequality comparisons. The subtleties with == and != arise because they<br>are  <i>operators</i>,  and  so  are  statically  resolved  (in  fact,  they  are  implemented  as<br>static functions). So, when you use == or !=, C# makes a <i>compile-time</i> decision as<br>to which type will perform the comparison, and no virtual behavior comes into<br>play. This is normally desirable. In the following example, the compiler hard-wires<br>== to the int type because x and y are both int:<br>
int x = 5;<br>int y = 5;<br>Console.WriteLine (x == y);      // True<br>
But in the next example, the compiler wires the == operator to the object type:<br>
object x = 5;<br>object y = 5;<br>
<b>FW Fundamentals</b><br>
Console.WriteLine (x == y);      // False<br>
Because object is a class (and so a reference type), object's == operator uses <i>refer-<br>ential equality</i> to compare x and y. The result is false, because x and y each refer to<br>different boxed objects on the heap.<br>
<b>The virtual Object.Equals method<br></b>To  correctly  equate  x  and  y  in  the  preceding  example,  we  can  use  the  virtual <br>Equals method. Equals is defined in System.Object, and so is available to all types:<br>
object x = 5;<br>object y = 5;<br>Console.WriteLine (<b>x.Equals (y)</b>);      // True<br>
Equals is resolved at runtime--according to the object's actual type. In this case, it<br>calls Int32's Equals method, which applies <i>value equality</i> to the operands, returning<br>true.  With  reference  types,  Equals  performs  referential  equality  comparison  by<br>default; with structs, Equals performs structural comparison by calling Equals on<br>each of its fields.<br>
<b>Equality Comparison | 247</b><br>
<hr>
<A name=268></a><b>Why the Complexity?</b><br>
You might wonder why the designers of C# didn't avoid the problem by making<br>== virtual, and so functionally identical to Equals. There are three reasons for this:<br>
· If the first operand is null, Equals fails with a NullReferenceException; a static<br>
operator does not.<br>
· Because the == operator is statically resolved, it executes extremely quickly.<br>
This  means  that  you  can  write  computationally  intensive  code  without<br>penalty--and without needing to learn another language such as C++.<br>
· Sometimes it can be useful to have == and Equals apply different definitions<br>
of equality. We describe this scenario later in this section.<br>
Hence, Equals is suitable for equating two objects in a type-agnostic fashion. The<br>following method equates two objects of any type:<br>
public static bool AreEqual (object obj1, object obj2)<br>
{<br>  return obj1.Equals (obj2);<br>
}<br>
There is one case, however, in which this fails. If the first argument is null, you get<br>a NullReferenceException. Here's the fix:<br>
public static bool AreEqual (object obj1, object obj2)<br>
{<br>  <b>if (obj1 == null) return obj2 == null;<br></b>  return obj1.Equals (obj2);<br>
}<br>
<b>The static object.Equals method<br></b>The object class provides a static helper method that does the work of AreEqual in<br>the preceding example. Its name is Equals--just like the virtual method--but there's<br>no conflict because it accepts <i>two</i> arguments:<br>
public static bool Equals (object objA, object objB)<br>
This provides a null-safe equality comparison algorithm for when the types are un-<br>known at compile time. For example:<br>
object x = 3, y = 3;<br>Console.WriteLine (object.Equals (x, y));   // True<br>x = null;<br>Console.WriteLine (object.Equals (x, y));   // False<br>y = null;<br>Console.WriteLine (object.Equals (x, y));   // True<br>
A  useful  application  is  when  writing  generic  types.  The  following  code  will  not<br>compile if object.Equals is replaced with the == or != operator:<br>
class Test &lt;T&gt;<br>{<br>  T _value;<br>  public void SetValue (T newValue)<br>
<b>248 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=269></a>  {<br>
    <b>if (!object.Equals (newValue, _value))<br></b>    {<br>      _value = newValue;<br>
      OnValueChanged();<br>
    }<br>  }<br>  protected virtual void OnValueChanged() { ... }<br>
}<br>
Operators are prohibited here because the compiler cannot bind to the static method<br>of an unknown type.<br>
A more elaborate way to implement this comparison is with the<br>EqualityComparer&lt;T&gt; class. This has the advantage of avoiding<br>boxing:<br>
if (!<b>EqualityComparer&lt;T&gt;.Default.Equals</b> (newValue, _value))<br>
We  discuss  EqualityComparer&lt;T&gt; in more detail in  Chapter 7<br>(see "Plugging in Equality and Order" on page 304).<br>
<b>The static object.ReferenceEquals method<br></b>Occasionally,  you  need  to  force  referential  equality  comparison.  The  static<br>object.ReferenceEquals method does just this:<br>
class Widget { ... }<br>
class Test<br>
{<br>  static void Main()<br>  {<br>
<b>FW Fundamentals</b><br>
    Widget w1 = new Widget();<br>    Widget w2 = new Widget();<br>    <b>Console.WriteLine (object.ReferenceEquals (w1, w2));     // False<br></b>  }<br>}<br>
You might want to do this because it's possible for Widget to override the virtual<br>Equals method, such that w1.Equals(w2) would return true. Further, it's possible for<br>Widget to overload the == operator so that w1==w2 would also return true. In such<br>cases,  calling  object.ReferenceEquals  guarantees  normal  referential  equality<br>semantics.<br>
Another way to force referential equality comparison is to cast<br>the values to object and then apply the == operator.<br>
<b>Equality Comparison | 249</b><br>
<hr>
<A name=270></a><b>The IEquatable&lt;T&gt; interface<br></b>A consequence of calling object.Equals is that it forces boxing on value types. This<br>is undesirable in highly performance-sensitive scenarios because boxing is relatively<br>expensive compared to the actual comparison. A solution was introduced in C# 2.0,<br>with the IEquatable&lt;T&gt; interface:<br>
public interface IEquatable&lt;T&gt;<br>
{<br>  bool Equals (T other);<br>
}<br>
The idea is that IEquatable&lt;T&gt;, when implemented, gives the same result as calling<br>object's virtual Equals method--but more quickly. Most basic .NET types imple-<br>ment IEquatable&lt;T&gt;. You can use IEquatable&lt;T&gt; as a constraint in a generic type:<br>
class Test&lt;T&gt; <b>where T : IEquatable&lt;T&gt;</b><br>
{<br>  public bool IsEqual (T a, T b)<br>  {<br>
    return <b>a.Equals (b)</b>;     // No boxing with generic T<br>
  }<br>
}<br>
If we remove the generic constraint, the class would still compile, but a.Equals(b)<br>would bind to the slower object.Equals (slower assuming T was a value type).<br>
<b>When Equals and == are not equal<br></b>We said earlier that it's sometimes useful for == and Equals to apply different defi-<br>nitions of equality. For example:<br>
double x = double.NaN;<br>Console.WriteLine (x == x);            // <b>False<br></b>Console.WriteLine (x.Equals (x));      // True<br>
The double type's == operator enforces that one NaN can never equal anything else--<br>even another NaN. This is most natural from a mathematical perspective, and it<br>reflects the underlying CPU behavior. The Equals method, however, is obliged to<br>apply <i>reflexive</i> equality; in other words:<br>
x.Equals (x) must <i>always</i> return true.<br>
Collections and dictionaries rely on Equals behaving this way; otherwise, they could<br>not find an item they previously stored.<br>
Having Equals and == apply different definitions of equality is actually quite rare<br>with value types. A more common scenario is with reference types, and happens<br>when the author customizes Equals so that it performs value equality while leaving<br>== to perform (default) referential equality. The StringBuilder class does exactly this:<br>
var sb1 = new StringBuilder (&quot;foo&quot;);<br>var sb2 = new StringBuilder (&quot;foo&quot;);<br>Console.WriteLine (sb1 == sb2);          // False <i>(referential equality)<br></i>Console.WriteLine (sb1.Equals (sb2));    // True  <i>(value equality)</i><br>
Let's now look at how to customize equality.<br>
<b>250 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=271></a><b>Equality and Custom Types<br></b>Recall default equality comparison behavior:<br>
· Value types use <i>value equality</i>.<br>· Reference types use <i>referential equality</i>.<br>
Further:<br>
· A  struct's  Equals  method  applies  <i>structural  value  equality</i>  by  default  (i.e.,  it<br>
compares each field in the struct).<br>
Sometimes it makes sense to override this behavior when writing a type. There are<br>two cases for doing so:<br>
· To change the meaning of equality<br>· To speed up equality comparisons for structs<br>
<b>Changing the meaning of equality<br></b>Changing the meaning of equality makes sense when the default behavior of == and<br>Equals is unnatural for your type and is <i>not what a consumer would expect</i>. An ex-<br>ample is DateTimeOffset, a struct with two private fields: a UTC DateTime and a<br>numeric integer offset. If you were writing this type, you'd probably want to ensure<br>that equality comparisons considered only the UTC DateTime field and not the offset<br>field. Another example is numeric types that support NaN values such as float and<br>double. If you were implementing such types yourself, you'd want to ensure that NaN-<br>comparison logic was supported in equality comparisons.<br>
With classes, it's sometimes more natural to offer <i>value equality</i> as the default instead<br>of <i>referential equality</i>. This is often the case with small classes that hold a simple<br>piece of data--such as <br>
<b>FW Fundamentals</b><br>
System.Uri (or System.String).<br>
<b>Speeding up equality comparisons with structs<br></b>The default <i>structural equality</i> comparison algorithm for structs is relatively slow.<br>Taking over this process by overriding Equals can improve performance by a factor<br>of five. Overloading the == operator and implementing IEquatable&lt;T&gt; allows un-<br>boxed equality comparisons, and this can speed things up by a factor of five again.<br>
Overriding equality semantics for reference types doesn't ben-<br>efit performance. The default algorithm for referential equality<br>comparison is already very fast because it simply compares two<br>32- or 64-bit references.<br>
There's actually another, rather peculiar case for customizing equality, and that's to<br>improve a struct's hashing algorithm for better performance in a hashtable. This<br>comes of the fact that equality comparison and hashing are joined at the hip. We'll<br>examine hashing in a moment.<br>
<b>Equality Comparison | 251</b><br>
<hr>
<A name=272></a><b>How to override equality semantics<br></b>Here is a summary of the steps:<br>
1. Override GetHashCode() and Equals().<br>2. (Optionally) overload != and ==.<br>3. (Optionally) implement IEquatable&lt;T&gt;.<br>
<b>Overriding GetHashCode<br></b>It  might  seem  odd  that  System.Object--with  its  small  footprint  of  members--<br>defines a method with a specialized and narrow purpose. GetHashCode is a virtual<br>method in Object that fits this description--it exists primarily for the benefit of just<br>the following two types:<br>
System.Collections.Hashtable<br>
System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;<br>
These are <i>hashtables</i>--collections where each element has a key used for storage and<br>retrieval. A hashtable applies a very specific strategy for efficiently allocating ele-<br>ments based on their key. This requires that each key have an Int32 number, or <i>hash<br>code</i>. The hash code need not be unique for each key, but should be as varied as<br>possible  for  good  hashtable  performance.  Hashtables  are  considered  important<br>enough that GetHashCode is defined in System.Object--so that every type can emit a<br>hash code.<br>
We  describe  hashtables  in  detail  in  "Dictionar-<br>ies" on page 292 in Chapter 7.<br>
Both reference and value types have default implementations of GetHashCode, mean-<br>ing you don't need to override this method--<i>unless you override</i> Equals. The con-<br>verse is also true: override GetHashCode and you must also override Equals.<br>Here are the other rules for overriding object.GetHashCode:<br>
· It must return the same value on two objects for which Equals returns true<br>
(hence, GetHashCode and Equals are overridden together).<br>
· It must not throw exceptions.<br>· It must return the same value if called repeatedly on the same object (unless the<br>
object has <i>changed</i>).<br>
For maximum performance in hashtables, GetHashCode should be written so as to<br>minimize the likelihood of two different values returning the same hash code. This<br>gives rise to the third reason for overriding Equals and GetHashCode on structs, which<br>is to provide a more efficient hashing algorithm than the default. The default for<br>structs simply performs a bitwise exclusive OR on each of the fields, which typically<br>generates more duplicate codes than if you wrote the algorithm yourself.<br>
<b>252 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=273></a>In  contrast,  the  default  GetHashCode  implementation  for  <i>classes</i>  is  based  on<br>an internal object token, which is unique for each instance in the CLR's current<br>implementation.<br>
If an object's hash code changes after it's been added as a key<br>to a dictionary, the object will no longer be accessible in the<br>dictionary. You can preempt this by basing hash code calcula-<br>tions on immutable fields.<br>
A complete example illustrating how to override GetHashCode is listed shortly.<br>
<b>Overriding Equals<br></b>The axioms for object.Equals are as follows:<br>
· An object cannot equal null (unless it's a nullable type).<br>· Equality is <i>reflexive</i> (an object equals itself).<br>· Equality is <i>commutative</i> (if a.Equals(b), then b.Equals(a)).<br>· Equality is <i>transitive</i> (if a.Equals(b) and b.Equals(c), then a.Equals(c)).<br>· Equality operations are repeatable and reliable (they don't throw exceptions).<br>
<b>Overloading == and !=<br></b>In addition to overriding Equals, you can optionally overload the equality and in-<br>equality operators. This is nearly always done with structs, because the consequence<br>of not doing so is that the == and != operators will simply not work on your type.<br>With classes, there are two ways to proceed:<br>
· Leave == and != alone--so that they apply referential equality.<br>
<b>FW Fundamentals</b><br>
· Overload == and != in line with Equals.<br>
The first approach is most common with custom types--especially <i>mutable</i> types.<br>It ensures that your type follows the expectation that == and != should exhibit ref-<br>erential equality with reference types and this avoids confusing consumers. We saw<br>an example earlier:<br>
var sb1 = new StringBuilder (&quot;foo&quot;);<br>var sb2 = new StringBuilder (&quot;foo&quot;);<br>Console.WriteLine (sb1 == sb2);          // False <i>(referential equality)<br></i>Console.WriteLine (sb1.Equals (sb2));    // True  <i>(value equality)</i><br>
The second approach makes sense with types for which a consumer would never<br>want referential equality. These are typically immutable--such as the string and<br>System.Uri classes--and are sometimes good candidates for structs.<br>
Although it's possible to overload != such that it means some-<br>thing other than !(==), this is almost never done in practice,<br>except in cases such as comparing float.NaN.<br>
<b>Equality Comparison | 253</b><br>
<hr>
<A name=274></a><b>Implementing IEquatable&lt;T&gt;<br></b>For  completeness,  it's  also  good  to  implement  IEquatable&lt;T&gt;  when  overriding <br>Equals.  Its  results  should  always  match  those  of  the  overridden  object's  Equals<br>method. Implementing IEquatable&lt;T&gt; comes at no programming cost if you struc-<br>ture your Equals method implementation, as in the following example.<br>
<b>An example: The Area struct<br></b>Imagine we need a struct to represent an area whose width and height are inter-<br>changeable. In other words, 5 × 10 is equal to 10 × 5. (Such a type would be suitable<br>in an algorithm that arranges rectangular shapes.)<br>
Here's the complete code:<br>
public struct Area : IEquatable &lt;Area&gt;<br>
{<br>  public readonly int Measure1;<br>
  public readonly int Measure2;<br>
  public Area (int m1, int m2)<br>
  {<br>
    Measure1 = Math.Min (m1, m2);<br>    Measure2 = Math.Max (m1, m2);<br>  }<br>
  public override bool Equals (object other)<br>  {<br>    if (!(other is Area)) return false;<br>    return Equals ((Area) other);        // Calls method below<br>  }<br>
  public bool Equals (Area other)        // Implements IEquatable&lt;Area&gt;<br>  {<br>    return Measure1 == other.Measure1 &amp;&amp; Measure2 == other.Measure2;<br>  }<br>
  public override int GetHashCode()<br>  {<br>    return Measure2 * 31 + Measure1;    // 31 = some prime number<br>  }<br>
  public static bool operator == (Area a1, Area a2)<br>  {<br>    return a1.Equals (a2);<br>  }<br>
  public static bool operator != (Area a1, Area a2)<br>  {<br>    return !a1.Equals (a2);<br>  }<br>}<br>
<b>254 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=275></a>Here's another way to implement the Equals method, leveraging<br>nullable types:<br>
Area? otherArea = other as Area?;<br>return otherArea.HasValue &amp;&amp; Equals (otherArea.Value);<br>
In implementing GetHashCode, we've helped to improve the likelihood of uniqueness<br>by multiplying the larger measure by some prime number (ignoring any overflow)<br>before adding the two together. When there are more than two fields, the following<br>pattern, suggested by Josh Bloch, gives good results while being performant:<br>
int hash = 17;   // 17 = some prime number<br>hash = hash * 31 + field1.GetHashCode();   // 31 = another prime number<br>
hash = hash * 31 + field2.GetHashCode();<br>
hash = hash * 31 + field3.GetHashCode();<br>
...<br>return hash;<br>
Here's a demo of the Area struct:<br>
Area a1 = new Area (5, 10);<br>Area a2 = new Area (10, 5);<br>
Console.WriteLine (a1.Equals (a2));    // True<br>
Console.WriteLine (a1 == a2);          // True<br>
<b>Pluggable equality comparers<br></b>If you want a type to take on different equality semantics just for a particular sce-<br>nario, you can use a pluggable IEqualityComparer. This is particularly useful in con-<br>junction with the standard collection classes, and we describe it in the following<br>chapter, in "Plugging in Equality and Order" on page 304.<br>
<b>FW Fundamentals</b><br>
<b>Order Comparison<br></b>As well as defining standard protocols for equality, C# and .NET define standard<br>protocols for determining the order of one object relative to another. The basic pro-<br>tocols are:<br>
· The IComparable interfaces (IComparable and IComparable&lt;T&gt;)<br>· The &gt; and &lt; operators<br>
The IComparable interfaces are used by general-purpose sorting algorithms. In the<br>following example, the static Array.Sort method works because System.String im-<br>plements the IComparable interfaces:<br>
string[] colors = { &quot;Green&quot;, &quot;Red&quot;, &quot;Blue&quot; };<br><b>Array.Sort (colors);<br></b>foreach (string c in colors) Console.Write (c + &quot; &quot;);   // Blue Green Red<br>
The &lt; and &gt; operators are more specialized, and they are intended mostly for numeric<br>types. Because they are statically resolved, they can translate to highly efficient byte-<br>code, suitable for computationally intensive algorithms.<br>
<b>Order Comparison | 255</b><br>
<hr>
<A name=276></a>The  .NET  Framework  also  provides  pluggable  ordering  protocols,  via  the<br>IComparer interfaces. We describe these in the final section of Chapter 7.<br>
<b>IComparable<br></b>The IComparable interfaces are defined as follows:<br>
public interface IComparable       { int CompareTo (object other); }<br>public interface IComparable&lt;in T&gt; { int CompareTo (T other);      }<br>
The  two  interfaces  represent  the  same  functionality.  With  value  types,  the<br>generic type-safe interface is faster than the nongeneric interface. In both cases, the<br>CompareTo method works as follows:<br>
· If a comes after b, a.CompareTo(b) returns a positive number.<br>· If a is the same as b, a.CompareTo(b) returns 0.<br>· If a comes before b, a.CompareTo(b) returns a negative number.<br>
For example:<br>
Console.WriteLine (&quot;Beck&quot;.CompareTo (&quot;Anne&quot;));       // 1<br>Console.WriteLine (&quot;Beck&quot;.CompareTo (&quot;Beck&quot;));       // 0<br>
Console.WriteLine (&quot;Beck&quot;.CompareTo (&quot;Chris&quot;));      // -1<br>
Most of the base types implement both IComparable interfaces. These interfaces are<br>also  sometimes  implemented  when  writing  custom  types.  An  example  is  given<br>shortly.<br>
<b>IComparable versus Equals<br></b>Consider a type that both overrides Equals and implements the IComparable inter-<br>faces. You'd expect that when Equals returns true, CompareTo should return 0. And<br>you'd be right. But here's the catch:<br>
When Equals returns false, CompareTo can return what it likes!<br>
In other words, equality can be "fussier" than comparison, but not vice versa (violate<br>this and sorting algorithms will break). So, CompareTo can say "All objects are equal"<br>while Equals says "But some are more equal than others!"<br>A great example of this is System.String. String's Equals method and == operator<br>use <i>ordinal</i> comparison, which compares the Unicode point values of each character.<br>Its CompareTo method, however, uses a less fussy <i>culture-dependent</i> comparison. On<br>most computers, for instance, the strings "" and "" are different according to<br>Equals, but the same according to CompareTo.<br>
In Chapter 7, we discuss the pluggable ordering protocol, IComparer, which allows<br>you to specify an alternative ordering algorithm when sorting or instantiating a sor-<br>ted collection. A custom IComparer can further extend the gap between CompareTo<br>and  Equals--a  case-insensitive  string  comparer,  for  instance,  will  return  0  when<br>comparing &quot;A&quot; and &quot;a&quot;. The reverse rule still applies, however: CompareTo can never<br>be fussier than Equals.<br>
<b>256 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=277></a>When  implementing  the  IComparable  interfaces  in  a  custom<br>type, you can avoid running afoul of this rule by writing the first<br>line of CompareTo as follows:<br>
if (Equals (other)) return 0;<br>
After that, it can return what it likes, as long as it's consistent!<br>
<b>&lt; and &gt;<br></b>Some types define &lt; and &gt; operators. For instance:<br>
bool after2010 = DateTime.Now &gt; new DateTime (2010, 1, 1);<br>
When  implemented,  the  &lt;  and  &gt;  operators  are  functionally  consistent  with  the<br>IComparable interfaces. This is standard practice across the .NET Framework.<br>
It's also standard practice to implement the IComparable interfaces whenever &lt; and<br>&gt; are overloaded, although the reverse is not true. In fact, most .NET types that<br>implement IComparable <i>do not</i> overload &lt; and &gt;. This differs from the situation with<br>equality, where it's normal to overload == when overriding Equals.<br>Typically, &gt; and &lt; are overloaded only when:<br>
· A type has a strong intrinsic concept of "greater than" and "less than" (versus<br>
IComparable's broader concepts of "comes before" and "comes after").<br>
· There is only one way <i>or context</i> in which to perform the comparison.<br>· The result is invariant across cultures.<br>
System.String doesn't satisfy the last point: the results of string comparisons can<br>vary according to language. Hence, string doesn't support the &gt; and &lt; operators:<br>
<b>FW Fundamentals</b><br>
bool error = &quot;Beck&quot; &gt; &quot;Anne&quot;;       // Compile-time error<br>
<b>Implementing the IComparable Interfaces<br></b>In  the  following  struct,  representing  a  musical  note,  we  implement  the<br>IComparable interfaces, as well as overloading the &lt; and &gt; operators. For complete-<br>ness, we also override Equals/GetHashCode and overload == and !=:<br>
public struct Note : IComparable&lt;Note&gt;, IEquatable&lt;Note&gt;, IComparable<br>{<br>  int _semitonesFromA;<br>  public int SemitonesFromA { get { return _semitonesFromA; } }<br>
  public Note (int semitonesFromA)<br>  {<br>    _semitonesFromA = semitonesFromA;<br>  }<br> <br>
  public int CompareTo (Note other)            // Generic IComparable&lt;T&gt;<br>  {<br>
<b>Order Comparison | 257</b><br>
<hr>
<A name=278></a>    if (Equals (other)) return 0;    // Fail-safe check<br>
    return _semitonesFromA.CompareTo (other._semitonesFromA);<br>  }<br>
  int IComparable.CompareTo (object other)     // Nongeneric IComparable<br>
  {<br>    if (!(other is Note))<br>      throw new InvalidOperationException (&quot;CompareTo: Not a note&quot;);<br>
    return CompareTo ((Note) other);<br>
  }<br>
  public static bool operator &lt; (Note n1, Note n2)<br>
  {<br>     return n1.CompareTo (n2) &lt; 0;<br>
  }<br>
  public static bool operator &gt; (Note n1, Note n2)<br>
  {<br>
    return n1.CompareTo (n2) &gt; 0;<br>  }<br>
  public bool Equals (Note other)    // for IEquatable&lt;Note&gt;<br>  {<br>
    return _semitonesFromA == other._semitonesFromA;<br>  }<br>
  public override bool Equals (object other)<br>  {<br>    if (!(other is Note)) return false;<br>    return Equals ((Note) other);<br>  }<br>
  public override int GetHashCode()<br>  {<br>    return _semitonesFromA.GetHashCode();<br>  }<br>
  public static bool operator == (Note n1, Note n2)<br>  {<br>     return n1.Equals (n2);<br>  }<br>
  public static bool operator != (Note n1, Note n2)<br>  {<br>     return !(n1 == n2);<br>  }<br>}<br>
<b>Utility Classes<br>Console<br></b>The static Console class handles standard input/output for console-based applica-<br>tions. In a command-line (Console) application, the input comes from the keyboard<br>
<b>258 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=279></a>via Read, ReadKey, and ReadLine, and the output goes to the text window via Write<br>and WriteLine. You can control the window's position and dimensions with the<br>properties  WindowLeft,  WindowTop,  WindowHeight,  and  WindowWidth.  You  can  also<br>change  the  BackgroundColor  and  ForegroundColor  properties  and  manipulate  the<br>cursor with the CursorLeft, CursorTop, and CursorSize properties:<br>
Console.WindowWidth = Console.LargestWindowWidth;<br>
Console.ForegroundColor = ConsoleColor.Green;<br>Console.Write (&quot;test... 50%&quot;);<br>
Console.CursorLeft -= 3;<br>Console.Write (&quot;90%&quot;);     // test... 90%<br>
The Write and WriteLine methods are overloaded to accept a composite format string<br>(see String.Format in "String and Text Handling" on page 193). However, neither<br>method accepts a format provider, so you are stuck with CultureInfo.CurrentCul<br>ture. (The workaround, of course, is to explicitly call string.Format.)<br>
The Console.Out property returns a TextWriter. Passing Console.Out to a method<br>that  expects  a  TextWriter  is  a  useful  way  to  get  that  method  to  write  to  the<br>Console for diagnostic purposes.<br>
You  can  also  redirect  the  Console's  input  and  output  streams  via  the  SetIn  and<br>SetOut methods:<br>
// First save existing output writer:<br>System.IO.TextWriter oldOut = Console.Out;<br>
// Redirect the console's output to a file:<br>using (System.IO.TextWriter w = System.IO.File.CreateText<br>
                                (&quot;e:\\output.txt&quot;))<br>{<br>  Console.SetOut (w);<br>  Console.WriteLine (&quot;Hello world&quot;);<br>
<b>FW Fundamentals</b><br>
}<br>
// Restore standard console output<br>Console.SetOut (oldOut);<br>
// Open the output.txt file in Notepad:<br>System.Diagnostics.Process.Start (&quot;e:\\output.txt&quot;);<br>
In Chapter 14, we describe how streams and text writers work.<br>
In a Visual Studio Windows application, the Console's output<br>is automatically redirected to Visual Studio's output window<br>(in debug mode). This can make Console.Write useful for diag-<br>nostic  purposes;  although  in  most  cases  the  Debug and Trace<br>classes in the System.Diagnostics namespace are more appro-<br>priate (see Chapter 13).<br>
<b>Utility Classes | 259</b><br>
<hr>
<A name=280></a><b>Environment<br></b>The static System.Environment class provides a range of useful properties:<br>
<i>Files and folders</i><br>
CurrentDirectory, SystemDirectory, CommandLine<br>
<i>Computer and operating system</i><br>
MachineName, ProcessorCount, OSVersion<br>
<i>User logon</i><br>
UserName, UserInteractive, UserDomainName<br>
<i>Diagnostics</i><br>
TickCount, StackTrace, WorkingSet, Version<br>
You can obtain additional folders by calling GetFolderPath; we describe this in "File<br>and Directory Operations" on page 559 in Chapter 14.<br>
You can access OS environment variables (what you see when you type "set" at the<br>command  prompt)  with  the  following  three  methods:  GetEnvironmentVariable,<br>GetEnvironmentVariables, and SetEnvironmentVariable.<br>
The ExitCode property lets you set the return code, for when your program is called<br>from a command or batch file, and the FailFast method terminates a program im-<br>mediately, without performing cleanup.<br>
<b>Process<br></b>The Process class in System.Diagnostics allows you to launch a new process.<br>The static Process.Start method has a number of overloads; the simplest accepts a<br>simple filename with optional arguments:<br>
Process.Start (&quot;notepad.exe&quot;);<br>Process.Start (&quot;notepad.exe&quot;, &quot;e:\\file.txt&quot;);<br>
You can also specify just a filename, and the registered program for its extension<br>will be launched:<br>
Process.Start (&quot;e:\\file.txt&quot;);<br>
The most flexible overload accepts a ProcessStartInfo instance. With this, you can<br>capture and redirect the launched process's input, output, and error output (if you<br>set UseShellExecute to false). The following captures the output of calling ipconfig:<br>
ProcessStartInfo psi = new ProcessStartInfo<br>{<br>  FileName = &quot;cmd.exe&quot;,<br>  Arguments = &quot;/c ipconfig /all&quot;,<br>  RedirectStandardOutput = true,<br>  UseShellExecute = false<br>};<br>Process p = Process.Start (psi);<br>string result = p.StandardOutput.ReadToEnd();<br>Console.WriteLine (result);<br>
<b>260 | Chapter 6:</b><b>Framework Fundamentals</b><br>
<hr>
<A name=281></a>You can do the same to invoke the csc compiler, if you set Filename to the following:<br>
psi.FileName = System.IO.Path.Combine (<br>
  System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory(),<br>
  &quot;csc.exe&quot;);<br>
If you don't redirect output, Process.Start executes the program in parallel to the<br>caller. If you want to wait for the new process to complete, you can call WaitFor<br>Exit on the Process object, with an optional timeout.<br>
The Process class also allows you to query and interact with other processes running<br>on the computer (see Chapter 13).<br>
<b>FW Fundamentals</b><br>
<b>Utility Classes | 261</b><br>
<hr>
<A name=282></a><hr>
<A name=283></a><b>7</b><br>
<b>Collections</b><br>
The .NET Framework provides a standard set of types for storing and managing<br>collections of objects. These include resizable lists, linked lists, and sorted and un-<br>sorted  dictionaries,  as  well  as  arrays.  Of  these,  only  arrays  form  part  of  the  C#<br>language; the remaining collections are just classes you instantiate like any other.<br>
The  types  in  the  Framework  for  collections  can  be  divided  into  the  following<br>categories:<br>
· Interfaces that define standard collection protocols<br>· Ready-to-use collection classes (lists, dictionaries, etc.)<br>· Base classes for writing application-specific collections<br>
This chapter covers each of these categories, with an additional section on the types<br>used in determining element equality and order.<br>
The collection namespaces are as follows:<br>
<b>Namespace</b><br>
<b>Contains</b><br>
System.Collections<br>
Nongeneric collection classes and interfaces<br>
System.Collections.Specialized<br>
Strongly typed nongeneric collection classes<br>
System.Collections.Generic<br>
Generic collection classes and interfaces<br>
System.Collections.ObjectModel<br>
Proxies and bases for custom collections<br>
System.Collections.Concurrent<br>
Thread-safe collections (see Chapter 22)<br>
<b>Enumeration<br></b>In computing, there are many different kinds of collections ranging from simple data<br>structures, such as arrays or linked lists, to more complex ones, such as red/black<br>trees and hashtables. Although the internal implementation and external charac-<br>teristics of these data structures vary widely, the ability to traverse the contents of<br>the collection is an almost universal need. The Framework supports this need via a<br>
<b>263</b><br>
<hr>
<A name=284></a>pair of interfaces (IEnumerable, IEnumerator, and their generic counterparts) that<br>allow different data structures to expose a common traversal API. These are part of<br>a larger set of collection interfaces illustrated in Figure 7-1.<br>
<i>Figure 7-1. Collection interfaces</i><br>
<b>IEnumerable and IEnumerator<br></b>The IEnumerator interface defines the basic low-level protocol by which elements in<br>a collection are traversed--or enumerated--in a forward-only manner. Its declara-<br>tion is as follows:<br>
public interface IEnumerator<br>{<br>  bool MoveNext();<br>  object Current { get; }<br>  void Reset();<br>}<br>
MoveNext advances the current element or "cursor" to the next position, returning<br>false if there are no more elements in the collection. Current returns the element at<br>the current position (usually cast from object to a more specific type). MoveNext must<br>be called before retrieving the first element--this is to allow for an empty collection.<br>The Reset method, if implemented, moves back to the start, allowing the collection<br>to be enumerated again. (Calling Reset is generally avoided because it's not sup-<br>ported by all enumerators.)<br>
Collections do not <i>implement</i> enumerators; instead, they <i>provide</i> enumerators, via<br>the interface IEnumerable:<br>
public interface IEnumerable<br>{<br>  IEnumerator GetEnumerator();<br>}<br>
<b>264 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=285></a>By defining a single method retuning an enumerator, IEnumerable provides flexibility<br>in that the iteration logic can be farmed off to another class. Moreover, it means that<br>several consumers can enumerate the collection at once without interfering with<br>each other. IEnumerable can be thought of as "IEnumeratorProvider," and it is the<br>most basic interface that collection classes implement.<br>
The following example illustrates low-level use of IEnumerable and IEnumerator:<br>
string s = &quot;Hello&quot;;<br>
// Because string implements IEnumerable, we can call GetEnumerator():<br>
IEnumerator rator = s.GetEnumerator();<br>
while (rator.MoveNext())<br>
{<br>  char c = (char) rator.Current;<br>
  Console.Write (c + &quot;.&quot;);<br>
}<br>
// Output:  H.e.l.l.o.<br>
However, it's rare to call methods on enumerators directly in this manner, because<br>C# provides a syntactic shortcut: the foreach statement. Here's the same example<br>rewritten using foreach:<br>
string s = &quot;Hello&quot;;      // The String class implements IEnumerable<br>
foreach (char c in s)<br>  Console.Write (c + &quot;.&quot;);<br>
<b>IEnumerable&lt;T&gt; and IEnumerator&lt;T&gt;<br></b>IEnumerator and IEnumerable are nearly always implemented in conjunction with<br>their extended generic versions:<br>
public interface IEnumerator&lt;T&gt; : IEnumerator, IDisposable<br>{<br>  T Current { get; }<br>}<br>
public interface IEnumerable&lt;T&gt; : IEnumerable<br>{<br>
<b>Collections</b><br>
  IEnumerator&lt;T&gt; GetEnumerator();<br>}<br>
By defining a typed version of Current and GetEnumerator, these interfaces strengthen<br>static  type  safety,  avoid  the  overhead  of  boxing  with  value-type  elements,  and<br>are  more  convenient  to  the  consumer.  Arrays  automatically  implement<br>IEnumerable&lt;T&gt; (where T is the member type of the array).<br>
Thanks to the improved static type safety, calling the following method with an array<br>of characters will generate a compile-time error:<br>
void Test (IEnumerable&lt;int&gt; numbers) { ... }<br>
<b>Enumeration | 265</b><br>
<hr>
<A name=286></a>It's  a  standard  practice  for  collection  classes  to  publicly  expose  IEnumerable&lt;T&gt;,<br>while "hiding" the nongeneric IEnumerable through explicit interface implementa-<br>tion. This is so that if you directly call GetEnumerator(), you get back the type-safe<br>generic IEnumerator&lt;T&gt;. There are times, though, when this rule is broken for reasons<br>of backward compatibility (generics did not exist prior to C# 2.0). A good example<br>is arrays--these must return the nongeneric (the nice way of putting it is "classic")<br>IEnumerator  to  avoid  breaking  earlier  code.  In  order  to  get  a  generic<br>IEnumerator&lt;T&gt;, you must cast to expose the explicit interface:<br>
int[] data = { 1, 2, 3 };<br>var rator = ((IEnumerable &lt;int&gt;)data).GetEnumerator();<br>
Fortunately,  you  rarely  need  to  write  this  sort  of  code,  thanks  to  the  foreach<br>statement.<br>
<b>IEnumerable&lt;T&gt; and IDisposable<br></b>IEnumerable&lt;T&gt; implements IDisposable. This allows enumerators to hold refer-<br>ences to resources such as database connections--and ensure that those resources<br>are released when enumeration is complete (or abandoned partway through). The<br>foreach statement recognizes this detail and translates this:<br>
foreach (var element in somethingEnumerable) { ... }<br>
into this:<br>
<b>using</b> (var rator = somethingEnumerable.GetEnumerator())<br>  while (rator.MoveNext())<br>  {<br>    var element = rator.Current;<br>    ...<br>  }<br>
The using block ensures disposal--more on IDisposable in Chapter 12.<br>
<b>Implementing the Enumeration Interfaces<br></b>You might want to implement IEnumerable or IEnumerable&lt;T&gt; for one or more of the<br>following reasons:<br>
· To support the foreach statement<br>· To interoperate with anything expecting a standard collection<br>· As part of implementing a more sophisticated collection interface<br>· To support collection initializers<br>
To implement IEnumerable/IEnumerable&lt;T&gt;, you must provide an enumerator. You<br>can do this in one of three ways:<br>
· If the class is "wrapping" another collection, by returning the wrapped collec-<br>
tion's enumerator<br>
· Via an iterator using yield return<br>· By instantiating your own IEnumerator/IEnumerator&lt;T&gt; implementation<br>
<b>266 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=287></a>You can also subclass an existing collection: Collection&lt;T&gt; is<br>designed just for this purpose (see "Customizable Collections<br>and Proxies" on page 298). Yet another approach is to use the<br>LINQ query operators that we'll cover in the next chapter.<br>
Returning  another  collection's  enumerator  is  just  a  matter  of  calling  GetEnumera<br>tor on the inner collection. However, this is viable only in the simplest scenarios,<br>where the items in the inner collection are exactly what are required. A more flexible<br>approach is to write an iterator, using C#'s yield return statement. An <i>iterator</i> is a<br>C#  language  feature  that  assists  in  writing  collections,  in  the  same  way  the<br>foreach statement assists in consuming collections. An iterator automatically han-<br>dles the implementation of IEnumerable and IEnumerator--or their generic versions.<br>Here's a simple example:<br>
public class MyCollection : IEnumerable<br>
{<br>  int[] data = { 1, 2, 3 };<br>
  public IEnumerator GetEnumerator()<br>
  {<br>
    foreach (int i in data)<br>      yield return i;<br>
  }<br>
}<br>
Notice the "black magic": GetEnumerator doesn't appear to return an enumerator at<br>all! Upon parsing the yield return statement, the compiler writes a hidden nested<br>enumerator class behind the scenes, and then refactors GetEnumerator to instantiate<br>and return that class. Iterators are powerful and simple (and are the basis for LINQ's<br>implementation).<br>
Keeping  with  this  approach,  we  can  also  implement  the  generic  interface<br>IEnumerable&lt;T&gt;:<br>
public class MyGenCollection : IEnumerable&lt;int&gt;<br>{<br>  int[] data = { 1, 2, 3 };<br>
  public IEnumerator&lt;int&gt; GetEnumerator()<br>
<b>Collections</b><br>
  {<br>    foreach (int i in data)<br>      yield return i;<br>  }<br>
  IEnumerator IEnumerable.GetEnumerator()     // Explicit implementation<br>  {                                           // keeps it hidden.<br>    return GetEnumerator();<br>  }<br>}<br>
Because IEnumerable&lt;T&gt; implements IEnumerable, we must implement both the ge-<br>neric and the nongeneric versions of GetEnumerator. In accordance with standard<br>
<b>Enumeration | 267</b><br>
<hr>
<A name=288></a>practice, we've implemented the nongeneric version explicitly. It can simply call the<br>generic GetEnumerator because IEnumerator&lt;T&gt; implements IEnumerator.<br>The class we've just written would be suitable as a basis from which to write a more<br>sophisticated  collection.  However,  if  we  need  nothing  above  a  simple  IEnumera<br>ble&lt;T&gt; implementation, the yield return statement allows for an easier variation.<br>Rather than writing a class, you can move the iteration logic into a method returning<br>a  generic  IEnumerable&lt;T&gt;  and  let  the  compiler  take  care  of  the  rest.  Here's  an<br>example:<br>
public class Test<br>{<br>  public static IEnumerable &lt;int&gt; GetSomeIntegers()<br>
  {<br>
    yield return 1;<br>
    yield return 2;<br>
    yield return 3;<br>  }<br>
}<br>
Here's our method in use:<br>
foreach (int i in Test.GetSomeIntegers())<br>
  Console.WriteLine (i);<br>
// Output<br>
1<br>2<br>3<br>
The  final  approach  in  writing  GetEnumerator  is  to  write  a  class  that  implements<br>IEnumerator directly. This is exactly what the compiler does behind the scenes, in<br>resolving iterators. (Fortunately, it's rare that you'll need to go this far yourself.) The<br>following example defines a collection that's hardcoded to contain the integers 1, 2,<br>and 3:<br>
public class MyIntList : IEnumerable<br>{<br>  int[] data = { 1, 2, 3 };<br>
  public IEnumerator GetEnumerator()<br>  {<br>    return new Enumerator (this);<br>  }<br>
  class Enumerator : IEnumerator       // Define an inner class<br>  {                                    // for the enumerator.<br>    MyIntList collection;<br>    int currentIndex = -1;<br>
    internal Enumerator (MyIntList collection)<br>    {<br>      this.collection = collection;<br>    }<br>
    public object Current<br>
<b>268 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=289></a>    {<br>
      get<br>      {<br>        if (currentIndex == -1)<br>
          throw new InvalidOperationException (&quot;Enumeration not started!&quot;);<br>
        if (currentIndex == collection.data.Length)<br>          throw new InvalidOperationException (&quot;Past end of list!&quot;);<br>        return collection.data [currentIndex];<br>
      }<br>
    }<br>
    public bool MoveNext()<br>
    {<br>      if (currentIndex &gt; collection.data.Length) return false;<br>
      return ++currentIndex &lt; collection.data.Length;<br>    }<br>
    public void Reset() { currentIndex = -1; }<br>  }<br>
}<br>
Implementing  Reset  is  optional--you  can  instead  throw  a<br>NotSupportedException.<br>
Note that the first call to MoveNext should move to the first (and not the second) item<br>in the list.<br>
To  get  on  par  with  an  iterator  in  functionality,  we  must  also  implement<br>IEnumerator&lt;T&gt;. Here's an example with bounds checking omitted for brevity:<br>
class MyIntList : IEnumerable&lt;int&gt;<br>{<br>  int[] data = { 1, 2, 3 };<br>
  // The generic enumerator is compatible with both IEnumerable and<br>
  // IEnumerable&lt;T&gt;. We implement the nongeneric GetEnumerator method<br>  // explicitly to avoid a naming conflict.<br>
  public IEnumerator&lt;int&gt; GetEnumerator() { return new Enumerator(this); }<br>
<b>Collections</b><br>
  IEnumerator IEnumerable.GetEnumerator() { return new Enumerator(this); }<br>
  class Enumerator : IEnumerator&lt;int&gt;<br>
  {<br>    int currentIndex = -1;<br>    MyIntList collection;<br>
    internal Enumerator (MyIntList collection)<br>    {<br>      this.collection = collection;<br>    }<br>
    public int Current { get { return collection.data [currentIndex]; } }<br>    object IEnumerator.Current { get { return Current; } }<br>
<b>Enumeration | 269</b><br>
<hr>
<A name=290></a>    public bool MoveNext()<br>
    {<br>      return ++currentIndex &lt; collection.data.Length;<br>    }<br>
    public void Reset() { currentIndex = -1; }<br>
    // Given we don't need a Dispose method, it's good practice to<br>
    // implement it explicitly, so it's hidden from the public interface.<br>
    void IDisposable.Dispose() {}<br>  }<br>
}<br>
The example with generics is faster because IEnumerator&lt;int&gt;.Current doesn't re-<br>quire casting from int to object, and so avoids the overhead of boxing.<br>
<b>When to Use the Nongeneric Interfaces</b><br>
Given  the  extra  type  safety  of  the  generic  collection  interfaces  such  as<br>IEnumerable&lt;T&gt;,  the  question  arises:  do  you  ever  need  to  use  the  nongeneric<br>IEnumerable (or ICollection or IList)?<br>
In the case of IEnumerable, you must implement this interface in conjunction with<br>IEnumerable&lt;T&gt;--because the latter derives from the former. However, it's very<br>rare that you actually implement these interfaces from scratch: in nearly all cases,<br>you can take the higher-level approach of using iterator methods, Collection&lt;T&gt;,<br>and LINQ.<br>
So, what about as a consumer? In nearly all cases, you can manage entirely with<br>the  generic  interfaces.  The  nongeneric  interfaces  are  still  occasionally  useful,<br>though, in their ability to provide type unification for collections across all element<br>types.  The  following  method,  for  instance,  counts  elements  in  any  collection<br><i>recursively</i>:<br>
public static int Count (IEnumerable e)<br>{<br>  int count = 0;<br>  foreach (object element in e)<br>  {<br>    var subCollection = element as IEnumerable;<br>
    if (subCollection != null)<br>      count += Count (subCollection);<br>    else<br>      count++;<br>  }<br>  return count;<br>}<br>
Because C# 4.0 offers covariance with generic interfaces, it might seem valid to<br>have this method instead accept IEnumerable&lt;object&gt;. This would fail with value-<br>type elements, however. It would also fail with legacy collections that don't im-<br>plement IEnumerable&lt;T&gt;-- an example is ControlCollection in Windows Forms.<br>
<b>270 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=291></a><b>The ICollection and IList Interfaces<br></b>Although the enumeration interfaces provide a protocol for forward-only iteration<br>over a collection, they don't provide a mechanism to determine the size of the col-<br>lection, access a member by index, search, or modify the collection. For such func-<br>tionality,  the  .NET  Framework  defines  the  ICollection,  IList,  and  IDictionary<br>interfaces. Each comes in both generic and nongeneric versions; however, the non-<br>generic versions exist mostly for legacy.<br>
The inheritance hierarchy for these interfaces was shown in Figure 7-1. The easiest<br>way to summarize them is as follows:<br>
IEnumerable&lt;T&gt;<i> (and </i>IEnumerable<i>)</i><br>
Provides minimum functionality (enumeration only)<br>
ICollection&lt;T&gt;<i> (and </i>ICollection<i>)</i><br>
Provides medium functionality (e.g., the Count property)<br>
IList &lt;T&gt;<i>/</i>IDictionary &lt;K,V&gt;<i> and their nongeneric versions</i><br>
Provide maximum functionality (including "random" access by index/key)<br>
It's rare that you'll need to <i>implement</i> any of these interfaces. In<br>nearly all cases when you need to write a collection class, you<br>can instead subclass Collection&lt;T&gt; (see "Customizable Collec-<br>tions and Proxies" on page 298). LINQ provides yet another<br>option that covers many scenarios.<br>
The generic and nongeneric versions differ in ways over and above what you might<br>expect, particularly in the case of ICollection. The reasons for this are mostly his-<br>torical: because generics came later, the generic interfaces were developed with the<br>benefit of hindsight. For this reason, ICollection&lt;T&gt; does not extend ICollection,<br>IList&lt;T&gt; does not extend IList, and IDictionary&lt;TKey, TValue&gt; does not extend<br>IDictionary. Of course, a collection class itself is free to implement both versions of<br>an interface if beneficial (which, often, it is).<br>
Another, subtler reason for IList&lt;T&gt; not extending IList is that<br>
<b>Collections</b><br>
casting to IList&lt;T&gt; would then return an interface with both<br>Add(T) and Add(object) members. This would effectively defeat<br>static type safety, because you could call Add with an object of<br>any type.<br>
This section covers ICollection&lt;T&gt;, IList&lt;T&gt;, and their nongeneric versions; "Dic-<br>tionaries" on page 292 covers the dictionary interfaces.<br>
<b>The ICollection and IList Interfaces | 271</b><br>
<hr>
<A name=292></a>There is no <i>consistent</i> rationale in the way the words <i>collection<br></i>and  <i>list</i>  are  applied  throughout  the  .NET  Framework.  For<br>instance,  since  IList&lt;T&gt;  is  a  more  functional  version  of<br>ICollection&lt;T&gt;, you might expect the class List&lt;T&gt; to be cor-<br>respondingly  more  functional  than  the  class  Collection&lt;T&gt;.<br>This is not the case. It's best to consider the terms <i>collection</i> and<br><i>list</i>  as  broadly  synonymous,  except  when  a  specific  type  is<br>involved.<br>
<b>ICollection&lt;T&gt; and ICollection<br></b>ICollection&lt;T&gt; is the standard interface for countable collections of objects. It pro-<br>vides the ability to determine the size of a collection (Count), determine whether an<br>item exists in the collection (Contains), copy the collection into an array (ToArray),<br>and determine whether the collection is read-only (IsReadOnly). For writable col-<br>lections, you can also Add, Remove, and Clear items from the collection. And since it<br>extends IEnumerable&lt;T&gt;, it can also be traversed via the foreach statement:<br>
public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerable<br>
{<br>  int Count { get; }<br>
  bool Contains (T item);<br>
  void CopyTo (T[] array, int arrayIndex);<br>
  bool IsReadOnly { get; }<br>
  void Add(T item);<br>  bool Remove (T item);<br>  void Clear();<br>}<br>
The  nongeneric  ICollection  is  similar  in  providing  a  countable  collection,<br>but  doesn't  provide  functionality  for  altering  the  list  or  checking  for  element<br>membership:<br>
public interface ICollection : IEnumerable<br>{<br>   int Count { get; }<br>   bool IsSynchronized { get; }<br>   object SyncRoot { get; }<br>   void CopyTo (Array array, int index);<br>}<br>
The  nongeneric  interface  also  defines  properties  to  assist  with  synchronization<br>(Chapter 21)--these were dumped in the generic version because thread safety is no<br>longer considered intrinsic to the collection.<br>
Both  interfaces  are  fairly  straightforward  to  implement.  If  implementing  a<br>read-only  ICollection&lt;T&gt;,  the  Add,  Remove,  and  Clear  methods  should  throw  a<br>NotSupportedException.<br>
These interfaces are usually implemented in conjunction with either the IList or the<br>IDictionary interface.<br>
<b>272 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=293></a><b>IList&lt;T&gt; and IList<br></b>IList&lt;T&gt; is the standard interface for collections indexable by position. In addition<br>to the functionality inherited from ICollection&lt;T&gt; and IEnumerable&lt;T&gt;, it provides<br>the ability to read or write an element by position (via an indexer) and insert/remove<br>by position:<br>
public interface IList&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable<br>{<br>  T this [int index] { get; set; }<br>
  int IndexOf (T item);<br>
  void Insert (int index, T item);<br>
  void RemoveAt (int index);<br>
}<br>
The IndexOf methods perform a linear search on the list, returning -1 if the specified<br>item is not found.<br>
The nongeneric version of IList has more members because it inherits less from<br>ICollection:<br>
public interface IList : ICollection, IEnumerable<br>
{<br>  object this [int index] { get; set }<br>  bool IsFixedSize { get; }<br>
  bool IsReadOnly  { get; }<br>
  int  Add      (object value);<br>
  void Clear();<br>  bool Contains (object value);<br>  int  IndexOf  (object value);<br>  void Insert   (int index, object value);<br>  void Remove   (object value);<br>  void RemoveAt (int index);<br>}<br>
The Add method on the nongeneric IList interface returns an integer--this is the<br>index of the newly added item. In contrast, the Add method on ICollection&lt;T&gt; has<br>a void return type.<br>The  general-purpose  List&lt;T&gt;  class  is  the  quintessential  implementation  of  both<br>IList&lt;T&gt;  and  IList.  C#  arrays  also  implement  both  the  generic  and  nongeneric<br>
<b>Collections</b><br>
ILists (although the methods that add or remove elements are hidden via explicit<br>interface implementation and throw a NotSupportedException if called).<br>
<b>The Array Class<br></b>The Array class is the implicit base class for all single and multidimensional arrays,<br>and it is one of the most fundamental types implementing the standard collection<br>interfaces. The Array class provides type unification, so a common set of methods<br>is available to all arrays, regardless of their declaration or underlying element type.<br>
Since arrays are so fundamental, C# provides explicit syntax for their declaration<br>and initialization, described in Chapters 2 and 3. When an array is declared using<br>C#'s  syntax,  the  CLR  implicitly  subtypes  the  Array  class--synthesizing  a<br>
<b>The Array Class | 273</b><br>
<hr>
<A name=294></a><i>pseudotype</i> appropriate to the array's dimensions and element types. This pseudo-<br>type implements the typed generic collection interfaces, such as IList&lt;string&gt;.<br>The CLR also treats array types specially upon construction, assigning them a con-<br>tiguous  space  in  memory.  This  makes  indexing  into  arrays  highly  efficient,  but<br>prevents them from being resized later on.<br>
Array implements the collection interfaces up to IList&lt;T&gt; in both their generic and<br>nongeneric  forms.  IList&lt;T&gt;  itself  is  implemented  explicitly,  though,  to  keep<br>Array's public interface clean of methods such as Add or Remove, which throw an<br>exception on fixed-length collections such as arrays. The Array class does actually<br>offer a static Resize method, although this works by creating a new array and then<br>copying over each element. As well as being inefficient, references to the array else-<br>where in the program will still point to the original version. A better solution for<br>resizable collections is to use the List&lt;T&gt; class (described in the following section).<br>An array can contain value type or reference type elements. Value type elements are<br>stored in place in the array, so an array of three long integers (each 8 bytes) will<br>occupy 24 bytes of contiguous memory. A reference type element, however, occupies<br>only as much space in the array as a reference (4 bytes in a 32-bit environment or 8<br>bytes in a 64-bit environment). Figure 7-2 illustrates the effect, in memory, of the<br>following program:<br>
StringBuilder[] builders = new StringBuilder [5];<br>
builders [0] = new StringBuilder (&quot;builder1&quot;);<br>builders [1] = new StringBuilder (&quot;builder2&quot;);<br>
builders [2] = new StringBuilder (&quot;builder3&quot;);<br>
long[] numbers = new long [3];<br>numbers [0] = 12345;<br>numbers [1] = 54321;<br>
<i>Figure 7-2. Arrays in memory</i><br>
<b>274 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=295></a>Because Array is a class, arrays are always (themselves) reference types--regardless<br>of the array's element type. This means that the statement arrayB = arrayA results<br>in two variables that reference the same array. Similarly, two distinct arrays will<br>always fail an equality test--unless you use a custom equality comparer. Framework<br>4.0 provides one for the purpose of comparing elements in arrays or tuples which<br>you can access via the StructuralComparisons type:<br>
object[] a1 = { &quot;string&quot;, 123, true };<br>
object[] a2 = { &quot;string&quot;, 123, true };<br>
Console.WriteLine (a1 == a2);                          // False<br>
Console.WriteLine (a1.Equals (a2));                    // False<br>
Console.WriteLine (a1.Equals (a2,<br>
 StructuralComparisons.StructuralEqualityComparer));   // True<br>
Arrays can be duplicated with the Clone method: arrayB = arrayA.Clone(). How-<br>ever, this results in a shallow clone, meaning that only the memory represented by<br>the array itself is copied. If the array contains value type objects, the values them-<br>selves are copied; if the array contains reference type objects, just the references are<br>copied (resulting in two arrays whose members reference the same objects). Fig-<br>ure 7-3 demonstrates the effect of adding the following code to our example:<br>
StringBuilder[] builders2 = builders;<br>StringBuilder[] shallowClone = (StringBuilder[]) builders.Clone();<br>
<b>Collections</b><br>
<i>Figure 7-3. Shallow-cloning an array</i><br>
To create a deep copy--where reference type subobjects are duplicated--you must<br>loop through the array and clone each element manually. The same rules apply to<br>other .NET collection types.<br>
Although Array is designed primarily for use with 32-bit indexers, it also has limited<br>support  for  64-bit  indexers  (allowing  an  array  to  theoretically  address  up  to  264<br>
<b>The Array Class | 275</b><br>
<hr>
<A name=296></a>elements) via several methods that accept both Int32 and Int64 parameters. These<br>overloads are useless in practice, because the CLR does not permit any object--<br>including  arrays--to  exceed  2GB  in  size  (whether  running  on  a  32-  or  64-bit<br>environment).<br>
Many of the methods on the Array class that you expect to be<br>instance methods are in fact static methods. This is an odd de-<br>sign decision, and means you should check for both static and<br>instance methods when looking for a method on Array.<br>
<b>Construction and Indexing<br></b>The easiest way to create and index arrays is through C#'s language constructs:<br>
int[] myArray = { 1, 2, 3 };<br>int first = myArray [0];<br>
int last = myArray [myArray.Length - 1];<br>
Alternatively, you can instantiate an array dynamically by calling Array.CreateIn<br>stance. This allows you to specify element type and rank (number of dimensions)<br>at  runtime,  as  well  as  allowing  nonzero-based  arrays  through  specifying  a  lower<br>bound.  Nonzero-based  arrays  are  not  CLS  (Common  Language  Specification)-<br>compliant.<br>
The static GetValue and SetValue methods let you access elements in a dynamically<br>created array (they also work on ordinary arrays):<br>
 // Create a string array 2 elements in length:<br>
 Array a = Array.CreateInstance (typeof(string), 2);<br> a.SetValue (&quot;hi&quot;, 0);                             //   a[0] = &quot;hi&quot;;<br> a.SetValue (&quot;there&quot;, 1);                          //   a[1] = &quot;there&quot;;<br> string s = (string) a.GetValue (0);               //   s = a[0];<br>
 // We can also cast to a C# array as follows:<br> string[] cSharpArray = (string[]) a;<br> string s2 = cSharpArray [0];<br>
Zero-indexed arrays created dynamically can be cast to a C# array of a matching or<br>compatible  type  (compatible  by  standard  array-variance  rules).  For  example,  if<br>Apple subclasses Fruit, Apple[] can be cast to Fruit[]. This leads to the issue of why<br>object[] was not used as the unifying array type rather the Array class. The answer<br>is that object[] is incompatible with both multidimensional and value-type arrays<br>(and nonzero-based arrays). An int[] array cannot be cast to object[]. Hence, we<br>require the Array class for full type unification.<br>
GetValue and SetValue also work on compiler-created arrays, and they are useful<br>when writing methods that can deal with an array of any type and rank. For multi-<br>dimensional arrays, they accept an <i>array</i> of indexers:<br>
public object GetValue (params int[] indices)<br>public void   SetValue (object value, params int[] indices)<br>
The following method prints the first element of any array, regardless of rank:<br>
<b>276 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=297></a> void WriteFirstValue (Array a)<br>
 {<br>   Console.Write (a.Rank + &quot;-dimensional; &quot;);<br>
   // The indexers array will automatically initialize to all zeros, so<br>
   // passing it into GetValue or SetValue will get/set the zero-based<br>   // (i.e., first) element in the array.<br>
   int[] indexers = new int[a.Rank];<br>
   Console.WriteLine (&quot;First value is &quot; +  a.GetValue (indexers));<br> }<br>
 void Demo()<br> {<br>
   int[]  oneD = { 1, 2, 3 };<br>   int[,] twoD = { {5,6}, {8,9} };<br>
   WriteFirstValue (oneD);   // 1-dimensional; first value is 1<br>
   WriteFirstValue (twoD);   // 2-dimensional; first value is 5<br> }<br>
For working with arrays of unknown type but known rank, ge-<br>nerics provide an easier and more efficient solution:<br>
void WriteFirstValue&lt;T&gt; (T[] array)<br>{<br>  Console.WriteLine (array[0]);<br>}<br>
SetValue throws an exception if the element is of an incompatible type for the array.<br>
When  an  array  is  instantiated,  whether  via  language  syntax  or  Array.CreateIn<br>stance, its elements are automatically initialized. For arrays with reference type el-<br>ements, this means writing nulls; for arrays with value type elements, this means<br>calling the value type's default constructor (effectively "zeroing" the members). The<br>Array class also provides this functionality on demand via the Clear method:<br>
public static void Clear (Array array, int index, int length);<br>
This method doesn't affect the size of the array. This is in contrast to the usual use<br>
<b>Collections</b><br>
of Clear (such as in ICollection&lt;T&gt;.Clear ), where the collection is reduced to zero<br>elements.<br>
<b>Enumeration<br></b>Arrays are easily enumerated with a foreach statement:<br>
int[] myArray = { 1, 2, 3};<br>foreach (int val in myArray)<br>  Console.WriteLine (val);<br>
You can also enumerate using the static Array.ForEach method, defined as follows:<br>
public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);<br>
<b>The Array Class | 277</b><br>
<hr>
<A name=298></a>This uses an Action delegate, with this signature:<br>
public delegate void Action&lt;T&gt; (T obj);<br>
Here's the first example rewritten with Array.ForEach:<br>
Array.ForEach (new[] { 1, 2, 3 }, Console.WriteLine);<br>
<b>Length and Rank<br></b>Array provides the following methods and properties for querying length and rank:<br>
public int  GetLength      (int dimension);<br>
public long GetLongLength  (int dimension);<br>
public int  Length       { get; }<br>
public long LongLength   { get; }<br>
public int GetLowerBound (int dimension);<br>
public int GetUpperBound (int dimension);<br>
public int Rank { get; }    // Returns number of dimensions in array<br>
GetLength and GetLongLength return the length for a given dimension (0 for a single-<br>dimensional array), and Length and LongLength return the total number of elements<br>in the array--all dimensions included.<br>
GetLowerBound  and  GetUpperBound  are  useful  with  nonzero  indexed  arrays.<br>GetUpperBound returns the same result as adding GetLowerBound to GetLength for any<br>given dimension.<br>
<b>Searching<br></b>The  Array  class  provides  a  range  of  methods  for  finding  elements  within  a  one-<br>dimensional array:<br>
<b>public static int BinarySearch&lt;T&gt; (T[] array,   object value);<br>public static int BinarySearch&lt;T&gt; (T[] array,   object value, IComparer&lt;T&gt;<br></b>                                                              <b>comparer);<br>public static int BinarySearch    (Array array, object value);<br>public static int BinarySearch    (Array array, object value, IComparer<br></b>                                                              <b>comparer);<br>public static int IndexOf&lt;T&gt;      (T[] array,   T value);<br>public static int IndexOf         (Array array, object value);<br>public static int LastIndexOf&lt;T&gt;  (T[] array,   T value);<br>public static int LastIndexOf     (Array array, object value);</b><br>
// Predicate-based searching:<br>
public static T    Find&lt;T&gt;        (T[] array, Predicate&lt;T&gt; match);<br>public static T    FindLast&lt;T&gt;    (T[] array, Predicate&lt;T&gt; match);<br>public static T[]  FindAll&lt;T&gt;     (T[] array, Predicate&lt;T&gt; match);<br>
public static bool Exists&lt;T&gt;        (T[] array, Predicate&lt;T&gt; match);<br>public static bool TrueForAll&lt;T&gt;    (T[] array, Predicate&lt;T&gt; match);<br>
<b>278 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=299></a><b>public static int  FindIndex&lt;T&gt;     (T[] array, Predicate&lt;T&gt; match);</b><br>
<b>public static int  FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);</b><br>
The methods shown in bold are also overloaded to accept the following additional<br>arguments:<br>
int index   // starting index at which to begin searching<br>
int length  // maximum number of elements to search<br>
None  of  these  methods  throws  an  exception  if  the  specified  value  is  not  found.<br>Instead, if an item is not found, methods returning an integer return -1 (assuming a<br>zero-indexed array), and methods returning a generic type return the type's default<br>value (e.g., 0 for an integer, or null for a string ).<br>The binary search methods are fast, but they work only on sorted arrays and require<br>that the elements be compared for <i>order</i>, rather than simply <i>equality</i>. To this effect,<br>the binary search methods can accept an IComparer or IComparer&lt;T&gt; object to arbi-<br>trate  on  ordering  decisions  (see  the  section  "Plugging  in  Equality  and  Or-<br>der" on page 304, later in this chapter). This must be consistent with any comparer<br>used in originally sorting the array. If no comparer is provided, the type's default<br>ordering algorithm will be applied, based on its implementation of IComparable/<br>IComparable&lt;T&gt;.<br>
The IndexOf and LastIndexOf methods perform a simple enumeration over the array,<br>returning the position of the first (or last) element that matches the given value.<br>
The predicate-based searching methods allow a method delegate or lambda expres-<br>sion to arbitrate on whether a given element is a "match." A predicate is simply a<br>delegate accepting an object and returning true or false:<br>
public delegate bool Predicate&lt;T&gt; (T object);<br>
In the following example, we search an array of strings for a name containing the<br>letter "a":<br>
static void Main()<br>{<br>  string[] names = { &quot;Rodney&quot;, &quot;Jack&quot;, &quot;Jill&quot; };<br>  string match = Array.Find (names, ContainsA);<br>  Console.WriteLine (match);     // Jack<br>}<br>static bool ContainsA (string name) { return name.Contains (&quot;a&quot;); }<br>
<b>Collections</b><br>
Here's the same code shortened with an anonymous method:<br>
string[] names = { &quot;Rodney&quot;, &quot;Jack&quot;, &quot;Jill&quot; };<br>string match = Array.Find (names, delegate (string name)<br>  { return name.Contains (&quot;a&quot;); } );<br>
A lambda expression shortens it further:<br>
string[] names = { &quot;Rodney&quot;, &quot;Jack&quot;, &quot;Jill&quot; };<br>string match = Array.Find (names, <b>n =&gt; n.Contains (&quot;a&quot;)</b>);     // Jack<br>
FindAll returns an array of all items satisfying the predicate. In fact, it's equivalent<br>to Enumerable.Where in the System.Linq namespace, except that FindAll returns an<br>array of matching items rather than an IEnumerable&lt;T&gt; of the same.<br>
<b>The Array Class | 279</b><br>
<hr>
<A name=300></a>Exists returns true if any array member satisfies the given predicate, and is equiv-<br>alent to Any in System.Linq.Enumerable.<br>
TrueForAll returns true if all items satisfy the predicate, and is equivalent to All in<br>System.Linq.Enumerable.<br>
<b>Sorting<br></b>Array has the following built-in sorting methods:<br>
// For sorting a single array:<br>
public static void Sort&lt;T&gt; (T[] array);<br>
public static void Sort    (Array array);<br>
// For sorting a pair of arrays:<br>
public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);<br>public static void Sort              (Array keys, Array items);<br>
Each of these methods is additionally overloaded to also accept:<br>
int index                 // Starting index at which to begin sorting<br>int length                // Number of elements to sort<br>
IComparer&lt;T&gt; comparer     // Object making ordering decisions<br>
Comparison&lt;T&gt; comparison  // Delegate making ordering decisions<br>
The following illustrates the simplest use of Sort:<br>
int[] numbers = { 3, 2, 1 };<br>Array.Sort (numbers);                     // Array is now { 1, 2, 3 }<br>
The methods accepting a pair of arrays work by rearranging the items of each array<br>in tandem, basing the ordering decisions on the first array. In the next example, both<br>the numbers and their corresponding words are sorted into numerical order:<br>
int[] numbers = { 3, 2, 1 };<br>string[] words = { &quot;three&quot;, &quot;two&quot;, &quot;one&quot; };<br>Array.Sort (numbers, words);<br>
// numbers array is now { 1, 2, 3 }<br>// words   array is now { &quot;one&quot;, &quot;two&quot;, &quot;three&quot; }<br>
Array.Sort requires that the elements in the array implement IComparable (see the<br>section  "Order  Comparison"  on  page  255  in  Chapter  6).  This  means  that  most<br>primitive C# types (such as integers, as in the preceding example) can be sorted. If<br>the elements are not intrinsically comparable, or you want to override the default<br>ordering, you must provide Sort with a custom comparison provider that reports on<br>the relative position of two elements. There are ways to do this:<br>
· Via a helper object that implements IComparer /IComparer&lt;T&gt; (see the section<br>
"Plugging in Equality and Order" on page 304)<br>
· Via a Comparison delegate:<br>
public delegate int Comparison&lt;T&gt; (T x, T y);<br>
<b>280 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=301></a>The Comparison delegate follows the same semantics as IComparer&lt;T&gt;.CompareTo: if<br>x comes before y, a negative integer is returned; if x comes after y, a positive integer<br>is returned; if x and y have the same sorting position, 0 is returned.<br>In this example, we sort an array of integers so that the odd numbers come first:<br>
int[] numbers = { 1, 2, 3, 4, 5 };<br>Array.Sort (numbers, (x, y) =&gt; x % 2 == y % 2 ? 0 : x % 2 == 1 ? -1 : 1);<br>
// numbers array is now { 3, 5, 1, 2, 4 }<br>
As an alternative to calling Sort, you can use LINQ's OrderBy<br>and ThenBy operators. Unlike Array.Sort, the LINQ operators<br>don't alter the original array, instead emitting the sorted result<br>in a fresh IEnumerable&lt;T&gt; sequence.<br>
<b>Reversing Elements<br></b>These Array methods reverse the order of all--or a part of--elements in an array:<br>
public static void Reverse (Array array);<br>
public static void Reverse (Array array, int index, int length);<br>
<b>Copying, Converting, and Resizing<br></b>Array provides shallow copying and cloning methods as follows:<br>
// Instance methods:<br>
public object Clone();<br>public void CopyTo (Array array, int index);<br>
// Static methods:<br>
public static void Copy (Array sourceArray,<br>                         Array destinationArray,<br>
                         int length);<br>
public static void Copy (Array sourceArray,      int sourceIndex,<br>                         Array destinationArray, int destinationIndex,<br>
<b>Collections</b><br>
                         int length);<br>
public static void ConstrainedCopy (<br>                         Array sourceArray,      int sourceIndex,<br>                         Array destinationArray, int destinationIndex,<br>                         int length);<br>
public static ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array)<br>
public static TOutput[] ConvertAll&lt;TInput, TOutput&gt;<br>  (TInput[] array, Converter&lt;TInput, TOutput&gt; converter)<br>
public static void Resize&lt;T&gt; (ref T[] array, int newSize);<br>
<b>The Array Class | 281</b><br>
<hr>
<A name=302></a>The Copy and CopyTo methods are overloaded to accept Int64 index arguments.<br>The  Clone  method  returns  a  whole  new  (shallow-copied)  array.  The  Copy  and<br>CopyTo methods copy a contiguous subset of the array. Copying a multidimensional<br>rectangular array requires you to map the multidimensional index to a linear index.<br>For example, the middle square (position[1,1]) in a 3 × 3 array is represented with<br>the index 4, from the calculation: 1*3 + 1. The source and destination ranges can<br>overlap without causing a problem.<br>
ConstrainedCopy performs an <i>atomic</i> operation: if all of the requested elements can-<br>not be successfully copied (due to a type error, for instance), the operation is rolled<br>back.<br>
AsReadOnly  returns  a  wrapper  that  prevents  elements  from  being  reassigned.<br>ConvertAll creates and returns a new array of element type TOutput, calling the sup-<br>plied Converter delegate to copy over the elements. Converter is defined as follows:<br>
public delegate TOutput Converter&lt;TInput,TOutput&gt; (TInput input)<br>
The following converts an array of floats to an array of integers:<br>
float[] reals = { 1.3f, 1.5f, 1.8f };<br>
int[] wholes = Array.ConvertAll (reals, r =&gt; Convert.ToInt32 (r));<br>
// wholes array is { 1, 2, 2 }<br>
The Resize method works by creating a new array and copying over the elements,<br>returning the new array via the reference parameter. However, any references to the<br>original array in other objects will remain unchanged.<br>
The System.Linq namespace offers an additional buffet of ex-<br>tension methods suitable for array conversion. These methods<br>return an IEnumerable&lt;T&gt;, which you can convert back to an<br>array via Enumerable 's ToArray method.<br>
<b>Lists, Queues, Stacks, and Sets<br></b>The Framework provides a comprehensive set of concrete collection classes that<br>implement the interfaces described in this chapter. This section concentrates on the<br><i>list-like</i>  collections  (versus  the  <i>dictionary-like</i>  collections  covered  in  "Dictionar-<br>ies" on page 292). As with the interfaces we discussed previously, you usually have<br>a choice of generic or nongeneric versions of each type. In terms of flexibility and<br>performance, the generic classes win, making their nongeneric counterparts redun-<br>dant except for backward compatibility. This differs from the situation with collec-<br>tion interfaces, where the nongeneric versions are still occasionally useful.<br>
Of the classes described in this section, the generic List class is the most commonly<br>used.<br>
<b>282 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=303></a><b>List&lt;T&gt; and ArrayList<br></b>The generic List and nongeneric ArrayList classes provide a dynamically sized array<br>of objects and are among the most commonly used of the collection classes. Array<br>List implements IList, whereas List&lt;T&gt; implements both IList and IList&lt;T&gt;. Un-<br>like with arrays, all interfaces are implemented publicly, and methods such as Add<br>and Remove are exposed and work as you would expect.<br>Internally, List&lt;T&gt; and ArrayList work by maintaining an internal array of objects,<br>replaced with a larger array upon reaching capacity. Appending elements is efficient<br>(since there is usually a free slot at the end), but inserting elements can be slow (since<br>all elements after the insertion point have to be shifted to make a free slot). As with<br>arrays, searching is efficient if the BinarySearch method is used on a list that has been<br>sorted, but is otherwise inefficient because each item must be individually checked.<br>
List&lt;T&gt; is up to several times faster than ArrayList if T is a value<br>type, because List&lt;T&gt; avoids the overhead of boxing and un-<br>boxing elements.<br>
List&lt;T&gt;  and  ArrayList  provide  constructors  that  accept  an  existing  collection  of<br>elements:  these  copy  each  element  from  the  existing  collecting  into  the  new<br>List&lt;T&gt; or ArrayList:<br>
public class List &lt;T&gt; : IList &lt;T&gt;<br>
{<br>  public List ();<br>
  public List (IEnumerable&lt;T&gt; collection);<br>  public List (int capacity);<br>
  // Add+Insert<br>  public void Add         (T item);<br>  public void AddRange    (IEnumerable&lt;T&gt; collection);<br>  public void Insert      (int index, T item);<br>  public void InsertRange (int index, IEnumerable&lt;T&gt; collection);<br>
  // Remove<br>  public bool Remove      (T item);<br>
<b>Collections</b><br>
  public void RemoveAt    (int index);<br>  public void RemoveRange (int index, int count);<br>  public int  RemoveAll   (Predicate&lt;T&gt; match);<br>
  // Indexing<br>  public T this [int index] { get; set; }<br>  public List&lt;T&gt; GetRange (int index, int count);<br>  public Enumerator&lt;T&gt; GetEnumerator();<br>
  // Exporting, copying and converting:<br>  public T[] ToArray();<br>  public void CopyTo (T[] array);<br>  public void CopyTo (T[] array, int arrayIndex);<br>  public void CopyTo (int index, T[] array, int arrayIndex, int count);<br>
<b>Lists, Queues, Stacks, and Sets | 283</b><br>
<hr>
<A name=304></a>  public ReadOnlyCollection&lt;T&gt; AsReadOnly();<br>
  public List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter &lt;T,TOutput&gt;<br>                                            converter);<br>  // Other:<br>
  public void Reverse();            // Reverses order of elements in list.<br>
  public int Capacity { get;set; }  // Forces expansion of internal array.<br>  public void TrimExcess();         // Trims internal array back to size.<br>  public void Clear();              // Removes all elements, so Count=0.<br>
}<br>
public delegate TOutput Converter &lt;TInput, TOutput&gt; (TInput input);<br>
In addition to these members, List&lt;T&gt; provides instance versions of all of Array's<br>searching and sorting methods.<br>
The following code demonstrates List's properties and methods. See "The Array<br>Class" on page 273 for examples on searching and sorting:<br>
List&lt;string&gt; words = new List&lt;string&gt;();    // New string-typed list<br>
words.Add (&quot;melon&quot;);<br>
words.Add (&quot;avocado&quot;);<br>
words.AddRange (new[] { &quot;banana&quot;, &quot;plum&quot; } );<br>
words.Insert (0, &quot;lemon&quot;);                           // Insert at start<br>words.InsertRange (0, new[] { &quot;peach&quot;, &quot;nashi&quot; });   // Insert at start<br>
words.Remove (&quot;melon&quot;);<br>
words.RemoveAt (3);                         // Remove the 4th element<br>words.RemoveRange (0, 2);                   // Remove first 2 elements<br>
// Remove all strings starting in 'n':<br>words.RemoveAll (s =&gt; s.StartsWith (&quot;n&quot;));<br>
Console.WriteLine (words [0]);                          // first word<br>Console.WriteLine (words [words.Count - 1]);            // last word<br>foreach (string s in words) Console.WriteLine (s);      // all words<br>List&lt;string&gt; subset = words.GetRange (1, 2);            // 2nd-&gt;3rd words<br>
string[] wordsArray = words.ToArray();    // Creates a new typed array<br>
// Copy first two elements to the end of an existing array:<br>string[] existing = new string [1000];<br>words.CopyTo (0, existing, 998, 2);<br>
List&lt;string&gt; upperCastWords = words.ConvertAll (s =&gt; s.ToUpper());<br>List&lt;int&gt; lengths = words.ConvertAll (s =&gt; s.Length);<br>
The  nongeneric  ArrayList  class  is  used  mainly  for  backward  compatibility  with<br>Framework  1.x  code  and  requires  clumsy  casts--as  the  following  example<br>demonstrates:<br>
ArrayList al = new ArrayList();<br>al.Add (&quot;hello&quot;);<br>string first = <b>(string)</b> al [0];<br>string[] strArr = <b>(string[])</b> al.ToArray (typeof (string));<br>
<b>284 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=305></a>Such casts cannot be verified by the compiler; the following compiles successfully<br>but then fails at runtime:<br>
int first = <b>(int)</b> al [0];    // Runtime exception<br>
An ArrayList is functionally similar to List&lt;object&gt;. Both are<br>useful when you need a list of mixed-type elements that share<br>no  common  base  type.  A  possible  advantage  of  choosing  an<br>ArrayList, in this case, would be if you need to deal with the list<br>using  reflection  (Chapter  18).  Reflection  is  easier  with  a<br>nongeneric ArrayList than a List&lt;object&gt;.<br>
If you import the System.Linq namespace, you can convert an ArrayList to a generic<br>List by calling Cast and then ToList:<br>
ArrayList al = new ArrayList();<br>
al.AddRange (new[] { 1, 5, 9 } );<br>
List&lt;int&gt; list = al.Cast&lt;int&gt;().ToList();<br>
Cast and ToList are extension methods in the System.Linq.Enumerable class, sup-<br>ported from .NET Framework 3.5.<br>
<b>LinkedList&lt;T&gt;<br></b>LinkedList&lt;T&gt; is a generic doubly linked list (see Figure 7-4). A doubly linked list is<br>a chain of nodes in which each references the node before, the node after, and the<br>actual element. Its main benefit is that an element can always be inserted efficiently<br>anywhere in the list, since it just involves creating a new node and updating a few<br>references. However, finding where to insert the node in the first place can be slow<br>as there's no intrinsic mechanism to index directly into a linked list; each node must<br>be traversed, and binary-chop searches are not possible.<br>
LinkedList&lt;T&gt;  implements  IEnumerable&lt;T&gt;  and  ICollection&lt;T&gt;  (and  their<br>nongeneric versions), but not IList&lt;T&gt; since access by index is not supported. List<br>nodes are implemented via the following class:<br>
public sealed class LinkedListNode&lt;T&gt;<br>{<br>
<b>Collections</b><br>
  public LinkedList&lt;T&gt; List { get; }<br>  public LinkedListNode&lt;T&gt; Next { get; }<br>  public LinkedListNode&lt;T&gt; Previous { get; }<br>  public T Value { get; set; }<br>}<br>
When adding a node, you can specify its position either relative to another node or<br>at the start/end of the list. LinkedList&lt;T&gt; provides the following methods for this:<br>
public void AddFirst(LinkedListNode&lt;T&gt; node);<br>public LinkedListNode&lt;T&gt; AddFirst (T value);<br>
public void AddLast (LinkedListNode&lt;T&gt; node);<br>public LinkedListNode&lt;T&gt; AddLast (T value);<br>
<b>Lists, Queues, Stacks, and Sets | 285</b><br>
<hr>
<A name=306></a>public void AddAfter (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);<br>
public LinkedListNode&lt;T&gt; AddAfter (LinkedListNode&lt;T&gt; node, T value);<br>
public void AddBefore (LinkedListNode&lt;T&gt; node, LinkedListNode&lt;T&gt; newNode);<br>
public LinkedListNode&lt;T&gt; AddBefore (LinkedListNode&lt;T&gt; node, T value);<br>
<i>Figure 7-4. LinkedList&lt;T&gt;</i><br>
Similar methods are provided to remove elements:<br>
public void Clear();<br>
public void RemoveFirst();<br>public void RemoveLast();<br>
public bool Remove (T value);<br>public void Remove (LinkedListNode&lt;T&gt; node);<br>
LinkedList&lt;T&gt; has internal fields to keep track of the number of elements in the list,<br>as well as the head and tail of the list. These are exposed in the following public<br>properties:<br>
public int Count { get; }                      // Fast<br>public LinkedListNode&lt;T&gt; First { get; }        // Fast<br>public LinkedListNode&lt;T&gt; Last { get; }         // Fast<br>
LinkedList&lt;T&gt; also supports the following searching methods (each requiring that<br>the list be internally enumerated):<br>
public bool Contains (T value);<br>
public LinkedListNode&lt;T&gt; Find (T value);<br>public LinkedListNode&lt;T&gt; FindLast (T value);<br>
Finally, LinkedList&lt;T&gt; supports copying to an array for indexed processing and ob-<br>taining an enumerator to support the foreach statement:<br>
public void CopyTo (T[] array, int index);<br>public Enumerator&lt;T&gt; GetEnumerator();<br>
<b>286 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=307></a>Here's a demonstration on the use of LinkedList&lt;string&gt;:<br>
var tune = new LinkedList&lt;string&gt;();<br>
tune.AddFirst (&quot;do&quot;);                           // <b>do</b><br>
tune.AddLast (&quot;so&quot;);                            // do - <b>so</b><br>
tune.AddAfter (tune.First, &quot;re&quot;);               // do - <b>re</b> - so<br>
tune.AddAfter (tune.First.Next, &quot;mi&quot;);          // do - re - <b>mi</b> - so<br>
tune.AddBefore (tune.Last, &quot;fa&quot;);               // do - re - mi - <b>fa</b> - so<br>
tune.RemoveFirst();                             // re - mi - fa - so<br>
tune.RemoveLast();                              // re - mi - fa<br>
LinkedListNode&lt;string&gt; miNode = tune.Find (&quot;mi&quot;);<br>tune.Remove (miNode);                           // re - fa<br>tune.AddFirst (miNode);                         // <b>mi</b> - re - fa<br>
foreach (string s in tune) Console.WriteLine (s);<br>
<b>Queue&lt;T&gt; and Queue<br></b>Queue&lt;T&gt; and Queue are first-in first-out (FIFO) data structures, providing methods<br>to Enqueue (add an item to the tail of the queue) and Dequeue (retrieve and remove<br>the item at the head of the queue). A Peek method is also provided to return the<br>element at the head of the queue without removing it, and a Count property (useful<br>in checking that elements are present before dequeuing).<br>
Although  queues  are  enumerable,  they  do  not  implement  IList&lt;T&gt;/IList,  since<br>members cannot be accessed directly by index. A ToArray method is provided, how-<br>ever, for copying the elements to an array where they can be randomly accessed:<br>
public class Queue&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable<br>{<br>  public Queue();<br>  public Queue (IEnumerable&lt;T&gt; collection);   // Copies existing elements<br>  public Queue (int capacity);                // To lessen auto-resizing<br>  public void Clear();<br>  public bool Contains (T item);<br>  public void CopyTo (T[] array, int arrayIndex);<br>  public int Count { get; }<br>  public T Dequeue();<br>
<b>Collections</b><br>
  public void Enqueue (T item);<br>  public Enumerator&lt;T&gt; GetEnumerator();       // To support foreach<br>  public T Peek();<br>  public T[] ToArray();<br>  public void TrimExcess();<br>}<br>
The following is an example of using Queue&lt;int&gt;:<br>
var q = new Queue&lt;int&gt;();<br>q.Enqueue (10);<br>q.Enqueue (20);<br>int[] data = q.ToArray();         // Exports to an array<br>Console.WriteLine (q.Count);      // &quot;2&quot;<br>Console.WriteLine (q.Peek());     // &quot;10&quot;<br>
<b>Lists, Queues, Stacks, and Sets | 287</b><br>
<hr>
<A name=308></a>Console.WriteLine (q.Dequeue());  // &quot;10&quot;<br>
Console.WriteLine (q.Dequeue());  // &quot;20&quot;<br>Console.WriteLine (q.Dequeue());  // throws an exception (queue empty)<br>
Queues are implemented internally using an array that's resized as required--much<br>like the generic List class. The queue maintains indexes that point directly to the<br>head and tail elements; therefore, enqueuing and dequeuing are extremely quick<br>operations (except when an internal resize is required).<br>
<b>Stack&lt;T&gt; and Stack<br></b>Stack&lt;T&gt; and Stack are last-in first-out (LIFO) data structures, providing methods<br>to Push (add an item to the top of the stack) and Pop (retrieve and remove an element<br>from the top of the stack). A nondestructive Peek method is also provided, as is a<br>Count property and a ToArray method for exporting the data for random access:<br>
public class Stack&lt;T&gt; : IEnumerable&lt;T&gt;, ICollection, IEnumerable<br>
{<br>  public Stack();<br>
  public Stack (IEnumerable&lt;T&gt; collection);   // Copies existing elements<br>  public Stack (int capacity);                // Lessens auto-resizing<br>
  public void Clear();<br>
  public bool Contains (T item);<br>
  public void CopyTo (T[] array, int arrayIndex);<br>  public int Count { get; }<br>  public Enumerator&lt;T&gt; GetEnumerator();       // To support foreach<br>
  public T Peek();<br>  public T Pop();<br>
  public void Push (T item);<br>  public T[] ToArray();<br>
  public void TrimExcess();<br>}<br>
The following example demonstrates Stack&lt;int&gt;:<br>
var s = new Stack&lt;int&gt;();<br>s.Push (1);                      //            Stack = 1<br>s.Push (2);                      //            Stack = 1,2<br>s.Push (3);                      //            Stack = 1,2,3<br>Console.WriteLine (s.Count);     // Prints 3<br>Console.WriteLine (s.Peek());    // Prints 3,  Stack = 1,2,3<br>Console.WriteLine (s.Pop());     // Prints 3,  Stack = 1,2<br>Console.WriteLine (s.Pop());     // Prints 2,  Stack = 1<br>Console.WriteLine (s.Pop());     // Prints 1,  Stack = &lt;empty&gt;<br>Console.WriteLine (s.Pop());     // throws exception<br>
Stacks are implemented internally with an array that's resized as required, as with<br>Queue&lt;T&gt; and List&lt;T&gt;.<br>
<b>BitArray<br></b>A BitArray is a dynamically sized collection of compacted bool values. It is more<br>memory-efficient than both a simple array of bool and a generic List of bool, because<br>it uses only one bit for each value, whereas the bool type otherwise occupies one<br>byte for each value:<br>
<b>288 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=309></a>public sealed class BitArray : ICollection, IEnumerable, ICloneable<br>
{<br>  // Constructors<br>  public BitArray (BitArray bits);    // An existing BitArray to copy<br>
  public BitArray (int length);       // Capacity, in bits<br>
  public BitArray (bool[] values);<br>  public BitArray (byte[] bytes);<br>  public BitArray (int[] values);<br>
  public BitArray (int length, bool defaultValue);<br>
  // To get/set value<br>  public bool this [int index] { get; set; }<br>
  public bool Get  (int index);<br>  public void Set  (int index, bool value);<br>
  public void SetAll (bool value);<br>
  // Bitwise operators<br>
  public BitArray Not();<br>
  public BitArray And (BitArray value);<br>  public BitArray Or  (BitArray value);<br>  public BitArray Xor (BitArray value);<br>
  // Copying<br>
  public void CopyTo (Array array, int index);<br>  public object Clone();<br>
  // Other<br>  public IEnumerator GetEnumerator();<br>  public int  Count          { get; }<br>  public int  Length         { get; set; }<br>  public bool IsReadOnly     { get; }<br>
  public bool IsSynchronized { get; }<br>  public object SyncRoot     { get; }<br>}<br>
The following is an example of using the BitArray class:<br>
var bits = new BitArray(2);<br>
bits[1] = true;<br>bits.Xor (bits);               // Bitwise exclusive-OR bits with itself<br>Console.WriteLine (bits[1]);   // False<br>
<b>Collections</b><br>
<b>HashSet&lt;T&gt; and SortedSet&lt;T&gt;<br></b>HashSet&lt;T&gt; and SortedSet&lt;T&gt; are generic collections new to Framework 3.5 and 4.0,<br>respectively. Both have the following distinguishing features:<br>
· Their Contains methods execute quickly using a hash-based lookup.<br>· They  do  not  store  duplicate  elements  and  silently  ignore  requests  to  add<br>
duplicates.<br>
· You cannot access an element by position.<br>
SortedSet&lt;T&gt; keeps elements in order, whereas HashSet&lt;T&gt; does not.<br>
<b>Lists, Queues, Stacks, and Sets | 289</b><br>
<hr>
<A name=310></a>The  commonality  of  these  types  is  captured  by  the  interface<br>ISet&lt;T&gt;.<br>
For  historical  reasons,  HashSet&lt;T&gt;  lives  in  <i>System.Core.dll<br></i>(whereas SortedSet&lt;T&gt; and ISet&lt;T&gt; live in <i>System.dll</i>).<br>
HashSet&lt;T&gt; is implemented with a hashtable that stores just keys; SortedSet&lt;T&gt; is<br>implemented with a red/black tree.<br>
Here's the definition for HashSet&lt;T&gt;:<br>
public class HashSet&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable<br>
{<br>  // Constructors<br>  public HashSet();<br>
  public HashSet (IEnumerable&lt;T&gt; collection);<br>
  public HashSet (IEqualityComparer&lt;T&gt; comparer);<br>
  public HashSet (IEnumerable&lt;T&gt; collection, IEqualityComparer&lt;T&gt; comparer);<br>
  // Testing for membership<br>  public bool Contains (T item);<br>
  // Adding / removing<br>
  public bool Add    (T item);<br>  public bool Remove (T item);<br>  public int RemoveWhere (Predicate&lt;T&gt; match);<br>
  public void Clear();<br>
  // Set operations - destructive<br>  public void UnionWith           (IEnumerable&lt;T&gt; other);   // Adds<br>  public void IntersectWith       (IEnumerable&lt;T&gt; other);   // Removes<br>  public void ExceptWith          (IEnumerable&lt;T&gt; other);   // Removes<br>  public void SymmetricExceptWith (IEnumerable&lt;T&gt; other);   // Removes<br>
  // Set operations - bool<br>  public bool IsSubsetOf         (IEnumerable&lt;T&gt; other);<br>  public bool IsProperSubsetOf   (IEnumerable&lt;T&gt; other);<br>  public bool IsSupersetOf       (IEnumerable&lt;T&gt; other);<br>  public bool IsProperSupersetOf (IEnumerable&lt;T&gt; other);<br>  public bool Overlaps           (IEnumerable&lt;T&gt; other);<br>  public bool SetEquals          (IEnumerable&lt;T&gt; other);<br>
  // Other<br>  public int Count { get; }<br>  public IEqualityComparer&lt;T&gt; Comparer { get; }<br>  public void CopyTo (T[] array);<br>  public void CopyTo (T[] array, int arrayIndex);<br>  public void CopyTo (T[] array, int arrayIndex, int count);<br>  public void TrimExcess();<br>  public static IEqualityComparer&lt;HashSet&lt;T&gt;&gt; CreateSetComparer();<br>}<br>
SortedSet&lt;T&gt; offers the same set of members, plus the following:<br>
<b>290 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=311></a>public virtual SortedSet&lt;T&gt; GetViewBetween (T lowerValue, T upperValue)<br>
public IEnumerable&lt;T&gt; Reverse()<br>
public T Min { get; }<br>
public T Max { get; }<br>
SortedSet&lt;T&gt; also accepts an optional IComparer&lt;T&gt; in its constructor (rather than<br>an <i>equality comparer</i>).<br>
The following constructs a HashSet&lt;char&gt; from an existing collection, tests for mem-<br>bership, and then enumerates the collection (notice the absence of duplicates):<br>
var letters = new HashSet&lt;char&gt; (&quot;the quick brown fox&quot;);<br>
Console.WriteLine (letters.Contains ('t'));      // true<br>
Console.WriteLine (letters.Contains ('j'));      // false<br>
foreach (char c in letters) Console.Write (c);   // the quickbrownfx<br>
(The  reason  we  can  pass  a  string  into  HashSet&lt;char&gt;'s  constructor  is  because<br>string implements IEnumerable&lt;char&gt;.)<br>
Here's an example of loading the same letters into a SortedSet&lt;char&gt;:<br>
var letters = new SortedSet&lt;char&gt; (&quot;the quick brown fox&quot;);<br>
foreach (char c in letters) Console.Write (c);   //  bcefhiknoqrtuwx<br>
Following on from this, we can obtain the letters between <i>f</i> and <i>j</i> as follows:<br>
foreach (char c in letters.<b>GetViewBetween</b> ('f', 'j'))<br>  Console.Write (c);                                    //  fhk<br>
The destructive set operators modify the original collection. UnionWith adds all the<br>elements  in  the  second  set  to  the  original  set  (excluding  duplicates).  Intersects<br>With removes the elements that are not in both sets. We remove all the vowels from<br>our set of characters in the following code:<br>
var letters = new HashSet&lt;char&gt; (&quot;the quick brown fox&quot;);<br>letters.IntersectWith (&quot;aeiou&quot;);<br>foreach (char c in letters) Console.Write (c);     // euio<br>
ExceptWith removes the specified elements from the source set. Here, we strip all<br>vowels from the set:<br>
<b>Collections</b><br>
var letters = new HashSet&lt;char&gt; (&quot;the quick brown fox&quot;);<br>letters.ExceptWith (&quot;aeiou&quot;);<br>foreach (char c in letters) Console.Write (c);     // th qckbrwnfx<br>
SymmetricExceptWith removes all but the elements that are unique to one set or the<br>other:<br>
var letters = new HashSet&lt;char&gt; (&quot;the quick brown fox&quot;);<br>letters.SymmetricExceptWith (&quot;the lazy brown fox&quot;);<br>foreach (char c in letters) Console.Write (c);     // quicklazy<br>
Because HashSet&lt;T&gt; and SortedSet&lt;T&gt; implement IEnumerable&lt;T&gt;, you can use an-<br>other set as the argument to any of the set operation methods.<br>
<b>Lists, Queues, Stacks, and Sets | 291</b><br>
<hr>
<A name=312></a><b>Dictionaries<br></b>A dictionary is a collection in which each element is a key/value pair. Dictionaries<br>are most commonly used for lookups and sorted lists.<br>
The  Framework  defines  a  standard  protocol  for  dictionaries,  via  the  interfaces<br>IDictionary and IDictionary &lt;TKey, TValue&gt;, as well as a set of general-purpose<br>dictionary classes. The classes each differ in the following regard:<br>
· Whether or not items are stored in sorted sequence<br>· Whether or not items can be accessed by position (index) as well as by key<br>· Whether generic or nongeneric<br>· Their performance when large<br>
Table 7-1 summarizes each of the dictionary classes and how they differ in these<br>respects. The performance times are in milliseconds, to perform 50,000 operations<br>on a dictionary with integer keys and values, on a 1.5 GHz PC. (The differences in<br>performance between generic and nongeneric counterparts using the same under-<br>lying  collection  structure  are  due  to  boxing,  and  show  up  only  with  value-type<br>elements.)<br>
<i>Table 7-1. Dictionary classes</i><br>
<b>Re-</b><br>
<b>Speed:</b><br>
<b>Speed:</b><br>
<b>trieve</b><br>
<b>Memory</b><br>
<b>Speed:</b><br>
<b>sequen-</b><br>
<b>re-</b><br>
<b>Internal</b><br>
<b>by</b><br>
<b>overhead (avg.</b><br>
<b>random</b><br>
<b>tial</b><br>
<b>trieval</b><br>
<b>Type</b><br>
<b>structure</b><br>
<b>index?</b><br>
<b>bytes per item)</b><br>
<b>insertion</b><br>
<b>insertion</b><br>
<b>by key</b><br>
<b>Unsorted</b><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
Dictionary &lt;K,V&gt;<br>
Hashtable<br>
No<br>
22<br>
30<br>
30<br>
20<br>
Hashtable<br>
Hashtable<br>
No<br>
38<br>
50<br>
50<br>
30<br>
ListDictionary<br>
Linked list<br>
No<br>
36<br>
50,000<br>
50,000<br>
50,000<br>
OrderedDictionary<br>
Hashtable<br>
Yes<br>
59<br>
70<br>
70<br>
40<br>
+ array<br>
<b>Sorted</b><br>
 <br>
 <br>
 <br>
 <br>
 <br>
 <br>
SortedDictionary<br>
Red/black<br>
No<br>
20<br>
130<br>
100<br>
120<br>
&lt;K,V&gt;<br>
tree<br>
SortedList &lt;K,V&gt;<br>
2xArray<br>
Yes<br>
2<br>
3,300<br>
30<br>
40<br>
SortedList<br>
2xArray<br>
Yes<br>
27<br>
4,500<br>
100<br>
180<br>
In Big-O notation, retrieval time by key is:<br>
· O(1) for Hashtable, Dictionary, and OrderedDictionary<br>· O(log <i>n</i>) for SortedDictionary and SortedList<br>· O(<i>n</i>) for ListDictionary (and nondictionary types such as List&lt;T&gt;)<br>
where <i>n</i> is the number of elements in the collection.<br>
<b>292 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=313></a><b>IDictionary&lt;TKey,TValue&gt;<br></b>IDictionary&lt;TKey,TValue&gt; defines the standard protocol for all key/value-based col-<br>lections. It extends ICollection&lt;T&gt; by adding methods and properties to access el-<br>ements based on a key of arbitrary type:<br>
public interface IDictionary &lt;TKey, TValue&gt; :<br>  ICollection &lt;KeyValuePair &lt;TKey, TValue&gt;&gt;, IEnumerable<br>
{<br>   bool ContainsKey (TKey key);<br>
   bool TryGetValue (TKey key, out TValue value);<br>
   void Add         (TKey key, TValue value);<br>   bool Remove      (TKey key);<br>
   TValue this [TKey key]      { get; set; }  // Main indexer - by key<br>
   ICollection &lt;TKey&gt; Keys     { get; }       // Returns just keys<br>
   ICollection &lt;TValue&gt; Values { get; }       // Returns just values<br>
}<br>
To add an item to a dictionary, you either call Add or use the index's set accessor--<br>the latter adds an item to the dictionary if the key is not already present (or updates<br>the item if it is present). Duplicate keys are forbidden in all dictionary implementa-<br>tions, so calling Add twice with the same key throws an exception.<br>To  retrieve  an  item  from  a  dictionary,  use  either  the  indexer  or  the  TryGetValue<br>method. If the key doesn't exist, the indexer throws an exception whereas TryGet<br>Value returns false. You can test for membership explicitly by calling ContainsKey;<br>however, this incurs the cost of two lookups if you then subsequently retrieve the<br>item.<br>
Enumerating  directly  over  an  IDictionary&lt;TKey,TValue&gt;  returns  a  sequence  of<br>KeyValuePair structs:<br>
public struct KeyValuePair &lt;TKey, TValue&gt;<br>{<br>  public TKey Key     { get; }<br>  public TValue Value { get; }<br>}<br>
You  can  enumerate  over  just  the  keys  or  values  via  the  dictionary's  Keys/Values<br>properties.<br>
<b>Collections</b><br>
We demonstrate the use of this interface with the generic Dictionary class in the<br>following section.<br>
<b>IDictionary<br></b>The  nongeneric  IDictionary  interface  is  the  same  in  principle  as<br>IDictionary&lt;TKey,TValue&gt;,  apart  from  two  important  functional  differences.<br>It's  important  to  be  aware  of  these  differences,  because  IDictionary  appears  in<br>legacy code (including the .NET Framework itself in places):<br>
<b>Dictionaries | 293</b><br>
<hr>
<A name=314></a>· Retrieving a nonexistent key via the indexer returns null (rather than throwing<br>
an exception).<br>
· Contains tests for membership rather than ContainsKey.<br>
Enumerating  over  a  nongeneric  IDictionary  returns  a  sequence  of  DictionaryEn<br>try structs:<br>
public struct DictionaryEntry<br>
{<br>  public object Key   { get; set; }<br>
  public object Value { get; set; }<br>}<br>
<b>Dictionary&lt;TKey,TValue&gt; and Hashtable<br></b>The generic Dictionary class is one of the most commonly used collections (along<br>with the List&lt;T&gt; collection). It uses a hashtable data structure to store keys and<br>values, and it is fast and efficient.<br>
The  nongeneric  version  of  Dictionary&lt;TKey,TValue&gt;  is<br>called  Hashtable;  there  is  no  nongeneric  class  called  Diction<br>ary. When we refer simply to Dictionary, we mean the generic<br>Dictionary&lt;TKey,TValue&gt; class.<br>
Dictionary implements both the generic and nongeneric IDictionary interfaces, the<br>generic IDictionary being exposed publicly. Dictionary is, in fact, a "textbook" im-<br>plementation of the generic IDictionary.<br>Here's how to use it:<br>
var d = new Dictionary&lt;string, int&gt;();<br>
d.Add(&quot;One&quot;, 1);<br>d[&quot;Two&quot;] = 2;     // adds to dictionary because &quot;two&quot; not already present<br>
d[&quot;Two&quot;] = 22;    // updates dictionary because &quot;two&quot; is now present<br>d[&quot;Three&quot;] = 3;<br>
Console.WriteLine (d[&quot;Two&quot;]);                // Prints &quot;22&quot;<br>Console.WriteLine (d.ContainsKey (&quot;One&quot;));   // true (fast operation)<br>Console.WriteLine (d.ContainsValue (3));     // true (slow operation)<br>int val = 0;<br>if (!d.TryGetValue (&quot;onE&quot;, out val))<br>  Console.WriteLine (&quot;No val&quot;);              // &quot;No val&quot; (case sensitive)<br>
// Three different ways to enumerate the dictionary:<br>
foreach (KeyValuePair&lt;string, int&gt; kv in d)          //  One ; 1<br>  Console.WriteLine (kv.Key + &quot;; &quot; + kv.Value);      //  Two ; 22<br>                                                     //  Three ; 3<br>
foreach (string s in d.Keys) Console.Write (s);      // OneTwoThree<br>Console.WriteLine();<br>foreach (int i in d.Values) Console.Write (i);       // 1223<br>
<b>294 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=315></a>Its underlying hashtable works by converting each element's key into an integer hash<br>code--a pseudounique value--and then applying an algorithm to convert the hash<br>code into a hash key. This hash key is used internally to determine which "bucket"<br>an entry belongs to. If the bucket contains more than one value, a linear search is<br>performed on the bucket. A hashtable typically starts out maintaining a 1:1 ratio of<br>buckets to values (a 1:1 <i>load factor</i>), meaning that each bucket contains only one<br>value. However, as more items are added to the hashtable, the load factor dynami-<br>cally increases, in a manner designed to optimize insertion and retrieval performance<br>as well as memory requirements.<br>
A dictionary can work with keys of any type, providing it's able to determine equality<br>between keys and obtain hash codes. By default, equality is determined via the key's<br>object.Equals method, and the pseudounique hash code is obtained via the key's<br>GetHashCode  method.  This  behavior  can  be  changed,  either  by  overriding  these<br>methods or by providing an IEqualityComparer object when constructing the dic-<br>tionary. A common application of this is to specify a case-insensitive equality com-<br>parer when using string keys:<br>
var d = new Dictionary&lt;string, int&gt; (StringComparer.OrdinalIgnoreCase);<br>
We discuss this further in "Plugging in Equality and Order" on page 304.<br>
As with many other types of collections, the performance of a dictionary can be<br>improved slightly by specifying the collection's expected size in the constructor,<br>avoiding or lessening the need for internal resizing operations.<br>
The nongeneric version is (more aptly) named Hashtable and is functionally similar<br>apart from differences stemming from it exposing the nongeneric IDictionary in-<br>terface discussed previously.<br>
The downside to Dictionary and Hashtable is that the items are not sorted. Further-<br>more, the original order in which the items were added is not retained. As with all<br>dictionaries, duplicate keys are not allowed.<br>
<b>OrderedDictionary<br></b>An OrderedDictionary is a nongeneric dictionary that maintains elements in the same<br>order that they were added. With an OrderedDictionary, you can access elements<br>both by index and by key.<br>
<b>Collections</b><br>
An OrderedDictionary is not a <i>sorted</i> dictionary.<br>
An OrderedDictionary is a combination of a Hashtable and an ArrayList. This means<br>it has all the functionality of a Hashtable, plus functions such as RemoveAt, as well as<br>an integer indexer. It also exposes Keys and Values properties that return elements<br>in their original order.<br>
This class was introduced in .NET 2.0, yet peculiarly, there's no generic version.<br>
<b>Dictionaries | 295</b><br>
<hr>
<A name=316></a><b>ListDictionary and HybridDictionary<br></b>ListDictionary uses a singly linked list to store the underlying data. It doesn't pro-<br>vide  sorting,  although  it  does  preserve  the  original  entry  order  of  the  items.<br>ListDictionary is extremely slow with large lists. Its only real "claim to fame" is its<br>efficiency with very small lists (fewer than 10 items).<br>
HybridDictionary  is  a  ListDictionary  that  automatically  converts  to  a  Hashtable<br>upon reaching a certain size, to address ListDictionary's problems with perform-<br>ance. The idea is to get a low memory footprint when the dictionary is small, and<br>good performance when the dictionary is large. However, given the overhead in<br>converting from one to the other--and the fact that a Dictionary is not excessively<br>heavy  or  slow  in  either  scenario--you  wouldn't  suffer  unreasonably  by  using  a<br>Dictionary to begin with.<br>
Both classes come only in nongeneric form.<br>
<b>Sorted Dictionaries<br></b>The Framework provides two dictionary classes internally structured such that their<br>content is always sorted by key:<br>
· SortedDictionary&lt;TKey,TValue&gt;<br>· SortedList&lt;TKey,TValue&gt;*<br>
(In this section, we will abbreviate &lt;TKey,TValue&gt; to &lt;,&gt;.)<br>
SortedDictionary&lt;,&gt;  uses  a  red/black  tree:  a  data  structure  designed  to  perform<br>consistently well in any insertion or retrieval scenario.<br>
SortedList&lt;,&gt; is implemented internally with an ordered array pair, providing fast<br>retrieval (via a binary-chop search) but poor insertion performance (because existing<br>values have to be shifted to make room for a new entry).<br>
SortedDictionary&lt;,&gt; is much faster than SortedList&lt;,&gt; at inserting elements in a<br>random sequence (particularly with large lists). SortedList&lt;,&gt;, however, has an ex-<br>tra ability: to access items by index as well as by key. With a sorted list, you can go<br>directly to the <i>n</i>th element in the sorting sequence (via the indexer on the Keys/<br>Values properties). To do the same with a SortedDictionary&lt;,&gt;, you must manually<br>enumerate over <i>n</i> items. (Alternatively, you could write a class that combines a sorted<br>dictionary with a list class.)<br>
None  of  the  three  collections  allows  duplicate  keys  (as  is  the  case  with  all<br>dictionaries).<br>
The  following  example  uses  reflection  to  load  all  the  methods  defined  in<br>System.Object  into  a  sorted  list  keyed  by  name,  and  then  enumerates  their  keys<br>and values:<br>
// MethodInfo is in the System.Reflection namespace<br>
* There's also a functionally identical nongeneric version of this called SortedList.<br>
<b>296 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=317></a>var sorted = new SortedList &lt;string, MethodInfo&gt;();<br>
foreach (MethodInfo m in typeof (object).GetMethods())<br>  sorted [m.Name] = m;<br>
foreach (string name in sorted.Keys)<br>  Console.WriteLine (name);<br>
foreach (MethodInfo m in sorted.Values)<br>
  Console.WriteLine (m.Name + &quot; returns a &quot; + m.ReturnType);<br>
Here's the result of the first enumeration:<br>
Equals<br>GetHashCode<br>GetType<br>
ReferenceEquals<br>
ToString<br>
Here's the result of the second enumeration:<br>
Equals returns a System.Boolean<br>GetHashCode returns a System.Int32<br>GetType returns a System.Type<br>
ReferenceEquals returns a System.Boolean<br>
ToString returns a System.String<br>
Notice that we populated the dictionary through its indexer. If we instead used the<br>Add method, it would throw an exception because the object class upon which we're<br>reflecting overloads the Equals method, and you can't add the same key twice to a<br>dictionary. By using the indexer, the later entry overwrites the earlier entry, pre-<br>venting this error.<br>
You can store multiple members of the same key by making each<br>value element a list:<br>
SortedList &lt;string, List&lt;MethodInfo&gt;&gt;<br>
Extending our example, the following retrieves the MethodInfo whose key is &quot;GetHash<br>Code&quot;, just as with an ordinary dictionary:<br>
<b>Collections</b><br>
Console.WriteLine (sorted [&quot;GetHashCode&quot;]);      // Int32 GetHashCode()<br>
So far, everything we've done would also work with a SortedDictionary&lt;,&gt;. The<br>following two lines, however, which retrieve the last key and value, work only with<br>a sorted list:<br>
Console.WriteLine (sorted.Keys  [sorted.Count - 1]);            // ToString<br>Console.WriteLine (sorted.Values[sorted.Count - 1].IsVirtual);  // True<br>
<b>Dictionaries | 297</b><br>
<hr>
<A name=318></a><b>Customizable Collections and Proxies<br></b>The collection classes discussed in previous sections are convenient in that they can<br>be directly instantiated, but they don't allow you to control what happens when an<br>item is added to or removed from the collection. With strongly typed collections in<br>an application, you sometimes need this control--for instance:<br>
· To fire an event when an item is added or removed<br>· To update properties because of the added or removed item<br>· To detect an "illegal" add/remove operation and throw an exception (for ex-<br>
ample, if the operation violates a business rule)<br>
The  .NET  Framework  provides  collection  classes  for  this  exact  purpose,  in  the<br>System.Collections.ObjectModel namespace. These are essentially proxies or wrap-<br>pers that implement IList&lt;T&gt; or IDictionary&lt;,&gt; by forwarding the methods through<br>to an underlying collection. Each  Add, Remove, or Clear operation is routed via a<br>virtual method that acts as a "gateway" when overridden.<br>
Customizable collection classes are commonly used for publicly exposed collections;<br>for  instance,  a  collection  of  controls  exposed  publicly  on  a  System.Windows.Form<br>class.<br>
<b>Collection&lt;T&gt; and CollectionBase<br></b>Collection&lt;T&gt; class is a customizable wrapper for List&lt;T&gt;.<br>
As well as implementing IList&lt;T&gt; and IList, it defines four additional virtual meth-<br>ods and a protected property as follows:<br>
public class Collection&lt;T&gt; :<br>  IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable<br>{<br>   // ...<br>
   protected virtual void ClearItems();<br>   protected virtual void InsertItem (int index, T item);<br>   protected virtual void RemoveItem (int index);<br>   protected virtual void SetItem (int index, T item);<br>
   protected IList&lt;T&gt; Items { get; }<br>}<br>
The virtual methods provide the gateway by which you can "hook in" to change or<br>enhance the list's normal behavior. The protected Items property allows the imple-<br>menter to directly access the "inner list"--this is used to make changes internally<br>without the virtual methods firing.<br>
The virtual methods need not be overridden; they can be left alone until there's a<br>requirement to alter the list's default behavior. The following example demonstrates<br>the typical "skeleton" use of Collection&lt;T&gt;:<br>
<b>298 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=319></a>public class Animal<br>
{<br>  public string Name;<br>  public int Popularity;<br>
  public Animal (string name, int popularity)<br>  {<br>    Name = name; Popularity = popularity;<br>
  }<br>
}<br>
public class AnimalCollection : Collection &lt;Animal&gt;<br>
{<br>  // AnimalCollection is already a fully functioning list of animals.<br>
  // No extra code is required.<br>}<br>
public class Zoo   // The class that will expose AnimalCollection.<br>
{                  // This would typically have additional members.<br>
  public readonly AnimalCollection Animals = new AnimalCollection();<br>
}<br>
class Program<br>{<br>  static void Main()<br>
  {<br>    Zoo zoo = new Zoo();<br>    zoo.Animals.Add (new Animal (&quot;Kangaroo&quot;, 10));<br>    zoo.Animals.Add (new Animal (&quot;Mr Sea Lion&quot;, 20));<br>    foreach (Animal a in zoo.Animals) Console.WriteLine (a.Name);<br>
  }<br>}<br>
As it stands, AnimalCollection is no more functional than a simple List&lt;Animal&gt;; its<br>role is to provide a base for future extension. To illustrate, we'll now add a  Zoo<br>property to Animal, so it can reference the Zoo in which it lives and override each of<br>the virtual methods in Collection&lt;Animal&gt; to maintain that property automatically:<br>
public class Animal<br>{<br>  public string Name;<br>
<b>Collections</b><br>
  public int Popularity;<br>  public Zoo Zoo { get; internal set; }<br>  public Animal(string name, int popularity)<br>  {<br>    Name = name; Popularity = popularity;<br>  }<br>}<br>
public class AnimalCollection : Collection &lt;Animal&gt;<br>{<br>  Zoo zoo;<br>  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }<br> <br>
<b>Customizable Collections and Proxies | 299</b><br>
<hr>
<A name=320></a>  protected override void InsertItem (int index, Animal item)<br>
  {<br>    base.InsertItem (index, item);<br>    item.Zoo = zoo;<br>
  }<br>
  protected override void SetItem (int index, Animal item)<br>  {<br>    base.SetItem (index, item);<br>
    item.Zoo = zoo;<br>
  }<br>  protected override void RemoveItem (int index)<br>  {<br>
    this [index].Zoo = null;<br>
    base.RemoveItem (index);<br>  }<br>  protected override void ClearItems()<br>
  {<br>
    foreach (Animal a in this) a.Zoo = null;<br>    base.ClearItems();<br>  }<br>
}<br>
public class Zoo<br>{<br>  public readonly AnimalCollection Animals;<br>  public Zoo() { Animals = new AnimalCollection (this); }<br>
}<br>
Collection&lt;T&gt; also has a constructor accepting an existing IList&lt;T&gt;. Unlike with<br>other collection classes, the supplied list is <i>proxied</i> rather than <i>copied</i>, meaning that<br>subsequent  changes  will  be  reflected  in  the  wrapping  Collection&lt;T&gt;  (although<br><i>without </i>Collection&lt;T&gt;'s virtual methods firing). Conversely, changes made via the<br>Collection&lt;T&gt; will change the underlying list.<br>
<b>CollectionBase<br></b>CollectionBase is the nongeneric version of Collection&lt;T&gt; introduced in Framework<br>1.0. This provides most of the same features as Collection&lt;T&gt; but is clumsier to use.<br>Instead of the template methods InsertItem, RemoveItem SetItem, and ClearItem,<br>CollectionBase has "hook" methods that double the number of methods required:<br>OnInsert,  OnInsertComplete,  OnSet,  OnSetComplete,  OnRemove,  OnRemoveComplete,<br>OnClear, and OnClearComplete. Because CollectionBase is nongeneric, you must also<br>implement typed methods when subclassing it--at a minimum, a typed indexer and<br>Add method.<br>
<b>KeyedCollection&lt;TKey,TItem&gt; and DictionaryBase<br></b>KeyedCollection&lt;TKey,TItem&gt; subclasses Collection&lt;TItem&gt;. It both adds and sub-<br>tracts functionality. What it adds is the ability to access items by key, much like with<br>a dictionary. What it subtracts is the ability to proxy your own inner list.<br>
<b>300 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=321></a>A keyed collection has some resemblance to an OrderedDictionary in that it com-<br>bines a linear list with a hashtable. However, unlike OrderedDictionary, it doesn't<br>implement IDictionary and doesn't support the concept of a key/value <i>pair</i>. Keys<br>are  obtained  instead  from  the  items  themselves:  via  the  abstract  GetKeyForItem<br>method.  This  means  enumerating  a  keyed  collection  is  just  like  enumerating  an<br>ordinary list.<br>
KeyedCollection&lt;TKey,TItem&gt;  is  best  thought  of  as  Collection&lt;TItem&gt;  plus  fast<br>lookup by key.<br>
Because it subclasses Collection&lt;&gt;, a keyed collection inherits all of Collection&lt;&gt;'s<br>functionality, except for the ability to specify an existing list in construction. The<br>additional members it defines are as follows:<br>
public abstract class KeyedCollection &lt;TKey, TItem&gt; : Collection &lt;TItem&gt;<br>
  // ...<br>
  protected abstract TKey GetKeyForItem(TItem item);<br>
  protected void ChangeItemKey(TItem item, TKey newKey);<br>
  // Fast lookup by key - this is in addition to lookup by index.<br>
  public TItem this[TKey key] { get; }<br>
  protected IDictionary&lt;TKey, TItem&gt; Dictionary { get; }<br>
}<br>
GetKeyForItem is what the implementer overrides to obtain an item's key from the<br>underlying object. The ChangeItemKey method must be called if the item's key prop-<br>erty changes, in order to update the internal dictionary. The Dictionary property<br>returns the internal dictionary used to implement the lookup, which is created when<br>the  first  item  is  added.  This  behavior  can  be  changed  by  specifying  a  creation<br>threshold in the constructor, delaying the internal dictionary from being created<br>until the threshold is reached (in the interim, a linear search is performed if an item<br>is requested by key). A good reason not to specify a creation threshold is that having<br>a  valid  dictionary  can  be  useful  in  obtaining  an  ICollection&lt;&gt;  of  keys,  via  the<br>Dictionary's  Keys  property.  This  collection  can  then  be  passed  on  to  a  public<br>property.<br>
The most common use for KeyedCollection&lt;,&gt; is in providing a collection of items<br>
<b>Collections</b><br>
accessible both by index and by name. To demonstrate this, we'll revisit the zoo,<br>this time implementing AnimalCollection as a KeyedCollection&lt;string,Animal&gt;:<br>
public class Animal<br>{<br>  string name;<br>  public string Name<br>  {<br>    get { return name; }<br>    set {<br>      if (Zoo != null) Zoo.Animals.NotifyNameChange (this, value);<br>      name = value;<br>    }<br>  }<br>
<b>Customizable Collections and Proxies | 301</b><br>
<hr>
<A name=322></a>  public int Popularity;<br>
  public Zoo Zoo { get; internal set; }<br>
  public Animal (string name, int popularity)<br>
  {<br>
    Name = name; Popularity = popularity;<br>  }<br>}<br>
public class AnimalCollection : KeyedCollection &lt;string, Animal&gt;<br>{<br>  Zoo zoo;<br>
  public AnimalCollection (Zoo zoo) { this.zoo = zoo; }<br>
  internal void NotifyNameChange (Animal a, string newName)<br>  {<br>
    this.ChangeItemKey (a, newName);<br>  }<br>
  protected override string GetKeyForItem (Animal item)<br>  {<br>
    return item.Name;<br>
  }<br>
  // The following methods would be implemented as in the previous example<br>
  protected override void InsertItem (int index, Animal item)...<br>  protected override void SetItem (int index, Animal item)...<br>
  protected override void RemoveItem (int index)...<br>  protected override void ClearItems()...<br>
}<br>
public class Zoo<br>{<br>  public readonly AnimalCollection Animals;<br>  public Zoo() { Animals = new AnimalCollection (this); }<br>}<br>
class Program<br>{<br>  static void Main()<br>  {<br>    Zoo zoo = new Zoo();<br>    zoo.Animals.Add (new Animal (&quot;Kangaroo&quot;, 10));<br>    zoo.Animals.Add (new Animal (&quot;Mr Sea Lion&quot;, 20));<br>
    Console.WriteLine (zoo.Animals [0].Popularity);               // 10<br>    Console.WriteLine (zoo.Animals [&quot;Mr Sea Lion&quot;].Popularity);   // 20<br>    zoo.Animals [&quot;Kangaroo&quot;].Name = &quot;Mr Roo&quot;;<br>    Console.WriteLine (zoo.Animals [&quot;Mr Roo&quot;].Popularity);        // 10<br>  }<br>}<br>
<b>DictionaryBase<br></b>The  nongeneric  version  of  KeyedCollection is called  DictionaryBase. This legacy<br>class  takes  very  different  in  its  approach:  it  implements  IDictionary  and  uses<br>
<b>302 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=323></a>clumsy  hook  methods  like  CollectionBase:  OnInsert,  OnInsertComplete,  OnSet,<br>OnSetComplete, OnRemove, OnRemoveComplete, OnClear, and OnClearComplete (and ad-<br>ditionally, OnGet). The primary advantage of implementing IDictionary over taking<br>the KeyedCollection approach is that you don't need to subclass it in order to obtain<br>keys. But since the very purpose of DictionaryBase is to be subclassed, it's no ad-<br>vantage at all. The improved model in KeyedCollection is almost certainly due to<br>the  fact  that  it  was  written  some  years  later,  with  the  benefit  of  hindsight.<br>DictionaryBase is best considered useful for backward compatibility.<br>
<b>ReadOnlyCollection&lt;T&gt;<br></b>ReadOnlyCollection&lt;T&gt; is a wrapper, or <i>proxy</i>, that provides a read-only view of a<br>collection. This is useful in allowing a class to publicly expose read-only access to a<br>collection that the class can still update internally.<br>
A read-only collection accepts the input collection in its constructor, to which it<br>maintains a permanent reference. It doesn't take a static copy of the input collection,<br>so  subsequent  changes  to  the  input  collection  are  visible  through  the  read-only<br>wrapper.<br>
To illustrate, suppose your class wants to provide read-only public access to a list<br>of strings called Names:<br>
public class Test<br>
{<br>  public List&lt;string&gt; Names { get; private set; }<br>
}<br>
This only does half the job. Although other types cannot reassign the Names property,<br>they can still call Add, Remove, or Clear on the list. The ReadOnlyCollection&lt;T&gt; class<br>resolves this:<br>
public class Test<br>{<br>  List&lt;string&gt; names;<br>  public ReadOnlyCollection&lt;string&gt; Names { get; private set; }<br>
  public Test()<br>  {<br>    names = new List&lt;string&gt;();<br>
<b>Collections</b><br>
    Names = new ReadOnlyCollection&lt;string&gt; (names);<br>  }<br>
  public void AddInternally() { names.Add (&quot;test&quot;); }<br>}<br>
Now, only members within the Test class can alter the list of names:<br>
Test t = new Test();<br>
Console.WriteLine (t.Names.Count);       // 0<br>t.AddInternally();<br>Console.WriteLine (t.Names.Count);       // 1<br>
<b>Customizable Collections and Proxies | 303</b><br>
<hr>
<A name=324></a>t.Names.Add (&quot;test&quot;);                    // Compiler error<br>
((IList&lt;string&gt;) t.Names).Add (&quot;test&quot;);  // NotSupportedException<br>
<b>Plugging in Equality and Order<br></b>In  the  sections  "Equality  Comparison"  on  page  245  and  "Order  Compari-<br>son" on page 255 in Chapter 6, we described the standard .NET protocols that make<br>a type equatable, hashable, and comparable. A type that implements these protocols<br>can  function  correctly  in  a  dictionary  or  sorted  list  "out  of  the  box."  More<br>specifically:<br>
· A type for which Equals and GetHashCode return meaningful results can be used<br>
as a key in a Dictionary or Hashtable.<br>
· A type that implements IComparable /IComparable&lt;T&gt; can be used as a key in<br>
any of the <i>sorted</i> dictionaries or lists.<br>
A type's default equating or comparison implementation typically reflects what is<br>most "natural" for that type. Sometimes, however, the default behavior is not what<br>you  want.  You  might  need  a  dictionary  whose  string-type  key  is  treated  case-<br>insensitively. Or you might want a sorted list of customers, sorted by each customer's<br>postcode. For this reason, the .NET Framework also defines a matching set of "plug-<br>in" protocols. The plug-in protocols achieve two things:<br>
· They allow you to switch in alternative equating or comparison behavior.<br>· They allow you to use a dictionary or sorted collection with a key type that's<br>
not intrinsically equatable or comparable.<br>
The plug-in protocols consist of the following interfaces:<br>
IEqualityComparer<i> and </i>IEqualityComparer&lt;T&gt;<br>
· Performs plug-in <i>equality comparison and hashing<br></i>· Recognized by Hashtable and Dictionary<br>
IComparer<i> and </i>IComparer&lt;T&gt;<br>
· Performs plug-in <i>order comparison<br></i>· Recognized by the sorted dictionaries and collections; also, Array.Sort<br>
Each interface comes in generic and nongeneric forms. The IEqualityComparer in-<br>terfaces also have a default implementation in a class called EqualityComparer.<br>In addition, Framework 4.0 adds two new interfaces called IStructuralEquatable<br>and IStructuralComparable, which allow the option of structural comparisons on<br>classes and arrays.<br>
<b>IEqualityComparer and EqualityComparer<br></b>An equality comparer switches in nondefault equality and hashing behavior, pri-<br>marily for the Dictionary and Hashtable classes.<br>
<b>304 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=325></a>Recall the requirements of a hashtable-based dictionary. It needs answers to two<br>questions for any given key:<br>
· Is it the same as another?<br>· What is its integer hash code?<br>
An  equality  comparer  answers  these  questions  by  implementing  the<br>IEqualityComparer interfaces:<br>
public interface IEqualityComparer&lt;T&gt;<br>
{<br>   bool Equals (T x, T y);<br>
   int GetHashCode (T obj);<br>
}<br>
public interface IEqualityComparer     // Nongeneric version<br>
{<br>   bool Equals (object x, object y);<br>   int GetHashCode (object obj);<br>}<br>
To write a custom comparer, you implement one or both of these interfaces (im-<br>plementing both gives maximum interoperability). As this is somewhat tedious, an<br>alternative is to subclass the abstract EqualityComparer class, defined as follows:<br>
public abstract class EqualityComparer&lt;T&gt; : IEqualityComparer,<br>                                            IEqualityComparer&lt;T&gt;<br>
{<br>  <b>public abstract bool Equals (T x, T y);<br></b>  <b>public abstract int GetHashCode (T obj);</b><br>
  bool IEqualityComparer.Equals (object x, object y);<br>  int IEqualityComparer.GetHashCode (object obj);<br>
  public static EqualityComparer&lt;T&gt; Default { get; }<br>}<br>
EqualityComparer implements both interfaces; your job is simply to override the two<br>abstract methods.<br>
The semantics for Equals and GetHashCode follow the same rules for object.Equals<br>and object.GetHashCode, described in Chapter 6. In the following example, we define<br>
<b>Collections</b><br>
a Customer class with two fields, and then write an equality comparer that matches<br>both the first and last names:<br>
public class Customer<br>{<br>  public string LastName;<br>  public string FirstName;<br>
  public Customer (string last, string first)<br>  {<br>    LastName = last;<br>    FirstName = first;<br>  }<br>}<br>
<b>Plugging in Equality and Order | 305</b><br>
<hr>
<A name=326></a>public class LastFirstEqComparer : EqualityComparer &lt;Customer&gt;<br>
{<br>  public override bool Equals (Customer x, Customer y)<br>  {<br>
    return x.LastName == y.LastName &amp;&amp; x.FirstName == y.FirstName;<br>
  }<br>
  public override int GetHashCode (Customer obj)<br>
  {<br>
    return (obj.LastName + &quot;;&quot; + obj.FirstName).GetHashCode();<br>  }<br>}<br>
To illustrate how this works, we'll create two customers:<br>
Customer c1 = new Customer (&quot;Bloggs&quot;, &quot;Joe&quot;);<br>
Customer c2 = new Customer (&quot;Bloggs&quot;, &quot;Joe&quot;);<br>
Because we haven't overridden object.Equals, normal reference type equality se-<br>mantics apply:<br>
Console.WriteLine (c1 == c2);               // False<br>Console.WriteLine (c1.Equals (c2));         // False<br>
The  same  default  equality  semantics  apply  when  using  these  customers  in  a<br>Dictionary without specifying an equality comparer:<br>
var d = new Dictionary&lt;Customer, string&gt;();<br>d [c1] = &quot;Joe&quot;;<br>
Console.WriteLine (d.ContainsKey (c2));         // False<br>
Now with the custom equality comparer:<br>
var eqComparer = new LastFirstEqComparer();<br>var d = new Dictionary&lt;Customer, string&gt; (eqComparer);<br>d [c1] = &quot;Joe&quot;;<br>Console.WriteLine (d.ContainsKey (c2));         // True<br>
In  this  example,  we  would  have  to  be  careful  not  to  change  the  customer's<br>FirstName or LastName while it was in use in the dictionary. Otherwise, its hash code<br>would change and the Dictionary would break.<br>
<b>EqualityComparer&lt;T&gt;.Default<br></b>Calling EqualityComparer&lt;T&gt;.Default returns a general-purpose equality comparer<br>that can be used as an alternative to the static object.Equals method. The advantage<br>is that first checks if T implements IEquatable&lt;T&gt; and if so, calls that implementation<br>instead, avoiding the boxing overhead. This is particularly useful in generic methods:<br>
static bool Foo&lt;T&gt; (T x, T y)<br> {<br>   bool same = <b>EqualityComparer&lt;T&gt;.Default.Equals</b> (x, y);<br>  ...<br>
<b>306 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=327></a><b>IComparer and Comparer<br></b>Comparers are used to switch in custom ordering logic for sorted dictionaries and<br>collections.<br>
Note that a comparer is useless to the unsorted dictionaries such as Dictionary and<br>Hashtable--these  require  an  IEqualityComparer  to  get  hash  codes.  Similarly,  an<br>equality comparer is useless for sorted dictionaries and collections.<br>
Here are the IComparer interface definitions:<br>
public interface IComparer<br>
{<br>  int Compare(object x, object y);<br>
}<br>public interface IComparer &lt;in T&gt;<br>
{<br>  int Compare(T x, T y);<br>
}<br>
As with equality comparers, there's an abstract class you can subtype instead of<br>implementing the interfaces:<br>
public abstract class Comparer&lt;T&gt; : IComparer, IComparer&lt;T&gt;<br>
{<br>   public static Comparer&lt;T&gt; Default { get; }<br>
   <b>public abstract int Compare (T x, T y);</b>       // Implemented <i>by</i> you<br>
   int IComparer.Compare (object x, object y);   // Implemented <i>for</i> you<br>}<br>
The following example illustrates a class that describes a wish, and a comparer that<br>sorts wishes by priority:<br>
class Wish<br>{<br>  public string Name;<br>  public int Priority;<br>
  public Wish (string name, int priority)<br>  {<br>    Name = name;<br>
<b>Collections</b><br>
    Priority = priority;<br>  }<br>}<br>
class PriorityComparer : Comparer &lt;Wish&gt;<br>{<br>  public override int Compare (Wish x, Wish y)<br>  {<br>    if (object.Equals (x, y)) return 0;          // Fail-safe check<br>    return x.Priority.CompareTo (y.Priority);<br>  }<br>}<br>
<b>Plugging in Equality and Order | 307</b><br>
<hr>
<A name=328></a>The object.Equals check ensures that we can never contradict the Equals method.<br>Calling the static object.Equals method in this case is better than calling x.Equals<br>because it still works if x is null!<br>Here's how our PriorityComparer is used to sort a List:<br>
var wishList = new List&lt;Wish&gt;();<br>wishList.Add (new Wish (&quot;Peace&quot;, 2));<br>
wishList.Add (new Wish (&quot;Wealth&quot;, 3));<br>wishList.Add (new Wish (&quot;Love&quot;, 2));<br>
wishList.Add (new Wish (&quot;3 more wishes&quot;, 1));<br>
wishList.Sort (new PriorityComparer());<br>
foreach (Wish w in wishList) Console.Write (w.Name + &quot; | &quot;);<br>
// OUTPUT: 3 more wishes | Love | Peace | Wealth |<br>
In the next example, SurnameComparer allows you to sort surname strings in an order<br>suitable for a phonebook listing:<br>
class SurnameComparer : Comparer &lt;string&gt;<br>
{<br>  string Normalize (string s)<br>
  {<br>    s = s.Trim().ToUpper();<br>    if (s.StartsWith (&quot;MC&quot;)) s = &quot;MAC&quot; + s.Substring (2);<br>
    return s;<br>
  }<br>
  public override int Compare (string x, string y)<br>  {<br>    return Normalize (x).CompareTo (Normalize (y));<br>  }<br>}<br>
Here's SurnameComparer in use in a sorted dictionary:<br>
var dic = new SortedDictionary&lt;string,string&gt; (new SurnameComparer());<br>dic.Add (&quot;MacPhail&quot;, &quot;second!&quot;);<br>dic.Add (&quot;MacWilliam&quot;, &quot;third!&quot;);<br>dic.Add (&quot;McDonald&quot;, &quot;first!&quot;);<br>
foreach (string s in dic.Values)<br>  Console.Write (s + &quot; &quot;);              // first! second! third!<br>
<b>StringComparer<br></b>StringComparer is  a  predefined  plug-in class  for  equating and comparing strings,<br>allowing you to specify language and case sensitivity. StringComparer implements<br>both IEqualityComparer and IComparer (and their generic versions), so it can be used<br>with any type of dictionary or sorted collection:<br>
// CultureInfo is defined in System.Globalization<br>
public abstract class StringComparer : IComparer, IComparer &lt;string&gt;,<br>                                       IEqualityComparer,<br>                                       IEqualityComparer &lt;string&gt;<br>
<b>308 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=329></a>{<br>  public abstract int Compare (string x, string y);<br>  public abstract bool Equals (string x, string y);<br>  public abstract int GetHashCode (string obj);<br>
  public static StringComparer Create (CultureInfo culture,<br>                                       bool ignoreCase);<br>  public static StringComparer CurrentCulture { get; }<br>
  public static StringComparer CurrentCultureIgnoreCase { get; }<br>
  public static StringComparer InvariantCulture { get; }<br>  public static StringComparer InvariantCultureIgnoreCase { get; }<br>  public static StringComparer Ordinal { get; }<br>
  public static StringComparer OrdinalIgnoreCase { get; }<br>
}<br>
Because StringComparer is abstract, you obtain instances via its static methods and<br>properties. StringComparer.Ordinal mirrors the default behavior for string equality<br>comparison and StringComparer.CurrentCulture for order comparison.<br>In the following example, an ordinal case-insensitive dictionary is created, such that<br>dict[&quot;Joe&quot;] and dict[&quot;JOE&quot;] mean the same thing:<br>
var dict = new Dictionary&lt;string, int&gt; (StringComparer.OrdinalIgnoreCase);<br>
In the next example, an array of names is sorted, using Australian English:<br>
string[] names = { &quot;Tom&quot;, &quot;HARRY&quot;, &quot;sheila&quot; };<br>
CultureInfo ci = new CultureInfo (&quot;en-AU&quot;);<br>Array.Sort&lt;string&gt; (names, StringComparer.Create (ci, false));<br>
The final example is a culture-aware version of the SurnameComparer we wrote in the<br>previous section (to compare names suitable for a phonebook listing):<br>
class SurnameComparer : Comparer &lt;string&gt;<br>{<br>  StringComparer strCmp;<br>
  public SurnameComparer (CultureInfo ci)<br>  {<br>    // Create a case-sensitive, culture-sensitive string comparer<br>    strCmp = StringComparer.Create (ci, false);<br>  }<br> <br>
<b>Collections</b><br>
  string Normalize (string s)<br>  {<br>    s = s.Trim();<br>    if (s.ToUpper().StartsWith (&quot;MC&quot;)) s = &quot;MAC&quot; + s.Substring (2);<br>    return s;<br>  }<br>
  public override int Compare (string x, string y)<br>  {<br>    // Directly call Compare on our culture-aware StringComparer<br>    return strCmp.Compare (Normalize (x), Normalize (y));<br>  }<br>}<br>
<b>Plugging in Equality and Order | 309</b><br>
<hr>
<A name=330></a><b>IStructuralEquatable and IStructuralComparable<br></b>As we said in the previous chapter, structs implement <i>structural comparison</i> by de-<br>fault: two structs are equal if all of their fields are equal. Sometimes, however, struc-<br>tural equality and order comparison are useful as plug-in options on other types as<br>well--such as arrays and tuples. Framework 4.0 introduces two new interfaces to<br>help with this:<br>
public interface IStructuralEquatable<br>
{<br>  bool Equals (object other, IEqualityComparer comparer);<br>
  int GetHashCode (IEqualityComparer comparer);<br>
}<br>
public interface IStructuralComparable<br>
{<br>  int CompareTo (object other, IComparer comparer);<br>}<br>
The IEqualityComparer/IComparer that you pass in are applied to each individual<br>element in the composite object. We can demonstrate this using arrays and tuples,<br>which implement these interfaces: in the following example, we compare two arrays<br>for equality: first using the default Equals method, and then using IStructuralEquat<br>able's version:<br>
int[] a1 = { 1, 2, 3 };<br>
int[] a2 = { 1, 2, 3 };<br>
Console.Write (a1.Equals (a2));                                 // False<br>Console.Write (a1.Equals (a2, EqualityComparer&lt;int&gt;.Default));  // True<br>
Here's another example:<br>
string[] a1 = &quot;the quick brown fox&quot;.Split();<br>string[] a2 = &quot;THE QUICK BROWN FOX&quot;.Split();<br>bool <b>isTrue</b> = a1.Equals (a2, StringComparer.InvariantCultureIgnoreCase);<br>
Tuples work in the same way:<br>
var t1 = Tuple.Create (1, &quot;foo&quot;);<br>var t2 = Tuple.Create (1, &quot;FOO&quot;);<br>bool <b>isTrue</b> = t1.Equals (t2, StringComparer.InvariantCultureIgnoreCase);<br>int <b>zero</b> = t1.CompareTo (t2, StringComparer.InvariantCultureIgnoreCase);<br>
The difference with tuples, though, is that their <i>default</i> equality and order compar-<br>ison implementations also apply structural comparisons:<br>
var t1 = Tuple.Create (1, &quot;FOO&quot;);<br>var t2 = Tuple.Create (1, &quot;FOO&quot;);<br>Console.WriteLine (t1.Equals (t2));   // True<br>
<b>310 | Chapter 7:</b><b>Collections</b><br>
<hr>
<A name=331></a><b>8</b><br>
<b>LINQ Queries</b><br>
LINQ, or Language Integrated Query, is a set of language and framework features<br>for writing structured type-safe queries over local object collections and remote data<br>sources. LINQ was introduced in C# 3.0 and Framework 3.5.<br>
LINQ enables you to query any collection implementing IEnumerable&lt;T&gt;, whether<br>an array, list, or XML DOM, as well as remote data sources, such as tables in SQL<br>Server. LINQ offers the benefits of both compile-time type checking and dynamic<br>query composition.<br>
This chapter describes the LINQ architecture and the fundamentals of writing quer-<br>ies.  All  core  types  are  defined  in  the  System.Linq  and  System.Linq.Expressions<br>namespaces.<br>
The examples in this and the following two chapters are pre-<br>loaded into an interactive querying tool called LINQPad. You<br>can download LINQPad from <i>www.linqpad.net</i>.<br>
<b>Getting Started<br></b>The basic units of data in LINQ are <i>sequences</i> and <i>elements</i>. A sequence is any object<br>that implements IEnumerable&lt;T&gt; and an element is each item in the sequence. In the<br>following example, names is a sequence, and Tom, Dick, and Harry are elements:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; };<br>
We call this a <i>local sequence</i> because it represents a local collection of objects in<br>memory.<br>
A <i>query operator</i> is a method that transforms a sequence. A typical query operator<br>accepts  an  <i>input  sequence</i>  and  emits  a  transformed  <i>output  sequence</i>.  In  the<br>Enumerable class in System.Linq, there are around 40 query operators--all imple-<br>mented as static extension methods. These are called <i>standard query operators</i>.<br>
<b>311</b><br>
<hr>
<A name=332></a>Queries that operate over local sequences are called local quer-<br>ies or <i>LINQ-to-objects</i> queries.<br>
LINQ also supports sequences that can be dynamically fed from<br>a remote data source such as a SQL Server. These sequences<br>additionally  implement  the  IQueryable&lt;T&gt;  interface  and  are<br>supported through a matching set of standard query operators<br>in the Queryable class. We discuss this further in the section<br>"Interpreted Queries" on page 339 later in this chapter.<br>
A query is an expression that transforms sequences with query operators. The sim-<br>plest query comprises one input sequence and one operator. For instance, we can<br>apply the Where operator on a simple array to extract those whose length is at least<br>four characters as follows:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; };<br>
<b>IEnumerable&lt;string&gt; filteredNames = System.Linq.Enumerable.Where<br></b>                                    <b>(names, n =&gt; n.Length &gt;= 4);</b><br>
foreach (string n in filteredNames)<br>
  Console.WriteLine (n);<br>
<i>Dick<br>Harry</i><br>
Because the standard query operators are implemented as extension methods, we<br>can call Where directly on names--as though it were an instance method:<br>
IEnumerable&lt;string&gt; filteredNames = <b>names.Where</b> (n =&gt; n.Length &gt;= 4);<br>
For this to compile, you must import the System.Linq namespace. Here's a complete<br>example:<br>
using System;<br>usign System.Collections.Generic;<br>using System.Linq;<br>
class LinqDemo<br>{<br>  static void Main()<br>  {<br>    string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot; };<br>
    <b>IEnumerable&lt;string&gt; filteredNames = names.Where (n =&gt; n.Length &gt;= 4);<br></b>    foreach (string name in filteredNames) Console.WriteLine (name);<br>  }<br>}<br>
<i>Dick<br>Harry</i><br>
<b>312 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=333></a>We  could  further  shorten  our  code  by  implicitly  typing<br>filteredNames:<br>
<b>var</b> filteredNames = names.Where (n =&gt; n.Length &gt;= 4);<br>
This can hinder readability, however, particularly outside of an<br>IDE, where there are no tool tips to help.<br>
In this chapter, we avoid implicitly typing query results except<br>when it's mandatory (as we'll see later, in the section "Projection<br>Strategies" on page 337), or when a query's type is irrelevant<br>to an example.<br>
Most query operators accept a lambda expression as an argument. The lambda ex-<br>pression helps guide and shape the query. In our example, the lambda expression is<br>as follows:<br>
n =&gt; n.Length &gt;= 4<br>
The input argument corresponds to an input element. In this case, the input argu-<br>ment n represents each name in the array and is of type string. The Where operator<br>requires that the lambda expression return a bool value, which if true, indicates that<br>the element should be included in the output sequence. Here's its signature:<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,<b>bool</b>&gt; predicate)<br>
The following query retrieves all names that contain the letter "a":<br>
IEnumerable&lt;string&gt; filteredNames = names.Where (<b>n =&gt; n.Contains (&quot;a&quot;)</b>);<br>
foreach (string name in filteredNames)<br>  Console.WriteLine (name);             // Harry<br>
So far, we've built queries using extension methods and lambda expressions. As we'll<br>see shortly, this strategy is highly composable in that it allows the chaining of query<br>operators. In the book, we refer to this as <i>fluent syntax</i>.* C# also provides another<br>syntax  for  writing  queries,  called  <i>query  expression</i>  syntax.  Here's  our  preceding<br>query written as a query expression:<br>
IEnumerable&lt;string&gt; filteredNames = from n in names<br>                                    where n.Contains (&quot;a&quot;)<br>                                    select n;<br>
Fluent syntax and query syntax are complementary. In the following two sections,<br>we explore each in more detail.<br>
<b>LINQ Queries</b><br>
* The term is based on Eric Evans and Martin Fowler's work on fluent interfaces.<br>
<b>Getting Started | 313</b><br>
<hr>
<A name=334></a><b>Fluent Syntax<br></b>Fluent syntax is the most flexible and fundamental. In this section, we describe how<br>to chain query operators to form more complex queries--and show why extension<br>methods are important to this process. We also describe how to formulate lambda<br>expressions for a query operator and introduce several new query operators.<br>
<b>Chaining Query Operators<br></b>In the preceding section, we showed two simple queries, each comprising a single<br>query operator. To build more complex queries, you append additional query op-<br>erators to the expression, creating a chain. To illustrate, the following query extracts<br>all strings containing the letter "a", sorts them by length, and then converts the<br>results to uppercase:<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
class LinqDemo<br>
{<br>  static void Main()<br>
  {<br>    string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
    IEnumerable&lt;string&gt; query = names<br>      .Where   (n =&gt; n.Contains (&quot;a&quot;))<br>
      .OrderBy (n =&gt; n.Length)<br>      .Select  (n =&gt; n.ToUpper());<br>
    foreach (string name in query) Console.WriteLine (name);<br>  }<br>}<br>
<i>JAY<br>MARY<br>HARRY</i><br>
The variable, n, in our example, is privately scoped to each of<br>the lambda expressions. We can reuse n for the same reason we<br>can reuse c in the following method:<br>
void Test()<br>{<br>  foreach (char c in &quot;string1&quot;) Console.Write (c);<br>  foreach (char c in &quot;string2&quot;) Console.Write (c);<br>
  foreach (char c in &quot;string3&quot;) Console.Write (c);<br>}<br>
Where, OrderBy, and Select are standard query operators that resolve to extension<br>methods in the Enumerable class (if you import the System.Linq namespace).<br>
<b>314 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=335></a>We already introduced the Where operator, which emits a filtered version of the input<br>sequence. The OrderBy operator emits a sorted version of its input sequence; the<br>Select method emits a sequence where each input element is transformed or <i>pro-<br>jected</i> with a given lambda expression (n.ToUpper(), in this case). Data flows from<br>left to right through the chain of operators, so the data is first filtered, then sorted,<br>then projected.<br>
A  query  operator  never  alters  the  input  sequence;  instead,  it<br>returns a new sequence. This is consistent with the <i>functional<br>programming</i> paradigm, from which LINQ was inspired.<br>
Here are the signatures of each of these extension methods (with the OrderBy signa-<br>ture simplified slightly):<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br>  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)<br>
public static IEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector)<br>
public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)<br>
When query operators are chained as in this example, the output sequence of one<br>operator is the input sequence of the next. The end result resembles a production<br>line of conveyor belts, as illustrated in Figure 8-1.<br>
<i>Figure 8-1. Chaining query operators</i><br>
We can construct the identical query <i>progressively</i>, as follows:<br>
// You must import the System.Linq namespace for this to compile:<br>
<b>LINQ Queries</b><br>
IEnumerable&lt;string&gt; filtered   = names   .Where   (n =&gt; n.Contains (&quot;a&quot;));<br>IEnumerable&lt;string&gt; sorted     = filtered.OrderBy (n =&gt; n.Length);<br>IEnumerable&lt;string&gt; finalQuery = sorted  .Select  (n =&gt; n.ToUpper());<br>
finalQuery is compositionally identical to the query we had constructed previously.<br>Further, each intermediate step also comprises a valid query that we can execute:<br>
foreach (string name in filtered)<br>  Console.Write (name + &quot;|&quot;);        // Harry|Mary|Jay|<br>
<b>Fluent Syntax | 315</b><br>
<hr>
<A name=336></a>Console.WriteLine();<br>
foreach (string name in sorted)<br>  Console.Write (name + &quot;|&quot;);        // Jay|Mary|Harry|<br>
Console.WriteLine();<br>
foreach (string name in finalQuery)<br>  Console.Write (name + &quot;|&quot;);        // JAY|MARY|HARRY|<br>
<b>Why extension methods are important<br></b>Instead of using extension method syntax, you can use conventional static method<br>syntax to call the query operators. For example:<br>
IEnumerable&lt;string&gt; filtered = Enumerable.Where (names,<br>
                                                 n =&gt; n.Contains (&quot;a&quot;));<br>IEnumerable&lt;string&gt; sorted = Enumerable.OrderBy (filtered, n =&gt; n.Length);<br>
IEnumerable&lt;string&gt; finalQuery = Enumerable.Select (sorted,<br>                                                    n =&gt; n.ToUpper());<br>
This is, in fact, how the compiler translates extension method calls. Shunning ex-<br>tension methods comes at a cost, however, if you want to write a query in a single<br>statement as we did earlier. Let's revisit the single-statement query--first in exten-<br>sion method syntax:<br>
IEnumerable&lt;string&gt; query = names.Where   (n =&gt; n.Contains (&quot;a&quot;))<br>
                                 .OrderBy (n =&gt; n.Length)<br>
                                 .Select  (n =&gt; n.ToUpper());<br>
Its  natural  linear  shape  reflects  the  left-to-right  flow  of  data,  as  well  as  keeping<br>lambda expressions alongside their query operators (<i>infix</i> notation). Without ex-<br>tension methods, the query loses its <i>fluency</i>:<br>
IEnumerable&lt;string&gt; query =<br>  Enumerable.Select (<br>    Enumerable.OrderBy (<br>      Enumerable.Where (<br>        names, n =&gt; n.Contains (&quot;a&quot;)<br>      ), n =&gt; n.Length<br>    ), n =&gt; n.ToUpper()<br>  );<br>
<b>Composing Lambda Expressions<br></b>In previous examples, we fed the following lambda expression to the Where operator:<br>
n =&gt; n.Contains (&quot;a&quot;)      // Input type=string, return type=bool.<br>
An expression returning a bool value is called a <i>predicate</i>.<br>
The purpose of the lambda expression depends on the particular query operator.<br>With the Where operator, it indicates whether an element should be included in the<br>
<b>316 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=337></a>output sequence. In the case of the OrderBy operator, the lambda expression maps<br>each element in the input sequence to its sorting key. With the Select operator, the<br>lambda expression determines how each element in the input sequence is trans-<br>formed before being fed to the output sequence.<br>
A lambda expression in a query operator always works on in-<br>dividual elements in the input sequence--not the sequence as<br>a whole.<br>
The  query  operator  evaluates  your  lambda  expression  upon  demand--<br>typically once per element in the input sequence. Lambda expressions allow you to<br>feed  your  own  logic  into  the  query  operators.  This  makes  the  query  operators<br>versatile--as well as being simple under the hood. Here's a complete implementa-<br>tion of Enumerable.Where, exception handling aside:<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)<br>{<br>  foreach (TSource element in source)<br>
    if (predicate (element))<br>
      yield return element;<br>}<br>
<b>Lambda expressions and Func signatures<br></b>The  standard  query  operators  utilize  generic  Func  delegates.  Func  is  a  family  of<br>general-purpose generic delegates in System.Linq, defined with the following intent:<br>
The  type  arguments  in  Func  appear  in  the  same  order  they  do  in  lambda<br>expressions.<br>
Hence, Func&lt;TSource,bool&gt; matches a TSource=&gt;bool lambda expression: one that<br>accepts a TSource argument and returns a bool value.<br>Similarly, Func&lt;TSource,TResult&gt; matches a TSource=&gt;TResult lambda expression.<br>The Func delegates are listed in the section "Lambda Expressions" on page 130 in<br>Chapter 4.<br>
<b>Lambda expressions and element typing<br></b>The standard query operators use the following generic type names:<br>
<b>Generic type letter</b><br>
<b>Meaning</b><br>
<b>LINQ Queries</b><br>
TSource<br>
Element type for the input sequence<br>
TResult<br>
Element type for the output sequence--if different from TSource<br>
TKey<br>
Element type for the key used in sorting, grouping, or joining<br>
TSource is determined by the input sequence. TResult and TKey are <i>inferred from your<br>lambda expression</i>.<br>
<b>Fluent Syntax | 317</b><br>
<hr>
<A name=338></a>For example, consider the signature of the Select query operator:<br>
public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, <b>Func&lt;TSource,TResult&gt;</b> selector)<br>
Func&lt;TSource,TResult&gt;  matches  a  TSource=&gt;TResult  lambda  expression:  one  that<br>maps an <i>input element</i> to an <i>output element</i>. TSource and TResult are different types,<br>so the lambda expression can change the type of each element. Further, the lambda<br>expression <i>determines the output sequence type</i>. The following query uses Select to<br>transform string type elements to integer type elements:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
IEnumerable&lt;int&gt; query = names.Select (n =&gt; n.Length);<br>
foreach (int length in query)<br>
  Console.Write (length + &quot;|&quot;);    // 3|4|5|4|3|<br>
The compiler <i>infers</i> the type of TResult from the return value of the lambda expres-<br>sion. In this case, TResult is inferred to be of type int.<br>The Where query operator is simpler and requires no type inference for the output,<br>since input and output elements are of the same type. This makes sense because the<br>operator merely filters elements; it does not <i>transform</i> them:<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br>  (this IEnumerable&lt;TSource&gt; source, <b>Func&lt;TSource,bool&gt;</b> predicate)<br>
Finally, consider the signature of the OrderBy operator:<br>
// Slightly simplified:<br>public static IEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt;<br>
  (this IEnumerable&lt;TSource&gt; source, <b>Func&lt;TSource,TKey&gt;</b> keySelector)<br>
Func&lt;TSource,TKey&gt; maps an input element to a <i>sorting key</i>. TKey is inferred from<br>your lambda expression and is separate from the input and output element types.<br>For instance, we could choose to sort a list of names by length (int key) or alpha-<br>betically (string key):<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>IEnumerable&lt;string&gt; sortedByLength, sortedAlphabetically;<br>sortedByLength       = names.OrderBy (n =&gt; n.Length);   // <b>int</b> key<br>sortedAlphabetically = names.OrderBy (n =&gt; n);          // <b>string</b> key<br>
You can call the query operators in Enumerable with traditional<br>delegates that refer to methods instead of lambda expressions.<br>This approach is effective in simplifying certain kinds of local<br>queries--particularly with LINQ to XML--and is demonstra-<br>ted in Chapter 10. It doesn't work with IQueryable&lt;T&gt;-based<br>sequences, however (e.g., when querying a database), because<br>the operators in Queryable require lambda expressions in order<br>to  emit  expression  trees.  We  discuss  this  later  in  the  section<br>"Interpreted Queries" on page 339.<br>
<b>318 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=339></a><b>Natural Ordering<br></b>The original ordering of elements within an input sequence is significant in LINQ.<br>Some query operators rely on this behavior, such as Take, Skip, and Reverse.<br>The Take operator outputs the first x elements, discarding the rest:<br>
int[] numbers  = { 10, 9, 8, 7, 6 };<br>IEnumerable&lt;int&gt; firstThree = numbers.Take (3);     // { 10, 9, 8 }<br>
The Skip operator ignores the first x elements and outputs the rest:<br>
IEnumerable&lt;int&gt; lastTwo    = numbers.Skip (3);     // { 7, 6 }<br>
Reverse does exactly as it says:<br>
IEnumerable&lt;int&gt; reversed   = numbers.Reverse();    // { 6, 7, 8, 9, 10 }<br>
Operators such as Where and Select preserve the original ordering of the input se-<br>quence. LINQ preserves the ordering of elements in the input sequence wherever<br>possible.<br>
<b>Other Operators<br></b>Not all query operators return a sequence. The <i>element</i> operators extract one element<br>from the input sequence; examples are First, Last, and ElementAt:<br>
int[] numbers    = { 10, 9, 8, 7, 6 };<br>
int firstNumber  = numbers.First();                     // 10<br>int lastNumber   = numbers.Last();                      // 6<br>int secondNumber = numbers.ElementAt(1);                // 9<br>int lowestNumber = numbers.OrderBy (n =&gt; n).First();    // 6<br>
The <i>aggregation</i> operators return a scalar value; usually of numeric type:<br>
int count = numbers.Count();          // 5;<br>int min = numbers.Min();              // 6;<br>
The <i>quantifiers</i> return a bool value:<br>
bool hasTheNumberNine = numbers.Contains (9);          // true<br>bool hasMoreThanZeroElements = numbers.Any();          // true<br>bool hasAnOddElement = numbers.Any (n =&gt; n % 2 == 1);  // true<br>
Because these operators don't return a collection, you can't call further query op-<br>erators on their result. In other words, they must appear as the last operator in a<br>query.<br>
Some query operators accept two input sequences. Examples are Concat, which ap-<br>pends one sequence to another, and Union, which does the same but with duplicates<br>
<b>LINQ Queries</b><br>
removed:<br>
int[] seq1 = { 1, 2, 3 };<br>int[] seq2 = { 3, 4, 5 };<br>IEnumerable&lt;int&gt; concat = seq1.Concat (seq2);    //  { 1, 2, 3, 3, 4, 5 }<br>IEnumerable&lt;int&gt; union  = seq1.Union (seq2);     //  { 1, 2, 3, 4, 5 }<br>
The joining operators also fall into this category. Chapter 9 covers all the query<br>operators in detail.<br>
<b>Fluent Syntax | 319</b><br>
<hr>
<A name=340></a><b>Query Expressions<br></b>C#  provides  a  syntactic  shortcut  for  writing  LINQ  queries,  called  <i>query  expres-<br>sions</i>. Contrary to popular belief, query expressions are based not on SQL, but on<br><i>list  comprehensions</i>  from  functional  programming  languages  such  as  LISP  and<br>Haskell.<br>
In  this  book  we  refer  to  query  expression  syntax  simply  as<br>"query syntax."<br>
In the preceding section, we wrote a fluent-syntax query to extract strings containing<br>the letter "a", sorted by length and converted to uppercase. Here's the same thing<br>in query syntax:<br>
using System;<br>
using System.Collections.Generic;<br>
using System.Linq;<br>
class LinqDemo<br>
{<br>  static void Main()<br>
  {<br>    string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
    IEnumerable&lt;string&gt; query =<br>      <b>from    n in names<br></b>      <b>where   n.Contains (&quot;a&quot;)     // Filter elements<br></b>      <b>orderby n.Length             // Sort elements</b><br>
      <b>select  n.ToUpper();         // Translate each element (project)</b><br>
    foreach (string name in query) Console.WriteLine (name);<br>
  }<br>}<br>
JAY<br>MARY<br>HARRY<br>
Query expressions always start with a from clause and ends with either a select or<br>group clause. The from clause declares an <i>range variable</i> (in this case, n), which you<br>can think of as traversing the input sequence--rather like foreach. Figure 8-2 illus-<br>trates the complete syntax as a railroad diagram.<br>
To read this diagram, start at the left and then proceed along<br>the track as if you were a train. For instance, after the mandatory<br>from clause, you can optionally include an orderby, where, let,<br>or  join  clause.  After  that,  you  can  either  continue  with  a<br>select or group clause, or go back and include another from,<br>orderby, where, let or join clause.<br>
<b>320 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=341></a><i>Figure 8-2. Query syntax</i><br>
The compiler processes a query expression by translating it into fluent syntax. It<br>does this in a fairly mechanical fashion--much like it translates foreach statements<br>into calls to GetEnumerator and MoveNext. This means that anything you can write in<br>query syntax you can also write in fluent syntax. The compiler (initially) translates<br>our example query into the following:<br>
IEnumerable&lt;string&gt; query = names.Where   (n =&gt; n.Contains (&quot;a&quot;))<br>
                                 .OrderBy (n =&gt; n.Length)<br>                                 .Select  (n =&gt; n.ToUpper());<br>
<b>LINQ Queries</b><br>
The Where, OrderBy, and Select operators then resolve using the same rules that<br>would apply if the query were written in fluent syntax. In this case, they bind to<br>extension methods in the Enumerable class, because the System.Linq namespace is<br>imported and names implements IEnumerable&lt;string&gt;. The compiler doesn't specif-<br>ically favor the Enumerable class, however, when translating query expressions. You<br>can think of the compiler as mechanically injecting the words "Where," "OrderBy,"<br>and "Select" into the statement, and then compiling it as though you'd typed the<br>
<b>Query Expressions | 321</b><br>
<hr>
<A name=342></a>method names yourself. This offers flexibility in how they resolve. The operators in<br>the database queries that we'll write in later sections, for instance, will bind instead<br>to extension methods in Queryable.<br>
If we remove the using System.Linq directive from our program,<br>the query would not compile, because the Where, OrderBy, and<br>Select methods would have nowhere to bind. Query expres-<br>sions <i>cannot compile</i> unless you import a namespace (or write<br>an instance method for every query operator!).<br>
<b>Range Variables<br></b>The identifier immediately following the from keyword syntax is called the <i>range<br>variable</i>.  A  range  variable  refers  to  the  current  element  in  the  sequence  that  the<br>operation is to be performed on.<br>
In our examples, the range variable n appears in every clause in the query. And yet,<br>the variable actually enumerates over a <i>different</i> sequence with each clause:<br>
from    n in names           // n is our range variable<br>
where   n.Contains (&quot;a&quot;)     // n = directly from the array<br>
orderby n.Length             // n = subsequent to being filtered<br>select  n.ToUpper()          // n = subsequent to being sorted<br>
This becomes clear when we examine the compiler's mechanical translation to fluent<br>syntax:<br>
names.Where   (n =&gt; n.Contains (&quot;a&quot;))      // Privately scoped n<br>     .OrderBy (n =&gt; n.Length)              // Privately scoped n<br>     .Select  (n =&gt; n.ToUpper())           // Privately scoped n<br>
As you can see, each instance of n is scoped privately to its own lambda expression.<br>Query  expressions  also  let  you  introduce  new  range  variables,  via  the  following<br>clauses:<br>
· let<br>· into<br>· An additional from clause<br>
We will cover these later in this chapter in "Composition Strategies" on page 333,<br>and also in Chapter 9, in "Projecting" on page 369 and "Joining" on page 370.<br>
<b>Query Syntax Versus SQL Syntax<br></b>Query expressions look superficially like SQL, yet the two are very different. A LINQ<br>query boils down to a C# expression, and so follows standard C# rules. For exam-<br>ple, with LINQ, you cannot use a variable before you declare it. In SQL, you refer-<br>ence a table alias in the SELECT clause before defining it in a FROM clause.<br>A subquery in LINQ is just another C# expression and so requires no special syntax.<br>Subqueries in SQL are subject to special rules.<br>
<b>322 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=343></a>With LINQ, data logically flows from left to right through the query. With SQL, the<br>order is less well-structured with regard data flow.<br>
A LINQ query comprises a conveyor belt or <i>pipeline</i> of operators that accept and<br>emit  <i>ordered  sequences</i>.  A  SQL  query  comprises  a  <i>network</i>  of  clauses  that  work<br>mostly with <i>unordered sets</i>.<br>
<b>Query Syntax Versus Fluent Syntax<br></b>Query and fluent syntax each have advantages.<br>
Query syntax is simpler for queries that involve any of the following:<br>
· A let clause for introducing a new variable alongside the range variable<br>· SelectMany, Join, or GroupJoin, followed by an outer range variable reference<br>
(We  describe  the  let  clause  in  the  later  section,  "Composition  Strat-<br>egies" on page 333; we describe SelectMany, Join, and GroupJoin in Chapter 9.)<br>The middle ground is queries that involve the simple use of Where, OrderBy, and<br>Select. Either syntax works well; the choice here is largely personal.<br>
For  queries  that  comprise  a  single  operator,  fluent  syntax  is  shorter  and  less<br>cluttered.<br>
Finally, there are many operators that have no keyword in query syntax. These re-<br>quire that you use fluent syntax--at least in part. This means any operator outside<br>of the following:<br>
Where, Select, SelectMany<br>OrderBy, ThenBy, OrderByDescending, ThenByDescending<br>GroupBy, Join, GroupJoin<br>
<b>Mixed Syntax Queries<br></b>If a query operator has no query-syntax support, you can mix query syntax and fluent<br>syntax. The only restriction is that each query-syntax component must be complete<br>(i.e., start with a from clause and end with a select or group clause).<br>Assuming this array declaration:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
the following example counts the number of names containing the letter "a":<br>
int matches = (from n in names where n.Contains (&quot;a&quot;) select n).Count();<br>// 3<br>
The next query obtains the first name in alphabetical order:<br>
<b>LINQ Queries</b><br>
string first = (from n in names orderby n select n).First();   // Dick<br>
The mixed syntax approach is sometimes beneficial in more complex queries. With<br>these simple examples, however, we could stick to fluent syntax throughout without<br>penalty:<br>
<b>Query Expressions | 323</b><br>
<hr>
<A name=344></a>int matches = names.Where (n =&gt; n.Contains (&quot;a&quot;)).Count();   // 3<br>
string first = names.OrderBy (n =&gt; n).First();               // Dick<br>
There  are  times  when  mixed  syntax  queries  offer  by  far  the<br>highest "bang for the buck" in terms of function and simplicity.<br>It's  important  not  to  unilaterally  favor  either  query  or  fluent<br>syntax; otherwise, you'll be unable to write mixed syntax quer-<br>ies without feeling a sense of failure!<br>
The remainder of this chapter will show key concepts in both fluent and query <br>syntax, where applicable.<br>
<b>Deferred Execution<br></b>An  important  feature  of  most  query  operators  is  that  they  execute  not  when<br>constructed, but when <i>enumerated</i> (in other words, when MoveNext is called on its<br>enumerator). Consider the following query:<br>
var numbers = new List&lt;int&gt;();<br>
numbers.Add (1);<br>
IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10);    // Build query<br>
numbers.Add (2);                    // Sneak in an extra element<br>
foreach (int n in query)<br>
  Console.Write (n + &quot;|&quot;);          // 10|20|<br>
The  extra  number  that  we  sneaked  into  the  list  <i>after</i>  constructing  the  query  is<br>included in the result, because it's not until the foreach statement runs that any<br>filtering or sorting takes place. This is called <i>deferred</i> or <i>lazy</i> execution. All standard<br>query operators provide deferred execution, with the following exceptions:<br>
· Operators that return a single element or scalar value, such as First or Count<br>· The following <i>conversion operators</i>:<br>
ToArray, ToList, ToDictionary, ToLookup<br>
These operators cause immediate query execution because their result types have<br>no mechanism for providing deferred execution. The Count method, for instance,<br>returns a simple integer, which then doesn't get enumerated. The following query<br>is executed immediately:<br>
int matches = numbers.Where (n =&gt; n &lt; 2).Count();    // 1<br>
Deferred execution is important because it decouples query <i>construction</i> from query<br><i>execution</i>. This allows you to construct a query in several steps, as well as making<br>database queries possible.<br>
<b>324 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=345></a>Subqueries provide another level of indirection. Everything in a<br>subquery is subject to deferred execution--including aggrega-<br>tion and conversion methods. We describe this in the section<br>"Subqueries" on page 330 later in this chapter.<br>
<b>Reevaluation<br></b>Deferred  execution  has  another  consequence:  a  deferred  execution  query  is<br>reevaluated when you re-enumerate:<br>
var numbers = new List&lt;int&gt;() { 1, 2 };<br>
IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * 10);<br>foreach (int n in query) Console.Write (n + &quot;|&quot;);   // 10|20|<br>
numbers.Clear();<br>
foreach (int n in query) Console.Write (n + &quot;|&quot;);   // &lt;nothing&gt;<br>
There are a couple of reasons why reevaluation is sometimes disadvantageous:<br>
· Sometimes you want to "freeze" or cache the results at a certain point in time.<br>· Some  queries  are  computationally  intensive  (or  rely  on  querying  a  remote<br>
database), so you don't want to unnecessarily repeat them.<br>
You can defeat reevaluation by calling a conversion operator, such as ToArray or<br>ToList. ToArray copies the output of a query to an array; ToList copies to a generic<br>List&lt;&gt;:<br>
var numbers = new List&lt;int&gt;() { 1, 2 };<br>
List&lt;int&gt; timesTen = numbers<br>  .Select (n =&gt; n * 10)<br>
  <b>.ToList();                // Executes immediately into a List&lt;int&gt;</b><br>
numbers.Clear();<br>Console.WriteLine (timesTen.Count);      // Still 2<br>
<b>Captured Variables<br></b>Deferred  execution  also  has  a  sinister  effect.  If  your  query's  lambda  expressions<br>reference local variables, these variables are subject to <i>captured variable</i> semantics.<br>This means that if you later change their value, the query changes as well:<br>
int[] numbers = { 1, 2 };<br>
<b>LINQ Queries</b><br>
int factor = 10;<br>IEnumerable&lt;int&gt; query = numbers.Select (n =&gt; n * <b>factor</b>);<br><b>factor = 20;<br></b>foreach (int n in query) Console.Write (n + &quot;|&quot;);   // <b>20|40|</b><br>
<b>Deferred Execution | 325</b><br>
<hr>
<A name=346></a>This can be a real trap when building up a query within a foreach loop. For example,<br>suppose we wanted to remove all vowels from a string. The following, although<br>inefficient, gives the correct result:<br>
IEnumerable&lt;char&gt; query = &quot;Not what you might expect&quot;;<br>
query = query.Where (c =&gt; c != 'a');<br>
query = query.Where (c =&gt; c != 'e');<br>
query = query.Where (c =&gt; c != 'i');<br>
query = query.Where (c =&gt; c != 'o');<br>
query = query.Where (c =&gt; c != 'u');<br>
foreach (char c in query) Console.Write (c);  // Nt wht y mght xpct<br>
Now watch what happens when we refactor this with a foreach loop:<br>
IEnumerable&lt;char&gt; query = &quot;Not what you might expect&quot;;<br>
foreach (char vowel in &quot;aeiou&quot;)<br>  query = query.Where (c =&gt; c != vowel);<br>
foreach (char c in query) Console.Write (c);   // <b>Not what yo might expect</b><br>
Only the 'u' is stripped! This is because, as we saw in Chapter 4 (see "Capturing<br>Outer Variables" on page 132 in "Lambda Expressions" on page 130), the compiler<br>scopes the iteration variable in the foreach loop as if it was declared <i>outside</i> the loop:<br>
IEnumerable&lt;char&gt; vowels = &quot;aeiou&quot;;<br>using (IEnumerator&lt;char&gt; rator = vowels.GetEnumerator())<br>
{<br>  <b>char vowel;</b><br>
  while (rator.MoveNext())<br>  {<br>    vowel = rator.Current;<br>    query = query.Where (c =&gt; c != vowel);<br>  }<br>}<br>
Because vowel is declared outside the loop, the <i>same</i> variable is repeatedly updated,<br>so each lambda expression captures the same vowel. When we later enumerate the<br>query, all lambda expressions reference that single variable's current value, which<br>is 'u'. To solve this, you must assign the loop variable to another variable declared<br><i>inside</i> the statement block:<br>
foreach (char vowel in &quot;aeiou&quot;)<br>{<br> <b>char temp = vowel;<br></b> query = query.Where (c =&gt; c != <b>temp</b>);<br>}<br>
This forces a fresh variable to be used on each loop iteration.<br>
<b>326 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=347></a><b>How Deferred Execution Works<br></b>Query operators provide deferred execution by returning <i>decorator</i> sequences.<br>
Unlike a traditional collection class such as an array or linked list, a decorator se-<br>quence (in general) has no backing structure of its own to store elements. Instead,<br>it wraps another sequence that you supply at runtime, to which it maintains a per-<br>manent dependency. Whenever you request data from a decorator, it in turn must<br>request data from the wrapped input sequence.<br>
The query operator's transformation constitutes the "decora-<br>tion." If the output sequence performed no transformation, it<br>would be a <i>proxy</i> rather than a decorator.<br>
Calling Where merely constructs the decorator wrapper sequence, holding a reference<br>to the input sequence, the lambda expression, and any other arguments supplied.<br>The input sequence is enumerated only when the decorator is enumerated.<br>
Figure 8-3 illustrates the composition of the following query:<br>
IEnumerable&lt;int&gt; lessThanTen = new int[] { 5, 12, 3 }.Where (n =&gt; n &lt; 10);<br>
<i>Figure 8-3. Decorator sequence</i><br>
When you enumerate lessThanTen, you're, in effect, querying the array through the<br>Where decorator.<br>
The good news--if you ever want to write your own query operator--is that im-<br>
<b>LINQ Queries</b><br>
plementing a decorator sequence is easy with a C# iterator. Here's how you can<br>write your own Select method:<br>
public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;<br>  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)<br>
{<br>  foreach (TSource element in source)<br>    yield return selector (element);<br>}<br>
<b>Deferred Execution | 327</b><br>
<hr>
<A name=348></a>This method is an iterator by virtue of the yield return statement. Functionally, it's<br>a shortcut for the following:<br>
public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;<br>  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)<br>
{<br>  return new <i>SelectSequence</i> (source, selector);<br>}<br>
where <i>SelectSequence</i> is a (compiler-written) class whose enumerator encapsulates<br>the logic in the iterator method.<br>
Hence, when you call an operator such as Select or Where, you're doing nothing<br>more than instantiating an enumerable class that decorates the input sequence.<br>
<b>Chaining Decorators<br></b>Chaining query operators creates a layering of decorators. Consider the following<br>query:<br>
IEnumerable&lt;int&gt; query = new int[] { 5, 12, 3 }.Where   (n =&gt; n &lt; 10)<br>
                                               .OrderBy (n =&gt; n)<br>                                               .Select  (n =&gt; n * 10);<br>
Each query operator instantiates a new decorator that wraps the previous sequence<br>(rather  like  a  Russian  doll).  The  object  model  of  this  query  is  illustrated  in  Fig-<br>ure 8-4. Note that this object model is fully constructed prior to any enumeration.<br>
<i>Figure 8-4. Layered decorator sequences</i><br>
When you enumerate query, you're querying the original array, transformed through<br>a layering or chain of decorators.<br>
<b>328 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=349></a>Adding ToList onto the end of this query would cause the pre-<br>ceding operators to execute right away, collapsing the whole<br>object model into a single list.<br>
Figure 8-5 shows the same object composition in UML syntax. Select's decorator<br>references the OrderBy decorator, which references Where's decorator, which refer-<br>ences the array. A feature of deferred execution is that you build the identical object<br>model if you compose the query progressively:<br>
IEnumerable&lt;int&gt;<br>  source    = new int[] { 5, 12, 3 },<br>
  filtered  = source   .Where   (n =&gt; n &lt; 10),<br>  sorted    = filtered .OrderBy (n =&gt; n),<br>
  query     = sorted   .Select  (n =&gt; n * 10);<br>
<i>Figure 8-5. UML decorator composition</i><br>
<b>How Queries Are Executed<br></b>Here are the results of enumerating the preceding query:<br>
foreach (int n in query) Console.WriteLine (n);<br>
30<br>50<br>
<b>LINQ Queries</b><br>
Behind the scenes, the foreach calls GetEnumerator on Select's decorator (the last or<br>outermost operator), which kicks everything off. The result is a chain of enumerators<br>that structurally mirrors the chain of decorator sequences. Figure 8-6 illustrates the<br>flow of execution as enumeration proceeds.<br>
In the first section of this chapter, we depicted a query as a production line of con-<br>veyor belts. Extending this analogy, we can say a LINQ query is a lazy production<br>
<b>Deferred Execution | 329</b><br>
<hr>
<A name=350></a><i>Figure 8-6. Execution of a local query</i><br>
line, where the conveyor belts roll elements only upon <i>demand</i>. Constructing a query<br>constructs a production line--with everything in place--but with nothing rolling.<br>Then  when  the  consumer  requests  an  element  (enumerates  over  the  query),  the<br>rightmost conveyor belt activates; this in turn triggers the others to roll--as and<br>when  input  sequence  elements  are  needed.  LINQ  follows  a  demand-driven  <i>pull<br></i>model,  rather  than  a  supply-driven  <i>push</i>  model.  This  is  important--as  we'll  see<br>later--in allowing LINQ to scale to querying SQL databases.<br>
<b>Subqueries<br></b>A subquery is a query contained within another query's lambda expression. The<br>following example uses a subquery to sort musicians by their last name:<br>
string[] musos = { &quot;David Gilmour&quot;, &quot;Roger Waters&quot;, &quot;Rick Wright&quot; };<br>
IEnumerable&lt;string&gt; query = musos.OrderBy (m =&gt; <b>m.Split().Last()</b>);<br>
m.Split converts each string into a collection of words, upon which we then call the<br>Last  query  operator.  m.Split().Last  is  the  subquery;  query  references  the  <i>outer<br>query</i>.<br>
Subqueries are permitted because you can put any valid C# expression on the right-<br>hand side of a lambda. A subquery is simply another C# expression. This means<br>that the rules for subqueries are a consequence of the rules for lambda expressions<br>(and the behavior of query operators in general).<br>
<b>330 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=351></a>The term <i>subquery</i>, in the general sense, has a broader meaning.<br>For the purpose of describing LINQ, we use the term only for a<br>query referenced from within the lambda expression of another<br>query. In a query expression, a subquery amounts to a query<br>referenced  from  an  expression  in  any  clause  except  the  from<br>clause.<br>
A subquery is privately scoped to the enclosing expression and is able to reference<br>the outer lambda argument (or range variable in a query expression).<br>
m.Split().Last is a very simple subquery. The next query retrieves all strings in an<br>array whose length matches that of the shortest string:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
IEnumerable&lt;string&gt; outerQuery = names<br>
  .Where (n =&gt; n.Length == <b>names.OrderBy (n2 =&gt; n2.Length)<br></b>                                <b>.Select  (n2 =&gt; n2.Length).First()</b>);<br>
Tom, Jay<br>
Here's the same thing as a query expression:<br>
IEnumerable&lt;string&gt; outerQuery =<br>
  from   n in names<br>
  where  n.Length ==<br>           <b>(from n2 in names orderby n2.Length select n2.Length).First()</b><br>
  select n;<br>
Because the outer range variable (n) is in scope for a subquery, we cannot reuse n as<br>the subquery's range variable.<br>
A subquery is executed whenever the enclosing lambda expression is evaluated. This<br>means a subquery is executed upon demand, at the discretion of the outer query.<br>You could say that execution proceeds from the <i>outside in</i>. Local queries follow this<br>model  literally;  interpreted  queries  (e.g.,  database  queries)  follow  this  model<br><i>conceptually</i>.<br>
The subquery executes as and when required, to feed the outer query. In our exam-<br>ple, the subquery (the top conveyor belt in Figure 8-7) executes once for every outer<br>loop iteration. This is illustrated in Figures 8-7 and 8-8.<br>
We can express our preceding subquery more succinctly as follows:<br>
IEnumerable&lt;string&gt; query =<br>  from   n in names<br>  where  n.Length == names.OrderBy (n2 =&gt; n2.Length).First().Length<br>
<b>LINQ Queries</b><br>
  select n;<br>
With the Min aggregation function, we can simplify the query further:<br>
IEnumerable&lt;string&gt; query =<br>  from   n in names<br>  where  n.Length == names.Min (n2 =&gt; n2.Length)<br>  select n;<br>
<b>Subqueries | 331</b><br>
<hr>
<A name=352></a><i>Figure 8-7. Subquery composition</i><br>
In the later section "Interpreted Queries" on page 339, we'll describe how remote<br>sources such as SQL tables can be queried. Our example makes an ideal database<br>query, because it would be processed as a unit, requiring only one round trip to the<br>database server. This query, however, is inefficient for a local collection because the<br>subquery is recalculated on each outer loop iteration. We can avoid this inefficiency<br>by running the subquery separately (so that it's no longer a subquery):<br>
int shortest = names.Min (n =&gt; n.Length);<br>
IEnumerable&lt;string&gt; query = from   n in names<br>                            where  n.Length == shortest<br>                            select n;<br>
Factoring out subqueries in this manner is nearly always desir-<br>able when querying local collections. An exception is when the<br>subquery  is  <i>correlated</i>,  meaning  that  it  references  the  outer<br>range variable. We explore correlated subqueries in the follow-<br>ing chapter, in the section "Projecting" on page 369.<br>
<b>Subqueries and Deferred Execution<br></b>An element or aggregation operator such as First or Count in a subquery doesn't<br>force the <i>outer</i> query into immediate execution--deferred execution still holds for<br>the outer query. This is because subqueries are called <i>indirectly</i>--through a delegate<br>in the case of a local query, or through an expression tree in the case of an interpreted<br>query.<br>
An interesting case arises when you include a subquery within a Select expression.<br>In the case of a local query, you're actually <i>projecting a sequence of queries</i>--each<br>
<b>332 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=353></a><i>Figure 8-8. UML subquery composition</i><br>
itself subject to deferred execution. The effect is generally transparent, and it serves<br>to further improve efficiency. We revisit Select subqueries in some detail in Chap-<br>ter 9.<br>
<b>Composition Strategies<br></b>In this section, we describe three strategies for building more complex queries:<br>
· Progressive query construction<br>
<b>LINQ Queries</b><br>
· Using the into keyword<br>· Wrapping queries<br>
All are <i>chaining</i> strategies and produce identical runtime queries.<br>
<b>Composition Strategies | 333</b><br>
<hr>
<A name=354></a><b>Progressive Query Building<br></b>At the start of the chapter, we demonstrated how you could build a fluent query<br>progressively:<br>
var filtered   = names    .Where   (n =&gt; n.Contains (&quot;a&quot;));<br>
var sorted     = filtered .OrderBy (n =&gt; n);<br>
var query      = sorted   .Select  (n =&gt; n.ToUpper());<br>
Because each of the participating query operators returns a decorator sequence, the<br>resultant query is the same chain or layering of decorators that you would get from<br>a  single-expression  query.  There  are  a  couple  of  potential  benefits,  however,  to<br>building queries progressively:<br>
· It can make queries easier to write.<br>· You can add query operators <i>conditionally</i>. For example:<br>
if (includeFilter) query = query.Where (...)<br>
This is more efficient than:<br>
query = query.Where (n =&gt; !includeFilter || <i>&lt;expression&gt;</i>)<br>
because it avoids adding an extra query operator if includeFilter is false.<br>A progressive approach is often useful in query comprehensions. To illustrate, imag-<br>ine we want to remove all vowels from a list of names, and then present in alpha-<br>betical order those whose length is still more than two characters. In fluent syntax,<br>we could write this query as a single expression--by projecting <i>before</i> we filter:<br>
IEnumerable&lt;string&gt; query = names<br>  .Select  (n =&gt; n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>                  .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;))<br>  .Where   (n =&gt; n.Length &gt; 2)<br>  .OrderBy (n =&gt; n);<br>
RESULT: { &quot;Dck&quot;, &quot;Hrry&quot;, &quot;Mry&quot; }<br>
Rather  than  calling  string's  Replace  method  five  times,  we<br>could remove vowels from a string more efficiently with a reg-<br>ular expression:<br>
n =&gt; Regex.Replace (n, &quot;[aeiou]&quot;, &quot;&quot;)<br>
string's  Replace  method  has  the  advantage,  though,  of  also<br>working in database queries.<br>
Translating this directly into a query expression is troublesome because the select<br>clause must come after the where and orderby clauses. And if we rearrange the query<br>so as to project last, the result would be different:<br>
IEnumerable&lt;string&gt; query =<br>  from    n in names<br>  where   n.Length &gt; 2<br>  orderby n<br>
<b>334 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=355></a>  select  n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>
           .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;);<br>
RESULT: { &quot;Dck&quot;, &quot;Hrry&quot;, &quot;Jy&quot;, &quot;Mry&quot;, &quot;Tm&quot; }<br>
Fortunately, there are a number of ways to get the original result in query syntax.<br>The first is by querying progressively:<br>
IEnumerable&lt;string&gt; query =<br>
  from   n in names<br>  select n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>
          .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;);<br>
query = from n in query where n.Length &gt; 2 orderby n select n;<br>
RESULT: { &quot;Dck&quot;, &quot;Hrry&quot;, &quot;Mry&quot; }<br>
<b>The into Keyword</b><br>
The into keyword is interpreted in two very different ways by<br>query expressions, depending on context. The meaning we're<br>describing now is for signaling <i>query continuation</i> (the other is<br>for signaling a GroupJoin).<br>
The into keyword lets you "continue" a query after a projection and is a shortcut<br>for progressively querying. With into, we can rewrite the preceding query as:<br>
IEnumerable&lt;string&gt; query =<br>  from   n in names<br>
  select n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>          .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)<br>  <b>into noVowel<br></b>    where noVowel.Length &gt; 2 orderby noVowel select noVowel;<br>
The only place you can use into is after a select or group clause. into "restarts" a<br>query, allowing you to introduce fresh where, orderby, and select clauses.<br>
Although it's easiest to think of into as restarting a query from<br>the perspective of a query expression, it's <i>all one query</i> when<br>translated to its final fluent form. Hence, there's no intrinsic<br>performance hit with into. Nor do you lose any points for its<br>use!<br>
<b>LINQ Queries</b><br>
The equivalent of into in fluent syntax is simply a longer chain of operators.<br>
<b>Scoping rules<br></b>All query variables are out of scope following an into keyword. The following will<br>not compile:<br>
<b>Composition Strategies | 335</b><br>
<hr>
<A name=356></a>var query =<br>
  from n1 in names<br>  select n1.ToUpper()<br>  into n2                              // Only n2 is visible from here on.<br>
    <b>where n1.Contains (&quot;x&quot;)            // Illegal: n1 is not in scope.</b><br>
    select n2;<br>
To see why, consider how this maps to fluent syntax:<br>
var query = names<br>  .Select (n1 =&gt; n1.ToUpper())<br>  <b>.Where  (n2 =&gt; n1.Contains (&quot;x&quot;));     // Error: n1 no longer in scope</b><br>
The original name (n1) is lost by the time the Where filter runs. Where's input sequence<br>contains only uppercase names, so it cannot filter based on n1.<br>
<b>Wrapping Queries<br></b>A query built progressively can be formulated into a single statement by wrapping<br>one query around another. In general terms:<br>
var tempQuery = <i>tempQueryExpr</i><br>
var finalQuery = from <i>...</i> in tempQuery <i>...</i><br>
can be reformulated as:<br>
var finalQuery = from <i>...</i> in (<i>tempQueryExpr</i>)<br>
Wrapping is semantically identical to progressive query building or using the into<br>keyword (without the intermediate variable). The end result in all cases is a linear<br>chain of query operators. For example, consider the following query:<br>
IEnumerable&lt;string&gt; query =<br>  from   n in names<br>  select n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>          .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;);<br>
query = from n in query where n.Length &gt; 2 orderby n select n;<br>
Reformulated in wrapped form, it's the following:<br>
IEnumerable&lt;string&gt; query =<br>  from n1 in<br>  (<br>    from   n2 in names<br>    select n2.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>             .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)<br>  )<br>  where n1.Length &gt; 2 orderby n1 select n1;<br>
When converted to fluent syntax, the result is the same linear chain of operators as<br>in previous examples.<br>
IEnumerable&lt;string&gt; query = names<br>  .Select  (n =&gt; n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>                  .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;))<br>  .Where   (n =&gt; n.Length &gt; 2)<br>  .OrderBy (n =&gt; n);<br>
<b>336 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=357></a>(The compiler does not emit the final .Select (n =&gt; n) because it's redundant.)<br>Wrapped queries can be confusing because they resemble the <i>subqueries</i> we wrote<br>earlier. Both have the concept of an inner and outer query. When converted to fluent<br>syntax, however, you can see that wrapping is simply a strategy for sequentially<br>chaining operators. The end result bears no resemblance to a subquery, which em-<br>beds an inner query within the <i>lambda expression</i> of another.<br>
Returning to a previous analogy: when wrapping, the "inner" query amounts to the<br><i>preceding conveyor belts</i>. In contrast, a subquery rides above a conveyor belt and is<br>activated upon demand through the conveyor belt's lambda worker (as illustrated<br>in Figure 8-7).<br>
<b>Projection Strategies<br>Object Initializers<br></b>So far, all our select clauses have projected scalar element types. With C# object<br>initializers, you can project into more complex types. For example, suppose, as a<br>first step in a query, we want to strip vowels from a list of names while still retaining<br>the original versions alongside, for the benefit of subsequent queries. We can write<br>the following class to assist:<br>
class TempProjectionItem<br>
{<br>  public string Original;    // Original name<br>  public string Vowelless;   // Vowel-stripped name<br>}<br>
and then project into it with object initializers:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
IEnumerable&lt;TempProjectionItem&gt; temp =<br>  from n in names<br>  <b>select new TempProjectionItem<br></b>  <b>{<br></b>    <b>Original  = n,<br></b>    <b>Vowelless = n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br></b>                 <b>.Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)<br></b>  };<br>
The result is of type IEnumerable&lt;TempProjectionItem&gt;, which we can subsequently<br>query:<br>
IEnumerable&lt;string&gt; query = from   item in temp<br>
<b>LINQ Queries</b><br>
                            where  item.Vowelless.Length &gt; 2<br>                            select item.Original;<br>Dick<br>Harry<br>Mary<br>
<b>Projection Strategies | 337</b><br>
<hr>
<A name=358></a><b>Anonymous Types<br></b>Anonymous types allow you to structure your intermediate results without writing<br>special classes. We can eliminate the TempProjectionItem class in our previous ex-<br>ample with anonymous types:<br>
var intermediate = from n in names<br>
  <b>select new</b><br>
  <b>{</b><br>
    <b>Original = n,</b><br>
    <b>Vowelless = n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br></b>                 <b>.Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)</b><br>
  };<br>
IEnumerable&lt;string&gt; query = from   item in intermediate<br>
                            where  item.Vowelless.Length &gt; 2<br>
                            select item.Original;<br>
This gives the same result as the previous example, but without needing to write a<br>one-off class. The compiler does the job instead, writing a temporary class with fields<br>that match the structure of our projection. This means, however, that the intermedi<br>ate query has the following type:<br>
IEnumerable &lt;<i>random-compiler-produced-name</i>&gt;<br>
The only way we can declare a variable of this type is with the var keyword. In this<br>case, var is more than just a clutter reduction device; it's a necessity.<br>We can write the whole query more succinctly with the into keyword:<br>
var query = from n in names<br>  select new<br>  {<br>     Original = n,<br>     Vowelless = n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br>                  .Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)<br>  }<br>  into temp<br>  where temp.Vowelless.Length &gt; 2<br>  select temp.Original;<br>
Query expressions provide a shortcut for writing this kind of query: the let keyword.<br>
<b>The let Keyword<br></b>The let keyword introduces a new variable alongside the range variable.<br>With let, we can write a query extracting strings whose length, excluding vowels,<br>exceeds two characters, as follows:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
IEnumerable&lt;string&gt; query =<br>  from n in names<br>  <b>let vowelless = n.Replace (&quot;a&quot;, &quot;&quot;).Replace (&quot;e&quot;, &quot;&quot;).Replace (&quot;i&quot;, &quot;&quot;)<br></b>                   <b>.Replace (&quot;o&quot;, &quot;&quot;).Replace (&quot;u&quot;, &quot;&quot;)</b><br>
<b>338 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=359></a>  where vowelless.Length &gt; 2<br>
  orderby vowelless<br>  select n;       // Thanks to let, n is still in scope.<br>
The compiler resolves a let clause by projecting into a temporary anonymous type<br>that  contains  both  the  range  variable  and  the  new  expression  variable.  In  other<br>words, the compiler translates this query into the preceding example.<br>
let accomplishes two things:<br>
· It projects new elements alongside existing elements.<br>· It allows an expression to be used repeatedly in a query without being rewritten.<br>
The let approach is particularly advantageous in this example, because it allows the<br>select clause to project either the original name (n) or its vowel-removed version (v).<br>
You can have any number of let statements, before or after a where statement (see<br>Figure 8-2). A let statement can reference variables introduced in earlier let state-<br>ments (subject to the boundaries imposed by an into clause). let <i>reprojects</i> all ex-<br>isting variables transparently.<br>
A let expression need not evaluate to a scalar type: sometimes it's useful to have it<br>evaluate to a subsequence, for instance.<br>
<b>Interpreted Queries<br></b>LINQ  provides  two  parallel  architectures:  <i>local</i>  queries  for  local  object<br>collections, and <i>interpreted</i> queries for remote data sources. So far, we've examined<br>the  architecture  of  local  queries,  which  operate  over  collections  implementing<br>IEnumerable&lt;&gt;.  Local  queries  resolve  to  query  operators  in  the  Enumerable  class,<br>which in turn resolve to chains of decorator sequences. The delegates that they ac-<br>cept--whether expressed in query syntax, fluent syntax, or traditional delegates--<br>are fully local to Intermediate Language (IL) code, just like any other C# method.<br>
By  contrast,  interpreted  queries  are  <i>descriptive</i>.  They  operate  over  sequences<br>that  implement  IQueryable&lt;T&gt;,  and  they  resolve  to  the  query  operators  in  the<br>Queryable class, which emit <i>expression trees</i> that are interpreted at runtime.<br>
The  query  operators  in  Enumerable  can  actually  work  with<br>IQueryable&lt;T&gt;  sequences.  The  difficulty  is  that  the  resultant<br>queries always execute locally on the client--this is why a sec-<br>ond set of query operators is provided in the Queryable class.<br>
<b>LINQ Queries</b><br>
There are two IQueryable&lt;T&gt; implementations in the .NET Framework:<br>
· LINQ to SQL<br>· Entity Framework (EF)<br>
<b>Interpreted Queries | 339</b><br>
<hr>
<A name=360></a>These <i>LINQ-to-db</i> technologies are very similar in their LINQ support: the LINQ-<br>to-db queries in this book will work with both LINQ to SQL and EF unless otherwise<br>specified.<br>
It's also possible to generate an IQueryable&lt;T&gt; wrapper around an ordinary enu-<br>merable collection by calling the AsQueryable method. We describe AsQueryable in<br>the section "Building Query Expressions" on page 361 later in this chapter.<br>
In this section, we'll use LINQ to SQL to illustrate interpreted query architecture<br>because LINQ to SQL lets us query without having to first write an Entity Data<br>Model. The queries that we write, however, work equally well with Entity Frame-<br>work (and also many third-party products).<br>
IQueryable&lt;T&gt; is an extension of IEnumerable&lt;&gt; with additional<br>methods for constructing expression trees. Most of the time you<br>can ignore the details of these methods; they're called indirectly<br>by  the  Framework.  The  section  "Building  Query  Expres-<br>sions" on page 361 covers IQueryable&lt;T&gt; in more detail.<br>
Suppose we create a simple customer table in SQL Server and populate it with a few<br>names using the following SQL script:<br>
create table Customer<br>(<br>  ID int not null primary key,<br>
  Name varchar(30)<br>
)<br>insert Customer values (1, 'Tom')<br>insert Customer values (2, 'Dick')<br>insert Customer values (3, 'Harry')<br>insert Customer values (4, 'Mary')<br>insert Customer values (5, 'Jay')<br>
With this table in place, we can write an interpreted LINQ query in C# to retrieve<br>customers whose name contains the letter "a" as follows:<br>
using System;<br>using System.Linq;<br>
using System.Data.Linq;            // in System.Data.Linq.dll<br>using System.Data.Linq.Mapping;<br>
[Table] public class Customer<br>{<br>  [Column(IsPrimaryKey=true)] public int ID;<br>  [Column]                    public string Name;<br>}<br>
class Test<br>{<br>  static void Main()<br>  {<br>    DataContext dataContext = new DataContext (&quot;<i>connection string</i>&quot;);<br>    Table&lt;Customer&gt; customers = dataContext.GetTable &lt;Customer&gt;();<br>
<b>340 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=361></a>    IQueryable&lt;string&gt; query = from c in customers<br>
      where   c.Name.Contains (&quot;a&quot;)<br>      orderby c.Name.Length<br>      select  c.Name.ToUpper();<br>
    foreach (string name in query) Console.WriteLine (name);<br>  }<br>}<br>
LINQ to SQL translates this query into the following SQL:<br>
SELECT UPPER([t0].[Name]) AS [value]<br>
FROM [Customer] AS [t0]<br>
WHERE [t0].[Name] LIKE @p0<br>ORDER BY LEN([t0].[Name])<br>
with the following end result:<br>
JAY<br>MARY<br>
HARRY<br>
<b>How Interpreted Queries Work<br></b>Let's examine how the preceding query is processed.<br>
First, the compiler converts query syntax to fluent syntax. This is done exactly as<br>with local queries:<br>
IQueryable&lt;string&gt; query = customers.Where   (n =&gt; n.Name.Contains (&quot;a&quot;))<br>                                    .OrderBy (n =&gt; n.Name.Length)<br>                                    .Select  (n =&gt; n.Name.ToUpper());<br>
Next, the compiler resolves the query operator methods. Here's where local and<br>interpreted  queries  differ--interpreted  queries  resolve  to  query  operators  in  the<br>Queryable class instead of the Enumerable class.<br>
To  see  why,  we  need  to  look  at  the  customers  variable,  the  source  upon  which<br>the  whole  query  builds.  customers  is  of  type  Table&lt;&gt;,  which  implements<br>IQueryable&lt;T&gt; (a subtype of IEnumerable&lt;&gt;). This means the compiler has a choice<br>in resolving Where: it could call the extension method in Enumerable or the following<br>extension method in Queryable:<br>
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this<br>  IQueryable&lt;TSource&gt; source, Expression &lt;Func&lt;TSource,bool&gt;&gt; predicate)<br>
The compiler chooses Queryable.Where because its signature is a <i>more specific match</i>.<br>
Queryable.Where  accepts  a  predicate  wrapped  in  an  Expression&lt;TDelegate&gt;  type.<br>
<b>LINQ Queries</b><br>
This instructs the compiler to translate the supplied lambda expression--in other<br>words, n=&gt;n.Name.Contains(&quot;a&quot;)--to an <i>expression tree</i> rather than a compiled del-<br>egate.  An  expression  tree  is  an  object  model  based  on  the  types  in<br>System.Linq.Expressions that can be inspected at runtime (so that LINQ to SQL or<br>EF can later translate it to a SQL statement).<br>
<b>Interpreted Queries | 341</b><br>
<hr>
<A name=362></a>Because Queryable.Where also returns IQueryable&lt;T&gt;, the same process follows with<br>the OrderBy and Select operators. The end result is illustrated in Figure 8-9. In the<br>shaded box, there is an <i>expression tree</i> describing the entire query, which can be<br>traversed at runtime.<br>
<i>Figure 8-9. Interpreted query composition</i><br>
<b>Execution<br></b>Interpreted queries follow a deferred execution model--just like local queries. This<br>means that the SQL statement is not generated until you start enumerating the query.<br>Further, enumerating the same query twice results in the database being queried<br>twice.<br>
Under the covers, interpreted queries differ from local queries in how they execute.<br>When you enumerate over an interpreted query, the outermost sequence runs a<br>program  that  traverses  the  entire  expression  tree,  processing  it  as  a  unit.  In  our<br>example, LINQ to SQL translates the expression tree to a SQL statement, which it<br>then executes, yielding the results as a sequence.<br>
<b>342 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=363></a>To work, LINQ to SQL needs some clues as to the schema of<br>the database. The Table and Column attributes that we applied<br>to the Customer class serve just this function. The section "LINQ<br>to  SQL  and  Entity  Framework"  on  page  346  describes  these<br>attributes in more detail. Entity Framework is similar except<br>that it also requires an Entity Data Model (EDM)--an XML file<br>describing the mapping between database and entities.<br>
We said previously that a LINQ query is like a production line. When you enumerate<br>an IQueryable conveyor belt, though, it doesn't start up the whole production line,<br>like with a local query. Instead, just the IQueryable belt starts up, with a special<br>enumerator that calls upon a production manager. The manager reviews the entire<br>production line--which consists not of compiled code, but of <i>dummies</i> (method call<br>expressions) with instructions pasted to their <i>foreheads</i> (expression trees). The man-<br>ager then traverses all the expressions, in this case transcribing them to a single piece<br>of paper (a SQL statement), which it then executes, feeding the results back to the<br>consumer. Only one belt turns; the rest of the production line is a network of empty<br>shells, existing just to describe what has to be done.<br>
This has some practical implications. For instance, with local queries, you can write<br>your own query methods (fairly easily, with iterators) and then use them to supple-<br>ment the predefined set. With remote queries, this is difficult, and even undesirable.<br>If you wrote a MyWhere extension method accepting IQueryable&lt;T&gt;, it would be like<br>putting  your  own  dummy  into  the  production  line.  The  production  manager<br>wouldn't know what to do with your dummy. Even if you intervened at this stage,<br>your solution would be hard-wired to a particular provider, such as LINQ to SQL,<br>and would not work with other IQueryable implementations. Part of the benefit of<br>having a standard set of methods in Queryable is that they define a <i>standard vocabu-<br>lary</i> for querying <i>any</i> remote collection. As soon as you try to extend the vocabulary,<br>you're no longer interoperable.<br>
Another consequence of this model is that an IQueryable provider may be unable to<br>cope with some queries--even if you stick to the standard methods. LINQ to SQL<br>and EF are both limited by the capabilities of the database server; some LINQ queries<br>have no SQL translation. If you're familiar with SQL, you'll have a good intuition<br>for what these are, although at times you have to experiment to see what causes a<br>runtime error; it can be surprising what <i>does</i> work!<br>
<b>Combining Interpreted and Local Queries<br></b>A query can include both interpreted and local operators. A typical pattern is to have<br>
<b>LINQ Queries</b><br>
the local operators on the <i>outside</i> and the interpreted components on the <i>inside</i>; in<br>other words, the interpreted queries feed the local queries. This pattern works well<br>with LINQ-to-database queries.<br>
<b>Interpreted Queries | 343</b><br>
<hr>
<A name=364></a>For instance, suppose we write a custom extension method to pair up strings in a<br>collection:<br>
public static IEnumerable&lt;string&gt; Pair (this IEnumerable&lt;string&gt; source)<br>{<br>  string firstHalf = null;<br>
  foreach (string element in source)<br>    if (firstHalf == null)<br>      firstHalf = element;<br>
    else<br>
    {<br>      yield return firstHalf + &quot;, &quot; + element;<br>      firstHalf = null;<br>
    }<br>
}<br>
We can use this extension method in a query that mixes LINQ to SQL and local<br>operators:<br>
DataContext dataContext = new DataContext (&quot;<i>connection string</i>&quot;);<br>
Table&lt;Customer&gt; customers = dataContext.GetTable &lt;Customer&gt;();<br>
IEnumerable&lt;string&gt; q = customers<br>
  .Select (c =&gt; c.Name.ToUpper())<br>
  .OrderBy (n =&gt; n)<br>  <b>.Pair()                         // Local from this point on.</b><br>
  <b>.Select ((n, i) =&gt; &quot;Pair &quot; + i.ToString() + &quot; = &quot; + n);</b><br>
foreach (string element in q) Console.WriteLine (element);<br>
Pair 0 = HARRY, MARY<br>Pair 1 = TOM, DICK<br>
Because  customers  is  of  a  type  implementing  IQueryable&lt;T&gt;,  the  Select<br>operator resolves to Queryable.Select. This returns an output sequence also of type<br>IQueryable&lt;T&gt;. But the next query operator, Pair, has no overload accepting IQuery<br>able&lt;T&gt;,  only  the  less  specific  IEnumerable&lt;&gt;.  So,  it  resolves  to  our  local  Pair<br>method--wrapping the interpreted query in a local query. Pair also emits IEnumer<br>able, so OrderBy wraps another local operator.<br>
On the LINQ to SQL side, the resulting SQL statement is equivalent to:<br>
SELECT UPPER (Name) FROM Customer ORDER BY UPPER (Name)<br>
The remaining work is done locally. Figure 8-10 shows the query diagrammatically.<br>In effect, we have a local query (on the outside), whose source is an interpreted query<br>(the inside).<br>
<b>344 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=365></a><i>Figure 8-10. Combining local and interpreted queries</i><br>
<b>AsEnumerable<br></b>Enumerable.AsEnumerable is the simplest of all query operators. Here's its complete<br>definition:<br>
public static IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt;<br>              (this IEnumerable&lt;TSource&gt; source)<br>{<br>    return source;<br>}<br>
Its purpose is to cast an IQueryable&lt;T&gt; sequence to IEnumerable&lt;T&gt;, forcing subse-<br>quent query operators to bind to Enumerable operators instead of Queryable opera-<br>tors. This causes the remainder of the query to execute locally.<br>
To illustrate, suppose we had a MedicalArticles table in SQL Server and wanted to<br>use LINQ to SQL or EF to retrieve all articles on influenza whose abstract contained<br>
<b>LINQ Queries</b><br>
less than 100 words. For the latter predicate, we need a regular expression:<br>
Regex wordCounter = new Regex (@&quot;\b(\w|[-'])+\b&quot;);<br>
var query = dataContext.MedicalArticles<br>  .Where (article =&gt; article.Topic == &quot;influenza&quot; &amp;&amp;<br>
                     <b>wordCounter.Matches (article.Abstract).Count</b> &lt; 100);<br>
<b>Interpreted Queries | 345</b><br>
<hr>
<A name=366></a>The  problem  is  that  SQL  Server  doesn't  support  regular  expressions,  so  the<br>LINQ-to-db providers will throw an exception, complaining that the query cannot<br>be translated to SQL. We can solve this by querying in two steps: first retrieving all<br>articles on influenza through a LINQ to SQL query, and then filtering <i>locally</i> for<br>abstracts of less than 100 words:<br>
Regex wordCounter = new Regex (@&quot;\b(\w|[-'])+\b&quot;);<br>
<b>IEnumerable&lt;MedicalArticle&gt;</b> sqlQuery = dataContext.MedicalArticles<br>
  .Where (article =&gt; article.Topic == &quot;influenza&quot;);<br>
IEnumerable&lt;MedicalArticle&gt; localQuery = sqlQuery<br>
  .Where (article =&gt; wordCounter.Matches (article.Abstract).Count &lt; 100);<br>
Because sqlQuery is of type IEnumerable&lt;MedicalArticle&gt;, the second query binds<br>to the local query operators, forcing that part of the filtering to run on the client.<br>
With AsEnumerable, we can do the same in a single query:<br>
Regex wordCounter = new Regex (@&quot;\b(\w|[-'])+\b&quot;);<br>
var query = dataContext.MedicalArticles<br>
  .Where (article =&gt; article.Topic == &quot;influenza&quot;)<br>
  <b>.AsEnumerable()</b><br>
  .Where (article =&gt; wordCounter.Matches (article.Abstract).Count &lt; 100);<br>
An alternative to calling AsEnumerable is to call ToArray or ToList. The advantage of<br>AsEnumerable is that it doesn't force immediate query execution, nor does it create<br>any storage structure.<br>
Moving query processing from the database server to the client<br>can  hurt  performance,  especially  if  it  means  retrieving  more<br>rows. A more efficient (though more complex) way to solve our<br>example  would  be  to  use  SQL  CLR  integration  to  expose  a<br>function  on  the  database  that  implemented  the  regular<br>expression.<br>
We demonstrate combined interpreted and local queries further in Chapter 10.<br>
<b>LINQ to SQL and Entity Framework<br></b>Throughout this and the following chapter, we use LINQ to SQL (L2S) and Entity<br>Framework (EF) to demonstrate interpreted queries. We'll now examine the key<br>features of these technologies.<br>
If  you're  already  familiar  with  L2S,  take  an  advance  look  at<br>Table 8-1 (at end of this section) for a summary of the API dif-<br>ferences with respect to querying.<br>
<b>346 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=367></a><b>LINQ to SQL Versus Entity Framework</b><br>
Both LINQ to SQL and Entity Framework are LINQ-enabled object-relational<br>mappers. The essential difference is that EF allows for stronger decoupling be-<br>tween the database schema and the classes that you query. Instead of querying<br>classes that closely represent the database schema, you query a higher-level ab-<br>straction described by an <i>Entity Data Model</i>. This offers extra flexibility, but incurs<br>a cost in both performance and simplicity.<br>
L2S was written by the C# team and was released with Framework 3.5; EF was<br>written by the ADO.NET team and was released later as part of Service Pack 1.<br>L2S has since been taken over by the ADO.NET team. This has resulted in the<br>product receiving only minor improvements in Framework 4.0, with the team<br>concentrating more on EF.<br>
EF has improved considerably in Framework 4.0, although each technology still<br>has unique strengths. L2S's strengths are ease of use, simplicity, performance, and<br>the quality of its SQL translations. EF's strength is its flexibility in creating so-<br>phisticated mappings between the database and entity classes. EF also allows for<br>databases other than SQL Server via a <i>provider model</i> (L2S also features a provider<br>model,  but  this  was  made  internal  to  encourage  third  parties  to  focus  on  EF<br>instead).<br>
A  welcome  enhancement  in  EF  4.0  is  that  it  now  supports  (almost)  the  same<br>querying functionality as L2S. This means that the LINQ-to-db queries that we<br>demonstrate in this book work with either technology. Further, it makes L2S ex-<br>cellent for learning how to query databases in LINQ--because it keeps the object-<br>relational side of things simple while you learn querying principles that also work<br>with EF.<br>
<b>LINQ to SQL Entity Classes<br></b>L2S allows you to use any class to represent data, as long as you decorate it with<br>appropriate attributes. Here's a simple example:<br>
<b>[Table]<br></b>public class Customer<br>
{<br>  <b>[Column(IsPrimaryKey=true)]<br></b>  public int ID;<br>
  <b>[Column]</b><br>
  public string Name;<br>}<br>
<b>LINQ Queries</b><br>
The [Table] attribute, in the System.Data.Linq.Mapping namespace, tells L2S that<br>an object of this type represents a row in a database table. By default, it assumes the<br>table name matches the class name; if this is not the case, you can specify the table<br>name as follows:<br>
[Table (Name=&quot;Customers&quot;)]<br>
<b>LINQ to SQL and Entity Framework | 347</b><br>
<hr>
<A name=368></a>A class decorated with the [Table] attribute is called an <i>entity</i> in L2S. To be useful,<br>its structure must closely--or exactly--match that of a database table, making it a<br>low-level construct.<br>
The [Column] attribute flags a field or property that maps to a column in a table. If<br>the column name differs from the field or property name, you can specify the column<br>name as follows:<br>
[Column (Name=&quot;FullName&quot;)]<br>
public string Name;<br>
The IsPrimaryKey property in the [Column] attribute indicates that the column par-<br>takes in the table's primary key and is required for maintaining object identity, as<br>well as allowing updates to be written back to the database.<br>
Instead of defining public fields, you can define public properties in conjunction<br>with private fields. This allows you to write validation logic into the property ac-<br>cessors. If you take this route, you can optionally instruct L2S to bypass your prop-<br>erty accessors and write to the field directly when populating from the database:<br>
string _name;<br>
[Column (<b>Storage=&quot;_name&quot;</b>)]<br>public string Name { get { return _name; } set { _name = value; } }<br>
Column(Storage=&quot;_name&quot;) tells L2S to write directly to the _name field (rather than the<br>Name property) when populating the entity. L2S's use of reflection allows the field to<br>be private--as in this example.<br>
You can generate entity classes automatically from a database<br>using either Visual Studio (add a new "LINQ to SQL Classes"<br>project item) or with the <i>SqlMetal</i> command-line tool.<br>
<b>Entity Framework Entity Classes<br></b>As with L2S, EF lets you use any class to represent data (although you have to im-<br>plement special interfaces if you want functionality such as navigation properties).<br>
The following entity class, for instance, represents a customer that ultimately maps<br>to a <i>customer</i> table in the database:<br>
// You'll need to reference System.Data.Entity.dll<br>
[EdmEntityType (NamespaceName = &quot;NutshellModel&quot;, Name = &quot;Customer&quot;)]<br>public partial class Customer<br>{<br>  [EdmScalarPropertyAttribute (EntityKeyProperty = true, IsNullable = false)]<br>  public int ID { get; set; }<br>
  [EdmScalarProperty (EntityKeyProperty = false, IsNullable = false)]<br>  public string Name { get; set; }<br>}<br>
<b>348 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=369></a>Unlike with L2S, however, a class such as this is not enough on its own. Remember<br>that with EF, you're not querying the database directly--you're querying a higher-<br>level model called the <i>Entity Data Model</i> (EDM). There needs to be some way to<br>describe  the  EDM,  and  this  is  most  commonly  done  via  an  XML  file  with<br>an <i>.edmx</i> extension, which contains three parts:<br>
· The <i>conceptual model</i>, which describes the EDM in isolation of the database<br>· The <i>store model</i>, which describes the database schema<br>· The <i>mapping</i>, which describes how the conceptual model maps to the store<br>
The easiest way to create an <i>.edmx</i> file is to add an "ADO.NET Entity Data Model"<br>project item in Visual Studio and then follow the wizard for generating entities from<br>a database. This creates not only the <i>.edmx</i> file, but the entity classes as well.<br>
The entity classes in EF map to the <i>conceptual model</i>. The types<br>that support querying and updating the conceptual model are<br>collectively called <i>Object Services</i>.<br>
The designer assumes that you initially want a simple 1:1 mapping between tables<br>and entities. You can enrich this, however, by tweaking the EDM either with the<br>designer or by editing the underlying <i>.edmx</i> file that it creates for you. Here are some<br>of the things you can do:<br>
· Map several tables into one entity.<br>· Map one table into several entities.<br>· Map inherited types to tables using the three standard kinds of strategies pop-<br>
ular in the ORM world.<br>
The three kinds of inheritance strategies are:<br>
<i>Table per hierarchy</i><br>
A single table maps to a whole class hierarchy. The table contains a discrimi-<br>nator column to indicate which type each row should map to.<br>
<i>Table per type</i><br>
A single table maps to one type, meaning that an inherited type maps to several<br>tables. EF generates a SQL JOIN when you query an entity, to merge all its base<br>types together.<br>
<i>Table per concrete type</i><br>
A separate table maps to each concrete type. This means that a base type maps<br>to several tables and EF generates a SQL UNION when you query for entities<br>
<b>LINQ Queries</b><br>
of a base type.<br>
(In contrast, L2S supports only table per hierarchy.)<br>
<b>LINQ to SQL and Entity Framework | 349</b><br>
<hr>
<A name=370></a>The EDM is complex: a thorough discussion can fill hundreds<br>of pages! A good book that describes this in detail is Julia Ler-<br>man's <i>Programming Entity Framework</i>.<br>
EF also lets you query through the EDM without LINQ--using a textual language<br>called Entity SQL (ESQL). This can be useful for dynamically constructed queries.<br>
<b>DataContext and ObjectContext<br></b>Once you've defined entity classes (and an EDM in the case of EF), you can start<br>querying. The first step is to instantiate a DataContext (L2S) or ObjectContext (EF),<br>specifying a connection string:<br>
var l2sContext = new DataContext (&quot;<i>database</i> <i>connection string</i>&quot;);<br>
var efContext = new ObjectContext (&quot;<i>entity connection string</i>&quot;);<br>
Instantiating a DataContext/ObjectContext directly is a low-level<br>approach and is good for demonstrating how the classes work.<br>More typically, though, you instantiate a <i>typed context</i> (a sub-<br>classed version of these classes), a process we'll describe shortly.<br>
With L2S, you pass in the database connection string; with EF, you must pass an <br><i>entity connection string</i>, which incorporates the database connection string plus in-<br>formation on how to find the EDM. (If you've created an EDM in Visual Studio, you<br>can find the entity connection string for your EDM in the <i>app.config</i> file.)<br>
You can then obtain a queryable object calling GetTable (L2S) or CreateObjectSet<br>(EF). The following example uses the Customer class that we defined earlier:<br>
var context = new DataContext (&quot;<i>database</i> <i>connection string</i>&quot;);<br>Table&lt;Customer&gt; customers = context.GetTable &lt;Customer&gt;();<br>
Console.WriteLine (customers.Count());              // # of rows in table.<br>
Customer cust = customers.Single (c =&gt; c.ID == 2);  // Retrieves Customer<br>                                                    // with ID of 2.<br>
Here's the same thing with EF:<br>
var context = new ObjectContext (&quot;<i>entity connection string</i>&quot;);<br>context.DefaultContainerName = &quot;NutshellEntities&quot;;<br>ObjectSet&lt;Customer&gt; customers = context.CreateObjectSet&lt;Customer&gt;();<br>
Console.WriteLine (customers.Count());              // # of rows in table.<br>
Customer cust = customers.Single (c =&gt; c.ID == 2);  // Retrieves Customer<br>                                                    // with ID of 2.<br>
<b>350 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=371></a>The Single operator is ideal for retrieving a row by primary key.<br>Unlike First, it throws an exception if more than one element<br>is returned.<br>
A DataContext/ObjectContext object does two things. First, it acts as a factory for<br>generating objects that you can query. Second, it keeps track of any changes that<br>you make to your entities so that you can write them back. We can continue our<br>previous example to update a customer with L2S as follows:<br>
Customer cust = customers.OrderBy (c =&gt; c.Name).First();<br>
cust.Name = &quot;Updated Name&quot;;<br>context.SubmitChanges();<br>
With EF, the only difference is that you call SaveChanges instead:<br>
Customer cust = customers.OrderBy (c =&gt; c.Name).First();<br>cust.Name = &quot;Updated Name&quot;;<br>
context.<b>SaveChanges</b>();<br>
<b>Typed contexts<br></b>Having to call GetTable&lt;Customer&gt;() or CreateObjectSet&lt;Customer&gt;() all the time is<br>awkward. A better approach is to subclass DataContext/ObjectContext for a partic-<br>ular database, adding properties that do this for each entity. This is called a <i>typed<br>context</i>:<br>
class NutshellContext : DataContext    // For LINQ to SQL<br>
{<br>  public Table&lt;Customer&gt; Customers<br>
  {<br>    get { return GetTable&lt;Customer&gt;(); }<br>  }<br>  // ... and so on, for each table in the database<br>}<br>
Here's the same thing for EF:<br>
class NutshellContext : ObjectContext   // For Entity Framework<br>{<br>  public ObjectSet&lt;Customer&gt; Customers<br>  {<br>    get { return CreateObjectSet&lt;Customer&gt;(); }<br>  }<br>  // ... and so on, for each entity in the conceptual model<br>}<br>
You can then simply do this:<br>
<b>LINQ Queries</b><br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>Console.WriteLine (<b>context.Customers.Count()</b>);<br>
If you use Visual Studio to create a "LINQ to SQL Classes" or "ADO.NET Entity<br>Data Model" project item, it builds a typed context for you automatically. The de-<br>signers can also do additional work such as pluralizing identifiers--in this example,<br>
<b>LINQ to SQL and Entity Framework | 351</b><br>
<hr>
<A name=372></a>it's context.Customers and not context.Customer, even though the SQL table and<br>entity class are both called Customer.<br>
<b>Disposing DataContext/ObjectContext</b><br>
Although DataContext/ObjectContext implement IDisposable, you can (in general)<br>get away without disposing instances. Disposing forces the context's connection<br>to dispose--but this is usually unnecessary because L2S and EF close connections<br>automatically whenever you finish retrieving results from a query.<br>
Disposing a context can actually be problematic because of lazy evaluation. Con-<br>sider the following:<br>
IQueryable&lt;Customer&gt; GetCustomers (string prefix)<br>
{<br>  using (var dc = new NutshellContext (&quot;<i>connection string</i>&quot;))<br>    return dc.GetTable&lt;Customer&gt;()<br>
             .Where (c =&gt; c.Name.StartsWith (prefix));<br>
}<br>...<br>foreach (Customer c in GetCustomers (&quot;a&quot;))<br>  Console.WriteLine (c.Name);<br>
This  will  fail  because  the  query  is  evaluated  when  we  enumerate  it--which  is<br><i>after</i> disposing its DataContext.<br>There are some caveats, though, on not disposing contexts:<br>
· It relies on the connection object releasing all unmanaged resources on the<br>
Close method. While this holds true with  SqlConnection, it's theoretically<br>possible  for  a  third-party  connection  to  keep  resources  open  if  you  call<br>Close but not Dispose (though this would arguably violate the contract de-<br>fined by IDbConnection.Close).<br>
· If you manually call GetEnumerator on a query (instead of using foreach) and<br>
then fail to either dispose the enumerator or consume the sequence, the con-<br>nection will remain open. Disposing the DataContext/ObjectContext provides<br>a backup in such scenarios.<br>
· Some people feel that it's tidier to dispose contexts (and all objects that im-<br>
plement IDisposable).<br>
If you want to explicitly dispose contexts, you must pass a DataContext/Object<br>Context  instance  into  methods  such  as  GetCustomers  to  avoid  the  problem<br>described.<br>
<b>Object tracking<br></b>A DataContext/ObjectContext instance keeps track of all the entities it instantiates,<br>so it can feed the same ones back to you whenever you request the same rows in a<br>table. In other words, a context in its lifetime will never emit two separate entities<br>that refer to the same row in a table (where a row is identified by primary key).<br>
<b>352 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=373></a>You can disable this behavior in L2S by setting ObjectTrackin<br>gEnabled to false on the DataContext object. In EF, you can dis-<br>able change tracking on a per-type basis:<br>
context.Customers.MergeOption = MergeOption.NoTracking;<br>
Disabling  object  tracking  also  prevents  you  from  submitting<br>updates to the data.<br>
To illustrate object tracking, suppose the customer whose name is alphabetically<br>first also has the lowest ID. In the following example, a and b will reference the same<br>object:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
Customer a = context.Customers.OrderBy (c =&gt; c.Name).First();<br>
Customer b = context.Customers.OrderBy (c =&gt; c.ID).First();<br>
This has a couple of interesting consequences. First, consider what happens when<br>L2S or EF encounters the second query. It starts by querying the database--and<br>obtaining a single row. It then reads the primary key of this row and performs a<br>lookup in the context's entity cache. Seeing a match, it returns the existing object<br><i>without updating any values</i>. So, if another user had just updated that customer's<br>Name in the database, the new value would be ignored. This is essential for avoiding<br>unexpected side effects (the Customer object could be in use elsewhere) and also for<br>managing concurrency. If you had altered properties on the Customer object and not<br>yet called SubmitChanges/SaveChanges, you wouldn't want your properties automat-<br>ically overwritten.<br>
To get fresh information from the database, you must either<br>instantiate a new context or call its Refresh method, passing in<br>the entity or entities that you want refreshed.<br>
The second consequence is that you cannot explicitly project into an entity type--<br>to select a subset of the row's columns--without causing trouble. For example, if<br>you want to retrieve only a customer's name, any of the following approaches is<br>valid:<br>
customers.Select (c =&gt; c.Name);<br>customers.Select (c =&gt; new { Name = c.Name } );<br>customers.Select (c =&gt; new MyCustomType { Name = c.Name } );<br>
The following, however, is not:<br>
<b>LINQ Queries</b><br>
customers.Select (c =&gt; new Customer { Name = c.Name } );<br>
This is because the Customer entities will end up partially populated. So, the next<br>time you perform a query that requests <i>all</i> customer columns, you get the same<br>cached Customer objects with only the Name property populated.<br>
<b>LINQ to SQL and Entity Framework | 353</b><br>
<hr>
<A name=374></a>In a multitier application, you cannot use a single static instance<br>of a DataContext or ObjectContext in the middle tier to handle<br>all  requests,  because  contexts  are  not  thread-safe.  Instead,<br>middle-tier methods must create a fresh context per client re-<br>quest. This is actually beneficial because it shifts the burden in<br>handling simultaneous updates to the database server, which is<br>properly equipped for the job. A database server, for instance,<br>will apply transaction isolation-level semantics.<br>
<b>Associations<br></b>The entity generation tools perform another useful job. For each relationship defined<br>in your database, they generate properties on each side that allow you to query that<br>relationship. For example, suppose we define a customer and purchase table in a<br>one-to-many relationship:<br>
create table Customer<br>(<br>  ID int not null primary key,<br>
  Name varchar(30) not null<br>
)<br>
create table Purchase<br>
(<br>  ID int not null primary key,<br>
  <b>CustomerID int references Customer (ID),<br></b>  Description varchar(30) not null,<br>  Price decimal not null<br>)<br>
With automatically generated entity classes, we can write queries such as this:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
// Retrieve all purchases made by the first customer (alphabetically):<br>
Customer cust1 = context.Customers.OrderBy (c =&gt; c.Name).First();<br><b>foreach (Purchase p in cust1.Purchases)<br></b>  Console.WriteLine (p.Price);<br>
// Retrieve the customer who made the lowest value purchase:<br>
Purchase cheapest = context.Purchases.OrderBy (p =&gt; p.Price).First();<br><b>Customer cust2 = cheapest.Customer;</b><br>
Further, if cust1 and cust2 happened to refer to the same customer, c1 and c2 would<br><i>refer to the same object</i>: cust1==cust2 would return true.<br>Let's examine the signature of the automatically generated Purchases property on<br>the Customer entity. With L2S:<br>
[Association (Storage=&quot;_Purchases&quot;, OtherKey=&quot;CustomerID&quot;)]<br>public EntitySet &lt;Purchase&gt; Purchases { get {<i>...</i>} set {<i>...</i>} }<br>
<b>354 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=375></a>With EF:<br>
[EdmRelationshipNavigationProperty (&quot;NutshellModel&quot;, &quot;FK<i>...</i>&quot;, &quot;Purchase&quot;)]<br>
public EntityCollection&lt;Purchase&gt; Purchases { get {<i>...</i>} set {<i>...</i>} }<br>
An EntitySet or EntityCollection is like a predefined query, with a built-in Where<br>clause that extracts related entities. The [Association] attribute gives L2S the in-<br>formation  it  needs  to  formulate  the  SQL  query;  the  [EdmRelationshipNavigation<br>Property] attribute tells EF where to look in the EDM for information about that<br>relationship.<br>
As  with  any  other  type  of  query,  you  get  deferred  execution.  With  L2S,  an<br>EntitySet is populated when you enumerate over it; with EF, an EntityCollection<br>is populated when you explicitly call its Load method.<br>Here's the Purchases.Customer property, on the other side of the relationship, with<br>L2S:<br>
[Association (Storage=&quot;_Customer&quot;,ThisKey=&quot;CustomerID&quot;,IsForeignKey=true)]<br>public Customer Customer { get {<i>...</i>} set {<i>...</i>} }<br>
Although the property is of type Customer, its underlying field (_Customer) is of type<br>EntityRef.  The  EntityRef  type  implements  deferred  loading,  so  the  related<br>Customer is not retrieved from the database until you actually ask for it.<br>
EF works in the same way, except that it doesn't populate the property simply by<br>you accessing it: you must call Load on its EntityReference object. This means EF<br>contexts must expose properties for both the actual parent object and its EntityRe<br>ference wrapper:<br>
[EdmRelationshipNavigationProperty (&quot;NutshellModel&quot;, &quot;FK<i>...</i>, &quot;Customer&quot;)]<br>
public Customer Customer { get {<i>...</i>} set {<i>...</i>} }<br>
public EntityReference&lt;Customer&gt; CustomerReference { get; set; }<br>
You can make EF behave like L2S and have it populate Entity<br>Collections  and  EntityReferences  simply  by  virtue  of  their<br>properties being accessed as follows:<br>
context.ContextOptions.DeferredLoadingEnabled = true;<br>
<b>Deferred Execution with L2S and EF<br></b>L2S and EF queries are subject to deferred execution, just like local queries. This<br>allows you to build queries progressively. There is one aspect, however, in which<br>L2S/EF  have  special  deferred  execution  semantics,  and  that  is  when  a  subquery<br>
<b>LINQ Queries</b><br>
appears inside a Select expression:<br>
· With local queries, you get double deferred execution, because from a func-<br>
tional perspective, you're selecting a sequence of <i>queries</i>. So, if you enumerate<br>the outer result sequence, but never enumerate the inner sequences, the sub-<br>query will never execute.<br>
<b>LINQ to SQL and Entity Framework | 355</b><br>
<hr>
<A name=376></a>· With L2S/EF, the subquery is executed at the same time as the main outer query.<br>
This avoids excessive round-tripping.<br>
For example, the following query executes in a single round trip upon reaching the<br>first foreach statement:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
var query = from c in context.Customers<br>            select<br>
               from p in c.Purchases<br>
               select new { c.Name, p.Price };<br>
<b>foreach (var customerPurchaseResults in query)<br></b>  foreach (var namePrice in customerPurchaseResults)<br>
    Console.WriteLine (namePrice.Name + &quot; spent &quot; + namePrice.Price);<br>
Any EntitySets/EntityCollections that you explicitly project are fully populated in<br>a single round trip:<br>
var query = from c in context.Customers<br>
            select new { c.Name, <b>c.Purchases</b> };<br>
<b>foreach (var row in query)<br></b>  <b>foreach (Purchase p in row.Purchases)   // No extra round-tripping<br></b>    Console.WriteLine (row.Name + &quot; spent &quot; + p.Price);<br>
But  if  we  enumerate  EntitySet/EntityCollection  properties  without  first  having<br>projected, deferred execution rules apply. In the following example, L2S and EF<br>execute another Purchases query on each loop iteration:<br>
context.ContextOptions.DeferredLoadingEnabled = true;  // For EF only.<br>
foreach (Customer c in <b>context.Customers</b>)<br>  foreach (Purchase p in c.Purchases)    // Another SQL round-trip<br>    Console.WriteLine (c.Name + &quot; spent &quot; + p.Price);<br>
This model is advantageous when you want to <i>selectively</i> execute the inner loop,<br>based on a test that can be performed only on the client:<br>
foreach (Customer c in context.Customers)<br>  if (<i>myWebService.HasBadCreditHistory (c.ID)</i>)<br>    foreach (Purchase p in c.Purchases)   // Another SQL round trip<br>      Console.WriteLine (...);<br>
(In  Chapter  9,  we  will  explore  Select  subqueries  in  more  detail,  in  "Projec-<br>ting" on page 369.)<br>
We've seen that you can avoid round-tripping by explicitly projecting associations.<br>L2S and EF offer other mechanisms for this too, which we cover in the following<br>two sections.<br>
<b>DataLoadOptions<br></b>The DataLoadOptions class is specific to L2S. It has two distinct uses:<br>
· It lets you specify, in advance, a filter for EntitySet associations (AssociateWith).<br>
<b>356 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=377></a>· It lets you request that certain EntitySets be eagerly loaded, to lessen round-<br>
tripping (LoadWith).<br>
<b>Specifying a filter in advance<br></b>Let's refactor our previous example as follows:<br>
foreach (Customer c in context.Customers)<br>  if (<i>myWebService.HasBadCreditHistory (c.ID)</i>)<br>
    ProcessCustomer (c);<br>
We'll define ProcessCustomer like this:<br>
void ProcessCustomer (Customer c)<br>{<br>  Console.WriteLine (c.ID + &quot; &quot; + c.Name);<br>
  foreach (Purchase p in c.Purchases)<br>
    Console.WriteLine (&quot;  - purchased a &quot; + p.Description);<br>}<br>
Now suppose we want to feed ProcessCustomer only a <i>subset</i> of each customer's<br>purchases; say, the high-value ones. Here's one solution:<br>
foreach (Customer c in context.Customers)<br>
  if (<i>myWebService.HasBadCreditHistory (c.ID)</i>)<br>    ProcessCustomer (<b>c.ID,</b><br>
                     <b>c.Name,</b><br>
                     c.Purchases.Where (p =&gt; p.Price &gt; 1000));<br>
...<br>void ProcessCustomer (<b>int custID, string custName,<br></b>                      IEnumerable&lt;Purchase&gt; purchases)<br>{<br>  Console.WriteLine (custID + &quot; &quot; + custName);<br>  foreach (Purchase p in purchases)<br>    Console.WriteLine (&quot;  - purchased a &quot; + p.Description);<br>}<br>
This is messy. It would get messier still if ProcessCustomer required more Customer<br>fields. A better solution is to use DataLoadOptions's AssociateWith method:<br>
DataLoadOptions options = new DataLoadOptions();<br><b>options.AssociateWith &lt;Customer&gt;<br></b> <b>(c =&gt; c.Purchases.Where (p =&gt; p.Price &gt; 1000));<br></b>context.LoadOptions = options;<br>
This instructs our DataContext instance always to filter a Customer's Purchases using<br>the given predicate. We can now use the original version of ProcessCustomer.<br>
AssociateWith doesn't change deferred execution semantics. When a particular re-<br>lationship  is  used,  it  simply  instructs  to  implicitly  add  a  particular  filter  to  the<br>
<b>LINQ Queries</b><br>
equation.<br>
<b>Eager loading<br></b>The second use for a DataLoadOptions is to request that certain EntitySets be eagerly<br>loaded with their parent. For instance, suppose you want to load all customers and<br>their purchases in a single SQL round trip:<br>
<b>LINQ to SQL and Entity Framework | 357</b><br>
<hr>
<A name=378></a>DataLoadOptions options = new DataLoadOptions();<br>
<b>options.LoadWith &lt;Customer&gt; (c =&gt; c.Purchases);<br></b>context.LoadOptions = options;<br>
foreach (Customer c in context.Customers)     // One round trip:<br>
  foreach (Purchase p in c.Purchases)<br>    Console.WriteLine (c.Name + &quot; bought a &quot; + p.Description);<br>
This instructs that whenever a Customer is retrieved, its Purchases should also be<br>retrieved at the same time. You can combine LoadWith with AssociateWith. The fol-<br>lowing  instructs  that  whenever  a  customer  is  retrieved,  its  <i>high-value</i>  purchases<br>should be retrieved in the same round trip:<br>
options.LoadWith &lt;Customer&gt; (c =&gt; c.Purchases);<br>
options.AssociateWith &lt;Customer&gt;<br>
  (c =&gt; c.Purchases.Where (p =&gt; p.Price &gt; 1000));<br>
<b>Eager Loading in Entity Framework<br></b>You can request in EF that associations be eagerly loaded with the Include method.<br>The following enumerates over each customer's purchases--while generating just<br>one SQL query:<br>
foreach (var c in context.Customers.<b>Include (&quot;Purchases&quot;)</b>)<br>
  foreach (var p in c.Purchases)<br>
    Console.WriteLine (p.Description);<br>
Include  can  be  used  with  arbitrary  breadth  and  depth.  For  example,  if  each<br>Purchase also had PurchaseDetails and SalesPersons navigation properties, the en-<br>tire nested structure could be eagerly loaded as follows:<br>
context.Customers.Include (&quot;Purchases.PurchaseDetails&quot;)<br>                 .Include (&quot;Purchases.SalesPersons&quot;)<br>
<b>Updates<br></b>L2S and EF also keep track of changes that you make to your entities and allow you<br>to  write  them  back  to  the  database  by  calling  SubmitChanges on the  DataContext<br>object, or SaveChanges on the ObjectContext object.<br>L2S's Table&lt;&gt; class provides InsertOnSubmit and DeleteOnSubmit methods for in-<br>serting and deleting rows in a table; EF's ObjectSet&lt;&gt; class provides AddObject and<br>DeleteObject methods to do the same thing. Here's how to insert a row:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
Customer cust = new Customer { ID=1000, Name=&quot;Bloggs&quot; };<br>context.Customers.InsertOnSubmit (cust);   // <b>AddObject</b> with EF<br>context.SubmitChanges();                   // <b>SaveChanges</b> with EF<br>
We can later retrieve that row, update it, and then delete it:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
Customer cust = context.Customers.Single (c =&gt; c.ID == 1000);<br>cust.Name = &quot;Bloggs2&quot;;<br>
<b>358 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=379></a>context.SubmitChanges();                  // Updates the customer<br>
context.Customers.DeleteOnSubmit (cust);  // <b>DeleteObject</b> with EF<br>context.SubmitChanges();                  // Deletes the customer<br>
SubmitChanges/SaveChanges  gathers  all  the  changes  that  were  made  to  its  entities<br>since the context's creation (or the last save), and then executes a SQL statement to<br>write them to the database. Any TransactionScope is honored; if none is present, it<br>wraps all statements in a new transaction.<br>
You can also add new or existing rows to an EntitySet/EntityCollection by calling<br>Add. L2S and EF automatically populate the foreign keys when you do this (after<br>calling SubmitChanges or SaveChanges):<br>
Purchase p1 = new Purchase { ID=100, Description=&quot;Bike&quot;,  Price=500 };<br>Purchase p2 = new Purchase { ID=101, Description=&quot;Tools&quot;, Price=100 };<br>
Customer cust = context.Customers.Single (c =&gt; c.ID == 1);<br>
cust.Purchases.Add (p1);<br>
cust.Purchases.Add (p2);<br>
context.SubmitChanges();  //  (or SaveChanges with EF)<br>
If you don't want the burden of allocating unique keys, you can<br>use  either  an  auto-incrementing  field  (IDENTITY  in  SQL<br>Server) or a Guid for the primary key.<br>
In this example, L2S/EF automatically writes 1 into the CustomerID column of each<br>of the new purchases (L2S knows to do this because of the association attribute that<br>we defined on the Purchases property; EF knows to do this because of information<br>in the EDM).<br>
[Association (Storage=&quot;_Purchases&quot;, <b>OtherKey=&quot;CustomerID&quot;</b>)]<br>public EntitySet &lt;Purchase&gt; Purchases { get {<i>...</i>} set {<i>...</i>} }<br>
If the Customer and Purchase entities were generated by the Visual Studio designer<br>or the <i>SqlMetal</i> command-line tool, the generated classes would include further code<br>to  keep  the  two  sides  of  each  relationship  in  sync.  In  other  words,  assigning<br>the Purchase.Customer property would automatically add the new customer to the<br>Customer.Purchases entity set--and vice versa. We can illustrate this by rewriting<br>the preceding example as follows:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
<b>LINQ Queries</b><br>
Customer cust = context.Customers.Single (c =&gt; c.ID == 1);<br>new Purchase { ID=100, Description=&quot;Bike&quot;,  Price=500, <b>Customer=cust</b> };<br>new Purchase { ID=101, Description=&quot;Tools&quot;, Price=100, <b>Customer=cust</b> };<br>
context.SubmitChanges();   // (<b>SaveChanges</b> with EF)<br>
<b>LINQ to SQL and Entity Framework | 359</b><br>
<hr>
<A name=380></a>When you remove a row from an EntitySet/EntityCollection, its foreign key field<br>is  automatically  set  to  null.  The  following  disassociates  our  two  recently  added<br>purchases from their customer:<br>
var context = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>
Customer cust = context.Customers.Single (c =&gt; c.ID == 1);<br>
cust.Purchases.Remove (cust.Purchases.Single (p =&gt; p.ID == 100));<br>
cust.Purchases.Remove (cust.Purchases.Single (p =&gt; p.ID == 101));<br>
context.SubmitChanges();    // Submit SQL to database (SaveChanges in EF)<br>
Because this tries to set each purchase's CustomerID field to null, Purchase.Custom<br>erID must be nullable in the database; otherwise, an exception is thrown. (Further,<br>the CustomerID field or property in the entity class must be a nullable type.)<br>To delete child entities entirely, remove them from the Table&lt;&gt; or ObjectSet&lt;&gt; in-<br>stead. With L2S:<br>
var c = context;<br>
c.Purchases.DeleteOnSubmit (c.Purchases.Single (p =&gt; p.ID == 100));<br>
c.Purchases.DeleteOnSubmit (c.Purchases.Single (p =&gt; p.ID == 101));<br>
c.SubmitChanges();         // Submit SQL to database<br>
With EF:<br>
var c = context;<br>c.Purchases.DeleteObject (c.Purchases.Single (p =&gt; p.ID == 100));<br>c.Purchases.DeleteObject (c.Purchases.Single (p =&gt; p.ID == 101));<br>c.SaveChanges();         // Submit SQL to database<br>
<b>API Differences Between L2S and EF<br></b>As we've seen, L2S and EF are similar in the aspect of querying with LINQ and<br>performing updates. Table 8-1 summarizes the API differences.<br>
<i>Table 8-1. API differences between L2S and EF</i><br>
<b>Purpose</b><br>
<b>LINQ to SQL</b><br>
<b>Entity Framework</b><br>
Gatekeeper class for all CRUD operations<br>
DataContext<br>
ObjectContext<br>
Method to (lazily) retrieve all entities of a given type from the<br>
GetTable<br>
CreateObjectSet<br>
store<br>Type returned by the above method<br>
Table&lt;T&gt;<br>
ObjectSet&lt;T&gt;<br>
Method to update the store with any additions, modifications,<br>
SubmitChanges<br>
SaveChanges<br>
or deletions to entity objects<br>Method to add a new entity to the store when the context is<br>
InsertOnSubmit<br>
AddObject<br>
updated<br>Method to delete an entity from the store when the context is<br>
DeleteOnSubmit<br>
DeleteObject<br>
updated<br>Type to represent one side of a relationship property, when<br>
EntitySet&lt;T&gt;<br>
EntityCollection&lt;T&gt;<br>
that side has a multiplicity of many<br>
<b>360 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=381></a><b>Purpose</b><br>
<b>LINQ to SQL</b><br>
<b>Entity Framework</b><br>
Type to represent one side of a relationship property, when<br>
EntityRef&lt;T&gt;<br>
EntityReference&lt;T&gt;<br>
that side has a multiplicity of one<br>Default strategy for loading relationship properties<br>
Lazy<br>
Explicit<br>
Construct that enables eager loading<br>
DataLoadOptions<br>
.Include()<br>
<b>Building Query Expressions<br></b>So far in this chapter, when we've needed to dynamically compose queries, we've<br>done so by conditionally chaining query operators. Although this is adequate in<br>many scenarios, sometimes you need to work at a more granular level and dynam-<br>ically compose the lambda expressions that feed the operators.<br>
In this section, we'll assume the following Product class:<br>
[Table] public partial class Product<br>{<br>  [Column(IsPrimaryKey=true)] public int ID;<br>
  [Column]                    public string Description;<br>
  [Column]                    public bool Discontinued;<br>  [Column]                    public DateTime LastSale;<br>}<br>
<b>Delegates Versus Expression Trees<br></b>Recall that:<br>
· Local queries, which use Enumerable operators, take delegates.<br>· Interpreted queries, which use Queryable operators, take expression trees.<br>
We can see this by comparing the signature of the Where operator in Enumerable and<br>Queryable:<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this<br>  <b>IEnumerable</b>&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate)<br>
public static IQueryable&lt;TSource&gt; Where&lt;TSource&gt; (this<br>  <b>IQueryable</b>&lt;TSource&gt; source, <b>Expression</b>&lt;Func&lt;TSource,bool&gt;<b>&gt;</b> predicate)<br>
When embedded within a query, a lambda expression looks identical whether it<br>binds to Enumerable's operators or Queryable's operators:<br>
IEnumerable&lt;Product&gt; q1 = localProducts.Where (<b>p =&gt; !p.Discontinued</b>);<br>IQueryable&lt;Product&gt;  q2 = sqlProducts.Where   (<b>p =&gt; !p.Discontinued</b>);<br>
<b>LINQ Queries</b><br>
When  you  assign  a  lambda  expression  to  an  intermediate  variable,  however,<br>you  must  be  explicit  on  whether  to  resolve  to  a  delegate  (i.e.,  Func&lt;&gt;)  or  an<br>expression tree (i.e., Expression&lt;Func&lt;&gt;&gt;). In the following example, predicate1 and<br>predicate2 are not interchangeable:<br>
<b>Building Query Expressions | 361</b><br>
<hr>
<A name=382></a>Func &lt;Product, bool&gt; predicate1 = p =&gt; !p.Discontinued;<br>
IEnumerable&lt;Product&gt; q1 = localProducts.Where (predicate1);<br>
Expression &lt;Func &lt;Product, bool&gt;&gt; predicate2 = p =&gt; !p.Discontinued;<br>
IQueryable&lt;Product&gt; q2 = sqlProducts.Where (predicate2);<br>
<b>Compiling expression trees<br></b>You can convert an expression tree to a delegate by calling Compile. This is of par-<br>ticular value when writing methods that return reusable expressions. To illustrate,<br>we'll add a static method to the Product class that returns a predicate evaluating to<br>true if a product is not discontinued and has sold in the past 30 days:<br>
public partial class Product<br>
{<br>  public static Expression&lt;Func&lt;Product, bool&gt;&gt; IsSelling()<br>  {<br>
    return p =&gt; !p.Discontinued &amp;&amp; p.LastSale &gt; DateTime.Now.AddDays (-30);<br>
  }<br>
}<br>
(We've defined this in a separate partial class to avoid being overwritten by an au-<br>tomatic DataContext generator such as Visual Studio's code generator.)<br>The method just written can be used both in interpreted and in local queries:<br>
void Test()<br>
{<br>  var dataContext = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>  Product[] localProducts = dataContext.Products.ToArray();<br>
  IQueryable&lt;Product&gt; sqlQuery =<br>    dataContext.Products.Where (Product.<b>IsSelling()</b>);<br>
  IEnumerable&lt;Product&gt; localQuery =<br>    localProducts.Where (<b>Product.IsSelling.Compile()</b>);<br>}<br>
You cannot convert in the reverse direction, from a delegate to<br>an expression tree. This makes expression trees more versatile.<br>
<b>AsQueryable<br></b>The AsQueryable operator lets you write whole <i>queries</i> that can run over either local<br>or remote sequences:<br>
IQueryable&lt;Product&gt; FilterSortProducts (IQueryable&lt;Product&gt; input)<br>{<br>  return from p in input<br>         where ...<br>         order by ...<br>
         select p;<br>}<br>
<b>362 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=383></a>void Test()<br>
{<br>  var dataContext = new NutshellContext (&quot;<i>connection string</i>&quot;);<br>  Product[] localProducts = dataContext.Products.ToArray();<br>
  var sqlQuery   = FilterSortProducts (dataContext.Products);<br>  var localQuery = FilterSortProducts (localProducts<b>.AsQueryable()</b>);<br>  ...<br>
}<br>
AsQueryable wraps IQueryable&lt;T&gt; clothing around a local sequence so that subse-<br>quent query operators resolve to expression trees. When you later enumerate over<br>the result, the expression trees are implicitly compiled (at a small performance cost),<br>and the local sequence enumerates as it would ordinarily.<br>
<b>Expression Trees<br></b>We  said  previously,  that  assigning  a  lambda  expression  to  a  variable  of  type<br>Expression&lt;TDelegate&gt; causes the C# compiler to emit an expression tree. With<br>some programming effort, you can do the same thing manually at runtime--in other<br>words, dynamically build an expression tree from scratch. The result can be cast to<br>an  Expression&lt;TDelegate&gt; and used in LINQ-to-db queries, or compiled into an<br>ordinary delegate by calling Compile.<br>
<b>The Expression DOM<br></b>An expression tree is a miniature code DOM. Each node in the tree is represented<br>by a type in the System.Linq.Expressions namespace; these types are illustrated in<br>Figure 8-11.<br>
<b>LINQ Queries</b><br>
<i>Figure 8-11. Expression types</i><br>
<b>Building Query Expressions | 363</b><br>
<hr>
<A name=384></a>From Framework 4.0, this namespace features additional ex-<br>pression types and methods to support language constructs that<br>can appear in code blocks. These are for the benefit of the DLR<br>and not lambda expressions. In other words, code-block-style<br>lambdas still cannot be converted to expression trees:<br>
Expression&lt;Func&lt;Customer,bool&gt;&gt; <b>invalid</b> =<br>  { return true; ]  // Code blocks not permitted<br>
The  base  class  for  all  nodes  is  the  (nongeneric)  Expression  class.  The  generic<br>Expression&lt;TDelegate&gt; class actually means "typed lambda expression" and might<br>have been named LambdaExpression&lt;TDelegate&gt; if it wasn't for the clumsiness of this:<br>
LambdaExpression&lt;Func&lt;Customer,bool&gt;&gt; f = ...<br>
Expression&lt;&gt;'s base type is the (nongeneric) LambdaExpression class. LamdbaExpres<br>sion  provides  type  unification  for  lambda  expression  trees:  any  typed<br>Expression&lt;&gt; can be cast to a LambdaExpression.<br>
The thing that distinguishes LambdaExpressions from ordinary Expressions is that<br>lambda expressions have <i>parameters</i>.<br>
To create an expression tree, don't instantiate node types directly; rather, call static<br>methods provided on the Expression class. Here are all the methods:<br>
Add<br>
ElementInit<br>
MakeMemberAccess<br>
Or<br>
AddChecked<br>
Equal<br>
MakeUnary<br>
OrElse<br>
And<br>
ExclusiveOr<br>
MemberBind<br>
Parameter<br>
AndAlso<br>
Field<br>
MemberInit<br>
Power<br>
ArrayIndex<br>
GreaterThan<br>
Modulo<br>
Property<br>
ArrayLength<br>
GreaterThanOrEqual<br>
Multiply<br>
PropertyOrField<br>
Bind<br>
Invoke<br>
MultiplyChecked<br>
Quote<br>
Call<br>
Lambda<br>
Negate<br>
RightShift<br>
Coalesce<br>
LeftShift<br>
NegateChecked<br>
Subtract<br>
Condition<br>
LessThan<br>
New<br>
SubtractChecked<br>
Constant<br>
LessThanOrEqual<br>
NewArrayBounds<br>
TypeAs<br>
Convert<br>
ListBind<br>
NewArrayInit<br>
TypeIs<br>
ConvertChecked<br>
ListInit<br>
Not<br>
UnaryPlus<br>
Divide<br>
MakeBinary<br>
NotEqual<br>
Figure 8-12 shows the expression tree that the following assignment creates:<br>
Expression&lt;Func&lt;string, bool&gt;&gt; f = s =&gt; s.Length &lt; 5;<br>
<b>364 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=385></a><IMG src="c#-4-nutshell-385_1.jpg"><br>
<i>Figure 8-12. Expression tree</i><br>
We can demonstrate this as follows:<br>
Console.WriteLine (f.Body.NodeType);                     // LessThan<br>
Console.WriteLine (((BinaryExpression) f.Body).Right);   // 5<br>
Let's now build this expression from scratch. The principle is that you start from<br>the bottom of the tree and work your way up. The bottommost thing in our tree is<br>a ParameterExpression, the lambda expression parameter called "s" of type string:<br>
ParameterExpression p = Expression.Parameter (typeof (string), &quot;s&quot;);<br>
The next step is to build the MemberExpression and ConstantExpression. In the former<br>case, we need to access the Length <i>property</i> of our parameter, "s":<br>
MemberExpression stringLength = Expression.Property (p, &quot;Length&quot;);<br>ConstantExpression five = Expression.Constant (5);<br>
Next is the LessThan comparison:<br>
BinaryExpression comparison = Expression.LessThan (stringLength, five);<br>
The  final  step  is  to  construct  the  lambda  expression,  which  links  an  expression<br>Body to a collection of parameters:<br>
<b>LINQ Queries</b><br>
Expression&lt;Func&lt;string, bool&gt;&gt; lambda<br>  = Expression.Lambda&lt;Func&lt;string, bool&gt;&gt; (comparison, p);<br>
A convenient way to test our lambda is by compiling it to a delegate:<br>
Func&lt;string, bool&gt; runnable = lambda.Compile();<br>
Console.WriteLine (runnable (&quot;kangaroo&quot;));           // False<br>Console.WriteLine (runnable (&quot;dog&quot;));                // True<br>
<b>Building Query Expressions | 365</b><br>
<hr>
<A name=386></a>The easiest way to figure out which expression type to use is to<br>examine an existing lambda expression in the Visual Studio de-<br>bugger.<br>
We continue this discussion online, at <i>http://www.albahari.com/expressions/</i>.<br>
<b>366 | Chapter 8:</b><b>LINQ Queries</b><br>
<hr>
<A name=387></a><b>9</b><br>
<b>LINQ Operators</b><br>
This chapter describes each of the LINQ query operators. As well as serving as a<br>reference,  two  of  the  sections,  "Projecting"  on  page  375  and  "Join-<br>ing" on page 370, cover a number of conceptual areas:<br>
· Projecting object hierarchies<br>· Joining with Select, SelectMany, Join, and GroupJoin<br>· Outer range variables in query expressions<br>
All of the examples in this chapter assume that a names array is defined as follows:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
Examples that query a database assume that a typed DataContext variable called<br>dataContext is instantiated as follows:<br>
var dataContext = new NutshellContext (&quot;<i>connection string...</i>&quot;);<br>
...<br>
public class NutshellContext : DataContext<br>{<br>  public NutshellContext (string cxString) : base (cxString) {}<br>
  public Table&lt;Customer&gt; Customers { get { return GetTable&lt;Customer&gt;(); } }<br>  public Table&lt;Purchase&gt; Purchases { get { return GetTable&lt;Purchase&gt;(); } }<br>}<br>
[Table] public class Customer<br>{<br>  [Column(IsPrimaryKey=true)]  public int ID;<br>  [Column]                     public string Name;<br>
  [Association (OtherKey=&quot;CustomerID&quot;)]<br>  public EntitySet&lt;Purchase&gt; Purchases = new EntitySet&lt;Purchase&gt;();<br>}<br> <br>
<b>367</b><br>
<hr>
<A name=388></a>[Table] public class Purchase<br>{<br>    [Column(IsPrimaryKey=true)]  public int ID;<br>
    [Column]                     public int? CustomerID;<br>
    [Column]                     public string Description;<br>    [Column]                     public decimal Price;<br>    [Column]                     public DateTime Date;<br>
  EntityRef&lt;Customer&gt; custRef;<br>
  [Association (Storage=&quot;custRef&quot;,ThisKey=&quot;CustomerID&quot;,IsForeignKey=true)]<br>  public Customer Customer<br>
  {<br>
    get { return custRef.Entity; } set { custRef.Entity = value; }<br>  }<br>}<br>
All the examples in this chapter are preloaded into LINQPad,<br>along with a sample database with a matching schema. You can<br>download LINQPad from <i>http://www.linqpad.net</i>.<br>
The entity classes shown are a simplified version of what LINQ to SQL tools typically<br>produce, and do not include code to update the opposing side in a relationship when<br>their entities have been reassigned.<br>
Here are the corresponding SQL table definitions:<br>
create table Customer<br>
(<br>  ID int not null primary key,<br>
  Name varchar(30) not null<br>)<br>create table Purchase<br>(<br>  ID int not null primary key,<br>
  CustomerID int references Customer (ID),<br>  Description varchar(30) not null,<br>  Price decimal not null<br>)<br>
All  examples  will  also  work  with  Entity  Framework,  except<br>where otherwise indicated. You can build an Entity Framework<br>ObjectContext from these tables by creating a new Entity Data<br>Model in Visual Studio, and then dragging the tables on to the<br>designer surface.<br>
<b>368 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=389></a><b>Overview<br></b>In this section, we provide an overview of the standard query operators.<br>
The standard query operators fall into three categories:<br>
· Sequence in, sequence out (sequence-to-sequence)<br>· Sequence in, single element or scalar value out<br>· Nothing in, sequence out (<i>generation</i> methods)<br>
We first present each of the three categories and the query operators they include,<br>and then we take up each individual query operator in detail.<br>
<b>Sequence</b><b>Sequence<br></b>Most query operators fall into this category--accepting one or more sequences as<br>input and emitting a single output sequence. Figure 9-1 illustrates those operators<br>that restructure the shape of the sequences.<br>
<i>Figure 9-1. Shape-changing operators</i><br>
<b>Filtering<br></b>IEnumerable&lt;TSource&gt;IEnumerable&lt;TSource&gt;<br>
Returns a subset of the original elements.<br>
Where, Take, TakeWhile, Skip, SkipWhile, Distinct<br>
<b>Projecting<br></b>IEnumerable&lt;TSource&gt;IEnumerable&lt;TResult&gt;<br>
Transforms each element with a lambda function.  SelectMany flattens nested se-<br>quences; Select and SelectMany perform inner joins, left outer joins, cross joins, and<br>non-equi joins with LINQ to SQL and EF.<br>
<b>LINQ Operators</b><br>
Select, SelectMany<br>
<b>Overview | 369</b><br>
<hr>
<A name=390></a><b>Joining<br></b>IEnumerable&lt;TOuter&gt;, IEnumerable&lt;TInner&gt;IEnumerable&lt;TResult&gt;<br>
Meshes elements of one sequence with another. The joining operators are designed<br>to be efficient with local queries and support inner and left outer joins.<br>
Join, GroupJoin<br>
<b>Ordering<br></b>IEnumerable&lt;TSource&gt;IOrderedEnumerable&lt;TSource&gt;<br>
Returns a reordering of a sequence.<br>
OrderBy, ThenBy, Reverse<br>
<b>Grouping<br></b>IEnumerable&lt;TSource&gt;IEnumerable&lt;IGrouping&lt;TSource,TElement&gt;&gt;<br>
Groups a sequence into subsequences.<br>
GroupBy<br>
<b>Set operators<br></b>IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;IEnumerable&lt;TSource&gt;<br>
Takes two same-typed sequences and returns their commonality, sum, or difference.<br>
Concat, Union, Intersect, Except<br>
<b>Zip operator<br></b>IEnumerable&lt;TFirst&gt;, IEnumerable&lt;TSecond&gt;IEnumerable&lt;TResult&gt;<br>
Enumerates two sequences in step, applying a function over each element pair.<br>
<b>Conversion methods: Import<br></b>IEnumerableIEnumerable&lt;TResult&gt;<br>
OfType, Cast<br>
<b>Conversion methods: Export<br></b>IEnumerable&lt;TSource&gt;An array, list, dictionary, lookup, or sequence<br>
ToArray, ToList, ToDictionary, ToLookup, AsEnumerable, AsQueryable<br>
<b>Sequence</b><b>Element or Scalar<br></b>The following query operators accept an input sequence and emit a single element<br>or scalar value.<br>
<b>Element operators<br></b>IEnumerable&lt;TSource&gt;TSource<br>
<b>370 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=391></a>Picks a single element from a sequence.<br>
First, FirstOrDefault, Last, LastOrDefault, Single, SingleOrDefault,<br>
ElementAt, ElementAtOrDefault, DefaultIfEmpty<br>
<b>Aggregation methods<br></b>IEnumerable&lt;TSource&gt;<i>scalar</i><br>
Performs  a  computation  across  a  sequence,  returning  a  scalar  value  (typically  a<br>number).<br>
Aggregate, Average, Count, LongCount, Sum, Max, Min<br>
<b>Quantifiers<br></b>IEnumerable&lt;TSource&gt;<i>bool</i><br>
An aggregation returning true or false.<br>
All, Any, Contains, SequenceEqual<br>
<b>Void</b><b>Sequence<br></b>In the third and final category are query operators that produce an output sequence<br>from scratch.<br>
<b>Generation methods<br></b>voidIEnumerable&lt;TResult&gt;<br>
Manufactures a simple sequence.<br>
Empty, Range, Repeat<br>
<b>Filtering<br></b>IEnumerable&lt;TSource&gt; IEnumerable&lt;TSource&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Where<br>
Returns a subset of elements that satisfy a given condition<br>
WHERE<br>
Take<br>
Returns the first count elements and discards the rest<br>
WHERE ROW_NUMBER()...<br>
or TOP <i>n</i> subquery<br>
Skip<br>
Ignores the first count elements and returns the rest<br>
WHERE ROW_NUMBER()...<br>
or NOT IN (SELECT TOP <i>n</i>...)<br>
TakeWhile<br>
Emits elements from the input sequence until the predicate is<br>
Exception thrown<br>
false<br>
SkipWhile<br>
Ignores elements from the input sequence until the predicate<br>
Exception thrown<br>
is false, and then emits the rest<br>
Distinct<br>
Returns a sequence that excludes duplicates<br>
SELECT DISTINCT...<br>
<b>LINQ Operators</b><br>
<b>Filtering | 371</b><br>
<hr>
<A name=392></a>The "SQL equivalents" column in the reference tables in this<br>chapter do not necessarily correspond to what an IQueryable<br>implementation such as LINQ to SQL will produce. Rather, it<br>indicates what you'd typically use to do the same job if you were<br>writing the SQL query yourself. Where there is no simple trans-<br>lation, the column is left blank. Where there is no translation at<br>all, the column reads "Exception thrown".<br>
Enumerable implementation code, when shown, excludes check-<br>ing for null arguments and indexing predicates.<br>
With each of the filtering methods, you always end up with either the same number<br>or fewer elements than you started with. You can never get more! The elements are<br>also identical when they come out; they are not transformed in any way.<br>
<b>Where</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Predicate<br>
TSource =&gt; bool or (TSource,int) =&gt; boola<br>
a Prohibited with LINQ to SQL and Entity Framework.<br>
<b>Query syntax</b><br>
where <i>bool-expression</i><br>
<b>Enumerable.Where implementation<br></b>The internal implementation of Enumerable.Where, null checking aside, is function-<br>ally equivalent to the following:<br>
<b>public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br></b>  (this IEnumerable&lt;TSource&gt; source, Func &lt;TSource, bool&gt; predicate)<br>{<br>  foreach (TSource element in source)<br>    if (predicate (element))<br>      yield return element;<br>
}<br>
<b>Overview<br></b>Where returns the elements from the input sequence that satisfy the given predicate.<br>
For instance:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br><b>IEnumerable&lt;string&gt; query = names.Where (name =&gt; name.EndsWith (&quot;y&quot;));</b><br>
// Result: { &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; }<br>
<b>372 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=393></a>In query syntax:<br>
IEnumerable&lt;string&gt; query = from n in names<br>
                            <b>where n.EndsWith (&quot;y&quot;)</b><br>
                            select n;<br>
A where clause can appear more than once in a query and be interspersed with let<br>clauses:<br>
from n in names<br>
<b>where n.Length &gt; 3</b><br>
let u = n.ToUpper()<br>
<b>where u.EndsWith (&quot;Y&quot;)<br></b>select u;                   // Result: { &quot;HARRY&quot;, &quot;MARY&quot; }<br>
Standard C# scoping rules apply to such queries. In other words, you cannot refer<br>to a variable prior to declaring it with an range variable or a let clause.<br>
<b>Indexed filtering<br></b>Where's predicate optionally accepts a second argument, of type int. This is fed with<br>the position of each element within the input sequence, allowing the predicate to<br>use this information in its filtering decision. For example, the following skips every<br>second element:<br>
<b>IEnumerable&lt;string&gt; query = names.Where ((n, i) =&gt; i % 2 == 0);</b><br>
// Result: { &quot;Tom&quot;, &quot;Harry&quot;, &quot;Jay&quot; }<br>
An exception is thrown if you use indexed filtering in LINQ to SQL or EF.<br>
<b>SQL LIKE comparisons in LINQ to SQL and EF<br></b>The following methods on string translate to SQL's LIKE operator:<br>
Contains, StartsWith, EndsWith<br>
For instance, c.Name.Contains (&quot;abc&quot;) translates to customer.Name LIKE '%abc%' (or<br>more accurately, a parameterized version of this). Contains lets you compare only a<br>against a locally evaluated expression; to compare against another column, you must<br>use the SqlMethods.Like method:<br>
... where SqlMethods.Like (c.Description, &quot;%&quot; + c.Name + &quot;%&quot;)<br>
SqlMethods.Like  also  lets  you  perform  more  complex  comparisons  (e.g.,  LIKE<br>'abc%def%').<br>
<b>&lt; and &gt; string comparisons in LINQ to SQL and EF<br></b>You can perform <i>order</i> comparison on strings with string's CompareTo method; this<br>maps to SQL's &lt; and &gt; operators:<br>
dataContext.Purchases.Where (p =&gt; p.Description.<b>CompareTo (&quot;C&quot;)</b> &lt; <b>0</b>)<br>
<b>LINQ Operators</b><br>
<b>Filtering | 373</b><br>
<hr>
<A name=394></a><b>WHERE x IN (..., ..., ...) in LINQ to SQL and EF<br></b>With LINQ to SQL and EF, you can apply the Contains operator to a local collection<br>within a filter predicate. For instance:<br>
<b>string[] chosenOnes = { &quot;Tom&quot;, &quot;Jay&quot; };</b><br>
from c in dataContext.Customers<br>
<b>where chosenOnes.Contains (c.Name)</b><br>
...<br>
This maps to SQL's IN operator--in other words:<br>
WHERE customer.Name <b>IN (&quot;Tom&quot;, &quot;Jay&quot;)</b><br>
If the local collection is an array of entities or nonscalar types, LINQ to SQL or EF<br>may instead emit an EXISTS clause.<br>
<b>Take and Skip</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Number of elements to take or skip<br>
int<br>
Take emits the first <i>n</i> elements and discards the rest; Skip discards the first <i>n</i> elements<br>and emits the rest. The two methods are useful together when implementing a web<br>page allowing a user to navigate through a large set of matching records. For in-<br>stance, suppose a user searches a book database for the term "mercury," and there<br>are 100 matches. The following returns the first 20:<br>
IQueryable&lt;Book&gt; query = dataContext.Books<br>
  .Where   (b =&gt; b.Title.Contains (&quot;mercury&quot;))<br>  .OrderBy (b =&gt; b.Title)<br>  <b>.Take (20);</b><br>
The next query returns books 21 to 40:<br>
IQueryable&lt;Book&gt; query = dataContext.Books<br>  .Where   (b =&gt; b.Title.Contains (&quot;mercury&quot;))<br>  .OrderBy (b =&gt; b.Title)<br>
  <b>.Skip (20).Take (20);</b><br>
LINQ to SQL and EF translate Take and Skip to the ROW_NUMBER function in SQL<br>Server 2005, or a TOP <i>n</i> subquery in earlier versions of SQL Server.<br>
<b>TakeWhile and SkipWhile</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Predicate<br>
TSource =&gt; bool or (TSource,int) =&gt; bool<br>
<b>374 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=395></a>TakeWhile enumerates the input sequence, emitting each item, until the given pred-<br>icate is false. It then ignores the remaining elements:<br>
int[] numbers      = { 3, 5, 2, 234, 4, 1 };<br><b>var takeWhileSmall = numbers.TakeWhile (n =&gt; n &lt; 100);   // { 3, 5, 2 }</b><br>
SkipWhile enumerates the input sequence, ignoring each item until the given pred-<br>icate is false. It then emits the remaining elements:<br>
int[] numbers      = { 3, 5, 2, 234, 4, 1 };<br><b>var skipWhileSmall = numbers.SkipWhile (n =&gt; n &lt; 100);   // { 234, 4, 1 }</b><br>
TakeWhile and SkipWhile have no translation to SQL and cause a runtime error if<br>used in a LINQ-to-db query.<br>
<b>Distinct<br></b>Distinct returns the input sequence, stripped of duplicates. Only the default equal-<br>ity comparer can be used for equality comparison. The following returns distinct<br>letters in a string:<br>
<b>char[] distinctLetters = &quot;HelloWorld&quot;.Distinct().ToArray();</b><br>
string s = new string (distinctLetters);                     // HeloWrd<br>
We  can  call  LINQ  methods  directly  on  a  string,  because  string  implements<br>IEnumerable&lt;char&gt;.<br>
<b>Projecting<br></b>IEnumerable&lt;TSource&gt;IEnumerable&lt;TResult&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Select<br>
Transforms each input element with the given lambda expression<br>
SELECT<br>
SelectMany<br>
Transforms each input element, and then flattens and concatenates the<br>
INNER JOIN,<br>
resultant subsequences<br>
LEFT OUTER JOIN,<br>
CROSS JOIN<br>
When querying a database, Select and SelectMany are the most<br>versatile  joining  constructs;  for  local  queries,  Join  and  Group<br>Join are the most <i>efficient</i> joining constructs.<br>
<b>Select</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Result selector<br>
TSource =&gt; TResult or (TSource,int) =&gt; TResulta<br>
<b>LINQ Operators</b><br>
a Prohibited with LINQ to SQL and Entity Framework.<br>
<b>Projecting | 375</b><br>
<hr>
<A name=396></a><b>Query syntax</b><br>
select <i>projection-expression</i><br>
<b>Enumerable implementation</b><br>
<b>public static IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt;</b><br>
  (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector)<br>
{<br>  foreach (TSource element in source)<br>    yield return selector (element);<br>
}<br>
<b>Overview<br></b>With Select, you always get the same number of elements that you started with.<br>Each element, however, can be transformed in any manner by the lambda function.<br>
The  following  selects  the  names  of  all  fonts  installed  on  the  computer  (from<br>System.Drawing):<br>
IEnumerable&lt;string&gt; query = from f in FontFamily.Families<br>
                            <b>select f.Name;</b><br>
foreach (string name in query) Console.WriteLine (name);<br>
In this example, the select clause converts a FontFamily object to its name. Here's<br>the lambda equivalent:<br>
IEnumerable&lt;string&gt; query = FontFamily.Families.Select (f =&gt; f.Name);<br>
Select statements are often used to project into anonymous types:<br>
var query =<br>  from f in FontFamily.Families<br>  <b>select new { f.Name, LineSpacing = f.GetLineSpacing (FontStyle.Bold) };</b><br>
A projection with no transformation is sometimes used with query syntax, in order<br>to satisfy the requirement that the query end in a select or group clause. The fol-<br>lowing selects fonts supporting strikeout:<br>
IEnumerable&lt;FontFamily&gt; query =<br>  from f in FontFamily.Families<br>  where f.IsStyleAvailable (FontStyle.Strikeout)<br>  <b>select f;</b><br>
foreach (FontFamily ff in query) Console.WriteLine (ff.Name);<br>
In such cases, the compiler omits the projection when translating to fluent syntax.<br>
<b>Indexed projection<br></b>The selector expression can optionally accept an integer argument, which acts as<br>an indexer, providing the expression with the position of each input in the input<br>sequence. This works only with local queries:<br>
string[] names = { &quot;Tom&quot;, &quot;Dick&quot;, &quot;Harry&quot;, &quot;Mary&quot;, &quot;Jay&quot; };<br>
<b>376 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=397></a>IEnumerable&lt;string&gt; query = names<br>
  .Select ((s,i) =&gt; i + &quot;=&quot; + s);     //  { &quot;0=Tom&quot;, &quot;1=Dick&quot;, ... }<br>
<b>Select subqueries and object hierarchies<br></b>You can nest a subquery in a select clause to build an object hierarchy. The fol-<br>lowing example returns a collection describing each directory under <i>D:\source</i>, with<br>a subcollection of files under each directory:<br>
DirectoryInfo[] dirs = new DirectoryInfo (@&quot;d:\source&quot;).GetDirectories();<br>
var query =<br>
  from d in dirs<br>
  where (d.Attributes &amp; FileAttributes.System) == 0<br>  select new<br>
  {<br>
    DirectoryName = d.FullName,<br>
    Created = d.CreationTime,<br>
    <b>Files = from f in d.GetFiles()<br></b>            <b>where (f.Attributes &amp; FileAttributes.Hidden) == 0</b><br>
            <b>select new { FileName = f.Name, f.Length, }</b><br>
  };<br>
foreach (var dirFiles in query)<br>{<br>  Console.WriteLine (&quot;Directory: &quot; + dirFiles.DirectoryName);<br>  foreach (var file in dirFiles.Files)<br>
    Console.WriteLine (&quot;  &quot; + file.FileName + &quot;Len: &quot; + file.Length);<br>}<br>
The inner portion of this query can be called a <i>correlated subquery</i>. A subquery is<br>correlated if it references an object in the outer query--in this case, it references d,<br>the directory being enumerated.<br>
A subquery inside a Select allows you to map one object hier-<br>archy to another, or map a relational object model to a hier-<br>archical object model.<br>
With local queries, a subquery within a Select causes double-deferred execution.<br>In our example, the files don't get filtered or projected until the inner foreach state-<br>ment enumerates.<br>
<b>Subqueries and joins in LINQ to SQL and EF<br></b>Subquery projections work well in LINQ to SQL and EF and can be used to do the<br>work of SQL-style joins. Here's how we retrieve each customer's name along with<br>their high-value purchases:<br>
<b>LINQ Operators</b><br>
<b>Projecting | 377</b><br>
<hr>
<A name=398></a>var query =<br>
  from c in dataContext.Customers<br>  select new {<br>               c.Name,<br>
               <b>Purchases = from p in dataContext.Purchases</b><br>
                           <b>where p.CustomerID == c.ID &amp;&amp; p.Price &gt; 1000<br></b>                           <b>select new { p.Description, p.Price }<br></b>             };<br>
foreach (var namePurchases in query)<br>{<br>  Console.WriteLine (&quot;Customer: &quot; + namePurchases.Name);<br>
  foreach (var purchaseDetail in namePurchases.Purchases)<br>
    Console.WriteLine (&quot;  - $$$: &quot; + purchaseDetail.Price);<br>}<br>
This style of query is ideally suited to interpreted queries. The<br>outer query and subquery are processed as a unit, avoiding un-<br>necessary round-tripping. With local queries, however, it's in-<br>efficient because every combination of outer and inner elements<br>must be enumerated to get the few matching combinations. A<br>better choice for local queries is Join or GroupJoin, described in<br>the following sections.<br>
This query matches up objects from two disparate collections, and it can be thought<br>of as a "Join." The difference between this and a conventional database join (or<br>subquery) is that we're not flattening the output into a single two-dimensional result<br>set. We're mapping the relational data to hierarchical data, rather than to flat data.<br>
Here's the same query simplified by using the Purchases association property on the<br>Customer entity:<br>
from c in dataContext.Customers<br>select new<br>{<br>  c.Name,<br>  <b>Purchases = from p in c.Purchases    // Purchases is EntitySet&lt;Purchase&gt;</b><br>
              where p.Price &gt; 1000<br>              select new { p.Description, p.Price }<br>};<br>
Both queries are analogous to a left outer join in SQL in the sense that we get all<br>customers in the outer enumeration, regardless of whether they have any purchases.<br>To emulate an inner join--where customers without high-value purchases are ex-<br>cluded--we would need to add a filter condition on the purchases collection:<br>
from c in dataContext.Customers<br><b>where c.Purchases.Any (p =&gt; p.Price &gt; 1000)<br></b>select new {<br>             c.Name,<br>             Purchases = from p in c.Purchases<br>                         where p.Price &gt; 1000<br>                         select new { p.Description, p.Price }<br>           };<br>
<b>378 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=399></a>This is slightly untidy, however, in that we've written the same predicate (Price &gt;<br>1000) twice. We can avoid this duplication with a let clause:<br>
from c in dataContext.Customers<br><b>let highValueP = from p in c.Purchases</b><br>
                 <b>where p.Price &gt; 1000</b><br>
                 <b>select new { p.Description, p.Price }<br></b>where highValueP.Any()<br>select new { c.Name, Purchases = highValueP };<br>
This style of query is flexible. By changing Any to Count, for instance, we can modify<br>the query to retrieve only customers with at least two high-value purchases:<br>
...<br><b>where highValueP.Count() &gt;= 2</b><br>
select new { c.Name, Purchases = highValueP };<br>
<b>Projecting into concrete types<br></b>Projecting into anonymous types is useful in obtaining intermediate results, but not<br>so  useful  if  you  want  to  send  a  result  set  back  to  a  client,  for  instance,  because<br>anonymous types can exist only as local variables within a method. An alternative<br>is to use concrete types for projections, such as DataSets or custom business entity<br>classes. A custom business entity is simply a class that you write with some proper-<br>ties, similar to a LINQ to SQL [Table] annotated class or an EF Entity, but designed<br>to hide lower-level (database-related) details. You might exclude foreign key fields<br>from business entity classes, for instance. Assuming we wrote custom entity classes<br>called CustomerEntity and PurchaseEntity, here's how we could project into them:<br>
IQueryable&lt;CustomerEntity&gt; query =<br>
  from c in dataContext.Customers<br>  <b>select new CustomerEntity<br></b>  {<br>    Name = c.Name,<br>    Purchases =<br>      (from p in c.Purchases<br>       where p.Price &gt; 1000<br>       <b>select new PurchaseEntity {<br></b>                                   <b>Description = p.Description,<br></b>                                   <b>Value = p.Price<br></b>                                 <b>}<br></b>      ).ToList()<br>  };<br>
// Force query execution, converting output to a more convenient List:<br>List&lt;CustomerEntity&gt; result = query.ToList();<br>
Notice that so far, we've not had to use a  Join or SelectMany statement. This is<br>because we're maintaining the hierarchical shape of the data, as illustrated in Fig-<br>ure 9-2. With LINQ, you can often avoid the traditional SQL approach of flattening<br>tables into a two-dimensional result set.<br>
<b>LINQ Operators</b><br>
<b>Projecting | 379</b><br>
<hr>
<A name=400></a><i>Figure 9-2. Projecting an object hierarchy</i><br>
<b>SelectMany</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Result selector<br>
TSource =&gt; IEnumerable&lt;TResult&gt;<br>
or (TSource,int) =&gt; IEnumerable&lt;TResult&gt;a<br>
a Prohibited with LINQ to SQL<br>
<b>Query syntax</b><br>
from <i>identifier1</i> in <i>enumerable-expression1<br></i>from <i>identifier2</i> in <i>enumerable-expression2<br></i>...<br>
<b>Enumerable implementation</b><br>
public static IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt;<br>  (IEnumerable&lt;TSource&gt; source,<br>   Func &lt;TSource,IEnumerable&lt;TResult&gt;&gt; selector)<br>{<br>  foreach (TSource element in source)<br>
    foreach (TResult subElement in selector (element))<br>      yield return subElement;<br>}<br>
<b>Overview<br></b>SelectMany concatenates subsequences into a single flat output sequence.<br>
Recall  that  for  each  input  element,  Select yields exactly one output element. In<br>contrast, SelectMany yields <i>0..n</i> output elements. The <i>0..n</i> elements come from a<br>subsequence or child sequence that the lambda expression must emit.<br>
SelectMany can be used to expand child sequences, flatten nested collections, and<br>join two collections into a flat output sequence. Using the conveyor belt analogy,<br>SelectMany funnels fresh material onto a conveyor belt. With SelectMany, each input<br>
<b>380 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=401></a>element is the <i>trigger</i> for the introduction of fresh material. The fresh material is<br>emitted by the selector lambda expression and must be a sequence. In other words,<br>the lambda expression must emit a <i>child sequence</i> per input <i>element</i>. The final result<br>is a concatenation of the child sequences emitted for each input element.<br>
Starting with a simple example, suppose we have an array of names as follows:<br>
string[] fullNames = { &quot;Anne Williams&quot;, &quot;John Fred Smith&quot;, &quot;Sue Green&quot; };<br>
which we wish to convert to a single flat collection of words--in other words:<br>
&quot;Anne&quot;, &quot;Williams&quot;, &quot;John&quot;, &quot;Fred&quot;, &quot;Smith&quot;, &quot;Sue&quot;, Green&quot;<br>
SelectMany is ideal for this task, because we're mapping each input element to a<br>variable number of output elements. All we must do is come up with a selector<br>expression that converts each input element to a child sequence. string.Split does<br>the job nicely: it takes a string and splits it into words, emitting the result as an array:<br>
string testInputElement = &quot;Anne Williams&quot;;<br>
string[] childSequence  = testInputElement.Split();<br>
// childSequence is { &quot;Anne&quot;, &quot;Williams&quot; };<br>
So, here's our SelectMany query and the result:<br>
<b>IEnumerable&lt;string&gt; query = fullNames.SelectMany (name =&gt; name.Split());</b><br>
foreach (string name in query)<br>  Console.Write (name + &quot;|&quot;);  // Anne|Williams|John|Fred|Smith|Sue|Green|<br>
If you replace SelectMany with Select, you get the same results<br>in hierarchical form. The following emits a sequence of string<br><i>arrays</i>, requiring nested foreach statements to enumerate:<br>
IEnumerable&lt;string[]&gt; query =<br>  fullNames.Select (name =&gt; name.Split());<br>
foreach (string[] stringArray in query)<br>  foreach (string name in stringArray)<br>
    Console.Write (name + &quot;/&quot;);<br>
The  benefit  of  SelectMany  is  that  it  yields  a  single  <i>flat</i>  result<br>sequence.<br>
SelectMany  is  supported  in  query  syntax  and  is  invoked  by  having  an  <i>additional<br>generator</i>--in other words, an extra from clause in the query. The from keyword has<br>two meanings in query syntax. At the start of a query, it introduces the original range<br>variable  and  input  sequence.  <i>Anywhere  else</i>  in  the  query,  it  translates  to<br>SelectMany. Here's our query in query syntax:<br>
IEnumerable&lt;string&gt; query =<br>  from fullName in fullNames<br>  <b>from name in fullName.Split()     // Translates to SelectMany<br></b>  select name;<br>
<b>LINQ Operators</b><br>
<b>Projecting | 381</b><br>
<hr>
<A name=402></a>Note that the additional generator introduces a new query variable--in this case,<br>name. The new query variable becomes the range variable from then on, and the old<br>range variable is demoted to an <i>outer range variable</i>.<br>
<b>Outer range variables<br></b>In  the  preceding  example,  fullName  becomes  an  outer  range  variable  after<br>SelectMany. Outer range variables remain in scope until the query either ends or<br>reaches an into clause. The extended scope of these variables is <i>the</i> killer scenario<br>for query syntax over fluent syntax.<br>
To  illustrate,  we  can  take  the  preceding  query  and  include  fullName  in  the  final<br>projection:<br>
IEnumerable&lt;string&gt; query =<br>
  from fullName in fullNames       // fullName = outer variable<br>
  from name in fullName.Split()    // name = range variable<br>
  <b>select name + &quot; came from &quot; + fullName;</b><br>
Anne came from Anne Williams<br>
Williams came from Anne Williams<br>
John came from John Fred Smith<br>...<br>
Behind the scenes, the compiler must pull some tricks to resolve outer references. A<br>good way to appreciate this is to try writing the same query in fluent syntax. It's<br>tricky! It gets harder still if you insert a where or orderby clause before projecting:<br>
from fullName in fullNames<br>
from name in fullName.Split()<br><b>orderby fullName, name<br></b>select name + &quot; came from &quot; + fullName;<br>
The problem is that SelectMany emits a flat sequence of child elements--in our case,<br>a  flat  collection  of  words.  The  original  outer  element  from  which  it  came<br>(fullName) is lost. The solution is to "carry" the outer element with each child, in a<br>temporary anonymous type:<br>
from fullName in fullNames<br>from x in fullName.Split()<b>.Select (name =&gt; new { name, fullName } )<br></b>orderby x.fullName, x.name<br>select x.name + &quot; came from &quot; + x.fullName;<br>
The only change here is that we're wrapping each child element (name) in an anon-<br>ymous type that also contains its fullName. This is similar to how a let clause is<br>resolved. Here's the final conversion to fluent syntax:<br>
IEnumerable&lt;string&gt; query = fullNames<br>  .SelectMany (fName =&gt; fName.Split()<br>                             <b>.Select (name =&gt; new { name, fName } ))<br></b>  .OrderBy (x =&gt; x.fName)<br>  .ThenBy  (x =&gt; x.name)<br>  .Select  (x =&gt; x.name + &quot; came from &quot; + x.fName);<br>
<b>382 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=403></a><b>Thinking in query syntax<br></b>As we just demonstrated, there are good reasons to use query syntax if you need the<br>outer range variable. In such cases, it helps not only to use query syntax, but also to<br>think directly in its terms.<br>
There are two basic patterns when writing additional generators. The first is <i>ex-<br>panding and flattening subsequences</i>. To do this, you call a property or method on<br>an existing query variable in your additional generator. We did this in the previous<br>example:<br>
from fullName in fullNames<br>
from name in <b>fullName</b>.Split()<br>
Here,  we've  expanded  from  enumerating  full  names  to  enumerating  words.  An<br>analogous LINQ-to-db query is when you expand child association properties. The<br>following query lists all customers along with their purchases:<br>
IEnumerable&lt;string&gt; query = from c in dataContext.Customers<br>                            from p in <b>c.Purchases</b><br>
                            select c.Name + &quot; bought a &quot; + p.Description;<br>
Tom bought a Bike<br>
Tom bought a Holiday<br>
Dick bought a Phone<br>
Harry bought a Car<br>...<br>
Here, we've expanded each customer into a subsequence of purchases.<br>
The second pattern is performing a <i>cross product</i> or <i>cross join</i>--where every element<br>of one sequence is matched with every element of another. To do this, introduce a<br>generator  whose  selector  expression  returns  a  sequence  unrelated  to  a  range<br>variable:<br>
int[] numbers = { 1, 2, 3 };  string[] letters = { &quot;a&quot;, &quot;b&quot; };<br>
IEnumerable&lt;string&gt; query = from n in numbers<br>                            <b>from l in letters<br></b>                            select n.ToString() + l;<br>
RESULT: { &quot;1a&quot;, &quot;1b&quot;, &quot;2a&quot;, &quot;2b&quot;, &quot;3a&quot;, &quot;3b&quot; }<br>
This style of query is the basis of SelectMany-style <i>joins</i>.<br>
<b>Joining with SelectMany<br></b>You can use SelectMany to join two sequences, simply by filtering the results of a<br>cross product. For instance, suppose we wanted to match players for a game. We<br>could start as follows:<br>
string[] players = { &quot;Tom&quot;, &quot;Jay&quot;, &quot;Mary&quot; };<br>
IEnumerable&lt;string&gt; query = from name1 in players<br>                            <b>from name2 in players</b><br>
<b>LINQ Operators</b><br>
                            select name1 + &quot; vs &quot; + name2;<br>
<b>Projecting | 383</b><br>
<hr>
<A name=404></a>RESULT: { &quot;Tom vs Tom&quot;, &quot;Tom vs Jay&quot;, &quot;Tom vs Mary&quot;,<br>
          &quot;Jay vs Tom&quot;, &quot;Jay vs Jay&quot;, &quot;Jay vs Mary&quot;,<br>          &quot;Mary vs Tom&quot;, &quot;Mary vs &quot;Jay&quot;, &quot;Mary vs Mary&quot; }<br>
The query reads: "For every player, reiterate every player, selecting player 1 vs player<br>2". Although we got what we asked for (a cross join), the results are not useful until<br>we add a filter:<br>
IEnumerable&lt;string&gt; query = from name1 in players<br>
                            from name2 in players<br>
                            <b>where name1.CompareTo (name2) &lt; 0</b><br>
                            orderby name1, name2<br>                            select name1 + &quot; vs &quot; + name2;<br>
RESULT: { &quot;Jay vs Mary&quot;, &quot;Jay vs Tom&quot;, &quot;Mary vs Tom&quot; }<br>
The filter predicate constitutes the <i>join condition</i>. Our query can be called a <i>non-equi<br>join</i>, because the join condition doesn't use an equality operator.<br>
We'll demonstrate the remaining types of joins with LINQ to SQL (they'll also work<br>with EF except where we explicitly use a foreign key field).<br>
<b>SelectMany in LINQ to SQL and EF<br></b>SelectMany in LINQ to SQL and EF can perform cross joins, non-equi joins, inner<br>joins, and left outer joins. You can use SelectMany with both predefined associations<br>and ad hoc relationships--just as with Select. The difference is that SelectMany<br>returns a flat rather than a hierarchical result set.<br>
A LINQ-to-db cross join is written just as in the preceding section. The following<br>query matches every customer to every purchase (a cross join):<br>
var query = from c in dataContext.Customers<br>            <b>from p in dataContext.Purchases<br></b>            select c.Name + &quot; might have bought a &quot; + p.Description;<br>
More typically, though, you'd want to match customers to their own purchases only.<br>You achieve this by adding a where clause with a joining predicate. This results in a<br>standard SQL-style equi-join:<br>
var query = from c in dataContext.Customers<br>            from p in dataContext.Purchases<br>            <b>where c.ID == p.CustomerID<br></b>            select c.Name + &quot; bought a &quot; + p.Description;<br>
This translates well to SQL. In the next section, we'll see how<br>it extends to support outer joins. Reformulating such queries<br>with  LINQ's  Join  operator  actually  makes  them  <i>less<br></i>extensible--LINQ is opposite to SQL in this sense.<br>
If you have association properties for relationships in your entities, you can express<br>the same query by expanding the subcollection instead of filtering the cross product:<br>
<b>384 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=405></a>from c in dataContext.Customers<br>
<b>from p in c.Purchases<br></b>select new { c.Name, p.Description };<br>
Entity Framework doesn't expose foreign keys in the entities,<br>so  for  recognized  relationships  you  <i>must</i>  use  its  association<br>properties rather than joining manually as we did previously.<br>
The advantage is that we've eliminated the joining predicate. We've gone from fil-<br>tering a cross product to expanding and flattening. Both queries, however, will result<br>in the same SQL.<br>
You can add where clauses to such a query for additional filtering. For instance, if<br>we wanted only customers whose names started with "T", we could filter as follows:<br>
from c in dataContext.Customers<br>
<b>where c.Name.StartsWith (&quot;T&quot;)</b><br>
from p in c.Purchases<br>select new { c.Name, p.Description };<br>
This LINQ-to-db query would work equally well if the where clause is moved one<br>line down. If it is a local query, however, moving the where clause down would make<br>it less efficient. With local queries, you should filter <i>before</i> joining.<br>
You can introduce new tables into the mix with additional from clauses. For instance,<br>if each purchase had purchase item child rows, you could produce a flat result set<br>of customers with their purchases, each with their purchase detail lines as follows:<br>
from c in dataContext.Customers<br>from p in c.Purchases<br>
<b>from pi in p.PurchaseItems<br></b>select new { c.Name, p.Description, pi.DetailLine };<br>
Each from clause introduces a new <i>child</i> table. To include data from a <i>parent</i> table<br>(via an association property), you don't add a from clause--you simply navigate to<br>the property. For example, if each customer has a salesperson whose name you want<br>to query, just do this:<br>
from c in dataContext.Customers<br>select new { Name = c.Name, SalesPerson = <b>c.SalesPerson.Name</b> };<br>
You don't use SelectMany in this case because there's no subcollection to flatten.<br>Parent association properties return a single item.<br>
<b>Outer joins with SelectMany<br></b>We saw previously that a Select subquery yields a result analogous to a left outer<br>join:<br>
from c in dataContext.Customers<br>select new {<br>             c.Name,<br>
<b>LINQ Operators</b><br>
             Purchases = from p in c.Purchases<br>                         where p.Price &gt; 1000<br>
<b>Projecting | 385</b><br>
<hr>
<A name=406></a>                         select new { p.Description, p.Price }<br>
           };<br>
In  this  example,  every  outer  element  (customer)  is  included,  regardless  of<br>whether the customer has any purchases. But suppose we rewrite this query with<br>SelectMany, so we can obtain a single flat collection rather than a hierarchical result<br>set:<br>
from c in dataContext.Customers<br><b>from p in c.Purchases</b><br>
where p.Price &gt; 1000<br>
select new { c.Name, p.Description, p.Price };<br>
In the process of flattening the query, we've switched to an inner join: customers<br>are now included only for whom one or more high-value purchases exist. To get a<br>left outer join with a flat result set, we must apply the DefaultIfEmpty query operator<br>on the inner sequence. This method returns null if its input sequence has no ele-<br>ments. Here's such a query, price predicate aside:<br>
from c in dataContext.Customers<br>
<b>from p in c.Purchases.DefaultIfEmpty()<br></b>select new { c.Name, p.Description, Price = (decimal?) p.Price };<br>
This works perfectly with LINQ to SQL and EF, returning all customers, even if they<br>have no purchases. But if we were to run this as a local query, it would crash, because<br>when p is null, p.Description and p.Price throw a NullReferenceException. We can<br>make our query robust in either scenario as follows:<br>
from c in dataContext.Customers<br>from p in c.Purchases.DefaultIfEmpty()<br>select new {<br>             c.Name,<br>             <b>Descript = p == null ? null : p.Description,<br></b>             <b>Price = p == null ? (decimal?) null : p.Price<br></b>           };<br>
Let's now reintroduce the price filter. We cannot use a where clause as we did before,<br>because it would execute <i>after</i> DefaultIfEmpty:<br>
from c in dataContext.Customers<br>from p in c.Purchases.DefaultIfEmpty()<br><b>where p.Price &gt; 1000...</b><br>
The  correct  solution  is  to  splice  the  Where  clause  <i>before</i>  DefaultIfEmpty  with  a<br>subquery:<br>
from c in dataContext.Customers<br><b>from p in c.Purchases.Where (p =&gt; p.Price &gt; 1000).DefaultIfEmpty()<br></b>select new {<br>             c.Name,<br>             <b>Descript = p == null ? null : p.Description,<br></b>             <b>Price = p == null ? (decimal?) null : p.Price<br></b>           };<br>
LINQ to SQL and EF translate this to a left outer join. This is an effective pattern<br>for writing such queries.<br>
<b>386 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=407></a>If you're used to writing outer joins in SQL, you might be temp-<br>ted to overlook the simpler option of a Select subquery for this<br>style of query, in favor of the awkward but familiar SQL-centric<br>flat approach. The hierarchical result set from a Select subquery<br>is often better suited to outer join-style queries because there<br>are no additional nulls to deal with.<br>
<b>Joining<br></b>IEnumerable&lt;TOuter&gt;, IEnumerable&lt;TInner&gt;IEnumerable&lt;TResult&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Join<br>
Applies a lookup strategy to match elements from two collections, emitting<br>
INNER JOIN<br>
a flat result set<br>
GroupJoin<br>
As above, but emits a hierarchical result set<br>
INNER JOIN,<br>
LEFT OUTER JOIN<br>
<b>Join and GroupJoin</b><br>
<b>Join arguments</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Outer sequence<br>
IEnumerable&lt;TOuter&gt;<br>
Inner sequence<br>
IEnumerable&lt;TInner&gt;<br>
Outer key selector<br>
TOuter =&gt; TKey<br>
Inner key selector<br>
TInner =&gt; TKey<br>
Result selector<br>
(TOuter,TInner) =&gt; TResult<br>
<b>GroupJoin arguments</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Outer sequence<br>
IEnumerable&lt;TOuter&gt;<br>
Inner sequence<br>
IEnumerable&lt;TInner&gt;<br>
Outer key selector<br>
TOuter =&gt; TKey<br>
Inner key selector<br>
TInner =&gt; TKey<br>
Result selector<br>
(TOuter,<b>IEnumerable&lt;TInner&gt;</b>) =&gt; TResult<br>
<b>Query syntax</b><br>
from <i>outer-var</i> in <i>outer-enumerable<br></i>join <i>inner-var</i> in <i>inner-enumerable</i> on <i>outer-key-expr</i> equals <i>inner-key-expr</i><br>
<b>LINQ Operators</b><br>
 [ into <i>identifier</i> ]<br>
<b>Joining | 387</b><br>
<hr>
<A name=408></a><b>Overview<br></b>Join and GroupJoin mesh two input sequences into a single output sequence. Join<br>emits flat output; GroupJoin emits hierarchical output.<br>
Join and GroupJoin provide an alternative strategy to Select and SelectMany. The<br>advantage of Join and GroupJoin is that they execute efficiently over local in-memory<br>collections, since they first load the inner sequence into a keyed lookup, avoiding<br>the need to repeatedly enumerate over every inner element. The disadvantage is that<br>they offer the equivalent of inner and left outer joins only; cross joins and non-equi<br>joins  must  still  be  done  with  Select/SelectMany.  With  LINQ  to  SQL  and  Entity<br>Framework  queries,  Join  and  GroupJoin  offer  no  real  benefits  over  Select  and<br>SelectMany.<br>
Table 9-1 summarizes the differences between each of the joining strategies.<br>
<i>Table 9-1. Joining strategies</i><br>
<b>Left</b><br>
<b>Non-</b><br>
<b>Result</b><br>
<b>Local query</b><br>
<b>Inner</b><br>
<b>outer</b><br>
<b>Cross</b><br>
<b>equi</b><br>
<b>Strategy</b><br>
<b>shape</b><br>
<b>efficiency</b><br>
<b>joins</b><br>
<b>joins</b><br>
<b>joins</b><br>
<b>joins</b><br>
Select + SelectMany<br>
Flat<br>
Bad<br>
Yes<br>
Yes<br>
Yes<br>
Yes<br>
Select + Select<br>
Nested<br>
Bad<br>
Yes<br>
Yes<br>
Yes<br>
Yes<br>
Join<br>
Flat<br>
Good<br>
Yes<br>
-<br>
-<br>
-<br>
GroupJoin<br>
Nested<br>
Good<br>
Yes<br>
Yes<br>
-<br>
-<br>
GroupJoin + SelectMany<br>
Flat<br>
Good<br>
Yes<br>
Yes<br>
-<br>
-<br>
<b>Join<br></b>The Join operator performs an inner join, emitting a flat output sequence.<br>
Entity Framework hides foreign key fields, so you can't man-<br>ually join across natural relationships (instead, you can query<br>across association properties, as we described in the previous<br>two sections).<br>
The simplest way to demonstrate Join is with LINQ to SQL. The following query<br>lists all customers alongside their purchases, without using an association property:<br>
IQueryable&lt;string&gt; query =<br>  from c in dataContext.Customers<br>  <b>join p in dataContext.Purchases on c.ID equals p.CustomerID<br></b>  select c.Name + &quot; bought a &quot; + p.Description;<br>
The results match what we would get from a SelectMany-style query:<br>
Tom bought a Bike<br>Tom bought a Holiday<br>Dick bought a Phone<br>Harry bought a Car<br>
<b>388 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=409></a>To see the benefit of Join over SelectMany, we must convert this to a local query.<br>We can demonstrate this by first copying all customers and purchases to arrays, and<br>then querying the arrays:<br>
Customer[] customers = dataContext.Customers.ToArray();<br>
Purchase[] purchases = dataContext.Purchases.ToArray();<br>var slowQuery = from c in customers<br>
                <b>from p in purchases where c.ID == p.CustomerID</b><br>
                select c.Name + &quot; bought a &quot; + p.Description;<br>
var fastQuery = from c in customers<br>                <b>join p in purchases on c.ID equals p.CustomerID</b><br>
                select c.Name + &quot; bought a &quot; + p.Description;<br>
Although both queries yield the same results, the Join query is considerably faster<br>because its implementation in Enumerable preloads the inner collection (purchases)<br>into a keyed lookup.<br>
The query syntax for join can be written in general terms as follows:<br>
join <i>inner-var</i> in <i>inner-sequence</i> on <i>outer-key-expr</i> equals <i>inner-key-expr</i><br>
Join  operators  in  LINQ  differentiate  between  the  <i>outer  sequence</i>  and  <i>inner  se-<br>quence</i>. Syntactically:<br>
· The <i>outer sequence</i> is the input sequence (in this case, customers).<br>· The <i>inner sequence</i> is the new collection you introduce (in this case, purchases).<br>
Join performs inner joins, meaning customers without purchases are excluded from<br>the output. With inner joins, you can swap the inner and outer sequences in the<br>query and still get the same results:<br>
from p in purchases                                // p is now outer<br><b>join c in customers on p.CustomerID equals c.ID    // c is now inner<br>...</b><br>
You can add further join clauses to the same query. If each purchase, for instance,<br>has one or more purchase items, you could join the purchase items as follows:<br>
from c in customers<br>join p in purchases on c.ID equals p.CustomerID           // first join<br><b>join pi in purchaseItems on p.ID equals pi.PurchaseID     // second join<br>...</b><br>
purchases acts as the <i>inner</i> sequence in the first join and as the <i>outer</i> sequence in the<br>second join. You could obtain the same results (inefficiently) using nested foreach<br>statements as follows:<br>
foreach (Customer c in customers)<br>  foreach (Purchase p in purchases)<br>    if (c.ID == p.CustomerID)<br>      foreach (PurchaseItem pi in purchaseItems)<br>        if (p.ID == pi.PurchaseID)<br>          Console.WriteLine (c.Name + &quot;,&quot; + p.Price + &quot;,&quot; + pi.Detail);<br>
<b>LINQ Operators</b><br>
<b>Joining | 389</b><br>
<hr>
<A name=410></a>In query syntax, variables from earlier joins remain in scope--just as outer range<br>variables do with SelectMany-style queries. You're also permitted to insert where and<br>let clauses in between join clauses.<br>
<b>Joining on multiple keys<br></b>You can join on multiple keys with anonymous types as follows:<br>
from x in sequenceX<br>
join y in sequenceY on new { K1 = x.Prop1, K2 = x.Prop2 }<br>
                equals new { K1 = y.Prop3, K2 = y.Prop4 }<br>
...<br>
For  this  to  work,  the  two  anonymous  types  must  be  structured  identically.  The<br>compiler then implements each with the same internal type, making the joining keys<br>compatible.<br>
<b>Joining in fluent syntax<br></b>The following query syntax join:<br>
 from c in <b>customers</b><br>
 join p in <b>purchases</b> on <b>c.ID</b> equals <b>p.CustomerID</b><br>
 select new { c.Name, p.Description, p.Price };<br>
in fluent syntax is as follows:<br>
 <b>customers</b>.Join (                // outer collection<br>
       <b>purchases</b>,                // inner collection<br>       c =&gt; <b>c.ID</b>,                // outer key selector<br>
       p =&gt; <b>p.CustomerID</b>,        // inner key selector<br>       (c, p) =&gt; new<br>
          { c.Name, p.Description, p.Price }    // result selector<br> );<br>
The result selector expression at the end creates each element in the output sequence.<br>If you have additional clauses prior to projecting, such as orderby in this example:<br>
from c in customers<br>join p in purchases on c.ID equals p.CustomerID<br><b>orderby p.Price<br></b>select c.Name + &quot; bought a &quot; + p.Description;<br>
you must manufacture a temporary anonymous type in the result selector in fluent<br>syntax. This keeps both c and p in scope following the join:<br>
customers.Join (                  // outer collection<br>      purchases,                  // inner collection<br>      c =&gt; c.ID,                  // outer key selector<br>      p =&gt; p.CustomerID,          // inner key selector<br>      <b>(c, p) =&gt; new { c, p } )    // result selector<br></b>  .OrderBy (x =&gt; x.p.Price)<br>  .Select  (x =&gt; x.c.Name + &quot; bought a &quot; + x.p.Description);<br>
Query syntax is usually preferable when joining; it's less fiddly.<br>
<b>390 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=411></a><b>GroupJoin<br></b>GroupJoin does the same work as Join, but instead of yielding a flat result, it yields<br>a hierarchical result, grouped by each outer element. It also allows left outer joins.<br>
The query syntax for GroupJoin is the same as for Join, but is followed by the into<br>keyword.<br>
Here's the most basic example:<br>
IEnumerable&lt;IEnumerable&lt;Purchase&gt;&gt; query =<br>
  from c in customers<br>
  join p in purchases on c.ID equals p.CustomerID<br>
  <b>into custPurchases</b><br>
  select custPurchases;   // custPurchases is a sequence<br>
An into clause translates to GroupJoin only when it appears di-<br>rectly after a join clause. After a select or group clause, it means<br><i>query continuation</i>. The two uses of the into keyword are quite<br>different, although they have one feature in common: they both<br>introduce a new query variable.<br>
The result is a sequence of sequences, which we could enumerate as follows:<br>
foreach (IEnumerable&lt;Purchase&gt; purchaseSequence in query)<br>
  foreach (Purchase p in purchaseSequence)<br>    Console.WriteLine (p.Description);<br>
This isn't very useful, however, because outerSeq has no reference to the outer cus-<br>tomer. More commonly, you'd reference the outer range variable in the projection:<br>
from c in customers<br>join p in purchases on c.ID equals p.CustomerID<br><b>into custPurchases<br>select new { CustName = c.Name, custPurchases };</b><br>
This gives the same results as the following (inefficient) Select subquery:<br>
from c in customers<br>select new<br>{<br>  CustName = c.Name,<br>
  custPurchases = purchases.Where (p =&gt; c.ID == p.CustomerID)<br>};<br>
By default, GroupJoin does the equivalent of a left outer join. To get an inner join--<br>where customers without purchases are excluded--filter on custPurchases:<br>
from c in customers join p in purchases on c.ID equals p.CustomerID<br>into custPurchases<br><b>where custPurchases.Any()<br></b>select ...<br>
Clauses after a group-join into operate on <i>subsequences</i> of inner child elements, not<br><i>individual</i> child elements. This means that to filter individual purchases, you'd have<br>
<b>LINQ Operators</b><br>
to call Where <i>before</i> joining:<br>
<b>Joining | 391</b><br>
<hr>
<A name=412></a>from c in customers<br>
join p in purchases<b>.Where (p2 =&gt; p2.Price &gt; 1000)<br></b>  on c.ID equals p.CustomerID<br>into custPurchases ...<br>
You can construct lambda queries with GroupJoin as you would with Join.<br>
<b>Flat outer joins<br></b>You run into a dilemma if you want both an outer join and a flat result set. Group<br>Join gives you the outer join; Join gives you the flat result set. The solution is to first<br>call GroupJoin, and then DefaultIfEmpty on each child sequence, and then finally<br>SelectMany on the result:<br>
from c in customers<br>
join p in purchases on c.ID equals p.CustomerID into custPurchases<br>
<b>from cp in custPurchases.DefaultIfEmpty()</b><br>
select new<br>{<br>  CustName = c.Name,<br>
  Price = cp == null ? (decimal?) null : cp.Price<br>
};<br>
DefaultIfEmpty emits a null value if a subsequence of purchases is empty. The second<br>from clause translates to SelectMany. In this role, it <i>expands and flattens</i> all the pur-<br>chase  subsequences,  concatenating  them  into  a  single  sequence  of  purchase<br><i>elements</i>.<br>
<b>Joining with lookups<br></b>The Join and GroupJoin methods in Enumerable work in two steps. First, they load<br>the inner sequence into a <i>lookup</i>. Second, they query the outer sequence in combi-<br>nation with the lookup.<br>
A <i>lookup</i> is a sequence of groupings that can be accessed directly by key. Another<br>way to think of it is as a dictionary of sequences--a dictionary that can accept many<br>elements  under  each  key.  Lookups  are  read-only  and  defined  by  the  following<br>interface:<br>
public interface ILookup&lt;TKey,TElement&gt; :<br>   IEnumerable&lt;IGrouping&lt;TKey,TElement&gt;&gt;, IEnumerable<br>{<br>  int Count { get; }<br>  bool Contains (TKey key);<br>  IEnumerable&lt;TElement&gt; this [TKey key] { get; }<br>}<br>
The  joining  operators--like  other  sequence-emitting<br>operators--honor deferred or lazy execution semantics. This<br>means the lookup is not built until you begin enumerating the<br>output sequence.<br>
<b>392 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=413></a>You can create and query lookups manually as an alternative strategy to using the<br>joining operators, when dealing with local collections. There are a couple of benefits<br>in doing so:<br>
· You can reuse the same lookup over multiple queries--as well as in ordinary<br>
imperative code.<br>
· Querying  a  lookup  is  an  excellent  way  of  understanding  how  Join  and<br>
GroupJoin work.<br>
The ToLookup extension method creates a lookup. The following loads all purchases<br>into a lookup--keyed by their CustomerID:<br>
ILookup&lt;int?,Purchase&gt; purchLookup =<br>  purchases.ToLookup (p =&gt; p.CustomerID, p =&gt; p);<br>
The first argument selects the key; the second argument selects the objects that are<br>to be loaded as values into the lookup.<br>
Reading a lookup is rather like reading a dictionary, except that the indexer returns<br>a <i>sequence</i> of matching items, rather than a <i>single</i> matching item. The following<br>enumerates all purchases made by the customer whose ID is 1:<br>
foreach (Purchase p in purchLookup [1])<br>
  Console.WriteLine (p.Description);<br>
With a lookup in place, you can write SelectMany/Select queries that execute as<br>efficiently as Join/GroupJoin queries. Join is equivalent to using SelectMany on a<br>lookup:<br>
from c in customers<br>from p in purchLookup [c.ID]<br>
select new { c.Name, p.Description, p.Price };<br>
Tom Bike 500<br>Tom Holiday 2000<br>Dick Bike 600<br>Dick Phone 300<br>...<br>
Adding a call to DefaultIfEmpty makes this into an outer join:<br>
from c in customers<br>from p in purchLookup [c.ID]<b>.DefaultIfEmpty()<br></b> select new {<br>              c.Name,<br>              <b>Descript = p == null ? null : p.Description,<br></b>              <b>Price = p == null ? (decimal?) null : p.Price<br></b>            };<br>
<b>LINQ Operators</b><br>
<b>Joining | 393</b><br>
<hr>
<A name=414></a>GroupJoin is equivalent to reading the lookup inside a projection:<br>
from c in customers<br>
select new {<br>
             CustName = c.Name,<br>             CustPurchases = purchLookup [c.ID]<br>           };<br>
<b>Enumerable implementations<br></b>Here's the simplest valid implementation of Enumerable.Join, null checking aside:<br>
public static IEnumerable &lt;TResult&gt; Join<br>
                                    &lt;TOuter,TInner,TKey,TResult&gt; (<br>  this IEnumerable &lt;TOuter&gt;     outer,<br>
  IEnumerable &lt;TInner&gt;          inner,<br>  Func &lt;TOuter,TKey&gt;            outerKeySelector,<br>
  Func &lt;TInner,TKey&gt;            innerKeySelector,<br>  Func &lt;TOuter,TInner,TResult&gt;  resultSelector)<br>
{<br>  ILookup &lt;TKey, TInner&gt; lookup = inner.ToLookup (innerKeySelector);<br>
  return<br>    from outerItem in outer<br>
    from innerItem in lookup [outerKeySelector (outerItem)]<br>    select resultSelector (outerItem, innerItem);<br>
}<br>
GroupJoin's implementation is like that of Join, but simpler:<br>
public static IEnumerable &lt;TResult&gt; GroupJoin<br>                                    &lt;TOuter,TInner,TKey,TResult&gt; (<br>
  this IEnumerable &lt;TOuter&gt;     outer,<br>  IEnumerable &lt;TInner&gt;          inner,<br>  Func &lt;TOuter,TKey&gt;            outerKeySelector,<br>  Func &lt;TInner,TKey&gt;            innerKeySelector,<br>  Func &lt;TOuter,IEnumerable&lt;TInner&gt;,TResult&gt;  resultSelector)<br>{<br>  ILookup &lt;TKey, TInner&gt; lookup = inner.ToLookup (innerKeySelector);<br>  return<br>
    from outerItem in outer<br>    select resultSelector<br>     (outerItem, lookup [outerKeySelector (outerItem)]);<br>}<br>
<b>Ordering<br></b>IEnumerable&lt;TSource&gt;IOrderedEnumerable&lt;TSource&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
OrderBy, ThenBy<br>
Sorts a sequence in ascending order<br>
ORDER BY ...<br>
OrderByDescending, ThenByDescending<br>
Sorts a sequence in descending order<br>
ORDER BY ... DESC<br>
Reverse<br>
Returns a sequence in reverse order<br>
Exception thrown<br>
Ordering operators return the same elements in a different order.<br>
<b>394 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=415></a><b>OrderBy, OrderByDescending, ThenBy, and ThenByDescending</b><br>
<b>OrderBy and OrderByDescending arguments</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Input sequence<br>
IEnumerable&lt;TSource&gt;<br>
Key selector<br>
TSource =&gt; TKey<br>
Return type = IOrderedEnumerable&lt;TSource&gt;<br>
<b>ThenBy and ThenByDescending arguments</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Input sequence<br>
IOrderedEnumerable&lt;TSource&gt;<br>
Key selector<br>
TSource =&gt; TKey<br>
<b>Query syntax</b><br>
orderby <i>expression1</i> [<i>descending</i>] [, <i>expression2</i> [descending] <i>...</i> ]<br>
<b>Overview<br></b>OrderBy returns a sorted version of the input sequence, using the keySelector ex-<br>pression to make comparisons. The following query emits a sequence of names in<br>alphabetical order:<br>
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s);<br>
The following sorts names by length:<br>
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s.Length);<br>
// Result: { &quot;Jay&quot;, &quot;Tom&quot;, &quot;Mary&quot;, &quot;Dick&quot;, &quot;Harry&quot; };<br>
The relative order of elements with the same sorting key (in this case, Jay/Tom and<br>Mary/Dick) is indeterminate--unless you append a ThenBy operator:<br>
IEnumerable&lt;string&gt; query = names.OrderBy (s =&gt; s.Length)<b>.ThenBy (s =&gt; s)</b>;<br>
// Result: { &quot;Jay&quot;, &quot;Tom&quot;, &quot;Dick&quot;, &quot;Mary&quot;, &quot;Harry&quot; };<br>
ThenBy reorders only elements that had the same sorting key in the preceding sort.<br>You can chain any number of ThenBy operators. The following sorts first by length,<br>then by the second character, and finally by the first character:<br>
names.OrderBy (s =&gt; s.Length).ThenBy (s =&gt; s[1]).ThenBy (s =&gt; s[0]);<br>
The equivalent in query syntax is this:<br>
from s in names<br><b>orderby s.Length, s[1], s[0]</b><br>
<b>LINQ Operators</b><br>
select s;<br>
<b>Ordering | 395</b><br>
<hr>
<A name=416></a>LINQ also provides OrderByDescending and ThenByDescending operators, which do<br>the same things, emitting the results in reverse order. The following LINQ-to-db<br>query retrieves purchases in descending order of price, with those of the same price<br>listed alphabetically:<br>
dataContext.Purchases.OrderByDescending (p =&gt; p.Price)<br>                     .ThenBy (p =&gt; p.Description);<br>
In query syntax:<br>
from p in dataContext.Purchases<br><b>orderby p.Price descending, p.Description</b><br>
select p;<br>
<b>Comparers and collations<br></b>In a local query, the key selector objects themselves determine the ordering algorithm<br>via their default IComparable implementation (see Chapter 7). You can override the<br>sorting algorithm by passing in an IComparer object. The following performs a case-<br>insensitive sort:<br>
names.OrderBy (n =&gt; n, StringComparer.CurrentCultureIgnoreCase);<br>
Passing in a comparer is not supported in query syntax, nor in any way by LINQ to<br>SQL or EF. When querying a database, the comparison algorithm is determined by<br>the participating column's collation. If the collation is case-sensitive, you can request<br>a case-insensitive sort by calling ToUpper in the key selector:<br>
from p in dataContext.Purchases<br>
<b>orderby p.Description.ToUpper()<br></b>select p;<br>
<b>IOrderedEnumerable and IOrderedQueryable<br></b>The ordering operators return special subtypes of IEnumerable&lt;T&gt;. Those in Enumera<br>ble return IOrderedEnumerable; those in Queryable return IOrderedQueryable. These<br>subtypes allow a subsequent ThenBy operator to refine rather than replace the existing<br>ordering.<br>
The additional members that these subtypes define are not publicly exposed, so they<br>present like ordinary sequences. The fact that they are different types comes into<br>play when building queries progressively:<br>
IOrderedEnumerable&lt;string&gt; query1 = names.OrderBy (s =&gt; s.Length);<br>IOrderedEnumerable&lt;string&gt; query2 = query1.ThenBy (s =&gt; s);<br>
If we instead declare query1 of type IEnumerable&lt;string&gt;, the second line would not<br>compile--ThenBy requires an input of type IOrderedEnumerable&lt;string&gt;. You can<br>avoid worrying about this by implicitly typing query variables:<br>
var query1 = names.OrderBy (s =&gt; s.Length);<br>var query2 = query1.ThenBy (s =&gt; s);<br>
Implicit  typing  can  create  problems  of  its  own,  though.  The  following  will  not<br>compile:<br>
<b>396 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=417></a>var query = names.OrderBy (s =&gt; s.Length);<br>
query = query.Where (n =&gt; n.Length &gt; 3);       // Compile-time error<br>
The  compiler  infers  query  to  be  of  type  IOrderedEnumerable&lt;string&gt;,  based  on<br>OrderBy's  output  sequence  type.  However,  the  Where  on  the  next  line  returns  an<br>ordinary IEnumerable&lt;string&gt;, which cannot be assigned back to query. You can<br>work  around  this  either  with  explicit  typing  or  by  calling  AsEnumerable()  after<br>OrderBy:<br>
var query = names.OrderBy (s =&gt; s.Length)<b>.AsEnumerable()</b>;<br>query = query.Where (n =&gt; n.Length &gt; 3);                   // OK<br>
The equivalent in interpreted queries is to call AsQueryable.<br>
<b>Grouping<br></b>IEnumerable&lt;TSource&gt;IEnumerable&lt;IGrouping&lt;TSource,TElement&gt;&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
GroupBy<br>
Groups a sequence into subsequences<br>
GROUP BY<br>
<b>GroupBy</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Input sequence<br>
IEnumerable&lt;TSource&gt;<br>
Key selector<br>
TSource =&gt; TKey<br>
Element selector (optional)<br>
TSource =&gt; TElement<br>
Comparer (optional)<br>
IEqualityComparer&lt;TKey&gt;<br>
<b>Query syntax</b><br>
group <i>element-expression</i> by <i>key-expression</i><br>
<b>Overview<br></b>GroupBy organizes a flat input sequence into sequences of <i>groups</i>. For example, the<br>following organizes all the files in <i>c:\temp</i> by extension:<br>
string[] files = Directory.GetFiles (&quot;c:\\temp&quot;);<br>
IEnumerable&lt;IGrouping&lt;string,string&gt;&gt; query =<br>  files.GroupBy (file =&gt; Path.GetExtension (file));<br>
Or if you're comfortable with implicit typing:<br>
var query = files.GroupBy (file =&gt; Path.GetExtension (file));<br>
Here's how to enumerate the result:<br>
<b>LINQ Operators</b><br>
<b>Grouping | 397</b><br>
<hr>
<A name=418></a>foreach (IGrouping&lt;string,string&gt; grouping in query)<br>
{<br>  Console.WriteLine (&quot;Extension: &quot; + <b>grouping.Key</b>);<br>  foreach (string filename in <b>grouping</b>)<br>
    Console.WriteLine (&quot;   - &quot; + filename);<br>
}<br>
Extension: .pdf<br>
  -- chapter03.pdf<br>
  -- chapter04.pdf<br>Extension: .doc<br>  -- todo.doc<br>
  -- menu.doc<br>
  -- Copy of menu.doc<br>...<br>
Enumerable.GroupBy works by reading the input elements into a temporary dictionary<br>of lists so that all elements with the same key end up in the same sublist. It then<br>emits a sequence of <i>groupings</i>. A grouping is a sequence with a Key property:<br>
public interface IGrouping &lt;TKey,TElement&gt; : IEnumerable&lt;TElement&gt;,<br>
                                             IEnumerable<br>{<br>  TKey Key { get; }    // Key applies to the subsequence as a whole<br>
}<br>
By default, the elements in each grouping are untransformed input elements, unless<br>you specify an elementSelector argument. The following projects each input element<br>to uppercase:<br>
files.GroupBy (file =&gt; Path.GetExtension (file), file =&gt; file.ToUpper());<br>
An elementSelector is independent of the keySelector. In our case, this means that<br>the Key on each grouping is still in its original case:<br>
<b>Extension: .pdf<br></b>  -- CHAPTER03.PDF<br>  -- CHAPTER04.PDF<br><b>Extension: .doc<br></b>  -- TODO.DOC<br>
Note that the subcollections are not emitted in alphabetical order of key. GroupBy<br>groups only; it does not <i>sort</i>; in fact, it preserves the original ordering. To sort, you<br>must add an OrderBy operator:<br>
files.GroupBy (file =&gt; Path.GetExtension (file), file =&gt; file.ToUpper())<br>     .OrderBy (grouping =&gt; grouping.Key);<br>
GroupBy has a simple and direct translation in query syntax:<br>
group <i>element-expr</i> by <i>key-expr</i><br>
Here's our example in query syntax:<br>
from file in files<br><b>group file.ToUpper() by Path.GetExtension (file);</b><br>
As with select, group "ends" a query--unless you add a query continuation clause:<br>
<b>398 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=419></a>from file in files<br>
group file.ToUpper() by Path.GetExtension (file) <b>into grouping<br></b>orderby grouping.Key<br>select grouping;<br>
Query continuations are often useful in a group by query. The next query filters out<br>groups that have fewer than five files in them:<br>
from file in files<br>
group file.ToUpper() by Path.GetExtension (file) into grouping<br><b>where grouping.Count() &lt; 5</b><br>
select grouping;<br>
A where after a group by is equivalent to HAVING in SQL. It applies<br>to each subsequence or grouping as a whole, rather than the<br>individual elements.<br>
Sometimes you're interested purely in the result of an aggregation on a grouping and<br>so can abandon the subsequences:<br>
string[] votes = { &quot;Bush&quot;, &quot;Gore&quot;, &quot;Gore&quot;, &quot;Bush&quot;, &quot;Bush&quot; };<br>
IEnumerable&lt;string&gt; query = from vote in votes<br>
                            group vote by vote into g<br>
                            <b>orderby g.Count() descending<br></b>                            <b>select g.Key;</b><br>
string winner = query.First();    // Bush<br>
<b>GroupBy in LINQ to SQL and EF<br></b>Grouping works in the same way when querying a database. If you have association<br>properties set up, you'll find, however, that the need to group arises less frequently<br>than with standard SQL. For instance, to select customers with at least two pur-<br>chases, you don't need to group; the following query does the job nicely:<br>
from c in dataContext.Customers<br><b>where c.Purchases.Count &gt;= 2</b><br>
select c.Name + &quot; has made &quot; + c.Purchases.Count + &quot; purchases&quot;;<br>
An example of when you might use grouping is to list total sales by year:<br>
from p in dataContext.Purchases<br>group p.Price by p.Date.Year into salesByYear<br>select new {<br>             Year       = salesByYear.Key,<br>             TotalValue = salesByYear.Sum()<br>           };<br>
LINQ's grouping operators expose a superset of SQL's "GROUP BY" functionality.<br>
Another  departure  from  traditional  SQL  comes  in  there  being  no  obligation  to<br>project the variables or expressions used in grouping or sorting.<br>
<b>LINQ Operators</b><br>
<b>Grouping | 399</b><br>
<hr>
<A name=420></a><b>Grouping by multiple keys<br></b>You can group by a composite key, using an anonymous type:<br>
from n in names<br>group n by new { FirstLetter = n[0], Length = n.Length };<br>
<b>Custom equality comparers<br></b>You can pass a custom equality comparer into GroupBy, in a local query, to change<br>the algorithm for key comparison. Rarely is this required, though, because changing<br>the key selector expression is usually sufficient. For instance, the following creates<br>a case-insensitive grouping:<br>
group name by name<i>.ToUpper()</i><br>
<b>Set Operators<br></b>IEnumerable&lt;TSource&gt;, IEnumerable&lt;TSource&gt;IEnumerable&lt;TSource&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Concat<br>
Returns a concatenation of elements in each of the two sequences<br>
UNION ALL<br>
Union<br>
Returns a concatenation of elements in each of the two sequences,<br>
UNION<br>
excluding duplicates<br>
Intersect<br>
Returns elements present in both sequences<br>
WHERE ... IN (...)<br>
Except<br>
Returns elements present in the first, but not the second sequence<br>
EXCEPT<br>
or<br>
WHERE ... NOT IN (...)<br>
<b>Concat and Union<br></b>Contact returns all the elements of the first sequence, followed by all the elements<br>of the second. Union does the same, but removes any duplicates:<br>
int[] seq1 = { 1, 2, 3 }, seq2 = { 3, 4, 5 };<br>
IEnumerable&lt;int&gt;<br>  concat = seq1.Concat (seq2),    //  { 1, 2, 3, 3, 4, 5 }<br>  union  = seq1.Union  (seq2);    //  { 1, 2, 3, 4, 5 }<br>
Specifying the type argument explicitly is useful when the sequences are differently<br>typed, but the elements have a common base type. For instance, with the reflection<br>API  (Chapter  18),  methods  and  properties  are  represented  with  MethodInfo  and<br>PropertyInfo classes, which have a common base class called MemberInfo. We can<br>concatenate methods and properties by stating that base class explicitly when calling<br>Concat:<br>
MethodInfo[] methods = typeof (string).GetMethods();<br>PropertyInfo[] props = typeof (string).GetProperties();<br>IEnumerable&lt;MemberInfo&gt; both = methods.Concat&lt;<b>MemberInfo</b>&gt; (props);<br>
<b>400 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=421></a>In the next example, we filter the methods before concatenating:<br>
var methods = typeof (string).GetMethods().Where (m =&gt; !m.IsSpecialName);<br>
var props = typeof (string).GetProperties();<br>
var both = methods.Concat&lt;MemberInfo&gt; (props);<br>
Interestingly, this example compiles in C# 4.0 but not in C# 3.0 because it relies<br>on interface type parameter variance: methods is of type IEnumerable&lt;MethodInfo&gt;,<br>which requires a covariant conversion to IEnumerable&lt;MemberInfo&gt;. It's a good il-<br>lustration of how variance makes things work more as you'd expect.<br>
<b>Intersect and Except<br></b>Intersect returns the elements that two sequences have in common. Except returns<br>the elements in the first input sequence that are <i>not</i> present in the second:<br>
int[] seq1 = { 1, 2, 3 }, seq2 = { 3, 4, 5 };<br>
IEnumerable&lt;int&gt;<br>
  commonality = seq1.Intersect (seq2),    //  { 3 }<br>
  difference1 = seq1.Except    (seq2),    //  { 1, 2 }<br>
  difference2 = seq2.Except    (seq1);    //  { 4, 5 }<br>
Enumerable.Except works internally by loading all of the elements in the first collec-<br>tion into a dictionary, then removing from the dictionary all elements present in the<br>second sequence. The equivalent in SQL is a NOT EXISTS or NOT IN subquery:<br>
SELECT number FROM numbers1Table<br>WHERE number NOT IN (SELECT number FROM numbers2Table)<br>
<b>The Zip Operator<br></b>IEnumerable&lt;TFirst&gt;, IEnumerable&lt;TSecond&gt;IEnumerable&lt;TResult&gt;<br>
The Zip operator was added in Framework 4.0. It enumerates two sequences in step<br>(like a zipper), returning a sequence based on applying a function over each element<br>pair. For instance, the following:<br>
int[] numbers = { 3, 5, 7 };<br>string[] words = { &quot;three&quot;, &quot;five&quot;, &quot;seven&quot;, &quot;ignored&quot; };<br>IEnumerable&lt;string&gt; zip = numbers.<b>Zip (words, (n, w) =&gt; n + &quot;=&quot; + w)</b>;<br>
produces a sequence with the following elements:<br>
3=three<br>5=five<br>7=seven<br>
Extraneous elements in either input sequence are ignored. Zip is not supported when<br>querying a database.<br>
<b>LINQ Operators</b><br>
<b>The Zip Operator | 401</b><br>
<hr>
<A name=422></a><b>Conversion Methods<br></b>LINQ deals primarily in sequences--collections of type IEnumerable&lt;T&gt;, in other<br>words. The conversion methods convert to and from other types of collections:<br>
<b>Method</b><br>
<b>Description</b><br>
OfType<br>
Converts IEnumerable to IEnumerable&lt;T&gt;, discarding wrongly typed elements<br>
Cast<br>
Converts IEnumerable to IEnumerable&lt;T&gt;, throwing an exception if there are any wrongly<br>
typed elements<br>
ToArray<br>
Converts IEnumerable&lt;T&gt; to T[]<br>
ToList<br>
Converts IEnumerable&lt;T&gt; to List&lt;T&gt;<br>
ToDictionary<br>
Converts IEnumerable&lt;T&gt; to Dictionary&lt;TKey,TValue&gt;<br>
ToLookup<br>
Converts IEnumerable&lt;T&gt; to ILookup&lt;TKey,TElement&gt;<br>
AsEnumerable<br>
Downcasts to IEnumerable&lt;T&gt;<br>
AsQueryable<br>
Casts or converts to IQueryable&lt;T&gt;<br>
<b>OfType and Cast<br></b>OfType  and  Cast  accept  a  nongeneric  IEnumerable  collection  and  emit  a  generic<br>IEnumerable&lt;T&gt; sequence that you can subsequently query:<br>
ArrayList classicList = new ArrayList();          // in System.Collections<br>
classicList.AddRange ( new int[] { 3, 4, 5 } );<br>
<b>IEnumerable&lt;int&gt; sequence1 = classicList.Cast&lt;int&gt;();</b><br>
Cast and OfType differ in their behavior when encountering an input element that's<br>of an incompatible type. Cast throws an exception; OfType ignores the incompatible<br>element. Continuing the preceding example:<br>
DateTime offender = DateTime.Now;<br>
classicList.Add (offender);<br>IEnumerable&lt;int&gt;<br>
  sequence2 = classicList.<b>OfType</b>&lt;int&gt;(), // OK - ignores offending DateTime<br>  sequence3 = classicList.<b>Cast</b>&lt;int&gt;();   // Throws exception<br>
The rules for element compatibility exactly follow those of C#'s is operator, and<br>therefore consider only reference conversions and unboxing conversions. We can<br>see this by examining the internal implementation of OfType:<br>
public static IEnumerable&lt;TSource&gt; OfType &lt;TSource&gt; (IEnumerable source)<br>{<br>  foreach (object element in source)<br>    <b>if (element is TSource)<br></b>      yield return (TSource)element;<br>}<br>
Cast has an identical implementation, except that it omits the type compatibility test:<br>
<b>402 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=423></a>public static IEnumerable&lt;TSource&gt; Cast &lt;TSource&gt; (IEnumerable source)<br>
{<br>  foreach (object element in source)<br>    yield return (TSource)element;<br>
}<br>
A consequence of these implementations is that you cannot use Cast to perform<br>numeric or custom conversions (for these, you must perform a Select operation<br>instead). In other words, Cast is not as flexible as C#'s cast operator:<br>
int i = 3;<br>
<b>long l = i</b>;         // Implicit <i>numeric conversion</i> int-&gt;long<br>
<b>int i2 = (int) l</b>;   // Explicit <i>numeric conversion</i> long-&gt;int<br>
We can demonstrate this by attempting to use OfType or Cast to convert a sequence<br>of ints to a sequence of longs:<br>
int[] integers = { 1, 2, 3 };<br>
IEnumerable&lt;long&gt; test1 = integers.OfType&lt;long&gt;();<br>
IEnumerable&lt;long&gt; test2 = integers.Cast&lt;long&gt;();<br>
When enumerated, test1 emits zero elements and test2 throws an exception. Ex-<br>amining OfType's implementation, it's fairly clear why. After substituting TSource,<br>we get the following expression:<br>
(element is long)<br>
which returns false for an int element, due to the lack of an inheritance relationship.<br>
The reason for test2 throwing an exception, when enumerated,<br>is subtler. Notice in Cast's implementation that element is of<br>type object. When TSource is a value type, the CLR assumes this<br>is an <i>unboxing conversion</i>, and synthesizes a method that re-<br>produces the scenario described in the section "Boxing and Un-<br>boxing" on page 86 in Chapter 3:<br>
int value = 123;<br>object element = value;<br>long result = <b>(long) element</b>;  // exception<br>
Because  the  element  variable  is  declared  of  type  object,  an<br>object-to-long cast is performed (an unboxing) rather than an<br>int-to-long numeric conversion. Unboxing operations require<br>an exact type match, so the object-to-long unbox fails when<br>given an int.<br>
As we suggested previously, the solution is to use an ordinary Select:<br>
IEnumerable&lt;long&gt; castLong = integers.Select (s =&gt; (long) s);<br>
OfType and Cast are also useful in downcasting elements in a generic input sequence.<br>For  instance,  if  you  have  an  input  sequence  of  type  IEnumerable&lt;Fruit&gt;,<br>OfType&lt;Apple&gt; would return just the apples. This is particularly useful in LINQ to<br>
<b>LINQ Operators</b><br>
XML (see Chapter 10).<br>
<b>Conversion Methods | 403</b><br>
<hr>
<A name=424></a>Cast has query syntax support: simply precede the range variable with a type:<br>
from <b>TreeNode</b> node in myTreeView.Nodes<br>
...<br>
<b>ToArray, ToList, ToDictionary, and ToLookup<br></b>ToArray and ToList emit the results into an array or generic list. These operators<br>force the immediate enumeration of the input sequence (unless indirected via a sub-<br>query  or  expression  tree).  For  examples,  refer  to  the  section  "Deferred  Execu-<br>tion" on page 324 in Chapter 8.<br>
ToDictionary and ToLookup accept the following arguments:<br>
<b>Argument</b><br>
<b>Type</b><br>
Input sequence<br>
IEnumerable&lt;TSource&gt;<br>
Key selector<br>
TSource =&gt; TKey<br>
Element selector (optional)<br>
TSource =&gt; TElement<br>
Comparer (optional)<br>
IEqualityComparer&lt;TKey&gt;<br>
ToDictionary also forces immediate execution of a sequence, writing the results to<br>a generic Dictionary. The keySelector expression you provide must evaluate to a<br>unique value for each element in the input sequence; otherwise, an exception is<br>thrown. In contrast, ToLookup allows many elements of the same key. We describe<br>lookups in the earlier section "Joining with lookups" on page 392.<br>
<b>AsEnumerable and AsQueryable<br></b>AsEnumerable upcasts a sequence to IEnumerable&lt;T&gt;, forcing the compiler to bind<br>subsequent query operators to methods in Enumerable, instead of Queryable. For an<br>example, see the section "Combining Interpreted and Local Queries" on page 343<br>in Chapter 8.<br>
AsQueryable downcasts a sequence to IQueryable&lt;T&gt; if it implements that interface.<br>Otherwise, it instantiates an IQueryable&lt;T&gt; wrapper over the local query.<br>
<b>Element Operators<br></b>IEnumerable&lt;TSource&gt;TSource<br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
First, FirstOrDefault<br>
Returns the first element in<br>
SELECT TOP 1 ... ORDER BY ...<br>
the sequence, optionally sat-<br>isfying a predicate<br>
Last,<br>
Returns the last element in<br>
SELECT TOP 1 ... ORDER BY ... DESC<br>
the sequence, optionally sat-<br>
LastOrDefault<br>
isfying a predicate<br>
<b>404 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=425></a><b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Single, SingleOrDefault<br>
Equivalent to First/<br>
 <br>
FirstOrDefault, but<br>
throws an exception if there<br>is more than one match<br>
ElementAt, ElementAtOrDefault<br>
Returns the element at the<br>
Exception thrown<br>
specified position<br>
DefaultIfEmpty<br>
Returns null or<br>
OUTER JOIN<br>
default(TSource) if<br>
the sequence has no<br>elements<br>
Methods ending in "OrDefault" return default(TSource) rather than throwing an<br>exception  if  the  input  sequence  is  empty  or  if  no  elements  match  the  supplied<br>predicate.<br>
default(TSource)is null for reference type elements, or "blank" (usually zero) for<br>value type elements.<br>
<b>First, Last, and Single</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Predicate (optional)<br>
TSource =&gt; bool<br>
The following example demonstrates First and Last:<br>
int[] numbers  = { 1, 2, 3, 4, 5 };<br>int first      = numbers.First();                      // 1<br>int last       = numbers.Last();                       // 5<br>int firstEven  = numbers.First  (n =&gt; n % 2 == 0);     // 2<br>int lastEven   = numbers.Last   (n =&gt; n % 2 == 0);     // 4<br>
The following demonstrates First versus FirstOrDefault:<br>
int firstBigError  = numbers.First          (n =&gt; n &gt; 10);   // Exception<br>int firstBigNumber = numbers.FirstOrDefault (n =&gt; n &gt; 10);   // 0<br>
To  avoid  an  exception,  Single  requires  exactly  one  matching  element;<br>SingleOrDefault requires one <i>or zero</i> matching elements:<br>
int onlyDivBy3 = numbers.Single (n =&gt; n % 3 == 0);   // 3<br>int divBy2Err  = numbers.Single (n =&gt; n % 2 == 0);   // Error: 2 &amp; 4 match<br>
int singleError = numbers.Single          (n =&gt; n &gt; 10);      // Error<br>int noMatches   = numbers.SingleOrDefault (n =&gt; n &gt; 10);      // 0<br>int divBy2Error = numbers.SingleOrDefault (n =&gt; n % 2 == 0);  // Error<br>
Single  is  the  "fussiest"  in  this  family  of  element  operators.  FirstOrDefault  and<br>LastOrDefault are the most tolerant.<br>
<b>LINQ Operators</b><br>
<b>Element Operators | 405</b><br>
<hr>
<A name=426></a>In LINQ to SQL and EF, Single is often used to retrieve a row from a table by primary<br>key:<br>
Customer cust = dataContext.Customers.Single (c =&gt; c.ID == 3);<br>
<b>ElementAt</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Index of element to return<br>
int<br>
ElementAt picks the <i>n</i>th element from the sequence:<br>
int[] numbers  = { 1, 2, 3, 4, 5 };<br>
int third      = numbers.ElementAt (2);            // 3<br>
int tenthError = numbers.ElementAt (9);            // Exception<br>int tenth      = numbers.ElementAtOrDefault (9);   // 0<br>
Enumerable.ElementAt is written such that if the input sequence happens to imple-<br>ment IList&lt;T&gt;, it calls IList&lt;T&gt;'s indexer. Otherwise, it enumerates <i>n</i> times, and<br>then returns the next element. ElementAt is not supported in LINQ to SQL or EF.<br>
<b>DefaultIfEmpty<br></b>DefaultIfEmpty converts empty sequences to null/default(). This is used in writing<br>flat outer joins: see the earlier sections "Outer joins with SelectMany" on page 385<br>and "Flat outer joins" on page 392.<br>
<b>Aggregation Methods<br></b>IEnumerable&lt;TSource&gt; <i>scalar</i><br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Count, LongCount<br>
Returns the number of elements in the input sequence,<br>
COUNT (...)<br>
optionally satisfying a predicate<br>
Min, Max<br>
Returns the smallest or largest element in the sequence<br>
MIN (...), MAX (...)<br>
Sum, Average<br>
Calculates a numeric sum or average over elements in the<br>
SUM (...), AVG (...)<br>
sequence<br>
Aggregate<br>
Performs a custom aggregation<br>
Exception thrown<br>
<b>Count and LongCount</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Predicate (optional)<br>
TSource =&gt; bool<br>
<b>406 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=427></a>Count simply enumerates over a sequence, returning the number of items:<br>
int fullCount = new int[] { 5, 6, 7 }.Count();    // 3<br>
The internal implementation of Enumerable.Count tests the input sequence to see<br>whether it happens to implement ICollection&lt;T&gt;. If it does, it simply calls ICollec<br>tion&lt;T&gt;.Count. Otherwise, it enumerates over every item, incrementing a counter.<br>
You can optionally supply a predicate:<br>
int digitCount = &quot;pa55w0rd&quot;.Count (c =&gt; char.IsDigit (c));   // 3<br>
LongCount does the same job as Count, but returns a 64-bit integer, allowing for se-<br>quences of greater than 2 billion elements.<br>
<b>Min and Max</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
Result selector (optional)<br>
TSource =&gt; TResult<br>
Min and Max return the smallest or largest element from a sequence:<br>
int[] numbers = { 28, 32, 14 };<br>
int smallest = numbers.Min();  // 14;<br>int largest  = numbers.Max();  // 32;<br>
If you include a selector expression, each element is first projected:<br>
int smallest = numbers.Max (n =&gt; n % 10);  // 8;<br>
A  selector  expression  is  mandatory  if  the  items  themselves  are  not  intrinsically<br>comparable--in other words, if they do not implement IComparable&lt;T&gt;:<br>
Purchase runtimeError = dataContext.Purchases.Min ();             // Error<br>decimal? lowestPrice = dataContext.Purchases.Min (p =&gt; p.Price);  // OK<br>
A selector expression determines not only how elements are compared, but also<br>the final result. In the preceding example, the final result is a decimal value, not a<br>purchase object. To get the cheapest purchase, you need a subquery:<br>
Purchase cheapest = dataContext.Purchases<br>  .Where (p =&gt; p.Price == dataContext.Purchases.Min (p2 =&gt; p2.Price))<br>  .FirstOrDefault();<br>
In this case, you could also formulate the query without an aggregation--using an<br>OrderBy followed by FirstOrDefault.<br>
<b>Sum and Average</b><br>
<b>Argument</b><br>
<b>Type</b><br>
Source sequence<br>
IEnumerable&lt;TSource&gt;<br>
<b>LINQ Operators</b><br>
Result selector (optional)<br>
TSource =&gt; TResult<br>
<b>Aggregation Methods | 407</b><br>
<hr>
<A name=428></a>Sum and Average are aggregation operators that are used in a similar manner to Min<br>and Max:<br>
decimal[] numbers  = { 3, 4, 8 };<br>decimal sumTotal   = numbers.Sum();               // 15<br>
decimal average    = numbers.Average();           // 5   (mean value)<br>
The following returns the total length of each of the strings in the names array:<br>
int combinedLength = names.Sum (s =&gt; s.Length);   // 19<br>
Sum and Average are fairly restrictive in their typing. Their definitions are hard-wired<br>to each of the numeric types (int, long, float, double, decimal, and their nullable<br>versions). In contrast, Min and Max can operate directly on anything that implements<br>IComparable&lt;T&gt;--such as a string, for instance.<br>
Further, Average always returns either decimal or double, according to the following<br>table:<br>
<b>Selector type</b><br>
<b>Result type</b><br>
decimal<br>
decimal<br>
int, long, float, double<br>
double<br>
This means the following does not compile ("cannot convert double to int"):<br>
int avg = new int[] { 3, 4 }.Average();<br>
But this will compile:<br>
double avg = new int[] { 3, 4 }.Average();   // 3.5<br>
Average implicitly upscales the input values to avoid loss of precision. In this exam-<br>ple, we averaged integers and got 3.5, without needing to resort to an input element<br>cast:<br>
double avg = numbers.Average (n =&gt; (double) n);<br>
When querying a database, Sum and Average translate to the standard SQL aggrega-<br>tions. The following query returns customers whose average purchase was more<br>than $500:<br>
from c in dataContext.Customers<br>where c.Purchases.Average (p =&gt; p.Price) &gt; 500<br>select c.Name;<br>
<b>Aggregate<br></b>Aggregate allows you to specify a custom accumulation algorithm for implementing<br>unusual aggregations. Aggregate is not supported in LINQ to SQL or Entity Frame-<br>work, and is somewhat specialized in its use cases. The following demonstrates how<br>Aggregate can do the work of Sum:<br>
int[] numbers = { 2, 3, 4 };<br>int sum = numbers.Aggregate (0, (total, n) =&gt; total + n);   // 9<br>
<b>408 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=429></a>The first argument to Aggregate is the <i>seed</i>, from which accumulation starts. The<br>second argument is an expression to update the accumulated value, given a fresh<br>element. You can optionally supply a third argument to project the final result value<br>from the accumulated value.<br>
Most problems for which Aggregate has been designed can be<br>solved as easily with a foreach loop--and with more familiar<br>syntax. The advantage of using Aggregate is that with large or<br>complex aggregations, you can automatically parallelize the op-<br>eration with PLINQ (see Chapter 22).<br>
<b>Unseeded aggregations<br></b>You can omit the seed value when calling Aggregate, in which case the first element<br>becomes  the  <i>implicit</i>  seed,  and  aggregation  proceeds  from  the  second  element.<br>Here's the preceding example, <i>unseeded</i>:<br>
int[] numbers = { 1, 2, 3 };<br>int sum = numbers.Aggregate ((total, n) =&gt; total + n);   // 6<br>
This gives the same result as before, but we're actually doing a <i>different calcula-<br>tion</i>. Before, we were calculating 0+1+2+3; now we're calculating 1+2+3. We can<br>better illustrate the difference by multiplying instead of adding:<br>
int[] numbers = { 1, 2, 3 };<br>
 int x = numbers.Aggregate (0, (prod, n) =&gt; prod * n);   // 0*1*2*3 = <b>0</b><br>
 int y = numbers.Aggregate (   (prod, n) =&gt; prod * n);   //   1*2*3 = <b>6</b><br>
As we'll see in Chapter 22, unseeded aggregations have the advantage of being par-<br>allelizable without requiring the use of special overloads. However, there are some<br>traps with unseeded aggregations.<br>
<b>Traps with unseeded aggregations<br></b>The  unseeded  aggregation  methods  are  intended  for  use  with  delegates  that  are<br><i>commutative</i> and <i>associative</i>. If used otherwise, the result is either <i>unintuitive</i> (with<br>ordinary queries) or <i>nondeterministic</i> (in the case that you parallelize the query with<br>PLINQ). For example, consider the following function:<br>
(total, n) =&gt; total + n * n<br>
This is neither commutative nor associative. (For example, 1+2*2 != 2+1*1). Let's<br>see what happens when we use it to sum the square of the numbers 2, 3, and 4:<br>
int[] numbers = { 2, 3, 4 };<br>int sum = numbers.Aggregate ((total, n) =&gt; total + n * n);    // 27<br>
Instead of calculating:<br>
2*2 + 3*3 + 4*4    // 29<br>
it calculates:<br>
<b>LINQ Operators</b><br>
2 + 3*3 + 4*4      // 27<br>
<b>Aggregation Methods | 409</b><br>
<hr>
<A name=430></a>We can fix this in a number of ways. First, we could include 0 as the first element:<br>
int[] numbers = { <b>0,</b> 2, 3, 4 };<br>
Not only is this inelegant, but it will still give incorrect results if parallelized--be-<br>cause PLINQ leverages the function's assumed associativity by selecting <i>multiple<br></i>elements as seeds. To illustrate, if we denote our aggregation function as follows:<br>
f(total, n) =&gt; total + n * n<br>
then LINQ to Objects would calculate this:<br>
f(f(f(0, 2),3),4)<br>
whereas PLINQ may do this:<br>
f(f(0,2),f(3,4))<br>
with the following result:<br>
First partition:   a = 0 + 2*2  (= 4)<br>
Second partition:  b = 3 + 4*4  (= 19)<br>Final result:          a + b*b  (= 365!)<br>
OR EVEN:               b + a*a  (= 35!)<br>
There are two good solutions. The first is to turn this into a seeded aggregation--<br>with zero as the seed. The only complication is that with PLINQ, we'd need to use<br>a special overload in order for the query not to execute sequentially (see "Optimizing<br>PLINQ" on page 886 in Chapter 22).<br>
The second solution is to restructure the query such that the aggregation function<br>is commutative and associative:<br>
int sum = numbers.Select (n =&gt; n * n).Aggregate ((total, n) =&gt; <b>total + n</b>);<br>
Of course, in such simple scenarios you can (and should) use<br>the Sum operator instead of Aggregate:<br>
int sum = numbers.Sum (n =&gt; n * n);<br>
You  can  actually  go  quite  far  just  with  Sum  and  Average.  For<br>instance, you can use Average to calculate a root-mean-square:<br>
Math.Sqrt (numbers.Average (n =&gt; n * n))<br>
and even standard deviation:<br>
double mean = numbers.Average();<br>double sdev = Math.Sqrt (numbers.Average (n =&gt;<br>              {<br>
                double dif = n - mean;<br>                return dif * dif;<br>              }));<br>
Both are safe, efficient and fully parallelizable. In Chapter 22,<br>we'll give a practical example of a custom aggregation that can't<br>be reduced to Sum or Average.<br>
<b>410 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=431></a><b>Quantifiers<br></b>IEnumerable&lt;TSource&gt;<i>bool</i><br>
<b>Method</b><br>
<b>Description</b><br>
<b>SQL equivalents</b><br>
Contains<br>
Returns true if the input sequence contains the given element<br>
WHERE ... IN (...)<br>
Any<br>
Returns true if any elements satisfy the given predicate<br>
WHERE ... IN (...)<br>
All<br>
Returns true if all elements satisfy the given predicate<br>
WHERE (...)<br>
SequenceEqual<br>
Returns true if the second sequence has identical elements to the input<br>
 <br>
sequence<br>
<b>Contains and Any<br></b>The Contains method accepts an argument of type TSource; Any accepts an optional<br><i>predicate</i>.<br>
Contains returns true if the given element is present:<br>
bool hasAThree = new int[] { 2, 3, 4 }.Contains (3);       // true;<br>
Any returns true if the given expression is true for at least one element. We can rewrite<br>the preceding query with Any as follows:<br>
bool hasAThree = new int[] { 2, 3, 4 }.Any (n =&gt; n == 3);  // true;<br>
Any can do everything that Contains can do, and more:<br>
bool hasABigNumber = new int[] { 2, 3, 4 }.Any (n =&gt; n &gt; 10);  // false;<br>
Calling Any without a predicate returns true if the sequence has one or more ele-<br>ments. Here's another way to write the preceding query:<br>
 bool hasABigNumber = new int[] { 2, 3, 4 }.Where (n =&gt; n &gt; 10).Any();<br>
Any is particularly useful in subqueries and is used often when querying databases,<br>for example:<br>
from c in dataContext.Customers<br>where c.Purchases.Any (p =&gt; p.Price &gt; 1000)<br>select c<br>
<b>All and SequenceEqual<br></b>All returns true if all elements satisfy a predicate. The following returns customers<br>whose purchases are less than $100:<br>
dataContext.Customers.Where (c =&gt; c.Purchases.All (p =&gt; p.Price &lt; 100));<br>
SequenceEqual compares two sequences. To return true, each sequence must have<br>identical elements, in the identical order.<br>
<b>LINQ Operators</b><br>
<b>Quantifiers | 411</b><br>
<hr>
<A name=432></a><b>Generation Methods<br></b>voidIEnumerable&lt;TResult&gt;<br>
<b>Method</b><br>
<b>Description</b><br>
Empty<br>
Creates an empty sequence<br>
Repeat<br>
Creates a sequence of repeating elements<br>
Range<br>
Creates a sequence of integers<br>
Empty, Repeat, and Range are static (nonextension) methods that manufacture simple<br>local sequences.<br>
<b>Empty<br></b>Empty manufactures an empty sequence and requires just a type argument:<br>
foreach (string s in Enumerable.Empty&lt;string&gt;())<br>  Console.Write (s);                              // &lt;nothing&gt;<br>
In conjunction with the ?? operator, Empty does the reverse of DefaultIfEmpty. For<br>example, suppose we have a jagged array of integers, and we want to get all the<br>integers into a single flat list. The following SelectMany query fails if any of the inner<br>arrays is null:<br>
int[][] numbers =<br>
{<br>  new int[] { 1, 2, 3 },<br>  new int[] { 4, 5, 6 },<br>  null                     // this null makes the query below fail.<br>};<br>
IEnumerable&lt;int&gt; flat = numbers.SelectMany (innerArray =&gt; innerArray);<br>
Empty in conjunction with ?? fixes the problem:<br>
IEnumerable&lt;int&gt; flat = numbers<br>  .SelectMany (innerArray =&gt; <b>innerArray ?? Enumerable.Empty &lt;int&gt;()</b>);<br>
foreach (int i in flat)<br>  Console.Write (i + &quot; &quot;);     // 1 2 3 4 5 6<br>
<b>Range and Repeat<br></b>Range and Repeat work only with integers. Range accepts a starting index and count:<br>
foreach (int i in Enumerable.Range (5, 5))<br>  Console.Write (i + &quot; &quot;);                    // 5 6 7 8 9<br>
Repeat accepts the number to repeat, and the number of iterations:<br>
foreach (int i in Enumerable.Repeat (5, 3))<br>  Console.Write (i + &quot; &quot;);                    // 5 5 5<br>
<b>412 | Chapter 9:</b><b>LINQ Operators</b><br>
<hr>
<A name=433></a><b>10</b><br>
<b>LINQ to XML</b><br>
The .NET Framework provides a number of APIs for working with XML data. From<br>Framework 3.5, the primary choice for general-purpose XML document processing<br>is <i>LINQ to XML</i>. LINQ to XML comprises a lightweight LINQ-friendly XML docu-<br>ment object model, and a set of supplementary query operators. In most scenarios,<br>it  can  be  considered  a  complete  replacement  for  the  preceding  W3C-compliant<br>DOM, a.k.a. XmlDocument.<br>In this chapter, we concentrate entirely on LINQ to XML. In the following chapter,<br>we  cover  the  more  specialized  XML  types  and  APIs,  including  the  forward-only<br>reader/writer, the types for working with schemas, stylesheets and XPaths, and the<br>legacy W3C-compliant DOM.<br>
The LINQ to XML DOM is extremely well designed and highly<br>performant. Even without LINQ, the LINQ to XML DOM is<br>valuable as a lightweight façade over the low-level XmlReader and<br>XmlWriter classes.<br>
All LINQ to XML types are defined in the System.Xml.Linq namespace.<br>
<b>Architectural Overview<br></b>This section starts with a very brief introduction to the concept of a DOM, and then<br>explains the rationale behind LINQ to XML's DOM.<br>
<b>413</b><br>
<hr>
<A name=434></a><b>What Is a DOM?<br></b>Consider the following XML file:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>
&lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>
  &lt;firstname&gt;Joe&lt;/firstname&gt;<br>  &lt;lastname&gt;Bloggs&lt;/lastname&gt;<br>&lt;/customer&gt;<br>
As with all XML files, we start with a <i>declaration</i>, and then a root <i>element</i>, whose<br>name is customer. It has two <i>attributes</i>, each with a name (id and status) and value<br>(&quot;123&quot; and &quot;archived&quot;). Within customer, there are two child elements, firstname<br>and lastname, each having simple text content (&quot;Joe&quot; and &quot;Bloggs&quot;).<br>Each of these constructs--declaration, element, attribute, value, and text content--<br>can be represented with a class. And if such classes have collection properties for<br>storing child content, we can assemble a <i>tree</i> of objects to fully describe a document.<br>This is called a <i>document object model</i>, or DOM.<br>
<b>The LINQ to XML DOM<br></b>LINQ to XML comprises two things:<br>
· An XML DOM, which we call the <i>X-DOM<br></i>· A set of about 10 supplementary query operators<br>
As you might expect, the X-DOM consists of types such as XDocument, XElement, and<br>XAttribute. Interestingly, the X-DOM types are not tied to LINQ--you can load,<br>instantiate, update, and save an X-DOM without ever writing a LINQ query.<br>
Conversely,  you  could  use  LINQ  to  query  a  DOM  created  of  the  older  W3C-<br>compliant types. However, this would be frustrating and limiting. The distinguish-<br>ing feature of the X-DOM is that it's <i>LINQ-friendly</i>. This means:<br>
· It has methods that emit useful IEnumerable sequences, upon which you can<br>
query.<br>
· Its constructors are designed such that you can build an X-DOM tree through<br>
a LINQ projection.<br>
<b>X-DOM Overview<br></b>Figure 10-1 shows the core X-DOM types. The most frequently used of these types is <br>XElement. XObject is the root of the <i>inheritance</i> hierarchy; XElement and XDocument<br>are roots of the <i>containership</i> hierarchy. Figure 10-2 shows the X-DOM tree created<br>from the following code:<br>
string xml = @&quot;&lt;customer id='123' status='archived'&gt;<br>                 &lt;firstname&gt;Joe&lt;/firstname&gt;<br>                 &lt;lastname&gt;Bloggs&lt;!--nice name--&gt;&lt;/lastname&gt;<br>               &lt;/customer&gt;&quot;;<br>
XElement customer = XElement.Parse (xml);<br>
<b>414 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=435></a><b>LINQ to XML</b><br>
<i>Figure 10-1. Core X-DOM types</i><br>
<i>Figure 10-2. A simple X-DOM tree</i><br>
XObject  is  the  abstract  base  class  for  all  XML  content.  It  defines  a  link  to  the<br>Parent element in the containership tree as well as an optional XDocument.<br>
XNode is the base class for most XML content excluding attributes. The distinguishing<br>feature of XNode is that it can sit in an ordered collection of mixed-type XNodes. For<br>instance, consider the following XML:<br>
<b>X-DOM Overview | 415</b><br>
<hr>
<A name=436></a>&lt;data&gt;<br>
  <b>Hello world<br></b>  <b>&lt;subelement1/&gt;<br></b>  <b>&lt;!--comment--&gt;</b><br>
  <b>&lt;subelement2/&gt;</b><br>
&lt;/data&gt;<br>
Within the parent element &lt;data&gt;, there's first an XText node (Hello world), then an<br>XElement node, then an XComment node, and then a second XElement node. In contrast,<br>an XAttribute will tolerate only other XAttributes as peers.<br>Although an XNode can access its parent XElement, it has no concept of <i>child</i> nodes:<br>this is the job of its subclass XContainer. XContainer defines members for dealing<br>with children and is the abstract base class for XElement and XDocument.<br>
XElement  introduces  members  for  managing  attributes--as  well  as  a  Name  and<br>Value. In the (fairly common) case of an element having a single XText child node,<br>the Value property on XElement encapsulates this child's content for both get and set<br>operations, cutting unnecessary navigation. Thanks to Value, you can mostly avoid<br>working directly with XText nodes.<br>
XDocument  represents  the  root  of  an  XML  tree.  More  precisely,  it  <i>wraps</i>  the  root<br>XElement,  adding  an  XDeclaration,  processing  instructions,  and  other  root-level<br>"fluff." Unlike with the W3C DOM, its use is optional: you can load, manipulate,<br>and  save  an  X-DOM  without  ever  creating  an  XDocument!  The  nonreliance  on<br>XDocument also means you can efficiently and easily move a node subtree to another<br>X-DOM hierarchy.<br>
<b>Loading and Parsing<br></b>Both XElement and XDocument provide static Load and Parse methods to build an X-<br>DOM tree from an existing source:<br>
· Load builds an X-DOM from a file, URI, Stream, TextReader, or XmlReader.<br>· Parse builds an X-DOM from a string.<br>
For example:<br>
XDocument fromWeb = XDocument.Load (&quot;http://albahari.com/sample.xml&quot;);<br>
XElement fromFile = XElement.Load (@&quot;e:\media\somefile.xml&quot;);<br>
XElement config = XElement.Parse (<br>@&quot;&lt;configuration&gt;<br>    &lt;client enabled='true'&gt;<br>      &lt;timeout&gt;30&lt;/timeout&gt;<br>    &lt;/client&gt;<br>  &lt;/configuration&gt;&quot;);<br>
In later sections, we describe how to traverse and update an X-DOM. As a quick<br>preview, here's how to manipulate the config element we just populated:<br>
foreach (XElement child in config.Elements())<br>  Console.WriteLine (child.Name);                     // client<br>
<b>416 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=437></a>XElement client = config.Element (&quot;client&quot;);<br>
<b>LINQ to XML</b><br>
bool enabled = (bool) client.Attribute (&quot;enabled&quot;);   // Read attribute<br>Console.WriteLine (enabled);                          // True<br>
client.Attribute (&quot;enabled&quot;).SetValue (!enabled);     // Update attribute<br>
int timeout = (int) client.Element (&quot;timeout&quot;);       // Read element<br>Console.WriteLine (timeout);                          // 30<br>
client.Element (&quot;timeout&quot;).SetValue (timeout * 2);    // Update element<br>
client.Add (new XElement (&quot;retries&quot;, 3));             // Add new element<br>
Console.WriteLine (config);         // Implicitly call config.ToString()<br>
Here's the result of that last Console.WriteLine:<br>
&lt;configuration&gt;<br>
  &lt;client enabled=&quot;false&quot;&gt;<br>
    &lt;timeout&gt;60&lt;/timeout&gt;<br>    &lt;retries&gt;3&lt;/retries&gt;<br>  &lt;/client&gt;<br>
&lt;/configuration<br>
XNode also provides a static ReadFrom method that instantiates<br>and  populates  any  type  of  node  from  an  XmlReader.  Unlike<br>Load,  it  stops  after  reading  one  (complete)  node,  so  you  can<br>continue to read manually from the XmlReader afterward.<br>
You can also do the reverse and use an XmlReader or XmlWriter<br>to  read  or  write  an  XNode,  via  its  CreateReader  and  Create<br>Writer methods.<br>
We describe XML readers and writers and how to use them with<br>the X-DOM in Chapter 11.<br>
<b>Saving and Serializing<br></b>Calling ToString on any node converts its content to an XML string--formatted with<br>line breaks and indentation as we just saw. (You can disable the line breaks and<br>indentation by specifying SaveOptions.DisableFormatting when calling ToString.)<br>
XElement and XDocument also provide a Save method that writes an X-DOM to a file,<br>Stream, TextWriter, or XmlWriter. If you specify a file, an XML declaration is auto-<br>matically written. There is also a WriteTo method defined in the XNode class, which<br>accepts just an XmlWriter.<br>We describe the handling of XML declarations when saving in more detail in the<br>section "Documents and Declarations" on page 431 later in this chapter.<br>
<b>X-DOM Overview | 417</b><br>
<hr>
<A name=438></a><b>Instantiating an X-DOM<br></b>Rather than using the Load or Parse methods, you can build an X-DOM tree by<br>manually instantiating objects and adding them to a parent via  XContainer's Add<br>method.<br>
To construct an XElement and XAttribute, simply provide a name and value:<br>
XElement lastName = new XElement (&quot;lastname&quot;, &quot;Bloggs&quot;);<br>
lastName.Add (new XComment (&quot;nice name&quot;));<br>
XElement customer = new XElement (&quot;customer&quot;);<br>
customer.Add (new XAttribute (&quot;id&quot;, 123));<br>
customer.Add (new XElement (&quot;firstname&quot;, &quot;Joe&quot;));<br>
customer.Add (lastName);<br>
Console.WriteLine (customer.ToString());<br>
The result:<br>
&lt;customer id=&quot;123&quot;&gt;<br>
  &lt;firstname&gt;Joe&lt;/firstname&gt;<br>  &lt;lastname&gt;Bloggs&lt;!--nice name--&gt;&lt;/lastname&gt;<br>
&lt;/customer&gt;<br>
A value is optional when constructing an XElement--you can provide just the element<br>name and add content later. Notice that when we did provide a value, a simple string<br>sufficed--we didn't need to explicitly create and add an XText child node. The X-<br>DOM does this work automatically, so you can deal simply with "values."<br>
<b>Functional Construction<br></b>In our preceding example, it's hard to glean the XML structure from the code. X-<br>DOM supports another mode of instantiation, called <i>functional construction</i> (from<br>functional programming). With functional construction, you build an entire tree in<br>a single expression:<br>
XElement customer =<br>  new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, 123),<br>    new XElement (&quot;firstname&quot;, &quot;joe&quot;),<br>    new XElement (&quot;lastname&quot;, &quot;bloggs&quot;,<br>      new XComment (&quot;nice name&quot;)<br>    )<br>  );<br>
This has two benefits. First, the code resembles the shape of the XML. Second, it<br>can be incorporated into the select clause of a LINQ query. For example, the fol-<br>lowing LINQ to SQL query projects directly into an X-DOM:<br>
XElement query =<br>  new XElement (&quot;customers&quot;,<br>    from c in dataContext.Customers<br>    select<br>      new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, c.ID),<br>        new XElement (&quot;firstname&quot;, c.FirstName),<br>
<b>418 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=439></a>        new XElement (&quot;lastname&quot;, c.LastName,<br>
<b>LINQ to XML</b><br>
          new XComment (&quot;nice name&quot;)<br>        )<br>      )<br>
  );<br>
More  on  this  later  in  this  chapter,  in  the  section  "Projecting  into  an  X-<br>DOM" on page 441.<br>
<b>Specifying Content<br></b>Functional  construction  is  possible  because  the  constructors  for  XElement  (and<br>XDocument) are overloaded to accept a params object array:<br>
public XElement (XName name, params object[] content)<br>
The same holds true for the Add method in XContainer:<br>
public void Add (params object[] content)<br>
Hence, you can specify any number of child objects of any type when building or<br>appending an X-DOM. This works because <i>anything</i> counts as legal content. To see<br>how, we need to examine how each content object is processed internally. Here are<br>the decisions made by XContainer, in order:<br>
1. If the object is null, it's ignored.<br>2. If  the  object  is  based  on  XNode  or  XStreamingElement,  it's  added  as  is  to  the<br>
Nodes collection.<br>
3. If the object is an XAttribute, it's added to the Attributes collection.<br>4. If the object is a string, it gets wrapped in an XText node and added to Nodes.*<br>5. If the object implements IEnumerable, it's enumerated, and the same rules are<br>
applied to each element.<br>
6. Otherwise, the object is converted to a string, wrapped in an XText node, and<br>
then added to Nodes.<br>
Everything ends up in one of two buckets: Nodes or Attributes. Furthermore, any<br>object is valid content because it can always ultimately call ToString on it and treat<br>it as an XText node.<br>
* The X-DOM actually optimizes this step internally by storing simple text content in a string. The<br>
XTEXT node is not actually created until you call Nodes( ) on the XContainer.<br>
 See the previous footnote.<br>
<b>Instantiating an X-DOM | 419</b><br>
<hr>
<A name=440></a>Before  calling  ToString  on  an  arbitrary  type,  XContainer  first<br>tests whether it is one of the following types:<br>
float, double, decimal, bool,<br>DateTime, DateTimeOffset, TimeSpan<br>
If  so,  it  calls  an  appropriate  typed  ToString  method  on  the<br>XmlConvert helper class instead of calling ToString on the object<br>itself. This ensures that the data is round-trippable and com-<br>pliant with standard XML formatting rules.<br>
<b>Automatic Deep Cloning<br></b>When a node or attribute is added to an element (whether via functional construc-<br>tion or an Add method), the node or attribute's Parent property is set to that element.<br>A node can have only one parent element: if you add an already parented node to a<br>second parent, the node is automatically <i>deep-cloned</i>. In the following example, each<br>customer has a separate copy of address:<br>
var address = new XElement (&quot;address&quot;,<br>
                  new XElement (&quot;street&quot;, &quot;Lawley St&quot;),<br>
                  new XElement (&quot;town&quot;, &quot;North Beach&quot;)<br>              );<br>
var customer1 = new XElement (&quot;customer1&quot;, address);<br>
var customer2 = new XElement (&quot;customer2&quot;, address);<br>
customer1.Element (&quot;address&quot;).Element (&quot;street&quot;).Value = &quot;Another St&quot;;<br>Console.WriteLine (<br>  customer2.Element (&quot;address&quot;).Element (&quot;street&quot;).Value);   // Lawley St<br>
This automatic duplication keeps X-DOM object instantiation free of side effects--<br>another hallmark of functional programming.<br>
<b>Navigating and Querying<br></b>As you might expect, the XNode and XContainer classes define methods and properties<br>for traversing the X-DOM tree. Unlike a conventional DOM, however, these func-<br>tions don't return a collection that implements IList&lt;T&gt;. Instead, they return either<br>a single value or a <i>sequence</i> that implements IEnumerable&lt;T&gt;--upon which you are<br>then expected to execute a LINQ query (or enumerate with a foreach). This allows<br>for advanced queries as well as simple navigation tasks--using familiar LINQ query<br>syntax.<br>
Element and attribute names are case-sensitive in the X-DOM--<br>just as they are in XML.<br>
<b>420 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=441></a><b>Child Node Navigation</b><br>
<b>LINQ to XML</b><br>
<b>Return type</b><br>
<b>Members</b><br>
<b>Works on</b><br>
XNode<br>
FirstNode { get; }<br>
XContainer<br>
 <br>
LastNode { get; }<br>
XContainer<br>
IEnumerable&lt;XNode&gt;<br>
Nodes()<br>
XContainer*<br>
 <br>
DescendantNodes()<br>
XContainer*<br>
 <br>
DescendantNodesAndSelf()<br>
XElement*<br>
XElement<br>
Element (XName)<br>
XContainer<br>
IEnumerable&lt;XElement&gt;<br>
Elements()<br>
XContainer*<br>
 <br>
Elements (XName)<br>
XContainer*<br>
 <br>
Descendants()<br>
XContainer*<br>
 <br>
Descendants (XName)<br>
XContainer*<br>
 <br>
DescendantsAndSelf()<br>
XElement*<br>
 <br>
DescendantsAndSelf (XName)<br>
XElement*<br>
bool<br>
HasElements { get; }<br>
XElement<br>
Functions marked with an asterisk in the third column of this<br>and other tables also operate on <i>sequences</i> of the same type. For<br>instance,  you  can  call  Nodes  on  either  an  XContainer  or  a  se-<br>quence of XContainer objects. This is possible because of ex-<br>tension methods defined in System.Xml.Linq--the supplemen-<br>tary query operators we talked about in the overview.<br>
<b>FirstNode, LastNode, and Nodes<br></b>FirstNode and LastNode give you direct access to the first or last child node; Nodes<br>returns all children as a sequence. All three functions consider only direct descend-<br>ants. For example:<br>
var bench = new XElement (&quot;bench&quot;,<br>              new XElement (&quot;toolbox&quot;,<br>                new XElement (&quot;handtool&quot;, &quot;Hammer&quot;),<br>                new XElement (&quot;handtool&quot;, &quot;Rasp&quot;)<br>              ),<br>              new XElement (&quot;toolbox&quot;,<br>
                new XElement (&quot;handtool&quot;, &quot;Saw&quot;),<br>                new XElement (&quot;powertool&quot;, &quot;Nailgun&quot;)<br>              ),<br>              new XComment (&quot;Be careful with the nailgun&quot;)<br>            );<br>foreach (XNode node in bench<b>.Nodes()</b>)<br>  Console.WriteLine (node.ToString (SaveOptions.DisableFormatting) + &quot;.&quot;);<br>
<b>Navigating and Querying | 421</b><br>
<hr>
<A name=442></a>This is the output:<br>
&lt;toolbox&gt;&lt;handtool&gt;Hammer&lt;/handtool&gt;&lt;handtool&gt;Rasp&lt;/handtool&gt;&lt;/toolbox&gt;.<br>
&lt;toolbox&gt;&lt;handtool&gt;Saw&lt;/handtool&gt;&lt;powertool&gt;Nailgun&lt;/powertool&gt;&lt;/toolbox&gt;.<br>
&lt;!--Be careful with the nailgun--&gt;.<br>
<b>Retrieving elements<br></b>The Elements method returns just the child nodes of type XElement:<br>
foreach (XElement e in bench<b>.Elements()</b>)<br>
  Console.WriteLine (e.Name + &quot;=&quot; + e.Value);    // toolbox=HammerRasp<br>                                                 // toolbox=SawNailgun<br>
The following LINQ query finds the toolbox with the nail gun:<br>
IEnumerable&lt;string&gt; query =<br>  from toolbox in bench.Elements()<br>
  where toolbox.Elements().Any (tool =&gt; tool.Value == &quot;Nailgun&quot;)<br>
  select toolbox.Value;<br>
RESULT: { &quot;SawNailgun&quot; }<br>
The next example uses a SelectMany query to retrieve the hand tools in all toolboxes:<br>
IEnumerable&lt;string&gt; query =<br>
  from toolbox in bench.Elements()<br>  from tool in toolbox.Elements()<br>
  where tool.Name == &quot;handtool&quot;<br>
  select tool.Value;<br>
RESULT: { &quot;Hammer&quot;, &quot;Rasp&quot;, &quot;Saw&quot; }<br>
Elements itself is equivalent to a LINQ query on Nodes. Our pre-<br>ceding query could be started as follows:<br>
from toolbox in bench.<b>Nodes().OfType&lt;XElement&gt;()<br></b>where ...<br>
Elements can also return just the elements of a given name. For example:<br>
int x = bench<b>.Elements (&quot;toolbox&quot;)</b>.Count();    // 2<br>
This is equivalent to:<br>
int x = bench.Elements().<b>Where (e =&gt; e.Name == &quot;toolbox&quot;)</b>.Count();  // 2<br>
Elements  is  also  defined  as  an  extension  method  accepting  IEnumerable&lt;XCon<br>tainer&gt; or, more precisely, it accepts an argument of this type:<br>
IEnumerable&lt;T&gt; where T : XContainer<br>
This allows it to work with sequences of elements, too. Using this method, we can<br>rewrite the query that finds the hand tools in all toolboxes as follows:<br>
from tool in bench.Elements (&quot;toolbox&quot;).<b>Elements</b> (&quot;handtool&quot;)<br>
select tool.Value.ToUpper();<br>
<b>422 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=443></a>The first call to Elements binds to XContainer's instance method; the second call to<br>
<b>LINQ to XML</b><br>
Elements binds to the extension method.<br>
<b>Retrieving a single element<br></b>The method Element (singular) returns the first matching element of the given name.<br>Element is useful for simple navigation, as follows:<br>
XElement settings = XElement.Load (&quot;databaseSettings.xml&quot;);<br>
string cx = settings.Element (&quot;database&quot;).Element (&quot;connectString&quot;).Value;<br>
Element  is  equivalent  to  calling  Elements()  and  then  applying  LINQ's<br>FirstOrDefault  query  operator  with  a  name-matching  predicate.  Element<br>returns null if the requested element doesn't exist.<br>
Element(&quot;xyz&quot;).Value  will  throw  a  NullReferenceException  if<br>element xyz does not exist. If you'd prefer a null rather than an<br>exception, cast the XElement to a string instead of querying its<br>Value property. In other words:<br>
string xyz = (string) settings.Element (&quot;xyz&quot;);<br>
This  works  because  XElement  defines  an  explicit  string<br>conversion--just for this purpose!<br>
<b>Recursive functions<br></b>XContainer  also  provides  Descendants  and  DescendantNodes  methods  that  return<br>child elements or nodes, <i>recursively</i>. Descendants accepts an optional element name.<br>Returning to our earlier example, we can use Descendants to find all the hand tools<br>as follows:<br>
Console.WriteLine (bench<b>.Descendants (&quot;handtool&quot;)</b>.Count());  // 3<br>
Both parent and leaf nodes are included, as the following example demonstrates:<br>
foreach (XNode node in bench<b>.DescendantNodes()</b>)<br>
  Console.WriteLine (node.ToString (SaveOptions.DisableFormatting));<br>
&lt;toolbox&gt;&lt;handtool&gt;Hammer&lt;/handtool&gt;&lt;handtool&gt;Rasp&lt;/handtool&gt;&lt;/toolbox&gt;<br>&lt;handtool&gt;Hammer&lt;/handtool&gt;<br>Hammer<br>&lt;handtool&gt;Rasp&lt;/handtool&gt;<br>Rasp<br>&lt;toolbox&gt;&lt;handtool&gt;Saw&lt;/handtool&gt;&lt;powertool&gt;Nailgun&lt;/powertool&gt;&lt;/toolbox&gt;<br>&lt;handtool&gt;Saw&lt;/handtool&gt;<br>Saw<br>&lt;powertool&gt;Nailgun&lt;/powertool&gt;<br>Nailgun<br>&lt;!--Be careful with the nailgun--&gt;<br>
The next query extracts all comments anywhere within the X-DOM that contain the<br>word "careful":<br>
<b>Navigating and Querying | 423</b><br>
<hr>
<A name=444></a>IEnumerable&lt;string&gt; query =<br>
  from c in bench.DescendantNodes().OfType&lt;XComment&gt;()<br>  where c.Value.Contains (&quot;careful&quot;)<br>  orderby c.Value<br>
  select c.Value;<br>
<b>Parent Navigation<br></b>All XNodes have a Parent property and Ancestor<i>XXX</i> methods for parent navigation.<br>A parent is always an XElement:<br>
<b>Return type</b><br>
<b>Members</b><br>
<b>Works on</b><br>
XElement<br>
Parent { get; }<br>
XNode*<br>
Enumerable&lt;XElement&gt;<br>
Ancestors()<br>
XNode*<br>
 <br>
Ancestors (XName)<br>
XNode*<br>
 <br>
AncestorsAndSelf()<br>
XElement*<br>
 <br>
AncestorsAndSelf (XName)<br>
XElement*<br>
If x is an XElement, the following always prints true:<br>
foreach (XNode child in x.Nodes())<br>
  Console.WriteLine (child.Parent == x);<br>
The same is not the case, however, if x is an XDocument. XDocument is peculiar: it can<br>have children, but can never be anyone's parent! To access the XDocument, you instead<br>use the Document property--this works on any object in the X-DOM tree.<br>
Ancestors returns a sequence whose first element is Parent, and whose next element<br>is Parent.Parent, and so on, until the root element.<br>
You  can  navigate  to  the  root  element  with  the  LINQ  query<br>AncestorsAndSelf().Last().<br>
Another  way  to  achieve  the  same  thing  is  to  call<br>Document.Root--although  this  works  only  if  an  XDocument  is<br>present.<br>
<b>Peer Node Navigation</b><br>
<b>Return type</b><br>
<b>Members</b><br>
<b>Defined in</b><br>
bool<br>
IsBefore (XNode node)<br>
XNode<br>
 <br>
IsAfter (XNode node)<br>
XNode<br>
XNode<br>
PreviousNode { get; }<br>
XNode<br>
 <br>
NextNode { get; }<br>
XNode<br>
IEnumerable&lt;XNode&gt;<br>
NodesBeforeSelf()<br>
XNode<br>
 <br>
NodesAfterSelf()<br>
XNode<br>
<b>424 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=445></a><b>Return type</b><br>
<b>Members</b><br>
<b>Defined in</b><br>
<b>LINQ to XML</b><br>
IEnumerable&lt;XElement&gt;<br>
ElementsBeforeSelf()<br>
XNode<br>
 <br>
ElementsBeforeSelf (XName name)<br>
XNode<br>
 <br>
ElementsAfterSelf()<br>
XNode<br>
 <br>
ElementsAfterSelf (XName name)<br>
XNode<br>
With PreviousNode and NextNode (and FirstNode/LastNode), you can traverse nodes<br>with the feel of a linked list. This is noncoincidental: internally, nodes are stored in<br>a linked list.<br>
XNode internally uses a <i>singly</i> linked list, so PreviousNode is not<br>performant.<br>
<b>Attribute Navigation</b><br>
<b>Return type</b><br>
<b>Members</b><br>
<b>Defined in</b><br>
bool<br>
HasAttributes { get; }<br>
XElement<br>
XAttribute<br>
Attribute (XName name)<br>
XElement<br>
 <br>
FirstAttribute { get; }<br>
XElement<br>
 <br>
LastAttribute { get; }<br>
XElement<br>
IEnumerable&lt;XAttribute&gt;<br>
Attributes()<br>
XElement<br>
 <br>
Attributes (XName name)<br>
XElement<br>
In addition, XAttribute defines PreviousAttribute and NextAttribute properties, as<br>well as Parent.<br>The Attributes method that accepts a name returns a sequence with either zero or<br>one element; an element cannot have duplicate attribute names in XML.<br>
<b>Updating an X-DOM<br></b>You can update elements and attributes in the following ways:<br>
· Call SetValue or reassign the Value property.<br>· Call SetElementValue or SetAttributeValue.<br>· Call one of the Remove<i>XXX</i> methods.<br>· Call one of the Add<i>XXX</i> or Replace<i>XXX</i> methods, specifying fresh content.<br>
You can also reassign the Name property on XElement objects.<br>
<b>Updating an X-DOM | 425</b><br>
<hr>
<A name=446></a><b>Simple Value Updates</b><br>
<b>Members</b><br>
<b>Works on</b><br>
SetValue (object value)<br>
XElement, XAttribute<br>
Value { get; set }<br>
XElement, XAttribute<br>
The SetValue method replaces an element or attribute's content with a simple value.<br>Setting the Value property does the same, but accepts string data only. We describe<br>both of these functions in detail later in this chapter (see the section "Working with<br>Values" on page 428).<br>
An effect of calling SetValue (or reassigning Value) is that it replaces all child nodes:<br>
XElement settings = new XElement (&quot;settings&quot;,<br>                      new XElement (&quot;timeout&quot;, 30)<br>
                    );<br>
settings.SetValue (&quot;blah&quot;);<br>
Console.WriteLine (settings.ToString());  // &lt;settings&gt;blah&lt;/settings&gt;<br>
<b>Updating Child Nodes and Attributes</b><br>
<b>Category</b><br>
<b>Members</b><br>
<b>Works on</b><br>
Add<br>
Add (params object[] content)<br>
XContainer<br>
 <br>
AddFirst (params object[] content)<br>
XContainer<br>
Remove<br>
RemoveNodes()<br>
XContainer<br>
 <br>
RemoveAttributes()<br>
XElement<br>
 <br>
RemoveAll()<br>
XElement<br>
Update<br>
ReplaceNodes (params object[] content)<br>
XContainer<br>
 <br>
ReplaceAttributes (params object[] content)<br>
XElement<br>
 <br>
ReplaceAll (params object[] content<br>
XElement<br>
 <br>
SetElementValue (XName name, object value)<br>
XElement<br>
 <br>
SetAttributeValue (XName name, object value)<br>
XElement<br>
The  most  convenient  methods  in  this  group  are  the  last  two:  SetElementValue<br>and  SetAttributeValue.  They  serve  as  shortcuts  for  instantiating  an  XElement  or<br>XAttribute and then Adding it to a parent, replacing any existing element or attribute<br>of that name:<br>
XElement settings = new XElement (&quot;settings&quot;);<br>settings.SetElementValue (&quot;timeout&quot;, 30);     // Adds child node<br>settings.SetElementValue (&quot;timeout&quot;, 60);     // Update it to 60<br>
Add appends a child node to an element or document. AddFirst does the same thing,<br>but inserts at the beginning of the collection rather than the end.<br>
You  can  remove  all  child  nodes  or  attributes  in  one  hit  with  RemoveNodes  or<br>RemoveAttributes. RemoveAll is equivalent to calling both of these methods.<br>
<b>426 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=447></a>The Replace<i>XXX</i> methods are equivalent to Removing and then Adding. They take a<br>
<b>LINQ to XML</b><br>
snapshot of the input, so e.ReplaceNodes(e.Nodes()) works as expected.<br>
<b>Updating Through the Parent</b><br>
<b>Members</b><br>
<b>Works on</b><br>
AddBeforeSelf (params object[] content)<br>
XNode<br>
AddAfterSelf (params object[] content)<br>
XNode<br>
Remove()<br>
XNode*, XAttribute*<br>
ReplaceWith (params object[] content)<br>
XNode<br>
The methods AddBeforeSelf, AddAfterSelf, Remove, and ReplaceWith don't operate<br>on the node's children. Instead, they operate on the collection in which the node<br>itself is in. This requires that the node have a parent element--otherwise, an excep-<br>tion is thrown. AddBeforeSelf and AddAfterSelf are useful for inserting a node into<br>an arbitrary position:<br>
XElement items = new XElement (&quot;items&quot;,<br>
                   new XElement (&quot;one&quot;),<br>
                   new XElement (&quot;three&quot;)<br>
                 );<br>
items.FirstNode.AddAfterSelf (new XElement (&quot;<b>two</b>&quot;));<br>
Here's the result:<br>
&lt;items&gt;&lt;one /&gt;&lt;<b>two</b> /&gt;&lt;three /&gt;&lt;/items&gt;<br>
Inserting into an arbitrary position within a long sequence of elements is actually<br>quite efficient, because nodes are stored internally in a linked list.<br>
The Remove method removes the current node from its parent. ReplaceWith does the<br>same--and then inserts some other content at the same position. For instance:<br>
XElement items = XElement.Parse (&quot;&lt;items&gt;&lt;one/&gt;&lt;two/&gt;&lt;three/&gt;&lt;/items&gt;&quot;);<br>items.FirstNode.ReplaceWith (new XComment (&quot;One was here&quot;));<br>
Here's the result:<br>
&lt;items&gt;<b>&lt;!--one was here--&gt;</b>&lt;two /&gt;&lt;three /&gt;&lt;/items&gt;<br>
<b>Removing a sequence of nodes or attributes<br></b>Thanks  to  extension  methods  in  System.Xml.Linq,  you  can  also  call  Remove  on  a<br><i>sequence</i> of nodes or attributes. Consider this X-DOM:<br>
XElement contacts = XElement.Parse (<br>@&quot;&lt;contacts&gt;<br>    &lt;customer name='Mary'/&gt;<br>    &lt;customer name='Chris' archived='true'/&gt;<br>    &lt;supplier name='Susan'&gt;<br>      &lt;phone archived='true'&gt;012345678&lt;!--confidential--&gt;&lt;/phone&gt;<br>    &lt;/supplier&gt;<br>  &lt;/contacts&gt;&quot;);<br>
<b>Updating an X-DOM | 427</b><br>
<hr>
<A name=448></a>The following removes all customers:<br>
contacts.Elements (&quot;customer&quot;).Remove();<br>
The next statement removes all archived contacts (so <i>Chris</i> disappears):<br>
contacts.Elements().Where (e =&gt; (bool?) e.Attribute (&quot;archived&quot;) == true)<br>
                   .Remove();<br>
If we replaced Elements() with Descendants(), all archived elements throughout the<br>DOM would disappear, with this result:<br>
&lt;contacts&gt;<br>
  &lt;customer name=&quot;Mary&quot; /&gt;<br>
  &lt;supplier name=&quot;Susan&quot; /&gt;<br>
&lt;/contacts&gt;<br>
The  next  example  removes  all  contacts  that  feature  the  comment  "confidential"<br>anywhere in their tree:<br>
contacts.Elements().Where (e =&gt; e.DescendantNodes()<br>                                 .OfType&lt;XComment&gt;()<br>
                                 .Any (c =&gt; c.Value == &quot;confidential&quot;)<br>
                          ).Remove();<br>
This is the result:<br>
&lt;contacts&gt;<br>
  &lt;customer name=&quot;Mary&quot; /&gt;<br>
  &lt;customer name=&quot;Chris&quot; archived=&quot;true&quot; /&gt;<br>
&lt;/contacts&gt;<br>
Contrast this with the following simpler query, which strips all comment nodes from<br>the tree:<br>
contacts.DescendantNodes().OfType&lt;XComment&gt;().Remove();<br>
Internally, the Remove methods first read all matching elements<br>into a temporary list, and then enumerate over the temporary<br>list to perform the deletions. This avoids errors that could oth-<br>erwise result from deleting and querying at the same time.<br>
<b>Working with Values<br></b>XElement and XAttribute both have a Value property of type string. If an element<br>has a single XText child node, XElement's Value property acts as a convenient shortcut<br>to the content of that node. With XAttribute, the Value property is simply the at-<br>tribute's value.<br>
Despite the storage differences, the X-DOM provides a consistent set of operations<br>for working with element and attribute values.<br>
<b>428 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=449></a><b>Setting Values</b><br>
<b>LINQ to XML</b><br>
There are two ways to assign a value: call SetValue or assign the Value property.<br>SetValue is more flexible because it accepts not just strings, but other simple data<br>types too:<br>
var e = new XElement (&quot;date&quot;, DateTime.Now);<br>e.SetValue (DateTime.Now.AddDays(1));<br>
Console.Write (e.Value);              // 2007-03-02T16:39:10.734375+09:00<br>
We could have instead just set the element's Value property, but this would mean<br>manually converting the DateTime to a string. This is more complicated than calling<br>ToString--it requires the use of XmlConvert for an XML-compliant result.<br>
When you pass a <i>value</i> into XElement or XAttribute's constructor, the same auto-<br>matic conversion takes place for nonstring types. This ensures that DateTimes are<br>correctly formatted; true is written in lowercase, and double.NegativeInfinity is<br>written as "-INF".<br>
<b>Getting Values<br></b>To go the other way around and parse a Value back to a base type, you simply cast<br>the XElement or XAttribute to the desired type. It sounds like it shouldn't work--<br>but it does! For instance:<br>
XElement e = new XElement (&quot;now&quot;, DateTime.Now);<br>
DateTime dt = (DateTime) e;<br>
XAttribute a = new XAttribute (&quot;resolution&quot;, 1.234);<br>double res = (double) a;<br>
An element or attribute doesn't store DateTimes or numbers natively--they're always<br>stored as text, and then parsed as needed. It also doesn't "remember" the original<br>type, so you must cast it correctly to avoid a runtime error. To make your code<br>robust, you can put the cast in a try/catch block, catching a FormatException.<br>Explicit casts on XElement and XAttribute can parse to the following types:<br>
· All standard numeric types<br>· string, bool, DateTime, DateTimeOffset, TimeSpan, and Guid<br>· Nullable&lt;&gt; versions of the aforementioned value types<br>
Casting to a nullable type is useful in conjunction with the Element and Attribute<br>methods, because if the requested name doesn't exist, the cast still works. For in-<br>stance, if x has no timeout element, the first line generates a runtime error and the<br>second line does not:<br>
int timeout = (int) x.Element (&quot;timeout&quot;);      // Error<br>int? timeout = (int?) x.Element (&quot;timeout&quot;);    // OK; timeout is null.<br>
You can factor away the nullable type in the final result with the ?? operator. The<br>following evaluates to 1.0 if the resolution attribute doesn't exist:<br>
double resolution = (double?) x.Attribute (&quot;resolution&quot;) ?? 1.0;<br>
<b>Working with Values | 429</b><br>
<hr>
<A name=450></a>Casting to a nullable type won't get you out of trouble, though, if the element or<br>attribute <i>exists</i> and has an empty (or improperly formatted) value. For this, you must<br>catch a FormatException.<br>You can also use casts in LINQ queries. The following returns "John":<br>
var data = XElement.Parse (<br>  @&quot;&lt;data&gt;<br>
      &lt;customer id='1' name='Mary' credit='100' /&gt;<br>      &lt;customer id='2' name='John' credit='150' /&gt;<br>
      &lt;customer id='3' name='Anne' /&gt;<br>
    &lt;/data&gt;&quot;);<br>
IEnumerable&lt;string&gt; query = from cust in data.Elements()<br>                            where <b>(int?)</b> cust.Attribute (&quot;credit&quot;) &gt; 100<br>
                            select cust.Attribute (&quot;name&quot;).Value;<br>
Casting to a nullable int avoids a NullReferenceException in the case of Anne, who<br>has no credit attribute. Another solution would be to add a predicate to the where<br>clause:<br>
where <b>cust.Attributes (&quot;credit&quot;).Any()</b> &amp;&amp; (int) cust.Attribute...<br>
The same principles apply in querying element values.<br>
<b>Values and Mixed Content Nodes<br></b>Giventhe value of Value, you might wonder when you'd ever need to deal directly<br>with XText nodes. The answer is when you have mixed content. For example:<br>
&lt;summary&gt;An XAttribute is &lt;bold&gt;not&lt;/bold&gt; an XNode&lt;/summary&gt;<br>
A simple Value property is not enough to capture summary's content. The summary<br>element contains three children: an XText node followed by an XElement, followed<br>by another XText node. Here's how to construct it:<br>
XElement summary = new XElement (&quot;summary&quot;,<br>                      new XText (&quot;An XAttribute is &quot;),<br>                      new XElement (&quot;bold&quot;, &quot;not&quot;),<br>                      new XText (&quot; an XNode&quot;)<br>                    );<br>
Interestingly, we can still query summary's Value--without getting an exception. In-<br>stead, we get a concatenation of each child's value:<br>
An XAttribute is not an XNode<br>
It's also legal to reassign summary's Value, at the cost of replacing all previous children<br>with a single new XText node.<br>
<b>Automatic XText Concatenation<br></b>When you add simple content to an XElement, the X-DOM appends to the existing<br>XText child rather than creating a new one. In the following examples, e1 and e2 end<br>up with just one child XText element whose value is HelloWorld:<br>
<b>430 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=451></a>var e1 = new XElement (&quot;test&quot;, &quot;Hello&quot;); e1.Add (&quot;World&quot;);<br>
<b>LINQ to XML</b><br>
var e2 = new XElement (&quot;test&quot;, &quot;Hello&quot;, &quot;World&quot;);<br>
If you specifically create XText nodes, however, you end up with multiple children:<br>
var e = new XElement (&quot;test&quot;, new XText (&quot;Hello&quot;), new XText (&quot;World&quot;));<br>Console.WriteLine (e.Value);             // HelloWorld<br>Console.WriteLine (e.Nodes().Count());   // 2<br>
XElement doesn't concatenate the two XText nodes, so the nodes' object identities<br>are preserved.<br>
<b>Documents and Declarations<br>XDocument<br></b>As we said previously, an XDocument wraps a root XElement and allows you to add an<br>XDeclaration, processing instructions, a document type, and root-level comments.<br>An XDocument is optional and can be ignored or omitted: unlike with the W3C DOM,<br>it does not serve as glue to keep everything together.<br>
An XDocument provides the same functional constructors as XElement. And because<br>it's  based  on  XContainer,  it  also  supports  the  Add<i>XXX</i>,  Remove<i>XXX</i>,  and  Replace<i>XXX<br></i>methods. Unlike XElement, however, an XDocument can accept only limited content:<br>
· A single XElement object (the "root")<br>· A single XDeclaration object<br>· A single XDocumentType object (to reference a DTD)<br>· Any number of XProcessingInstruction objects<br>· Any number of XComment objects<br>
Of these, only the root XElement is mandatory in order to have<br>a  valid  XDocument.  The  XDeclaration  is  optional--if  omitted,<br>default settings are applied during serialization.<br>
The simplest valid XDocument has just a root element:<br>
var doc = new XDocument (<br>            new XElement (&quot;test&quot;, &quot;data&quot;)<br>          );<br>
Notice that we didn't include an XDeclaration object. The file generated by calling<br>doc.Save would still contain an XML declaration, however, because one is generated<br>by default.<br>
<b>Documents and Declarations | 431</b><br>
<hr>
<A name=452></a>The next example produces a simple but correct XHTML file, illustrating all the<br>constructs that an XDocument can accept:<br>
var styleInstruction = new XProcessingInstruction (<br>  &quot;xml-stylesheet&quot;, &quot;href='styles.css' type='text/css'&quot;);<br>
var docType = new XDocumentType (&quot;html&quot;,<br>  &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;,<br>  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;, null);<br>
XNamespace ns = &quot;http://www.w3.org/1999/xhtml&quot;;<br>
var root =<br>  new XElement (ns + &quot;html&quot;,<br>
    new XElement (ns + &quot;head&quot;,<br>      new XElement (ns + &quot;title&quot;, &quot;An XHTML page&quot;)),<br>
    new XElement (ns + &quot;body&quot;,<br>      new XElement (ns + &quot;p&quot;, &quot;This is the content&quot;))<br>
  );<br>
var doc =<br>  new XDocument (<br>    <b>new XDeclaration (&quot;1.0&quot;, &quot;utf-8&quot;, &quot;no&quot;),</b><br>
    <b>new XComment (&quot;Reference a stylesheet&quot;),</b><br>
    <b>styleInstruction,<br></b>    <b>docType,<br></b>    <b>root);</b><br>
doc.Save (&quot;test.html&quot;);<br>
The resultant <i>test.html</i> reads as follows:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;no&quot;?&gt;<br>&lt;!--Reference a stylesheet--&gt;<br>&lt;?xml-stylesheet href='styles.css' type='text/css'?&gt;<br>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;<br>                      &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;<br>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;An XHTML page&lt;/title&gt;<br>
  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;p&gt;This is the content&lt;/p&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br>
XDocument has a Root property that serves as a shortcut for accessing a document's<br>single XElement. The reverse link is provided by XObject's Document property, which<br>works for all objects in the tree:<br>
Console.WriteLine (doc.Root.Name.LocalName);          // html<br>XElement bodyNode = doc.Root.Element (ns + &quot;body&quot;);<br>Console.WriteLine (bodyNode.Document == doc);         // True<br>
Recall that a document's children have no Parent:<br>
<b>432 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=453></a>Console.WriteLine (doc.Root.Parent == null);          // True<br>
<b>LINQ to XML</b><br>
foreach (XNode node in doc.Nodes())<br>  Console.Write (node.Parent == null);                // TrueTrueTrueTrue<br>
An  XDeclaration  is  not  an  XNode  and  does  not  appear  in  the<br>document's Nodes collection--unlike comments, processing in-<br>structions, and the root element. Instead, it gets assigned to a<br>dedicated property called Declaration. This is why "True" is<br>repeated four and not five times in the last example.<br>
<b>XML Declarations<br></b>A standard XML file starts with a declaration such as the following:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>
An XML declaration ensures that the file will be correctly parsed and understood by<br>a reader. XElement and XDocument follow these rules in emitting XML declarations:<br>
· Calling Save with a filename always writes a declaration.<br>· Calling Save with an XmlWriter writes a declaration unless the XmlWriter is in-<br>
structed otherwise.<br>
· The ToString method never emits an XML declaration.<br>
You can instruct an XmlWriter not to produce a declaration by<br>setting  the  OmitXmlDeclaration and ConformanceLevel proper-<br>ties  of  an  XmlWriterSettings  object  when  constructing  the<br>XmlWriter. We describe this in Chapter 11.<br>
The presence or absence of an XDeclaration object has no effect on whether an XML<br>declaration gets written. The purpose of an XDeclaration is instead to <i>hint the XML<br>serialization</i>--in two ways:<br>
· What text encoding to use<br>· What  to  put  in  the  XML  declaration's  encoding  and  standalone  attributes<br>
(should a declaration be written)<br>
XDeclaration's constructor accepts three arguments, which correspond to the at-<br>tributes version, encoding, and standalone. In the following example, <i>test.xml</i> is<br>encoded in UTF-16:<br>
var doc = new XDocument (<br>            new XDeclaration (&quot;1.0&quot;, &quot;<b>utf-16</b>&quot;, &quot;yes&quot;),<br>            new XElement (&quot;test&quot;, &quot;data&quot;)<br>          );<br>doc.Save (&quot;test.xml&quot;);<br>
<b>Documents and Declarations | 433</b><br>
<hr>
<A name=454></a>Whatever  you  specify  for  the  XML  version  is  ignored  by  the<br>XML writer: it always writes &quot;1.0&quot;.<br>
The encoding must use an IETF code such as &quot;utf-16&quot;--just as it would appear in<br>the XML declaration.<br>
<b>Writing a declaration to a string<br></b>Suppose we want to serialize an XDocument to a string--including the XML decla-<br>ration.  Because  ToString  doesn't  write  a  declaration,  we'd  have  to  use  an<br>XmlWriter instead:<br>
var doc = new XDocument (<br>
            <b>new XDeclaration (&quot;1.0&quot;, &quot;utf-8&quot;, &quot;yes&quot;),<br></b>            new XElement (&quot;test&quot;, &quot;data&quot;)<br>          );<br>
var output = new StringBuilder();<br>
var settings = new XmlWriterSettings { Indent = true };<br>
using (XmlWriter xw = XmlWriter.Create (output, settings))<br>  doc.Save (xw);<br>
Console.WriteLine (output.ToString());<br>
This is the result:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-16&quot; standalone=&quot;yes&quot;?&gt;<br>
&lt;test&gt;data&lt;/test&gt;<br>
Notice  that  we  got  UTF-16  in  the  output--even  though  we  explicitly  requested<br>UTF-8 in an XDeclaration! This might look like a bug, but in fact, XmlWriter is being<br>remarkably smart. Because we're writing to a string and not a file or stream, it's<br>impossible to apply any encoding other than UTF-16--the format in which strings<br>are internally stored. Hence, XmlWriter writes &quot;utf-16&quot;--so as not to lie.<br>This  also  explains  why  the  ToString  method  doesn't  emit  an  XML  declaration.<br>Imagine that instead of calling Save, you did the following to write an XDocument to<br>a file:<br>
File.WriteAllText (&quot;data.xml&quot;, doc.ToString());<br>
As it stands, <i>data.xml</i> would lack an XML declaration, making it incomplete but<br>still parsable (you can infer the text encoding). But if ToString() emitted an XML<br>declaration,  <i>data.xml</i>  would  actually  contain  an  <i>incorrect</i>  declaration<br>(encoding=&quot;utf-16&quot;),  which  might  prevent  it  from  being  read  at  all,  because<br>WriteAllText encodes using UTF-8.<br>
<b>Names and Namespaces<br></b>Just as .NET types can have namespaces, so too can XML elements and attributes.<br>
XML namespaces achieve two things. First, rather like namespaces in C#, they help<br>avoid naming collisions. This can become an issue when you merge data from one<br>
<b>434 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=455></a>XML file into another. Second, namespaces assign <i>absolute</i> meaning to a name. The<br>
<b>LINQ to XML</b><br>
name "nil," for instance, could mean anything. Within the <i>http://www.w3.org/2001/<br>xmlschema-instance</i>  namespace,  however,  "nil"  means  something  equivalent  to<br>null in C# and comes with specific rules on how it can be applied.<br>
Because XML namespaces are a significant source of confusion, we'll cover the topic<br>first in general, and then move on to how they're used in LINQ to XML.<br>
<b>Namespaces in XML<br></b>Suppose  we  want  to  define  a  customer  element  in  the  namespace  OReilly.Nut<br>shell.CSharp. There are two ways to proceed. The first is to use the xmlns attribute<br>as follows:<br>
&lt;customer <b>xmlns=&quot;OReilly.Nutshell.CSharp&quot;</b>/&gt;<br>
xmlns is a special reserved attribute. When used in this manner, it performs two<br>functions:<br>
· It specifies a namespace for the element in question.<br>· It specifies a default namespace for all descendant elements.<br>
This means that in the following example, address and postcode implicitly live in<br>the OReilly.Nutshell.CSharp namespace:<br>
&lt;customer xmlns=&quot;OReilly.Nutshell.CSharp&quot;&gt;<br>
  &lt;address&gt;<br>    &lt;postcode&gt;02138&lt;/postcode&gt;<br>  &lt;/address&gt;<br>&lt;/customer&gt;<br>
If we want address and postcode to have <i>no</i> namespace, we'd have to do this:<br>
&lt;customer xmlns=&quot;OReilly.Nutshell.CSharp&quot;s&gt;<br>  &lt;address <b>xmlns=&quot;&quot;</b>&gt;<br>    &lt;postcode&gt;02138&lt;/postcode&gt;     &lt;!-- postcode now inherits empty ns --&gt;<br>  &lt;/address&gt;<br>&lt;/customer&gt;<br>
<b>Prefixes<br></b>The other way to specify a namespace is with a <i>prefix</i>. A prefix is an alias that you<br>assign  to  a  namespace  to  save  typing.  There  are  two  steps  in  using  a  prefix--<br><i>defining</i> the prefix and <i>using</i> it. You can do both together as follows:<br>
&lt;<b>nut:</b>customer <b>xmlns:nut</b>=&quot;OReilly.Nutshell.CSharp&quot;/&gt;<br>
Two distinct things are happening here. On the right, xmlns:nut=&quot;...&quot; defines a<br>prefix called nut and makes it available to this element and all its descendants. On<br>the left, nut:customer assigns the newly allocated prefix to the customer element.<br>A prefixed element <i>does not</i> define a default namespace for descendants. In the fol-<br>lowing XML, firstname has an empty namespace:<br>
<b>Names and Namespaces | 435</b><br>
<hr>
<A name=456></a>&lt;nut:customer nut:xmlns=&quot;OReilly.Nutshell.CSharp&quot;&gt;<br>
  &lt;firstname&gt;Joe&lt;/firstname&gt;<br>&lt;/customer&gt;<br>
To give firstname the OReilly.Nutshell.CSharp prefix, we must do this:<br>
&lt;nut:customer xmlns:nut=&quot;OReilly.Nutshell.CSharp&quot;&gt;<br>  &lt;<b>nut:</b>firstname&gt;Joe&lt;/firstname&gt;<br>
&lt;/customer&gt;<br>
You can also define a prefix--or prefixes--for the convenience of your descendants,<br>without assigning any of them to the parent element itself. The following defines<br>two  prefixes,  i  and  z,  while  leaving  the  customer  element  itself  with  an  empty<br>namespace:<br>
&lt;customer xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>          xmlns:z=&quot;http://schemas.microsoft.com/2003/10/Serialization/&quot;&gt;<br>
  ...<br>
&lt;/customer&gt;<br>
If this was the root node, the whole document would have i and z at its fingertips.<br>Prefixes are convenient when elements need to draw from a number of namespaces.<br>
Notice  that  both  namespaces  in  this  example  are  URIs.  Using  URIs  (that  you<br>own)  is  standard  practice:  it  ensures  namespace  uniqueness.  So,  in  real  life,  our<br>customer element would more likely be:<br>
&lt;customer xmlns=&quot;http://oreilly.com/schemas/nutshell/csharp&quot;/&gt;<br>
or:<br>
&lt;nut:customer xmlns:nut=&quot;http://oreilly.com/schemas/nutshell/csharp&quot;/&gt;<br>
<b>Attributes<br></b>You can assign namespaces to attributes too. The main difference is that it always<br>requires a prefix. For instance:<br>
&lt;customer xmlns:nut=&quot;OReilly.Nutshell.CSharp&quot; <b>nut:id=&quot;123&quot;</b> /&gt;<br>
Another difference is that an unqualified attribute always has an empty namespace:<br>it never inherits a default namespace from a parent element.<br>
Attributes tend not to need namespaces because their meaning is usually local to the<br>element. An exception is with general-purpose or metadata attributes, such as the<br>nil attribute defined by W3C:<br>
&lt;customer xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>  &lt;firstname&gt;Joe&lt;/firstname&gt;<br>  &lt;lastname <b>xsi:nil=&quot;true&quot;</b>/&gt;<br>&lt;/customer&gt;<br>
This indicates unambiguously that lastname is nil (null in C#) and not an empty<br>string. Because we've used the standard namespace, a general-purpose parsing utility<br>could know with certainty our intention.<br>
<b>436 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=457></a><b>Specifying Namespaces in the X-DOM</b><br>
<b>LINQ to XML</b><br>
So far in this chapter, we've used just simple strings for XElement and XAttribute<br>names. A simple string corresponds to an XML name with an empty namespace--<br>rather like a .NET type defined in the global namespace.<br>
There are a couple of ways to specify an XML namespace. The first is to enclose it<br>in braces, before the local name. For example:<br>
var e = new XElement (&quot;<b>{http://domain.com/xmlspace}customer</b>&quot;, &quot;Bloggs&quot;);<br>
Console.WriteLine (e.ToString());<br>
Here's the resulting XML:<br>
&lt;customer xmlns=&quot;http://domain.com/xmlspace&quot;&gt;Bloggs&lt;/customer&gt;<br>
The second (and more performant) approach is to use the XNamespace and XName<br>types. Here are their definitions:<br>
public sealed class XNamespace<br>
{<br>  public string NamespaceName { get; }<br>}<br>
public sealed class XName     // A local name with optional namespace<br>
{<br>  public string LocalName { get; }<br>
  public XNamespace Namespace { get; }   // Optional<br>
}<br>
Both types define implicit casts from string, so the following is legal:<br>
XNamespace ns   = &quot;http://domain.com/xmlspace&quot;;<br>XName localName = &quot;customer&quot;;<br>XName fullName  = &quot;{http://domain.com/xmlspace}customer&quot;;<br>
XName also overloads the + operator, allowing you to combine a namespace and name<br>without using braces:<br>
XNamespace ns = &quot;http://domain.com/xmlspace&quot;;<br><b>XName fullName = ns + &quot;customer&quot;;<br></b>Console.WriteLine (fullName);     // {http://domain.com/xmlspace}customer<br>
All constructors and methods in the X-DOM that accept an element or attribute<br>name actually accept an XName object rather than a string. The reason you can sub-<br>stitute a string--as in all our examples to date--is because of the implicit cast.<br>
Specifying a namespace is the same whether for an element or an attribute:<br>
XNamespace ns = &quot;http://domain.com/xmlspace&quot;;<br>var data = new XElement (<b>ns + &quot;data&quot;</b>,<br>              new XAttribute (<b>ns + &quot;id&quot;</b>, 123)<br>           );<br>
<b>Names and Namespaces | 437</b><br>
<hr>
<A name=458></a><b>The X-DOM and Default Namespaces<br></b>The X-DOM ignores the concept of default namespaces until it comes time to ac-<br>tually output XML. This means that when you construct a child XElement, you must<br>give it a namespace explicitly if needed: it <i>will not</i> inherit from the parent:<br>
XNamespace ns = &quot;http://domain.com/xmlspace&quot;;<br>var data = new XElement (<b>ns + &quot;data&quot;</b>,<br>
             new XElement (<b>ns + &quot;customer&quot;</b>, &quot;Bloggs&quot;),<br>
             new XElement (<b>ns + &quot;purchase&quot;</b>, &quot;Bicycle&quot;)<br>
           );<br>
The X-DOM does, however, apply default namespaces when reading and outputting<br>XML:<br>
Console.WriteLine (data.ToString());<br>
OUTPUT:<br>
  <b>&lt;data xmlns=&quot;http://domain.com/xmlspace&quot;&gt;<br></b>    <b>&lt;customer&gt;Bloggs&lt;/customer&gt;</b><br>
    <b>&lt;purchase&gt;Bicycle&lt;/purchase&gt;</b><br>
  <b>&lt;/data&gt;</b><br>
Console.WriteLine (data.Element (ns + &quot;customer&quot;).ToString());<br>
OUTPUT:<br>
  <b>&lt;customer xmlns=&quot;http://domain.com/xmlspace&quot;&gt;Bloggs&lt;/customer&gt;</b><br>
If you construct XElement children without specifying namespaces--in other words:<br>
XNamespace ns = &quot;http://domain.com/xmlspace&quot;;<br>var data = new XElement (ns + &quot;data&quot;,<br>             new XElement (<b>&quot;customer&quot;</b>, &quot;Bloggs&quot;),<br>             new XElement (<b>&quot;purchase&quot;</b>, &quot;Bicycle&quot;)<br>           );<br>Console.WriteLine (data.ToString());<br>
you get this result instead:<br>
&lt;data xmlns=&quot;http://domain.com/xmlspace&quot;&gt;<br>  &lt;customer <b>xmlns=&quot;&quot;</b>&gt;Bloggs&lt;/customer&gt;<br>  &lt;purchase <b>xmlns=&quot;&quot;</b>&gt;Bicycle&lt;/purchase&gt;<br>&lt;/data&gt;<br>
Another trap is failing to include a namespace when navigating an X-DOM:<br>
XNamespace ns = &quot;http://domain.com/xmlspace&quot;;<br>var data = new XElement (<b>ns + &quot;data&quot;</b>,<br>             new XElement (<b>ns + &quot;customer&quot;</b>, &quot;Bloggs&quot;),<br>             new XElement (<b>ns + &quot;purchase&quot;</b>, &quot;Bicycle&quot;)<br>           );<br>XElement x = data.Element (ns + &quot;customer&quot;);    // ok<br>XElement y = data.Element (&quot;customer&quot;);         // null<br>
If you build an X-DOM tree without specifying namespaces, you can subsequently<br>assign every element to a single namespace as follows:<br>
<b>438 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=459></a>foreach (XElement e in data.DescendantsAndSelf())<br>
<b>LINQ to XML</b><br>
  if (e.Name.Namespace == &quot;&quot;)<br>    e.Name = ns + e.Name.LocalName;<br>
<b>Prefixes<br></b>The X-DOM treats prefixes just as it treats namespaces: purely as a serialization<br>function. This means you can choose to completely ignore the issue of prefixes--<br>and get by! The only reason you might want to do otherwise is for efficiency when<br>outputting to an XML file. For example, consider this:<br>
XNamespace ns1 = &quot;http://domain.com/space1&quot;;<br>
XNamespace ns2 = &quot;http://domain.com/space2&quot;;<br>
var mix = new XElement (ns1 + &quot;data&quot;,<br>
            new XElement (ns2 + &quot;element&quot;, &quot;value&quot;),<br>
            new XElement (ns2 + &quot;element&quot;, &quot;value&quot;),<br>
            new XElement (ns2 + &quot;element&quot;, &quot;value&quot;)<br>
          );<br>
By default, XElement will serialize this as follows:<br>
&lt;data xmlns=&quot;http://domain.com/space1&quot;&gt;<br>
  &lt;element xmlns=&quot;http://domain.com/space2&quot;&gt;value&lt;/element&gt;<br>  &lt;element xmlns=&quot;http://domain.com/space2&quot;&gt;value&lt;/element&gt;<br>  &lt;element xmlns=&quot;http://domain.com/space2&quot;&gt;value&lt;/element&gt;<br>
&lt;/data&gt;<br>
As you can see, there's a bit of unnecessary duplication. The solution is <i>not</i> to change<br>the way you construct the X-DOM, but instead to give the serializer a hint prior to<br>writing the XML. Do this by adding attributes defining prefixes that you want to see<br>applied. This is typically done on the root element:<br>
mix.SetAttributeValue (XNamespace.Xmlns + &quot;ns1&quot;, ns1);<br>mix.SetAttributeValue (XNamespace.Xmlns + &quot;ns2&quot;, ns2);<br>
This assigns the prefix "ns1" to our XNamespace variable ns1, and "ns2" to ns2. The<br>X-DOM automatically picks up these attributes when serializing and uses them to<br>condense the resulting XML. Here's the result now of calling ToString on mix:<br>
&lt;ns1:data xmlns:ns1=&quot;http://domain.com/space1&quot;<br>          xmlns:ns2=&quot;http://domain.com/space2&quot;&gt;<br>  &lt;ns2:element&gt;value&lt;/ns2:element&gt;<br>  &lt;ns2:element&gt;value&lt;/ns2:element&gt;<br>  &lt;ns2:element&gt;value&lt;/ns2:element&gt;<br>&lt;/ns1:data&gt;<br>
Prefixes don't change the way you construct, query, or update the X-DOM--for<br>these activities, you ignore the presence of prefixes and continue to use full names.<br>Prefixes come into play only when converting to and from XML files or streams.<br>
Prefixes are also honored in serializing attributes. In the following example, we re-<br>cord a customer's date of birth and credit as &quot;nil&quot;, using the W3C-standard attrib-<br>ute. The highlighted line ensures that the prefix is serialized without unnecessary<br>namespace repetition:<br>
<b>Names and Namespaces | 439</b><br>
<hr>
<A name=460></a>XNamespace xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot;;<br>
var nil = new XAttribute (xsi + &quot;nil&quot;, true);<br>
var cust = new XElement (&quot;customers&quot;,<br>
             <b>new XAttribute (XNamespace.Xmlns + &quot;xsi&quot;, xsi),</b><br>
             new XElement (&quot;customer&quot;,<br>               new XElement (&quot;lastname&quot;, &quot;Bloggs&quot;),<br>               new XElement (&quot;dob&quot;, nil),<br>
               new XElement (&quot;credit&quot;, nil)<br>
             )<br>           );<br>
This is its XML:<br>
&lt;customers xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>  &lt;customer&gt;<br>
    &lt;lastname&gt;Bloggs&lt;/lastname&gt;<br>
    &lt;dob xsi:nil=&quot;true&quot; /&gt;<br>    &lt;credit xsi:nil=&quot;true&quot; /&gt;<br>  &lt;/customer&gt;<br>
&lt;/customers&gt;<br>
For brevity, we predeclared the nil XAttribute so that we could use it twice in build-<br>ing  the  DOM.  You're  allowed  to  reference  the  same  attribute  twice  because  it's<br>automatically duplicated as required.<br>
<b>Annotations<br></b>You can attach custom data to any XObject with an annotation. Annotations are<br>intended for your own private use and are treated as black boxes by X-DOM. If<br>you've ever used the Tag property on a Windows Forms or WPF control, you'll be<br>familiar with the concept--the difference is that you have multiple annotations, and<br>your annotations can be <i>privately scoped</i>. You can create an annotation that other<br>types cannot even see--let alone overwrite.<br>
The following methods on XObject add and remove annotations:<br>
public void AddAnnotation (object annotation)<br>public void RemoveAnnotations&lt;T&gt;()     where T : class<br>
The following methods retrieve annotations:<br>
public T Annotation&lt;T&gt;()               where T : class<br>public IEnumerable&lt;T&gt; Annotations&lt;T&gt;() where T : class<br>
Each annotation is keyed by its <i>type</i>, which must be a reference type. The following<br>adds and then retrieves a string annotation:<br>
XElement e = new XElement (&quot;test&quot;);<br>e.AddAnnotation (&quot;Hello&quot;);<br>Console.WriteLine (e.Annotation&lt;string&gt;());   // Hello<br>
You can add multiple annotations of the same type, and then use the Annotations<br>method to retrieve a <i>sequence</i> of matches.<br>
<b>440 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=461></a>A public type such as string doesn't make a great key, however, because code in<br>
<b>LINQ to XML</b><br>
other types can interfere with your annotations. A better approach is to use an in-<br>ternal or (nested) private class:<br>
class X<br>
{<br>  class CustomData { internal string Message; }   // Private nested type<br>
  static void Test()<br>
  {<br>
    XElement e = new XElement (&quot;test&quot;);<br>    e.AddAnnotation (new CustomData { Message = &quot;Hello&quot; } );<br>
    Console.Write (e.Annotations&lt;CustomData&gt;().First().Message);  // Hello<br>
  }<br>
}<br>
To remove annotations, you must also have access to the key's type:<br>
e.RemoveAnnotations&lt;CustomData&gt;();<br>
<b>Projecting into an X-DOM<br></b>So far, we've shown how to use LINQ to get data <i>out</i> of an X-DOM. You can also<br>use LINQ queries to project <i>into</i> an X-DOM. The source can be anything over which<br>LINQ can query, such as:<br>
· LINQ to SQL or Entity Framework queries<br>· A local collection<br>· Another X-DOM<br>
Regardless of the source, the strategy is the same in using LINQ to emit an X-DOM:<br>first write a <i>functional construction</i> expression that produces the desired X-DOM<br>shape, and then build a LINQ query around the expression.<br>
For instance, suppose we want to retrieve customers from a database into the fol-<br>lowing XML:<br>
&lt;customers&gt;<br>  &lt;customer id=&quot;1&quot;&gt;<br>    &lt;name&gt;Sue&lt;/name&gt;<br>    &lt;buys&gt;3&lt;/buys&gt;<br>  &lt;/customer&gt;<br>  ...<br>&lt;/customers&gt;<br>
We start by writing a functional construction expression for the X-DOM using sim-<br>ple literals:<br>
var customers =<br>  new XElement (&quot;customers&quot;,<br>    new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, 1),<br>      new XElement (&quot;name&quot;, &quot;Sue&quot;),<br>      new XElement (&quot;buys&quot;, 3)<br>    )<br>  );<br>
<b>Projecting into an X-DOM | 441</b><br>
<hr>
<A name=462></a>We then turn this into a projection and build a LINQ query around it:<br>
var customers =<br>
  new XElement (&quot;customers&quot;,<br>
    <b>from c in dataContext.Customers<br></b>    <b>select<br></b>      new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, <b>c.ID</b>),<br>
        new XElement (&quot;name&quot;, <b>c.Name</b>),<br>
        new XElement (&quot;buys&quot;, <b>c.Purchases.Count</b>)<br>      )<br>    );<br>
In Entity Framework, you must call .ToList() after retrieving<br>customers, so that the third line reads:<br>
from c in objectContext.Customers.<b>ToList()</b><br>
Here's the result:<br>
&lt;customers&gt;<br>
  &lt;customer id=&quot;1&quot;&gt;<br>
    &lt;name&gt;Tom&lt;/name&gt;<br>
    &lt;buys&gt;3&lt;/buys&gt;<br>
  &lt;/customer&gt;<br>  &lt;customer id=&quot;2&quot;&gt;<br>
    &lt;name&gt;Harry&lt;/name&gt;<br>
    &lt;buys&gt;2&lt;/buys&gt;<br>
  &lt;/customer&gt;<br>    ...<br>&lt;/customers&gt;<br>
We can see how this works more clearly by constructing the same query in two steps.<br>First:<br>
IEnumerable&lt;XElement&gt; sqlQuery =<br>  from c in dataContext.Customers<br>
  select<br>    new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, c.ID),<br>
      new XElement (&quot;name&quot;, c.Name),<br>      new XElement (&quot;buys&quot;, c.Purchases.Count)<br>    );<br>
This inner portion is a normal LINQ to SQL query that projects into custom types<br>(from LINQ to SQL's perspective). Here's the second step:<br>
var customers = new XElement (&quot;customers&quot;, sqlQuery);<br>
This  constructs  the  root  XElement.  The  only  thing  unusual  is  that  the  content,<br>sqlQuery, is not a single XElement but an IQueryable&lt;XElement&gt;--which implements<br>IEnumerable&lt;XElement&gt;. Remember that in the processing of XML content, collec-<br>tions are automatically enumerated. So, each XElement gets added as a child node.<br>This outer query also defines the line at which the query transitions from being a<br>database query to a local LINQ to enumerable query. XElement's constructor doesn't<br>
<b>442 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=463></a>know about IQueryable&lt;&gt;, so it forces enumeration of the database query--and ex-<br>
<b>LINQ to XML</b><br>
ecution of the SQL statement.<br>
<b>Eliminating Empty Elements<br></b>Suppose in the preceding example that we also wanted to include details of the<br>customer's most recent high-value purchase. We could do this as follows:<br>
var customers =<br>
  new XElement (&quot;customers&quot;,<br>
    from c in dataContext.Customers<br>    let lastBigBuy = (from p in c.Purchases<br>
                      where p.Price &gt; 1000<br>
                      orderby p.Date descending<br>
                      select p).FirstOrDefault()<br>    select<br>      new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, c.ID),<br>
        new XElement (&quot;name&quot;, c.Name),<br>
        new XElement (&quot;buys&quot;, c.Purchases.Count),<br>
        <b>new XElement (&quot;lastBigBuy&quot;,<br></b>          <b>new XElement (&quot;description&quot;,</b><br>
            <b>lastBigBuy == null ? null : lastBigBuy.Description),</b><br>
          <b>new XElement (&quot;price&quot;,</b><br>
            <b>lastBigBuy == null ? 0m : lastBigBuy.Price)</b><br>
        )<br>
      )<br>
  );<br>
This emits empty elements, though, for customers with no high-value purchases. (If<br>it was a local query rather than a database query, it would throw a NullReferenceEx<br>ception.) In such cases, it would be better to omit the lastBigBuy node entirely. We<br>can achieve this by wrapping the constructor for the lastBigBuy element in a con-<br>ditional operator:<br>
    select<br>      new XElement (&quot;customer&quot;, new XAttribute (&quot;id&quot;, c.ID),<br>        new XElement (&quot;name&quot;, c.Name),<br>        new XElement (&quot;buys&quot;, c.Purchases.Count),<br>        <b>lastBigBuy == null ? null :<br></b>          <b>new XElement (&quot;lastBigBuy&quot;,<br></b>            <b>new XElement (&quot;description&quot;, lastBigBuy.Description),<br></b>            <b>new XElement (&quot;price&quot;, lastBigBuy.Price)</b><br>
For customers with no lastBigBuy, a null is emitted instead of an empty XElement.<br>This is what we want, because null content is simply ignored.<br>
<b>Streaming a Projection<br></b>If you're projecting into an X-DOM only to Save it (or call ToString on it), you can<br>improve memory efficiency through an XStreamingElement. An XStreamingElement is<br>a cut-down version of XElement that applies <i>deferred loading</i> semantics to its child<br>content. To use it, you simply replace the outer XElements with XStreamingElements:<br>
<b>Projecting into an X-DOM | 443</b><br>
<hr>
<A name=464></a>var customers =<br>
  new <b>XStreamingElement</b> (&quot;customers&quot;,<br>    from c in dataContext.Customers<br>    select<br>
      new <b>XStreamingElement</b> (&quot;customer&quot;, new XAttribute (&quot;id&quot;, c.ID),<br>
        new XElement (&quot;name&quot;, c.Name),<br>        new XElement (&quot;buys&quot;, c.Purchases.Count)<br>      )<br>
    );<br>
customers.Save (&quot;data.xml&quot;);<br>
The queries passed into an XStreamingElement's constructor are not enumerated un-<br>til you call Save, ToString, or WriteTo on the element; this avoids loading the whole<br>X-DOM into memory at once. The flipside is that the queries are reevaluated, should<br>you re-Save. Also, you cannot traverse an XStreamingElement's child content--it does<br>not expose methods such as Elements or Attributes.<br>
XStreamingElement is not based on XObject--or any other class--because it has such<br>a limited set of members. The only members it has, besides  Save, ToString, and<br>WriteTo, are an Add method, which accepts content like the constructor and a Name<br>property.<br>
XStreamingElement does not allow you to <i>read</i> content in a streamed fashion--for<br>this, you must use an XmlReader in conjunction with the X-DOM. We describe how<br>to do this in the section "Patterns for Using XmlReader/XmlWriter" on page 459<br>in Chapter 11.<br>
<b>Transforming an X-DOM<br></b>You can transform an X-DOM by reprojecting it. For instance, suppose we want to<br>transform an <i>msbuild</i> XML file, used by the C# compiler and Visual Studio to de-<br>scribe a project, into a simple format suitable for generating a report. An <i>msbuild</i> file<br>looks like this:<br>
&lt;Project DefaultTargets=&quot;Build&quot; xmlns=&quot;http://schemas.microsoft.com/dev...&gt;<br>  &lt;PropertyGroup&gt;<br>    &lt;Platform Condition=&quot; '$(Platform)' == '' &quot;&gt;AnyCPU&lt;/Platform&gt;<br>    &lt;ProductVersion&gt;9.0.11209&lt;/ProductVersion&gt;<br>    ...<br>  &lt;/PropertyGroup&gt;<br>  &lt;ItemGroup&gt;<br>    &lt;Compile Include=&quot;ObjectGraph.cs&quot; /&gt;<br>    &lt;Compile Include=&quot;Program.cs&quot; /&gt;<br>    &lt;Compile Include=&quot;Properties\AssemblyInfo.cs&quot; /&gt;<br>    &lt;Compile Include=&quot;Tests\Aggregation.cs&quot; /&gt;<br>    &lt;Compile Include=&quot;Tests\Advanced\RecursiveXml.cs&quot; /&gt;<br>  &lt;/ItemGroup&gt;<br>  &lt;ItemGroup&gt;<br>    ...<br>  &lt;/ItemGroup&gt;<br>   ...<br>&lt;/Project&gt;<br>
Let's say we want to include only files, as follows:<br>
<b>444 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=465></a>&lt;ProjectReport&gt;<br>
<b>LINQ to XML</b><br>
  &lt;File&gt;ObjectGraph.cs&lt;/File&gt;<br>  &lt;File&gt;Program.cs&lt;/File&gt;<br>  &lt;File&gt;Properties\AssemblyInfo.cs&lt;/File&gt;<br>
  &lt;File&gt;Tests\Aggregation.cs&lt;/File&gt;<br>
  &lt;File&gt;Tests\Advanced\RecursiveXml.cs&lt;/File&gt;<br>&lt;/ProjectReport&gt;<br>
The following query performs this transformation:<br>
XElement project = XElement.Load (&quot;myProjectFile.csproj&quot;);<br>XNamespace ns = project.Name.Namespace;<br>
var query =<br>
  new XElement (&quot;ProjectReport&quot;,<br>    from compileItem in<br>      project.Elements (ns + &quot;ItemGroup&quot;).Elements (ns + &quot;Compile&quot;)<br>
    let include = compileItem.Attribute (&quot;Include&quot;)<br>
    where include != null<br>    select new XElement (&quot;File&quot;, include.Value)<br>  );<br>
The query first extracts all ItemGroup elements, and then uses the Elements extension<br>method to obtain a flat sequence of all their Compile subelements. Notice that we<br>had to specify an XML namespace--everything in the original file inherits the name-<br>space defined by the Project element--so a local element name such as ItemGroup<br>won't work on its own. Then, we extracted the Include attribute value and projected<br>its value as an element.<br>
<b>Advanced transformations<br></b>When querying a local collection such as an X-DOM, you're free to write custom<br>query operators to assist with more complex queries.<br>
Suppose in the preceding example that we instead wanted a hierarchical output,<br>based on folders:<br>
&lt;Project&gt;<br>  &lt;File&gt;ObjectGraph.cs&lt;/File&gt;<br>  &lt;File&gt;Program.cs&lt;/File&gt;<br>  &lt;Folder name=&quot;Properties&quot;&gt;<br>    &lt;File&gt;AssemblyInfo.cs&lt;/File&gt;<br>  &lt;/Folder&gt;<br>  &lt;Folder name=&quot;Tests&quot;&gt;<br>    &lt;File&gt;Aggregation.cs&lt;/File&gt;<br>    &lt;Folder name=&quot;Advanced&quot;&gt;<br>      &lt;File&gt;RecursiveXml.cs&lt;/File&gt;<br>    &lt;/Folder&gt;<br>  &lt;/Folder&gt;<br>&lt;/Project&gt;<br>
To produce this, we need to process path strings such as <i>Tests\Advanced\Recursi-<br>veXml.cs</i> recursively. The following method does just this: it accepts a sequence of<br>path strings and emits an X-DOM hierarchy consistent with our desired output:<br>
<b>Projecting into an X-DOM | 445</b><br>
<hr>
<A name=466></a>static IEnumerable&lt;XElement&gt; ExpandPaths (IEnumerable&lt;string&gt; paths)<br>
{<br>  var brokenUp = from path in paths<br>                 let split = path.Split (new char[] { '\\' }, 2)<br>
                 orderby split[0]<br>
                 select new<br>                 {<br>                   name = split[0],<br>
                   remainder = split.ElementAtOrDefault (1)<br>
                 };<br>
  IEnumerable&lt;XElement&gt; files = from b in brokenUp<br>
                                where b.remainder == null<br>                                select new XElement (&quot;file&quot;, b.name);<br>
  IEnumerable&lt;XElement&gt; folders = from b in brokenUp<br>                                  where b.remainder != null<br>
                                  group b.remainder by b.name into grp<br>
                                  select new XElement (&quot;folder&quot;,<br>                                    new XAttribute (&quot;name&quot;, grp.Key),<br>                                    ExpandPaths (grp)<br>
                                  );<br>
  return files.Concat (folders);<br>}<br>
The first query splits each path string at the first backslash, into a name + remainder:<br>
Tests\Advanced\RecursiveXml.cs -&gt; Tests + Advanced\RecursiveXml.cs<br>
If remainder is null, we're dealing with a straight filename. The files query extracts<br>these cases.<br>
If remainder is not null, we've got a folder. The folders query handles these cases.<br>Because other files can be in the same folder, it must group by folder name to bring<br>them all together. For each group, it then executes the same function for the sub-<br>elements.<br>
The  final  result  is  a  concatenation  of  files  and  folders.  The  Concat  operator<br>preserves  order,  so  all  the  files  come  first,  alphabetically,  then  all  the  folders,<br>alphabetically.<br>
With this method in place, we can complete the query in two steps. First, we extract<br>a simple sequence of path strings:<br>
IEnumerable&lt;string&gt; paths =<br>  from compileItem in<br>    project.Elements (ns + &quot;ItemGroup&quot;).Elements (ns + &quot;Compile&quot;)<br>  let include = compileItem.Attribute (&quot;Include&quot;)<br>  where include != null<br>  select include.Value;<br>
Then, we feed this into our ExpandPaths method for the final result:<br>
var query = new XElement (&quot;Project&quot;, ExpandPaths (paths));<br>
<b>446 | Chapter 10:</b><b>LINQ to XML</b><br>
<hr>
<A name=467></a><b>11</b><br>
<b>Other XML Technologies</b><br>
The System.Xml namespace comprises the following namespaces and core classes:<br>
System.Xml.*<br>
XmlReader<i> and </i>XmlWriter<br>
High-performance, forward-only cursors for reading or writing an XML<br>stream<br>
XmlDocument<br>
Represents an XML document in a W3C-style DOM<br>
System.Xml.XPath<br>
Infrastructure and API (XPathNavigator) for XPath, a string-based language for<br>querying XML<br>
System.Xml.XmlSchema<br>
Infrastructure and API for (W3C) XSD schemas<br>
System.Xml.Xsl<br>
Infrastructure  and  API  (XslCompiledTransform)  for  performing  (W3C)  XSLT<br>transformations of XML<br>
System.Xml.Serialization<br>
Supports the serialization of classes to and from XML (see Chapter 16)<br>
System.Xml.XLinq<br>
Modern, simplified, LINQ-centric version of XmlDocument (see Chapter 10)<br>
W3C  is  an  abbreviation  for  World  Wide  Web  Consortium,  where  the  XML<br>standards are defined.<br>
XmlConvert, the static class for parsing and formatting XML strings, is covered in<br>Chapter 6.<br>
<b>447</b><br>
<hr>
<A name=468></a><b>XmlReader<br></b>XmlReader is a high-performance class for reading an XML stream in a low-level,<br>forward-only manner.<br>
Consider the following XML file:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>
&lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
&lt;/customer&gt;<br>
To instantiate an XmlReader, you call the static XmlReader.Create method, passing in<br>a Stream, a TextReader, or a URI string. For example:<br>
using (XmlReader reader = XmlReader.Create (&quot;customer.xml&quot;))<br>
  ...<br>
To construct an XmlReader that reads from a string:<br>
XmlReader reader = XmlReader.Create (<br>
  new System.IO.StringReader (myString));<br>
You can also pass in an XmlReaderSettings object to control parsing and validation<br>options. The following three properties on XmlReaderSettings are particularly useful<br>for skipping over superfluous content:<br>
bool IgnoreComments                  // Skip over comment nodes?<br>bool IgnoreProcessingInstructions    // Skip over processing instructions?<br>bool IgnoreWhitespace                // Skip over whitespace?<br>
In the following example, we instruct the reader not to emit whitespace nodes, which<br>are a distraction in typical scenarios:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>settings.IgnoreWhitespace = true;<br>
using (XmlReader reader = XmlReader.Create (&quot;customer.xml&quot;, settings))<br>  ...<br>
Another useful property on XmlReaderSettings is ConformanceLevel. Its default value<br>of Document instructs the reader to assume a valid XML document with a single root<br>node. This is a problem if you want to read just an inner portion of XML, containing<br>multiple nodes:<br>
&lt;firstname&gt;Jim&lt;/firstname&gt;<br>&lt;lastname&gt;Bo&lt;/lastname&gt;<br>
To  read  this  without  throwing  an  exception,  you  must  set  ConformanceLevel  to<br>Fragment.<br>
XmlReaderSettings also has a property called CloseInput, which indicates whether<br>to close the underlying stream when the reader is closed (there's an analogous prop-<br>erty on XmlWriterSettings called CloseOutput). The default value for CloseInput and<br>CloseOutput is true.<br>
<b>448 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=469></a><b>Reading Nodes<br></b>The units of an XML stream are <i>XML nodes</i>. The reader traverses the stream in<br>textual (depth-first) order. The Depth property of the reader returns the current depth<br>of the cursor.<br>
The most primitive way to read from an XmlReader is to call Read. It advances to the<br>next node in the XML stream, rather like MoveNext in IEnumerator. The first call to<br>
<b>More XML</b><br>
Read positions the cursor at the first node. When Read returns false, it means the<br>cursor has advanced <i>past</i> the last node, at which point the XmlReader should be closed<br>and abandoned.<br>
In this example, we read every node in the XML stream, outputting each node type<br>as we go:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>
settings.IgnoreWhitespace = true;<br>
using (XmlReader reader = XmlReader.Create (&quot;customer.xml&quot;, settings))<br>
  while (reader.Read())<br>
  {<br>
    Console.Write (new string (' ',reader.Depth*2));  // Write indentation<br>    Console.WriteLine (reader.NodeType);<br>
  }<br>
The output is as follows:<br>
XmlDeclaration<br>
Element<br>  Element<br>
    Text<br>  EndElement<br>  Element<br>    Text<br>  EndElement<br>EndElement<br>
Attributes are not included in Read-based traversal (see the sec-<br>tion "Reading Attributes" on page 454, later in this chapter).<br>
NodeType is of type XmlNodeType, which is an enum with these members:<br>
None<br>
Comment<br>
Document<br>
XmlDeclaration<br>
Entity<br>
DocumentType<br>
Element<br>
EndEntity<br>
DocumentFragment<br>
EndElement<br>
EntityReference<br>
Notation<br>
Text<br>
ProcessingInstruction<br>
Whitespace<br>
Attribute<br>
CDATA<br>
SignificantWhitespace<br>
<b>XmlReader | 449</b><br>
<hr>
<A name=470></a>Two string properties on XmlReader provide access to a node's content: Name and<br>Value. Depending on the node type, either Name or Value (or both) is populated:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>settings.IgnoreWhitespace = true;<br>
settings.ProhibitDtd = false;      // Must set this to read DTDs<br>
using (XmlReader r = XmlReader.Create (&quot;customer.xml&quot;, settings))<br>
  while (r.Read())<br>  {<br>
    Console.Write (r.NodeType.ToString().PadRight (17, '-'));<br>
    Console.Write (&quot;&gt; &quot;.PadRight (r.Depth * 3));<br>
    switch (r.NodeType)<br>    {<br>
      case XmlNodeType.Element:<br>
      case XmlNodeType.EndElement:<br>
        Console.WriteLine (r.Name); break;<br>
      case XmlNodeType.Text:<br>
      case XmlNodeType.CDATA:<br>
      case XmlNodeType.Comment:<br>
      case XmlNodeType.XmlDeclaration:<br>        Console.WriteLine (r.Value); break;<br>
      case XmlNodeType.DocumentType:<br>
        Console.WriteLine (r.Name + &quot; - &quot; + r.Value); break;<br>
      default: break;<br>    }<br>
  }<br>
To demonstrate this, we'll expand our XML file to include a document type, entity,<br>CDATA, and comment:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br>&lt;!DOCTYPE customer [ &lt;!ENTITY tc &quot;Top Customer&quot;&gt; ]&gt;<br>&lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>  &lt;quote&gt;&lt;![CDATA[C#'s operators include: &lt; &gt; &amp;]]&gt;&lt;/quote&gt;<br>  &lt;notes&gt;Jim Bo is a &amp;tc;&lt;/notes&gt;<br>  &lt;!--  That wasn't so bad! --&gt;<br>&lt;/customer&gt;<br>
An entity is like a macro; a CDATA is like a verbatim string (<b>@</b>&quot;...&quot;) in C#. Here's<br>the result:<br>
XmlDeclaration---&gt; version=&quot;1.0&quot; encoding=&quot;utf-8&quot;<br>DocumentType-----&gt; customer -  &lt;!ENTITY tc &quot;Top Customer&quot;&gt;<br>Element----------&gt; customer<br>Element----------&gt;  firstname<br>Text-------------&gt;     Jim<br>EndElement-------&gt;  firstname<br>Element----------&gt;  lastname<br>Text-------------&gt;     Bo<br>EndElement-------&gt;  lastname<br>
<b>450 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=471></a>Element----------&gt;  quote<br>
CDATA------------&gt;     C#'s operators include: &lt; &gt; &amp;<br>EndElement-------&gt;  quote<br>Element----------&gt;  notes<br>
Text-------------&gt;     Jim Bo is a Top Customer<br>
EndElement-------&gt;  notes<br>Comment----------&gt;    That wasn't so bad!<br>EndElement-------&gt;  customer<br>
<b>More XML</b><br>
XmlReader automatically resolves entities, so in our example, the entity reference<br>&amp;tc; expands into Top Customer.<br>
<b>Reading Elements<br></b>Often, you already know the structure of the XML document that you're reading.<br>To help with this, XmlReader provides a range of methods that read while <i>presum-<br>ing</i> a particular structure. This simplifies your code, as well as performing some<br>validation at the same time.<br>
XmlReader  throws  an  XmlException  if  any  validation  fails.<br>XmlException has LineNumber and LinePosition properties indi-<br>cating  where  the  error  occurred--logging  this  information  is<br>essential if the XML file is large!<br>
ReadStartElement verifies that the current NodeType is StartElement, and then calls<br>Read. If you specify a name, it verifies that it matches that of the current element.<br>
ReadEndElement verifies that the current NodeType is EndElement, and then calls Read.<br>
For instance, we could read this:<br>
&lt;firstname&gt;Jim&lt;/firstname&gt;<br>
as follows:<br>
reader.ReadStartElement (&quot;firstname&quot;);<br>Console.WriteLine (reader.Value);<br>reader.ReadEndElement();<br>
The ReadElementContentAsString method does all of this in one hit. It reads a start<br>element, a text node, and an end element, returning the content as a string:<br>
string firstName = reader.ReadElementContentAsString (&quot;firstname&quot;, &quot;&quot;);<br>
The second argument refers to the namespace, which is blank in this example. There<br>are  also  typed  versions  of  this  method,  such  as  ReadElementContentAsInt,  which<br>parse the result. Returning to our original XML document:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>  &lt;creditlimit&gt;500.00&lt;/creditlimit&gt;    &lt;!-- OK, we sneaked this in! --&gt;<br>&lt;/customer&gt;<br>
<b>XmlReader | 451</b><br>
<hr>
<A name=472></a>We could read it in as follows:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>
settings.IgnoreWhitespace = true;<br>
using (XmlReader r = XmlReader.Create (&quot;customer.xml&quot;, settings))<br>{<br>  r.MoveToContent();                // Skip over the XML declaration<br>
  r.<b>ReadStartElement</b> (&quot;customer&quot;);<br>  string firstName    = r.<b>ReadElementContentAsString</b> (&quot;firstname&quot;, &quot;&quot;);<br>  string lastName     = r.<b>ReadElementContentAsString</b> (&quot;lastname&quot;, &quot;&quot;);<br>
  decimal creditLimit = r.<b>ReadElementContentAsDecimal</b> (&quot;creditlimit&quot;, &quot;&quot;);<br>
  r.MoveToContent();      // Skip over that pesky comment<br>  r.<b>ReadEndElement</b>();     // Read the closing customer tag<br>
}<br>
The MoveToContent method is really useful. It skips over all the<br>fluff: XML declarations, whitespace, comments, and processing<br>instructions. You can also instruct the reader to do most of this<br>automatically through the properties on XmlReaderSettings.<br>
<b>Optional elements<br></b>In the previous example, suppose that &lt;lastname&gt; was optional. The solution to this<br>is straightforward:<br>
r.ReadStartElement (&quot;customer&quot;);<br>string firstName    = r. ReadElementContentAsString (&quot;firstname&quot;, &quot;&quot;);<br>
<b>string lastName     = r.Name == &quot;lastname&quot;</b><br>
                      <b>? r.ReadElementContentAsString() : null;<br></b>decimal creditLimit = r.ReadElementContentAsDecimal (&quot;creditlimit&quot;, &quot;&quot;);<br>
<b>Random element order<br></b>The examples in this section rely on elements appearing in the XML file in a set<br>order. If you need to cope with elements appearing in any order, the easiest solution<br>is to read that section of the XML into an X-DOM. We describe how to do this later<br>in the section "Patterns for Using XmlReader/XmlWriter" on page 459.<br>
<b>Empty elements<br></b>The way that XmlReader handles empty elements presents a horrible trap. Consider<br>the following element:<br>
&lt;customerList&gt;&lt;/customerList&gt;<br>
In XML, this is equivalent to:<br>
&lt;customerList/&gt;<br>
And yet, XmlReader treats the two differently. In the first case, the following code<br>works as expected:<br>
<b>452 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=473></a>reader.ReadStartElement (&quot;customerList&quot;);<br>
reader.ReadEndElement();<br>
In the second case, ReadEndElement throws an exception, because there is no separate<br>"end element" as far as XmlReader is concerned. The workaround is to check for an<br>empty element as follows:<br>
bool isEmpty = reader.IsEmptyElement;<br>
reader.ReadStartElement (&quot;customerList&quot;);<br>
<b>More XML</b><br>
if (!isEmpty) reader.ReadEndElement();<br>
In reality, this is a nuisance only when the element in question may contain child<br>elements (such as a customer list). With elements that wrap simple text (such as<br>firstname), you can avoid the whole issue by calling a method such as ReadElement<br>ContentAsString. The ReadElement<i>XXX</i> methods handle both kinds of empty elements<br>correctly.<br>
<b>Other ReadXXX methods<br></b>Table 11-1 summarizes all Read<i>XXX</i> methods in XmlReader. Most of these are designed<br>to work with elements. The sample XML fragment shown in bold is the section read<br>by the method described.<br>
<i>Table 11-1. Read methods</i><br>
<b>Works on</b><br>
<b>Input</b><br>
<b>Data</b><br>
<b>Members</b><br>
<b>NodeType</b><br>
<b>Sample XML fragment</b><br>
<b>parameters</b><br>
<b>returned</b><br>
ReadContentAs<i>XXX</i><br>
Text<br>
&lt;a&gt;<b>x</b>&lt;/a&gt;<br>
 <br>
x<br>
ReadString<br>
Text<br>
&lt;a&gt;<b>x</b>&lt;/a&gt;<br>
 <br>
x<br>
ReadElementString<br>
Element<br>
<b>&lt;a&gt;x&lt;/a&gt;</b><br>
 <br>
x<br>
ReadElementContentAs<i>XXX</i><br>
Element<br>
<b>&lt;a&gt;x&lt;/a&gt;</b><br>
 <br>
x<br>
ReadInnerXml<br>
Element<br>
<b>&lt;a&gt;x&lt;/a&gt;</b><br>
 <br>
x<br>
ReadOuterXml<br>
Element<br>
<b>&lt;a&gt;x&lt;/a&gt;</b><br>
 <br>
&lt;a&gt;x&lt;/a&gt;<br>
ReadStartElement<br>
Element<br>
<b>&lt;a&gt;</b>x&lt;/a&gt;<br>
 <br>
 <br>
ReadEndElement<br>
Element<br>
&lt;a&gt;x<b>&lt;/a&gt;</b><br>
 <br>
 <br>
ReadSubtree<br>
Element<br>
<b>&lt;a&gt;x&lt;/a&gt;</b><br>
 <br>
&lt;a&gt;x&lt;/a&gt;<br>
ReadToDescendent<br>
Element<br>
<b>&lt;a&gt;x</b>&lt;b&gt;&lt;/b&gt;&lt;/a&gt;<br>
&quot;b&quot;<br>
 <br>
ReadToFollowing<br>
Element<br>
<b>&lt;a&gt;x</b>&lt;b&gt;&lt;/b&gt;&lt;/a&gt;<br>
&quot;b&quot;<br>
 <br>
ReadToNextSibling<br>
Element<br>
<b>&lt;a&gt;x&lt;/a</b>&gt;&lt;b&gt;&lt;/b&gt;<br>
&quot;b&quot;<br>
 <br>
ReadAttributeValue<br>
Attribute<br>
See "Reading Attrib-<br>
 <br>
 <br>
utes" on page 454<br>
The  ReadContentAs<i>XXX</i>  methods  parse  a  text  node  into  type  <i>XXX</i>.  Internally,  the<br>XmlConvert class performs the string-to-type conversion. The text node can be within<br>an element or an attribute.<br>
<b>XmlReader | 453</b><br>
<hr>
<A name=474></a>The  ReadElementContentAs<i>XXX</i>  methods  are  wrappers  around  corresponding  Read<br>ContentAs<i>XXX</i> methods. They apply to the <i>element</i> node, rather than the <i>text</i> node<br>enclosed by the element.<br>
The typed Read<i>XXX</i> methods also include versions that read base<br>64 and BinHex formatted data into a byte array.<br>
ReadInnerXml is typically applied to an element, and it reads and returns an element<br>and all its descendents. When applied to an attribute, it returns the value of the<br>attribute.<br>
ReadOuterXml is the same as ReadInnerXml, except it includes rather than excludes<br>the element at the cursor position.<br>
ReadSubtree returns a proxy reader that provides a view over just the current element<br>(and its descendents). The proxy reader must be closed before the original reader<br>can be safely read again. At the point the proxy reader is closed, the cursor position<br>of the original reader moves to the end of the subtree.<br>
ReadToDescendent moves the cursor to the start of the first descendent node with the<br>specified name/namespace.<br>
ReadToFollowing  moves  the  cursor  to  the  start  of  the  first  node--regardless  of<br>depth--with the specified name/namespace.<br>
ReadToNextSibling moves the cursor to the start of the first sibling node with the<br>specified name/namespace.<br>
ReadString  and  ReadElementString  behave  like  ReadContentAsString  and  ReadEle<br>mentContentAsString, except that they throw an exception if there's more than a<br><i>single</i> text node within the element. In general, these methods should be avoided,<br>as they throw an exception if an element contains a comment.<br>
<b>Reading Attributes<br></b>XmlReader provides an indexer giving you direct (random) access to an element's<br>attributes--by  name  or  position.  Using  the  indexer  is  equivalent  to  calling<br>GetAttribute.<br>
Given the following XML fragment:<br>
&lt;customer id=&quot;123&quot; status=&quot;archived&quot;/&gt;<br>
we could read its attributes as follows:<br>
Console.WriteLine (reader [&quot;id&quot;]);              // 123<br>Console.WriteLine (reader [&quot;status&quot;]);          // archived<br>Console.WriteLine (reader [&quot;bogus&quot;] == null);   // True<br>
<b>454 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=475></a>The XmlReader must be positioned <i>on a start element</i> in order to<br>read  attributes.  <i>After</i>  calling  ReadStartElement,  the  attributes<br>are gone forever!<br>
Although attribute order is semantically irrelevant, you can access attributes by their<br>ordinal position. We could rewrite the preceding example as follows:<br>
<b>More XML</b><br>
Console.WriteLine (reader [0]);            // 123<br>Console.WriteLine (reader [1]);            // archived<br>
The indexer also lets you specify the attribute's namespace--if it has one.<br>
AttributeCount returns the number of attributes for the current node.<br>
<b>Attribute nodes<br></b>To explicitly traverse attribute nodes, you must make a special diversion from the<br>normal path of just calling Read. A good reason to do so is if you want to parse<br>attribute values into other types, via the ReadContentAs<i>XXX</i> methods.<br>The diversion must begin from a <i>start element</i>. To make the job easier, the forward-<br>only rule is relaxed during attribute traversal: you can jump to any attribute (forward<br>or backward) by calling MoveToAttribute.<br>
MoveToElement returns you to the start element from anyplace<br>within the attribute node diversion.<br>
Returning to our previous example:<br>
&lt;customer id=&quot;123&quot; status=&quot;archived&quot;/&gt;<br>
we can do this:<br>
reader.MoveToAttribute (&quot;status&quot;);<br>string status = ReadContentAsString();<br>
reader.MoveToAttribute (&quot;id&quot;);<br>int id = ReadContentAsInt();<br>
MoveToAttribute returns false if the specified attribute doesn't exist.<br>
You can also traverse each attribute in sequence by calling the MoveToFirstAttri<br>bute and then the MoveToNextAttribute methods:<br>
if (reader.MoveToFirstAttribute())<br>
  do<br>  {<br>    Console.WriteLine (reader.Name + &quot;=&quot; + reader.Value);<br>  }<br>  while (reader.MoveToNextAttribute());<br>
// OUTPUT:<br>
<b>XmlReader | 455</b><br>
<hr>
<A name=476></a>id=123<br>
status=archived<br>
<b>Namespaces and Prefixes<br></b>XmlReader provides two parallel systems for referring to element and attribute names:<br>
· Name<br>· NamespaceURI and LocalName<br>
Whenever you read an element's Name property or call a method that accepts a single<br>name argument, you're using the first system. This works well if no namespaces or<br>prefixes are present; otherwise, it acts in a crude and literal manner. Namespaces<br>are ignored, and prefixes are included exactly as they were written. For example:<br>
<b>Sample fragment</b><br>
<b>Name</b><br>
&lt;<b>customer</b> ...&gt;<br>
customer<br>
&lt;<b>customer</b> xmlns='blah' ...&gt;<br>
customer<br>
&lt;<b>x:customer</b> ...&gt;<br>
x:customer<br>
The following code works with the first two cases:<br>
reader.ReadStartElement (&quot;customer&quot;);<br>
The following is required to handle the third case:<br>
reader.ReadStartElement (&quot;x:customer&quot;);<br>
The second system works through two <i>namespace-aware</i> properties: NamespaceURI<br>and LocalName. These properties take into account prefixes and default namespaces<br>defined by parent elements. Prefixes are automatically expanded. This means that<br>NamespaceURI always reflects the semantically correct namespace for the current el-<br>ement, and LocalName is always free of prefixes.<br>When you pass two name arguments into a method such as ReadStartElement, you're<br>using this same system. For example, consider the following XML:<br>
&lt;customer <b>xmlns=&quot;DefaultNamespace&quot; xmlns:other=&quot;OtherNamespace&quot;</b>&gt;<br>  &lt;address&gt;<br>    &lt;other:city&gt;<br>    ...<br>
We could read this as follows:<br>
reader.ReadStartElement (&quot;customer&quot;, &quot;DefaultNamespace&quot;);<br>
reader.ReadStartElement (&quot;address&quot;,  &quot;DefaultNamespace&quot;);<br>reader.ReadStartElement (&quot;city&quot;,     &quot;OtherNamespace&quot;);<br>
Abstracting away prefixes is usually exactly what you want. If necessary, you can<br>see what prefix was used through the Prefix property and convert it into a name-<br>space by calling LookupNamespace.<br>
<b>456 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=477></a><b>XmlWriter<br></b>XmlWriter is a forward-only writer of an XML stream. The design of XmlWriter is<br>symmetrical to XmlReader.<br>As with XmlTextReader, you construct an XmlWriter by calling Create with an optional<br>settings object. In the following example, we enable indenting to make the output<br>
<b>More XML</b><br>
more human-readable, and then write a simple XML file:<br>
XmlWriterSettings settings = new XmlWriterSettings();<br>
settings.Indent = true;<br>
using (XmlWriter writer = XmlWriter.Create (&quot;..\\..\\foo.xml&quot;, settings))<br>{<br>  writer.WriteStartElement (&quot;customer&quot;);<br>
  writer.WriteElementString (&quot;firstname&quot;, &quot;Jim&quot;);<br>
  writer.WriteElementString (&quot;lastname&quot;,&quot; Bo&quot;);<br>
  writer.WriteEndElement();<br>}<br>
This  produces  the  following  document  (the  same  as  the  file  we  read  in  the  first<br>example of XmlReader):<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br>&lt;customer&gt;<br>
  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
&lt;/customer&gt;<br>
XmlWriter automatically writes the declaration at the top unless you indicate other-<br>wise in XmlWriterSettings, by setting OmitXmlDeclaration to true or ConformanceLe<br>vel to Fragment. The latter also permits writing multiple root nodes--something that<br>otherwise throws an exception.<br>
The WriteValue method writes a single text node. It accepts both string and nonstring<br>types  such  as  bool  and  DateTime,  internally  calling  XmlConvert  to  perform  XML-<br>compliant string conversions:<br>
writer.WriteStartElement (&quot;birthdate&quot;);<br>writer.WriteValue (DateTime.Now);<br>writer.WriteEndElement();<br>
In contrast, if we call:<br>
WriteElementString (&quot;birthdate&quot;, DateTime.Now.ToString());<br>
the result would be both non-XML-compliant and vulnerable to incorrect parsing.<br>
WriteString is equivalent to calling WriteValue with a string. XmlWriter automatically<br>escapes characters that would otherwise be illegal within an attribute or element,<br>such as &amp; &lt; &gt;, and extended Unicode characters.<br>
<b>XmlWriter | 457</b><br>
<hr>
<A name=478></a><b>Writing Attributes<br></b>You can write attributes immediately after writing a start element:<br>
writer.WriteStartElement (&quot;customer&quot;);<br>
writer.WriteAttributeString (&quot;id&quot;, &quot;1&quot;);<br>
writer.WriteAttributeString (&quot;status&quot;, &quot;archived&quot;);<br>
To  write  nonstring  values,  call  WriteStartAttribute,  WriteValue,  and  then<br>WriteEndAttribute.<br>
<b>Writing Other Node Types<br></b>XmlWriter also defines the following methods for writing other kinds of nodes:<br>
WriteBase64       // for binary data<br>
WriteBinHex       // for binary data<br>
WriteCData<br>WriteComment<br>
WriteDocType<br>
WriteEntityRef<br>
WriteProcessingInstruction<br>
WriteRaw<br>
WriteWhitespace<br>
WriteRaw directly injects a string into the output stream. There is also a WriteNode<br>method that accepts an XmlReader, echoing everything from the given XmlReader.<br>
<b>Namespaces and Prefixes<br></b>The overloads for the Write* methods allow you to associate an element or attribute<br>with a namespace. Let's rewrite the contents of the XML file in our previous example.<br>This time we will associate all the elements with the <i>http://oreilly.com</i> namespace,<br>declaring the prefix o at the customer element:<br>
writer.WriteStartElement (&quot;o&quot;, &quot;customer&quot;, &quot;http://oreilly.com&quot;);<br>writer.WriteElementString (&quot;o&quot;, &quot;firstname&quot;, &quot;http://oreilly.com&quot;, &quot;Jim&quot;);<br>writer.WriteElementString (&quot;o&quot;, &quot;lastname&quot;, &quot;http://oreilly.com&quot;, &quot;Bo&quot;);<br>writer.WriteEndElement();<br>
The output is now as follows:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;o:customer xmlns:o='http://oreilly.com'&gt;<br>  &lt;o:firstname&gt;Jim&lt;/o:firstname&gt;<br>  &lt;o:lastname&gt;Bo&lt;/o:lastname&gt;<br>&lt;/o:customer&gt;<br>
Notice how for brevity XmlWriter omits the child element's namespace declarations<br>when they are already declared by the parent element.<br>
<b>458 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=479></a><b>Patterns for Using XmlReader/XmlWriter<br>Working with Hierarchical Data<br></b>Consider the following classes:<br>
public class Contacts<br>
<b>More XML</b><br>
{<br>  public IList&lt;Customer&gt; Customers = new List&lt;Customer&gt;();<br>
  public IList&lt;Supplier&gt; Suppliers = new List&lt;Supplier&gt;();<br>
}<br>
public class Customer { public string FirstName, LastName; }<br>
public class Supplier { public string Name;                }<br>
Suppose you want to use XmlReader and XmlWriter to serialize a Contacts object to<br>XML as in the following:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>
&lt;contacts&gt;<br>
   &lt;customer id=&quot;1&quot;&gt;<br>
      &lt;firstname&gt;Jay&lt;/firstname&gt;<br>      &lt;lastname&gt;Dee&lt;/lastname&gt;<br>   &lt;/customer&gt;<br>
   &lt;customer&gt;                     &lt;!-- we'll assume id is optional --&gt;<br>
      &lt;firstname&gt;Kay&lt;/firstname&gt;<br>
      &lt;lastname&gt;Gee&lt;/lastname&gt;<br>   &lt;/customer&gt;<br>
   &lt;supplier&gt;<br>
      &lt;name&gt;X Technologies Ltd&lt;/name&gt;<br>   &lt;/supplier&gt;<br>&lt;/contacts&gt;<br>
The best approach is not to write one big method, but to encapsulate XML func-<br>tionality  in  the  Customer  and  Supplier  types  themselves  by  writing  ReadXml  and<br>WriteXml methods on these types. The pattern in doing so is straightforward:<br>
· ReadXml and WriteXml leave the reader/writer at the same depth when they exit.<br>· ReadXml reads the outer element, whereas WriteXml writes only its inner content.<br>
Here's how we would write the Customer type:<br>
public class Customer<br>{<br>  public const string XmlName = &quot;customer&quot;;<br>  public int? ID;<br>  public string FirstName, LastName;<br>
  public Customer () { }<br>  public Customer (XmlReader r) { ReadXml (r); }<br>
  public void ReadXml (XmlReader r)<br>  {<br>    if (r.MoveToAttribute (&quot;id&quot;)) ID = r.ReadContentAsInt();<br>    <b>r.ReadStartElement();</b><br>
<b>Patterns for Using XmlReader/XmlWriter | 459</b><br>
<hr>
<A name=480></a>    FirstName = r.ReadElementContentAsString (&quot;firstname&quot;, &quot;&quot;);<br>
    LastName = r.ReadElementContentAsString (&quot;lastname&quot;, &quot;&quot;);<br>    <b>r.ReadEndElement();<br></b>  }<br>
  public void WriteXml (XmlWriter w)<br>  {<br>    if (ID.HasValue) w.WriteAttributeString (&quot;id&quot;, &quot;&quot;, ID.ToString());<br>
    w.WriteElementString (&quot;firstname&quot;, FirstName);<br>
    w.WriteElementString (&quot;lastname&quot;, LastName);<br>  }<br>}<br>
Notice that ReadXml reads the outer start and end element nodes. If its caller did this<br>job instead, Customer couldn't read its own attributes. The reason for not making<br>WriteXml symmetrical in this regard is twofold:<br>
· The caller might need to choose how the outer element is named.<br>· The  caller  might  need  to  write  extra  XML  attributes,  such  as  the  element's<br>
<i>subtype</i> (which could then be used to decide which class to instantiate when<br>reading back the element).<br>
Another benefit of following this pattern is that it makes your implementation com-<br>patible with IXmlSerializable (see Chapter 16).<br>The Supplier class is analogous:<br>
public class Supplier<br>{<br>  public const string XmlName = &quot;supplier&quot;;<br>  public string Name;<br>
  public Supplier () { }<br>  public Supplier (XmlReader r) { ReadXml (r); }<br>
  public void ReadXml (XmlReader r)<br>  {<br>    <b>r.ReadStartElement();<br></b>    Name = r.ReadElementContentAsString (&quot;name&quot;, &quot;&quot;);<br>    <b>r.ReadEndElement();<br></b>  }<br>
  public void WriteXml (XmlWriter w)<br>  {<br>    w.WriteElementString (&quot;name&quot;, Name);<br>  }<br>}<br>
With  the  Contacts  class,  we  must  enumerate  the  customers  element  in  ReadXml,<br>checking whether each subelement is a customer or a supplier. We also have to code<br>around the empty element trap:<br>
public void ReadXml (XmlReader r)<br>{<br>  bool isEmpty = r.IsEmptyElement;           // This ensures we don't get<br>  <b>r.ReadStartElement();</b>                      // snookered by an empty<br>
<b>460 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=481></a>  if (isEmpty) return;                       // &lt;contacts/&gt; element!<br>
  while (r.NodeType == XmlNodeType.Element)<br>  {<br>    if (r.Name == Customer.XmlName)      Customers.Add (new Customer (r));<br>
    else if (r.Name == Supplier.XmlName) Suppliers.Add (new Supplier (r));<br>
    else<br>      throw new XmlException (&quot;Unexpected node: &quot; + r.Name);<br>  }<br>
<b>More XML</b><br>
  <b>r.ReadEndElement();</b><br>
}<br>
public void WriteXml (XmlWriter w)<br>
{<br>  foreach (Customer c in Customers)<br>
  {<br>    <b>w.WriteStartElement (Customer.XmlName);</b><br>
    c.WriteXml (w);<br>    <b>w.WriteEndElement();</b><br>
  }<br>  foreach (Supplier s in Suppliers)<br>
  {<br>    <b>w.WriteStartElement (Supplier.XmlName);</b><br>
    s.WriteXml (w);<br>    <b>w.WriteEndElement();</b><br>
  }<br>}<br>
<b>Mixing XmlReader/XmlWriter with an X-DOM<br></b>You  can  fly  in  an  X-DOM  at  any  point  in  the  XML  tree  where  XmlReader  or<br>XmlWriter becomes too cumbersome. Using the X-DOM to handle inner elements<br>is an excellent way to combine X-DOM's ease of use with the low-memory footprint<br>of XmlReader and XmlWriter.<br>
<b>Using XmlReader with XElement<br></b>To read the current element into an X-DOM, you call XNode.ReadFrom, passing in<br>the XmlReader. Unlike XElement.Load, this method is not "greedy" in that it doesn't<br>expect to see a whole document. Instead, it reads just the end of the current subtree.<br>
For instance, suppose we have an XML logfile structured as follows:<br>
&lt;log&gt;<br>  &lt;logentry id=&quot;1&quot;&gt;<br>    &lt;date&gt;...&lt;/date&gt;<br>    &lt;source&gt;...&lt;/source&gt;<br>    ...<br>  &lt;/logentry&gt;<br>  ...<br>&lt;/log&gt;<br>
<b>Patterns for Using XmlReader/XmlWriter | 461</b><br>
<hr>
<A name=482></a>If there were 1 million logentry elements, reading the whole thing into an X-DOM<br>would  waste  memory.  A  better  solution  is  to  traverse  each  logentry  with  an<br>XmlReader, and then use XElement to process the elements individually:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>
settings.IgnoreWhitespace = true;<br>
using (XmlReader r = XmlReader.Create (&quot;logfile.xml&quot;, settings))<br>
{<br>  r.ReadStartElement (&quot;log&quot;);<br>
  while (r.Name == &quot;logentry&quot;)<br>  {<br>
    <b>XElement logEntry = (XElement) XNode.ReadFrom (r);<br></b>    int id = (int) logEntry.Attribute (&quot;id&quot;);<br>
    DateTime date = (DateTime) logEntry.Element (&quot;date&quot;);<br>    string source = (string) logEntry.Element (&quot;source&quot;);<br>    ...<br>
  }<br>
  r.ReadEndElement();<br>
}<br>
If  you  follow  the  pattern  described  in  the  previous  section,  you  can  slot  an<br>XElement into a custom type's ReadXml or WriteXml method without the caller ever<br>knowing you've cheated! For instance, we could rewrite Customer's ReadXml method<br>as follows:<br>
public void ReadXml (XmlReader r)<br>
{<br>  <b>XElement x = (XElement) XNode.ReadFrom (r);<br></b>  FirstName = (string) x.Element (&quot;firstname&quot;);<br>  LastName = (string) x.Element (&quot;lastname&quot;);<br>}<br>
XElement collaborates with XmlReader to ensure that namespaces are kept intact and<br>prefixes are properly expanded--even if defined at an outer level. So, if our XML<br>file read like this:<br>
&lt;log xmlns=&quot;http://loggingspace&quot;&gt;<br>  &lt;logentry id=&quot;1&quot;&gt;<br>  ...<br>
the XElements we constructed at the logentry level would correctly inherit the outer<br>namespace.<br>
<b>Using XmlWriter with XElement<br></b>You can use an XElement just to write inner elements to an XmlWriter. The following<br>code writes 1 million logentry elements to an XML file using XElement--without<br>storing the whole thing in memory:<br>
<b>462 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=483></a>using (XmlWriter w = XmlWriter.Create (&quot;log.xml&quot;))<br>
{<br>  w.WriteStartElement (&quot;log&quot;);<br>  for (int i = 0; i &lt; 1000000; i++)<br>
  {<br>
    XElement e = new XElement (&quot;logentry&quot;,<br>                   new XAttribute (&quot;id&quot;, i),<br>                   new XElement (&quot;date&quot;, DateTime.Today.AddDays (-1)),<br>
<b>More XML</b><br>
                   new XElement (&quot;source&quot;, &quot;test&quot;));<br>
    <b>e.WriteTo (w);<br></b>  }<br>  w.WriteEndElement ();<br>
}<br>
Using an XElement incurs minimal execution overhead. If we amend this example to<br>use XmlWriter throughout, there's no measurable difference in execution time.<br>
<b>XmlDocument<br></b>XmlDocument is an in-memory representation of an XML document. Its object model<br>and the methods that its types expose conform to a pattern defined by the W3C. So,<br>if you're familiar with another W3C-compliant XML DOM (e.g., in Java), you'll be<br>at  home  with  XmlDocument. When compared to the X-DOM, however, the W3C<br>model is much "clunkier."<br>
The base type for all objects in an XmlDocument tree is XmlNode. The following types<br>derive from XmlNode:<br>
XmlNode<br>  XmlDocument<br>  XmlDocumentFragment<br>  XmlEntity<br>  XmlNotation<br>  <b>XmlLinkedNode</b><br>
XmlLinkedNode exposes NextSibling and PreviousSibling properties and is an ab-<br>stract base for the following subtypes:<br>
XmlLinkedNode<br>  XmlCharacterData<br>  XmlDeclaration<br>  XmlDocumentType<br>  XmlElement<br>  XmlEntityReference<br>  XmlProcesingInstruction<br>
<b>Loading and Saving an XmlDocument<br></b>To load an XmlDocument from an existing source, you instantiate an XmlDocument and<br>then call Load or LoadXml:<br>
· Load accepts a filename, Stream, TextReader, or XmlReader.<br>· LoadXml accepts a literal XML string.<br>
<b>XmlDocument | 463</b><br>
<hr>
<A name=484></a>To save a document, call Save with a filename, Stream, TextWriter, or XmlWriter:<br>
XmlDocument doc = new XmlDocument();<br>
doc.Load (&quot;customer1.xml&quot;);<br>
doc.Save (&quot;customer2.xml&quot;);<br>
<b>Traversing an XmlDocument<br></b>To illustrate traversing an XmlDocument, we'll use the following XML file:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
&lt;/customer&gt;<br>
The  ChildNodes  property  (defined  in  XNode)  allows  you  to  descend  into  the  tree<br>structure. This returns an indexable collection:<br>
XmlDocument doc = new XmlDocument();<br>
doc.Load (&quot;customer.xml&quot;);<br>
Console.WriteLine (doc.DocumentElement.<b>ChildNodes</b>[0].InnerText);   // Jim<br>Console.WriteLine (doc.DocumentElement.<b>ChildNodes</b>[1].InnerText);   // Bo<br>
With the ParentNode property, you can ascend back up the tree:<br>
Console.WriteLine (<br>
  doc.DocumentElement.ChildNodes[1].<b>ParentNode</b>.Name);        // customer<br>
The following properties also help traverse the document (all of which return null<br>if the node does not exist):<br>
FirstChild<br>LastChild<br>NextSibling<br>PreviousSibling<br>
The following two statements both output firstname:<br>
Console.WriteLine (doc.DocumentElement.FirstChild.Name);<br>Console.WriteLine (doc.DocumentElement.LastChild.PreviousSibling.Name);<br>
XmlNode exposes an Attributes property for accessing attributes either by name (and<br>namespace) or by ordinal position. For example:<br>
Console.WriteLine (doc.DocumentElement.Attributes [&quot;id&quot;].Value);<br>
<b>InnerText and InnerXml<br></b>The InnerText property represents the concatenation of all child text nodes. The<br>following two lines both output Jim, since our XML document contains only a single<br>text node:<br>
Console.WriteLine (doc.DocumentElement.ChildNodes[0].InnerText);<br>Console.WriteLine (doc.DocumentElement.ChildNodes[0].FirstChild.Value);<br>
<b>464 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=485></a>Setting the InnerText property replaces <i>all</i> child nodes with a single text node. Be<br>careful when setting InnerText to not accidentally wipe over element nodes. For<br>example:<br>
doc.DocumentElement.ChildNodes[0].InnerText = &quot;Jo&quot;;              // wrong<br>
doc.DocumentElement.ChildNodes[0].FirstChild.InnerText = &quot;Jo&quot;;   // right<br>
The InnerXml property represents the XML fragment <i>within</i> the current node. You<br>
<b>More XML</b><br>
typically use InnerXml on elements:<br>
Console.WriteLine (doc.DocumentElement.InnerXml);<br>
// OUTPUT:<br>
&lt;firstname&gt;Jim&lt;/firstname&gt;&lt;lastname&gt;Bo&lt;/lastname&gt;<br>
InnerXml throws an exception if the node type cannot have children.<br>
<b>Creating and Manipulating Nodes<br></b>To create and add new nodes:<br>
1. Call one of the Create<i>XXX</i> methods on the XmlDocument, such as CreateElement.<br>2. Add  the  new  node  into  the  tree  by  calling  AppendChild,  PrependChild,<br>
InsertBefore, or InsertAfter on the desired parent node.<br>
Creating nodes requires that you first have an XmlDocument--<br>you cannot simply instantiate an XmlElement on its own like with<br>the X-DOM. Nodes rely on a host XmlDocument for sustenance.<br>
For example:<br>
XmlDocument doc = new XmlDocument();<br>XmlElement customer = doc.CreateElement (&quot;customer&quot;);<br>doc.AppendChild (customer);<br>
The following creates a document matching the XML we started with earlier in this<br>chapter in the section "XmlReader" on page 448:<br>
XmlDocument doc = new XmlDocument ();<br>doc.AppendChild (doc.CreateXmlDeclaration (&quot;1.0&quot;, null, &quot;yes&quot;));<br>
XmlAttribute id     = doc.CreateAttribute (&quot;id&quot;);<br>XmlAttribute status = doc.CreateAttribute (&quot;status&quot;);<br>id.Value     = &quot;123&quot;;<br>status.Value = &quot;archived&quot;;<br>
XmlElement firstname = doc.CreateElement (&quot;firstname&quot;);<br>XmlElement lastname  = doc.CreateElement (&quot;lastname&quot;);<br>firstname.AppendChild (doc.CreateTextNode (&quot;Jim&quot;));<br>lastname.AppendChild  (doc.CreateTextNode (&quot;Bo&quot;));<br>
XmlElement customer = doc.CreateElement (&quot;customer&quot;);<br>customer.Attributes.Append (id);<br>customer.Attributes.Append (status);<br>
<b>XmlDocument | 465</b><br>
<hr>
<A name=486></a>customer.AppendChild (lastname);<br>
customer.AppendChild (firstname);<br>
doc.AppendChild (customer);<br>
You can construct the tree in any order. In the previous example, it doesn't matter<br>if you rearrange the order of the lines that append child nodes.<br>
To remove a node, you call RemoveChild, ReplaceChild, or RemoveAll.<br>
<b>Namespaces</b><br>
See Chapter 10 for an introduction to XML namespaces and<br>prefixes.<br>
The CreateElement and CreateAttribute methods are overloaded to let you specify<br>a namespace and prefix:<br>
Create<i>XXX</i> (string name);<br>
Create<i>XXX</i> (string name, string namespaceURI);<br>Create<i>XXX</i> (string prefix, string localName, string namespaceURI);<br>
The name parameter refers to either a local name (i.e., no prefix) or a name qualified<br>with a prefix. The namespaceURI parameter is used if and only if you are <i>declaring<br></i>(rather than merely referring to) a namespace.<br>
Here  is  an  example  of  <i>declaring</i>  a  namespace  with  a  prefix  while  creating  an<br>element:<br>
XmlElement customer = doc.CreateElement (&quot;o&quot;, &quot;customer&quot;,<br>                                         &quot;http://oreilly.com&quot;);<br>
Here  is  an  example  of  <i>referring</i>  to  a  namespace  with  a  prefix  while  creating  an<br>element:<br>
XmlElement customer = doc.CreateElement (&quot;o:firstname&quot;);<br>
In the next section, we will explain how to deal with namespaces when writing XPath <br>queries.<br>
<b>XPath<br></b>XPath is the W3C standard for XML querying. In the .NET Framework, XPath can<br>query an XmlDocument rather like LINQ queries an X-DOM. XPath has a wider scope,<br>though, in that it's also used by other XML technologies, such as XML schema,<br>XLST, and XAML.<br>
<b>466 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=487></a>XPath  queries  are  expressed  in  terms  of  the  XPath  2.0  Data<br>Model. Both the DOM and the XPath Data Model represent an<br>XML document as a tree. The difference is that the XPath Data<br>Model is purely data-centric, abstracting away the formatting<br>aspects of XML text. For example, CDATA sections are not re-<br>quired in the XPath Data Model, since the only reason CDATA<br>sections exist is to enable text to contain markup character se-<br>
<b>More XML</b><br>
quences.  The  XPath  specification  is  at  <i>http://www.w3.org/tr/<br>xpath20/</i>.<br>
The examples in this section all use the following XML file:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>&lt;customers&gt;<br>
  &lt;customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>
    &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
    &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
  &lt;/customer&gt;<br>
  &lt;customer&gt;<br>
    &lt;firstname&gt;Thomas&lt;/firstname&gt;<br>    &lt;lastname&gt;Jefferson&lt;/lastname&gt;<br>
  &lt;/customer&gt;<br>
&lt;/customers&gt;<br>
You can write XPath queries within code in the following ways:<br>
· Call one of the Select<i>XXX</i> methods on an XmlDocument or XmlNode.<br>· Spawn an XPathNavigator from either:<br>
-- An XmlDocument<br>-- An XPathDocument<br>
· Call an XPath<i>XXX</i> extension method on an XNode.<br>
The Select<i>XXX</i> methods accept an XPath query string. For example, the following<br>finds the firstname node of an XmlDocument:<br>
XmlDocument doc = new XmlDocument();<br>doc.Load (&quot;customers.xml&quot;);<br><b>XmlNode n = doc.SelectSingleNode (&quot;customers/customer[firstname='Jim']&quot;);<br></b>Console.WriteLine (n.InnerText);  // JimBo<br>
The Select<i>XXX</i> methods delegate their implementation to XPathNavigator, which you<br>can also use directly--over either an XmlDocument or a read-only XPathDocument.<br>You can also execute XPath queries over an X-DOM, via extension methods defined<br>in System.Xml.XPath:<br>
XDocument doc = XDocument.Load (@&quot;Customers.xml&quot;);<br>XElement e = e.<b>XPathSelectElement</b> (&quot;customers/customer[firstname='Jim']&quot;);<br>Console.WriteLine (e.Value);  // JimBo<br>
<b>XPath | 467</b><br>
<hr>
<A name=488></a>The extension methods for use with XNodes are:<br>
CreateNavigator<br>XPathEvaluate<br>XPathSelectElement<br>XPathSelectElements<br>
<b>Common XPath Operators<br></b>The XPath specification is huge. However, you can get by knowing just a few oper-<br>ators (see Table 11-2), just as you can play a lot of songs knowing just three chords.<br>
<i>Table 11-2. Common XPath operators</i><br>
<b>Operator</b><br>
<b>Description</b><br>
/<br>
Children<br>
//<br>
Recursively children<br>
.<br>
Current node (usually implied)<br>
..<br>
Parent node<br>
*<br>
Wildcard<br>
@<br>
Attribute<br>
[]<br>
Filter<br>
:<br>
Namespace separator<br>
To find the customers node:<br>
XmlNode node = doc.SelectSingleNode (&quot;customers&quot;);<br>
The / symbol queries child nodes. To select the customer nodes:<br>
XmlNode node = doc.SelectSingleNode (&quot;customers/customer&quot;);<br>
The // operator includes all child nodes, regardless of nesting level. To select all<br>lastname nodes:<br>
XmlNodeList nodes = doc.SelectNodes (&quot;//lastname&quot;);<br>
The .. operator selects parent nodes. This example is a little silly because we're<br>starting from the root anyway, but it serves to illustrate the functionality:<br>
XmlNodeList nodes = doc.SelectNodes (&quot;customers/customer..customers&quot;);<br>
The * operator selects nodes regardless of name. The following selects the child<br>nodes of customer, regardless of name:<br>
XmlNodeList nodes = doc.SelectNodes (&quot;customers/customer/*&quot;);<br>
The @ operator selects attributes. * can be used as a wildcard. Here is how to select<br>the id attribute:<br>
XmlNode node = doc.SelectSingleNode (&quot;customers/customer/@id&quot;);<br>
<b>468 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=489></a>The [] operator filters a selection, in conjunction with the operators =, !=, &lt;, &gt;, not(),<br>and, and or. In this example, we filter on firstname:<br>
XmlNode n = doc.SelectSingleNode (&quot;customers/customer[firstname='Jim']&quot;);<br>
The : operator qualifies a namespace. Had the customers element been qualified<br>with the x namespace, we would access it as follows:<br>
XmlNode node = doc.SelectSingleNode (&quot;x:customers&quot;);<br>
<b>More XML</b><br>
<b>XPathNavigator<br></b>XPathNavigator is a cursor over the XPath Data Model representation of an XML<br>document. It is loaded with primitive methods that move the cursor around the tree<br>(e.g., move to parent, move to first child, etc.). The XPathNavigator's Select* meth-<br>ods take an XPath string to express more complex navigations or queries that return<br>multiple nodes.<br>
Spawn instances of XPathNavigator from an XmlDocument, an XPathDocument, or an-<br>other XPathNavigator. Here is an example of spawning an XPathNavigator from an<br>XmlDoument:<br>
XPathNavigator nav = doc.CreateNavigator();<br>
XPathNavigator jim = nav.SelectSingleNode<br>  (<br>    &quot;customers/customer[firstname='Jim']&quot;<br>
  );<br>
Console.WriteLine (jim.Value);                    // JimBo<br>
In the XPath Data Model, the value of a node is the concatenation of the text ele-<br>ments, equivalent to XmlDocument's InnerText property.<br>The SelectSingleNode method returns a single XPathNavigator. The Select method<br>returns an XPathNodeIterator, which simply iterates over multiple XPathNavigators.<br>For example:<br>
XPathNavigator nav = doc.CreateNavigator();<br>string xPath = &quot;customers/customer/firstname/text()&quot;;<br>foreach (XPathNavigator navC in nav.Select (xPath))<br>  Console.WriteLine (navC.Value);<br>
OUTPUT:<br>Jim<br>Thomas<br>
To perform faster queries, you can compile an XPath query into an XPathExpres<br>sion. You then pass the compiled expression to a Select* method, instead of a string.<br>For example:<br>
XPathNavigator nav = doc.CreateNavigator();<br>XPathExpression expr = nav.Compile (&quot;customers/customer/firstname&quot;);<br>foreach (XPathNavigator a in nav.Select (expr))<br>  Console.WriteLine (a.Value);<br> <br>
<b>XPath | 469</b><br>
<hr>
<A name=490></a>OUTPUT:<br>
Jim<br>Thomas<br>
<b>Querying with Namespaces<br></b>Querying elements and attributes that contain namespaces requires some extra un-<br>intuitive steps. Consider the following XML file:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;<br>
&lt;<b>o:</b>customers <b>xmlns:o='http://oreilly.com'</b>&gt;<br>
  &lt;<b>o:</b>customer id=&quot;123&quot; status=&quot;archived&quot;&gt;<br>
    &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
    &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
  &lt;/<b>o:</b>customer&gt;<br>
  &lt;<b>o:</b>customer&gt;<br>    &lt;firstname&gt;Thomas&lt;/firstname&gt;<br>
    &lt;lastname&gt;Jefferson&lt;/lastname&gt;<br>
  &lt;/<b>o:</b>customer&gt;<br>
&lt;/<b>o:</b>customers&gt;<br>
The following query will fail, despite qualifying the nodes with the prefix o:<br>
XmlDocument doc = new XmlDocument();<br>doc.Load (&quot;customers.xml&quot;);<br>
<b>XmlNode n = doc.SelectSingleNode (&quot;o:customers/o:customer&quot;);</b><br>
Console.WriteLine (n.InnerText);  // JimBo<br>
To make this query work, you must first create an XmlNamespaceManager instance as<br>follows:<br>
XmlNamespaceManager xnm = new XmlNamespaceManager (doc.NameTable);<br>
You can treat NameTable as a black box (XmlNamespaceManager uses it internally to<br>cache and reuse strings). Once we create the namespace manager, we can add prefix/<br>namespace pairs to it as follows:<br>
xnm.AddNamespace (&quot;o&quot;, &quot;http://oreilly.com&quot;);<br>
The Select* methods on XmlDocument and XPathNavigator have overloads that accept<br>an XmlNamespaceManager. We can successfully rewrite the previous query as follows:<br>
XmlNode n = doc.SelectSingleNode (&quot;o:customers/o:customer&quot;<b>, xnm</b>);<br>
<b>XPathDocument<br></b>XPathDocument  is  used  for  read-only  XML  documents  that  conform  to  the  W3C<br>XPath Data Model. An XPathNavigator backed by an XPathDocument is faster than an<br>XmlDocument, but it cannot make changes to the underlying document:<br>
XPathDocument doc = new XPathDocument (&quot;customers.xml&quot;);<br>XPathNavigator nav = doc.CreateNavigator();<br>foreach (XPathNavigator a in nav.Select (&quot;customers/customer/firstname&quot;))<br>  Console.WriteLine (a.Value);<br>
<b>470 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=491></a>OUTPUT:<br>
Jim<br>Thomas<br>
<b>XSD and Schema Validation<br></b>The content of a particular XML document is nearly always domain-specific, such<br>
<b>More XML</b><br>
as a Microsoft Word document, an application configuration document, or a web<br>service. For each domain, the XML file conforms to a particular pattern. There are<br>several standards for describing the schema of such a pattern, to standardize and<br>automate the interpretation and validation of XML documents. The most widely<br>accepted standard is <i>XSD</i>, short for <i>XML Schema Definition</i>. Its precursors, DTD<br>and XDR, are also supported by System.Xml.<br>Consider the following XML document:<br>
&lt;?xml version=&quot;1.0&quot;?&gt;<br>
&lt;customers&gt;<br>
  &lt;customer id=&quot;1&quot; status=&quot;active&quot;&gt;<br>
    &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
    &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
  &lt;/customer&gt;<br>  &lt;customer id=&quot;1&quot; status=&quot;archived&quot;&gt;<br>
    &lt;firstname&gt;Thomas&lt;/firstname&gt;<br>
    &lt;lastname&gt;Jefferson&lt;/lastname&gt;<br>
  &lt;/customer&gt;<br>&lt;/customers&gt;<br>
We can write an XSD for this document as follows:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;xs:schema attributeFormDefault=&quot;unqualified&quot;<br>           elementFormDefault=&quot;qualified&quot;<br>           xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<br>  &lt;xs:element name=&quot;customers&quot;&gt;<br>    &lt;xs:complexType&gt;<br>      &lt;xs:sequence&gt;<br>        &lt;xs:element maxOccurs=&quot;unbounded&quot; name=&quot;customer&quot;&gt;<br>          &lt;xs:complexType&gt;<br>            &lt;xs:sequence&gt;<br>              &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot; /&gt;<br>              &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot; /&gt;<br>            &lt;/xs:sequence&gt;<br>            &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:int&quot; use=&quot;required&quot; /&gt;<br>            &lt;xs:attribute name=&quot;status&quot; type=&quot;xs:string&quot; use=&quot;required&quot; /&gt;<br>          &lt;/xs:complexType&gt;<br>        &lt;/xs:element&gt;<br>      &lt;/xs:sequence&gt;<br>    &lt;/xs:complexType&gt;<br>  &lt;/xs:element&gt;<br>&lt;/xs:schema&gt;<br>
As you can see, XSD documents are themselves written in XML. Furthermore, an<br>XSD document is describable with XSD--you can find that definition at <i>http://www<br>.w3.org/2001/xmlschema.xsd</i>.<br>
<b>XSD and Schema Validation | 471</b><br>
<hr>
<A name=492></a><b>Performing Schema Validation<br></b>You can validate an XML file or document against one or more schemas before<br>reading or processing it. There are a number of reasons to do so:<br>
· You can get away with less error checking and exception handling.<br>· Schema validation picks up errors you might otherwise overlook.<br>· Error messages are detailed and informative.<br>
To perform validation, plug a schema into an XmlReader, an XmlDocument, or an X-<br>DOM object, and then read or load the XML as you would normally. Schema vali-<br>dation happens automatically as content is read, so the input stream is not read<br>twice.<br>
<b>Validating with an XmlReader<br></b>Here's how to plug a schema from the file <i>customers.xsd</i> into an XmlReader:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>
<b>settings.ValidationType = ValidationType.Schema;</b><br>
<b>settings.Schemas.Add (null, &quot;customers.xsd&quot;);</b><br>
using (XmlReader r = XmlReader.Create (&quot;customers.xml&quot;, settings))<br>
  ...<br>
If the schema is inline, set the following flag instead of adding to Schemas:<br>
settings.ValidationFlags |= XmlSchemaValidationFlags.ProcessInlineSchema;<br>
You then Read as you would normally. If schema validation fails at any point, an<br>XmlSchemaValidationException is thrown.<br>
Calling Read on its own validates both elements and attributes:<br>you don't need to navigate to each individual attribute for it to<br>be validated.<br>
If you want <i>only</i> to validate the document, you can do this:<br>
using (XmlReader r = XmlReader.Create (&quot;customers.xml&quot;, settings))<br>  try { while (r.Read()) ; }<br>  catch (XmlSchemaValidationException ex)<br>  {<br>    ...<br>  }<br>
XmlSchemaValidationException has properties for the error Message, LineNumber, and<br>LinePosition. In this case, it only tells you about the first error in the document. If<br>you  want  to  report  on  all  errors  in  the  document,  you  instead  must  handle  the<br>ValidationEventHandler event:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>settings.ValidationType = ValidationType.Schema;<br>settings.Schemas.Add (null, &quot;customers.xsd&quot;);<br>
<b>472 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=493></a><b>settings.ValidationEventHandler += ValidationHandler;</b><br>
using (XmlReader r = XmlReader.Create (&quot;customers.xml&quot;, settings))<br>  while (r.Read()) ;<br>
When you handle this event, schema errors no longer throw exceptions. Instead,<br>they fire your event handler:<br>
static void ValidationHandler (object sender, ValidationEventArgs e)<br>{<br>
<b>More XML</b><br>
  Console.WriteLine (&quot;Error: &quot; + e.Exception.Message);<br>}<br>
The  Exception  property  of  ValidationEventArgs  contains  the  XmlSchemaValidatio<br>nException that would have otherwise been thrown.<br>
The System.Xml namespace also contains a class called XmlVali<br>datingReader. This was used to perform schema validation prior<br>to Framework 2.0, and it is now deprecated.<br>
<b>Validating an X-DOM or XmlDocument<br></b>To validate an XML file or stream while reading into an X-DOM or XmlDocument,<br>you create an XmlReader, plug in the schemas, and then use the reader to load the<br>DOM:<br>
XmlReaderSettings settings = new XmlReaderSettings();<br>
settings.ValidationType = ValidationType.Schema;<br>
settings.Schemas.Add (null, &quot;customers.xsd&quot;);<br>
XDocument doc;<br>using (XmlReader r = XmlReader.Create (&quot;customers.xml&quot;, settings))<br>  try { <b>doc = XDocument.Load (r);</b> }<br>  catch (XmlSchemaValidationException ex) { ... }<br>
XmlDocument xmlDoc = new XmlDocument();<br>using (XmlReader r = XmlReader.Create (&quot;customers.xml&quot;, settings))<br>  try { <b>xmlDoc.Load (r);</b> }<br>
  catch (XmlSchemaValidationException ex) { ... }<br>
You can also validate an XDocument or XElement that's already in memory, by calling<br>extension methods in System.Xml.Schema. These methods accept an XmlSchemaSet (a<br>collection of schemas) and a validation event handler:<br>
XDocument doc = XDocument.Load (@&quot;customers.xml&quot;);<br>XmlSchemaSet set = new XmlSchemaSet ();<br>set.Add (null, @&quot;customers.xsd&quot;);<br>StringBuilder errors = new StringBuilder ();<br>doc.<b>Validate</b> (set, (sender, args) =&gt; { errors.AppendLine<br>                                       (args.Exception.Message); }<br>             );<br>Console.WriteLine (errors.ToString());<br>
<b>XSD and Schema Validation | 473</b><br>
<hr>
<A name=494></a>To  validate  an  XmlDocument  already  in  memory,  add  the  schema(s)  to  the<br>XmlDocument's  Schemas  collection  and  then  call  the  document's  Validate  method,<br>passing in a ValidationEventHandler to process the errors.<br>
<b>XSLT<br></b>XSLT stands for <i>Extensible Stylesheet Language Transformations</i>. It is an XML lan-<br>guage that describes how to transform one XML language into another. The quin-<br>tessential example of such a transformation is transforming an XML document (that<br>typically  describes  data)  into  an  XHTML  document  (that  describes  a  formatted<br>document).<br>
Consider the following XML file:<br>
&lt;customer&gt;<br>
  &lt;firstname&gt;Jim&lt;/firstname&gt;<br>
  &lt;lastname&gt;Bo&lt;/lastname&gt;<br>
&lt;/customer&gt;<br>
The following XSLT file describes such a transformation:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>  &lt;xsl:stylesheet xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;<br>
version=&quot;1.0&quot;&gt;<br>
  &lt;xsl:template match=&quot;/&quot;&gt;<br>
    &lt;html&gt;<br>      &lt;p&gt;&lt;xsl:value-of select=&quot;//firstname&quot;/&gt;&lt;/p&gt;<br>
      &lt;p&gt;&lt;xsl:value-of select=&quot;//lastname&quot;/&gt;&lt;/p&gt;<br>    &lt;/html&gt;<br>
  &lt;/xsl:template&gt;<br>&lt;/xsl:stylesheet&gt;<br>
The output is as follows:<br>
&lt;html&gt;<br>  &lt;p&gt;Jim&lt;/p&gt;<br>  &lt;p&gt;Bo&lt;/p&gt;<br>&lt;/html&gt;<br>
The  System.Xml.Xsl.XslCompiledTransform  transform  class  efficiently  performs<br>XLST transforms. It renders XmlTransform obsolete. XmlTransform works very simply:<br>
XslCompiledTransform transform = new XslCompiledTransform();<br>transform.Load (&quot;test.xslt&quot;);<br>transform.Transform (&quot;input.xml&quot;, &quot;output.xml&quot;);<br>
Generally,  it's  more  useful  to  use  the  overload  of  Transform  that  accepts  an<br>XmlWriter rather than an output file, so you can control the formatting.<br>
<b>474 | Chapter 11:</b><b>Other XML Technologies</b><br>
<hr>
<A name=495></a><b>12</b><br>
<b>Disposal and Garbage Collection</b><br>
Some objects require explicit tear-down code to release resources such as open files,<br>locks, operating system handles, and unmanaged objects. In .NET parlance, this is<br>called <i>disposal</i>, and it is supported through the IDisposable interface. The managed<br>memory occupied by unused objects must also be reclaimed at some point; this<br>function is known as <i>garbage collection</i> and is performed by the CLR.<br>
Disposal differs from garbage collection in that disposal is usually explicitly insti-<br>gated; garbage collection is totally automatic. In other words, the programmer takes<br>care of such things as releasing file handles, locks, and operating system resources<br>while the CLR takes care of releasing memory.<br>
This chapter discusses both disposal and garbage collection, also describing C#<br>finalizers and the pattern by which they can provide a backup for disposal. Lastly,<br>we discuss the intricacies of the garbage collector and other memory management<br>options.<br>
<b>IDisposable, Dispose, and Close<br></b>The .NET Framework defines a special interface for types requiring a tear-down<br>method:<br>
public interface IDisposable<br>{<br>  void Dispose();<br>}<br>
C#'s using statement provides a syntactic shortcut for calling Dispose on objects<br>that implement IDisposable, using a try/finally block. For example:<br>
using (FileStream fs = new FileStream (&quot;myFile.txt&quot;, FileMode.Open))<br>{<br>  // ... Write to the file ...<br>}<br>
<b>475</b><br>
<hr>
<A name=496></a>The compiler converts this to:<br>
FileStream fs = new FileStream (&quot;myFile.txt&quot;, FileMode.Open);<br>
try<br>
{<br>  // ... Write to the file ...<br>}<br>finally<br>
{<br>  if (fs != null) ((IDisposable)fs).Dispose();<br>}<br>
The finally block ensures that the Dispose method is called even when an exception<br>is thrown,* or the code exits the block early.<br>
In simple scenarios, writing your own disposable type is just a matter of implement-<br>ing IDisposable and writing the Dispose method:<br>
sealed class Demo : IDisposable<br>
{<br>  public void Dispose()<br>
  {<br>    // Perform cleanup / tear-down.<br>    ...<br>
  }<br>
}<br>
This pattern works well in simple cases and is appropriate for<br>sealed classes. We'll describe a more elaborate pattern that can<br>provide a backup for consumers that forget to call Dispose in<br>"Calling Dispose from a Finalizer" on page 484. With unsealed<br>types, there's a strong case for following this latter pattern from<br>the  outset--otherwise,  it  becomes  very  messy  if  the  subtype<br>wants to add such functionality itself.<br>
<b>Standard Disposal Semantics<br></b>The Framework follows a de facto set of rules in its disposal logic. These rules are<br>not hard-wired to the Framework or C# language in any way; their purpose is to<br>define a consistent protocol to consumers. Here they are:<br>
1. Once disposed, an object is beyond redemption. It cannot be reactivated, and<br>
calling its methods or properties throws an ObjectDisposedException.<br>
2. Calling an object's Dispose method repeatedly causes no error.<br>3. If disposable object <i>x</i> contains or "wraps" or "possesses" disposable object <i>y</i>,<br>
<i>x</i>'s Dispose method automatically calls <i>y</i>'s Dispose method--unless instructed<br>otherwise.<br>
* In "Interrupt and Abort" on page 855 in Chapter 21, we describe how aborting a thread can<br>
violate the safety of this pattern. This is rarely an issue in practice because aborting threads is<br>widely discouraged for precisely this (and other) reasons.<br>
<b>476 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=497></a>These rules are also helpful when writing your own types, though not mandatory.<br>Nothing prevents you from writing an "Undispose" method, other than, perhaps,<br>the flak you might cop from colleagues!<br>
According  to  rule  3,  a  container  object  automatically  disposes  its  child  objects.<br>A good example is a Windows container control such as a Form or Panel. The con-<br>tainer may host many child controls, yet you don't dispose every one of them ex-<br>plicitly: closing or disposing the parent control or form takes care of the whole lot.<br>Another example is when you wrap a FileStream in a DeflateStream. Disposing the<br>DeflateStream also disposes the FileStream--unless you instructed otherwise in the<br>constructor.<br>
<b>Close and Stop</b><br>
<b>Disposal and GC</b><br>
Some types define a method called Close in addition to Dispose. The Framework is<br>not completely consistent on the semantics of a Close method, although in nearly<br>all cases it's either:<br>
· Functionally identical to Dispose<br>· A functional <i>subset</i> of Dispose<br>
An example of the latter is IDbConnection: a Closed connection can be re-Opened; a<br>Disposed connection cannot. Another example is a Windows Form activated with<br>ShowDialog: Close hides it; Dispose releases its resources.<br>
Some classes define a Stop method (e.g., Timer or HttpListener), which may release<br>unmanaged resources, like Dispose, but unlike Dispose, it allows for re-Starting.<br>
<b>When to Dispose<br></b>A  safe  rule  to  follow  (in  nearly  all  cases)  is  "If  in  doubt,  dispose."  A  disposable<br>object--if it could talk--would say the following:<br>
When you've finished with me, let me know. If simply abandoned, I might<br>cause trouble for other object instances, the application domain, the computer,<br>the network, or the database!<br>
Objects wrapping an unmanaged resource handle will nearly always require dis-<br>posal, in order to free the handle. Examples include Windows Forms controls, file<br>or  network  streams,  network  sockets,  GDI+  pens,  brushes,  and  bitmaps.  Con-<br>versely, if a type is disposable, it will often (but not always) reference an unmanaged<br>handle, directly or indirectly. This is because unmanaged handles provide the gate-<br>way to the "outside world" of operating system resources, network connections,<br>database locks--the primary means by which objects can create trouble outside of<br>themselves if improperly abandoned.<br>
There are, however, three scenarios for <i>not</i> disposing:<br>
· When obtaining a <i>shared</i> object via a static field or property<br>· When an object's Dispose method does something that you don't want<br>
<b>IDisposable, Dispose, and Close | 477</b><br>
<hr>
<A name=498></a>· When an object's Dispose method is unnecessary <i>by design</i>, and disposing that<br>
object would add complexity to your program<br>
The first category is rare. The main cases are in the System.Drawing namespace: the<br>GDI+ objects obtained through <i>static fields or properties</i> (such as Brushes.Blue) must<br>never be disposed because the same instance is used throughout the life of the ap-<br>plication.  Instances  that  you  obtain  through  constructors,  however  (such  as  new<br>SolidBrush), <i>should</i> be disposed, as should instances obtained through static <i>meth-<br>ods</i> (such as Font.FromHdc).<br>The  second  category  is  more  common.  There  are  some  good  examples  in  the<br>System.IO and System.Data namespaces:<br>
<b>Type</b><br>
<b>Disposal function</b><br>
<b>When not to dispose</b><br>
MemoryStream<br>
Prevents further I/O<br>
When you later need to read/write the stream<br>
StreamReader,<br>
Flushes the reader/writer and<br>
When you want to keep the underlying stream open (you<br>
StreamWriter<br>
closes the underlying stream<br>
must instead call Flush on a StreamWriter when<br>
you're done)<br>
IDbConnection<br>
Releases a database connection<br>
If you need to re-Open it, you should call Close instead<br>
and clears the connection string<br>
of Dispose<br>
DataContext<br>
Prevents further use<br>
When you might have lazily evaluated queries connected<br>
(LINQ to SQL)<br>
to that context<br>
MemoryStream's Dispose method disables only the object; it doesn't perform any crit-<br>ical cleanup because a MemoryStream holds no unmanaged handles or other such<br>resources.<br>
The third category includes the following classes: WebClient, StringReader, String<br>Writer, and BackgroundWorker (in System.ComponentModel). These types are disposa-<br>ble under the duress of their base class rather than through a genuine need to perform<br>essential cleanup. If you happen to instantiate and work with such an object entirely<br>in one method, wrapping it in a using block adds little inconvenience. But if the<br>object is longer-lasting, keeping track of when it's no longer used so that you can<br>dispose of it adds unnecessary complexity. In such cases, you can simply ignore<br>object disposal.<br>
<b>Opt-in Disposal<br></b>Because IDisposable makes a type tractable with C#'s using construct, there's a<br>temptation  to  extend  the  reach  of  IDisposable  to  nonessential  activities.  For<br>instance:<br>
public sealed class HouseManager : IDisposable<br>
{<br>  public void Dispose()<br>  {<br>    CheckTheMail();<br>  }<br>  ...<br>}<br>
<b>478 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=499></a>The idea is that a consumer of this class can choose to circumvent the nonessential<br>cleanup--simply  by  not  calling  Dispose.  This,  however,  relies  on  the  consumer<br>knowing  what's  inside  Demo's Dispose method. It also breaks if  <i>essential</i> cleanup<br>activity is later added:<br>
public void Dispose()<br>{<br>  CheckTheMail();    // Nonessential<br>  LockTheHouse();    // Essential<br>
}<br>
The solution to this problem is the opt-in disposal pattern:<br>
public sealed class HouseManager : IDisposable<br>
<b>Disposal and GC</b><br>
{<br>  public readonly bool CheckMailOnDispose;<br>
  public Demo (bool checkMailOnDispose)<br>
  {<br>
    CheckMailOnDispose = checkMailOnDispose;<br>
  }<br>
  public void Dispose()<br>
  {<br>
    <b>if (CheckMailOnDispose)</b> CheckTheMail();<br>
    LockTheHouse();<br>  }<br>
  ...<br>
}<br>
The consumer can then always call Dispose--providing simplicity and avoiding the<br>need for special documentation or reflection. An example of where this pattern is<br>implemented  is  in  the  DeflateStream  class,  in  System.IO.Compression.  Here's  its<br>constructor:<br>
public DeflateStream (Stream stream, CompressionMode mode, bool leaveOpen)<br>
The nonessential activity is closing the inner stream (the first parameter) upon dis-<br>posal. There are times when you want to leave the inner stream open and yet still<br>dispose the DeflateStream to perform its <i>essential</i> tear-down activity (flushing buf-<br>fered data).<br>
This pattern might look simple, yet it escaped StreamReader and StreamWriter (the<br>System.IO  namespace).  The  result  is  messy:  StreamWriter  must  expose  another<br>method (Flush) to perform essential cleanup for consumers not calling Dispose. The<br>CryptoStream class in System.Security.Cryptography suffers a similar problem and<br>requires that you call FlushFinalBlock to tear it down while keeping the inner stream<br>open.<br>
<b>IDisposable, Dispose, and Close | 479</b><br>
<hr>
<A name=500></a>You could describe this as an <i>ownership</i> issue. The question for<br>a disposable object is: do I really own the underlying resource<br>that I'm using? Or am I just renting it from someone else who<br>manages both the underlying resource lifetime and, by some<br>undocumented contract, my lifetime?<br>
Following the opt-in pattern avoids this problem by making the<br>ownership contract documented and explicit.<br>
<b>Clearing Fields in Disposal<br></b>In general, you don't need to clear an object's fields in its Dispose method. However,<br>it is good practice to unsubscribe from events that the object has subscribed to in-<br>ternally over its lifetime (see "Managed Memory Leaks" on page 491 for an exam-<br>ple).  Unsubscribing  from  such  events  avoids  receiving  unwanted  event<br>notifications--and avoids unintentionally keeping the object alive in the eyes of the<br>garbage collector (GC).<br>
A Dispose method itself does not cause memory to be released--<br>this can happen only in garbage collection.<br>
It's also worth setting a field to indicate that the object is disposed so that you can<br>throw an ObjectDisposedException if a consumer later tries to call members on the<br>object. A good pattern is to use a publicly readable automatic property for this:<br>
public bool IsDisposed { get; private set; }<br>
Although technically unnecessary, it can also be good to clear an object's own event<br>handlers (by setting them to null) in the Dispose method. This eliminates the pos-<br>sibility of those events firing during or after disposal.<br>
Occasionally, an object holds high-value secrets, such as encryption keys. In these<br>cases, it can make sense to clear such data from fields during disposal (to avoid<br>discovery by less privileged assemblies or malware). The SymmetricAlgorithm class<br>in System.Security.Cryptography does exactly this, by calling Array.Clear on the<br>byte array holding the encryption key.<br>
<b>Automatic Garbage Collection<br></b>Regardless of whether an object requires a Dispose method for custom tear-down<br>logic, at some point the memory it occupies on the heap must be freed. The CLR<br>handles  this  side  of  it  entirely  automatically,  via  an  automatic  GC.  You  never<br>deallocate managed memory yourself. For example, consider the following method:<br>
<b>480 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=501></a>public void Test()<br>
{<br>  byte[] myArray = new byte[1000];<br>  ...<br>
}<br>
<b>Garbage Collection and Memory Consumption</b><br>
The GC tries to strike a balance between the time it spends doing garbage collec-<br>tion  and  the  application's  memory  consumption  (working  set).  Consequently,<br>applications can consume more memory than they need, particularly if large tem-<br>porary arrays are constructed.<br>
<b>Disposal and GC</b><br>
The problem can look worse than it is, though, if you judge memory consumption<br>by the "Memory Usage" figure reported by the Task Manager in Windows XP.<br>Unlike with later versions of Windows (which report <i>private working set</i>), the XP<br>figure includes memory that a process has internally deallocated and is willing to<br>rescind immediately to the operating system should another process need it. (It<br>doesn't return the memory to the operating system immediately to avoid the over-<br>head of asking for it back, should it be required a short while later. It reasons: "If<br>the computer has plenty of free memory, why not use it to lessen allocation/deal-<br>location overhead?")<br>
You can determine your process's real memory consumption by querying a per-<br>formance counter (System.Diagnostics):<br>
string procName = Process.GetCurrentProcess().ProcessName;<br>
using (PerformanceCounter pc = new PerformanceCounter<br>      (&quot;Process&quot;, &quot;Private Bytes&quot;, procName))<br>  Console.WriteLine (pc.NextValue());<br>
Reading performance counters requires administrative privileges.<br>
When Test executes, an array to hold 1,000 bytes is allocated on the memory heap.<br>The array is referenced by the variable myArray, stored on the local variable stack.<br>When the method exits, this local variable myArray pops out of scope, meaning that<br>nothing is left to reference the array on the memory heap. The orphaned array then<br>becomes eligible to be reclaimed in garbage collection.<br>
In debug mode with optimizations disabled, the lifetime of an<br>object referenced by a local variable extends to the end of the<br>code block to ease debugging. Otherwise, it becomes eligible<br>for collection at the earliest point at which it's no longer used.<br>
Garbage collection does not happen immediately after an object is orphaned. Rather<br>like garbage collection on the street, it happens periodically, although (unlike gar-<br>bage collection on the street) not to a fixed schedule. The CLR bases its decision on<br>when to collect upon a number of factors, such as the available memory, the amount<br>of memory allocation, and the time since the last collection. This means that there's<br>
<b>Automatic Garbage Collection | 481</b><br>
<hr>
<A name=502></a>an indeterminate delay between an object being orphaned and being released from<br>memory. Theoretically, it can range from nanoseconds to days.<br>
The  GC  doesn't  collect  all  garbage  with  every  collection.  In-<br>stead, the memory manager divides objects into <i>generations</i> and<br>the  GC  collects  new  generations  (recently  allocated  objects)<br>more frequently than old generations (long-lived objects). We'll<br>discuss  this  in  more  detail  in  "How  the  Garbage  Collector<br>Works" on page 487.<br>
<b>Roots<br></b>A root is something that keeps an object alive. If an object is not directly or indirectly<br>referenced by a root, it will be eligible for garbage collection.<br>
A root is one of the following:<br>
· A local variable or parameter in an executing method (or in any method in its<br>
call stack)<br>
· A static variable<br>· An object on the queue that stores objects ready for finalization (see the next<br>
section)<br>
It's impossible for code to execute in a deleted object, so if there's any possibility of<br>an (instance) method executing, its object must somehow be referenced in one of<br>these ways.<br>
Note that a group of objects that reference each other cyclically are considered dead<br>without a root referee (see Figure 12-1). To put it in another way, objects that cannot<br>be  accessed  by  following  the  arrows  (references)  from  a  root  object  are<br><i>unreachable</i>--and therefore subject to collection.<br>
<b>Finalizers<br></b>Prior to an object being released from memory, its <i>finalizer</i> runs, if it has one. A<br>finalizer is declared in the same way as a constructor, but it is prefixed by the ~<br>symbol:<br>
class Test<br>{<br>  ~Test()<br>  {<br>    // Finalizer logic...<br>  }<br>}<br>
Finalizers are possible because garbage collection works in distinct phases. First, the<br>GC  identifies  the  unused  objects  ripe  for  deletion.  Those  without  finalizers  are<br>
<b>482 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=503></a><b>Disposal and GC</b><br>
<i>Figure 12-1. Roots</i><br>
deleted right away. Those with pending (unrun) finalizers are kept alive (for now)<br>and are put onto a special queue.<br>
At that point, garbage collection is complete, and your program continues executing.<br>The <i>finalizer thread</i> then kicks in and starts running in parallel to your program,<br>picking objects off that special queue and running their finalization methods. Prior<br>to each object's finalizer running, it's still very much alive--that queue acts as a root<br>object. Once it's been dequeued and the finalizer executed, the object becomes or-<br>phaned and will get deleted in the next collection (for that object's <i>generation</i>).<br>
Finalizers can be useful, but they come with some provisos:<br>
· Finalizers slow the allocation and collection of memory (the GC needs to keep<br>
track of which finalizers have run).<br>
· Finalizers prolong the life of the object and any <i>referred</i> objects (they must all<br>
await the next garbage truck for actual deletion).<br>
· It's impossible to predict in what order the finalizers for a set of objects will be<br>
called.<br>
· You have limited control over when the finalizer for an object will be called.<br>· If code in a finalizer blocks, other objects cannot get finalized.<br>· Finalizers  may  be  circumvented  altogether  if  an  application  fails  to  unload<br>
cleanly.<br>
In summary, finalizers are somewhat like lawyers--although there are cases in which<br>you really need them, in general you don't want to use them unless absolutely nec-<br>essary. If you do use them, you need to be 100% sure you understand what they are<br>doing for you.<br>
<b>Finalizers | 483</b><br>
<hr>
<A name=504></a>Here are some guidelines for implementing finalizers:<br>
· Ensure that your finalizer executes quickly.<br>· Never block in your finalizer (Chapter 21).<br>· Don't reference other finalizable objects.<br>· Don't throw exceptions.<br>
An object's finalizer can get called even if an exception is thrown<br>during construction. For this reason, it pays not to assume that<br>fields are correctly initialized when writing a finalizer.<br>
<b>Calling Dispose from a Finalizer<br></b>One excellent use for finalizers is to provide a backup for cases when you forget to<br>call Dispose on a disposable object; it's usually better to have an object disposed late<br>than never! There's a standard pattern for implementing this, as follows:<br>
class Test : IDisposable<br>
{<br>  public void Dispose()             // NOT virtual<br>
  {<br>
    Dispose (true);<br>    GC.SuppressFinalize (this);     // Prevent finalizer from running.<br>
  }<br>
  protected virtual void Dispose (bool disposing)<br>  {<br>    if (disposing)<br>    {<br>      // Call Dispose() on other objects owned by this instance.<br>      // You can reference other finalizable objects here.<br>      // ...<br>    }<br>
    // Release unmanaged resources owned by (just) this object.<br>    // ...<br>  }<br>
  ~Test()<br>  {<br>    Dispose (false);<br>  }<br>}<br>
Dispose is overloaded to accept a bool disposing flag. The parameterless version is<br><i>not</i> declared as virtual and simply calls the enhanced version with true.<br>The  enhanced  version  contains  the  actual  disposal  logic  and  is  protected  and<br>virtual; this provides a safe point for subclasses to add their own disposal logic.<br>The  disposing  flag  means  it's  being  called  "properly"  from  the  Dispose  method<br>rather than in "last-resort mode" from the finalizer. The idea is that when called<br>with  disposing  set  to  false,  this  method  should  not,  in  general,  reference  other<br>
<b>484 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=505></a>objects with finalizers (because such objects may themselves have been finalized and<br>so be in an unpredictable state). This rules out quite a lot! Here are a couple of tasks<br>it can still perform in last-resort mode, when disposing is false:<br>
· Releasing any <i>direct references</i> to operating system resources (obtained, per-<br>
haps, via a P/Invoke call to the Win32 API)<br>
· Deleting a temporary file created on construction<br>
To make this robust, any code capable of throwing an exception should be wrapped<br>in a try/catch block, and the exception, ideally, logged. Any logging should be as<br>simple and robust as possible.<br>
Notice that we call GC.SuppressFinalize in the parameterless Dispose method--this<br>
<b>Disposal and GC</b><br>
prevents the finalizer from running when the GC later catches up with it. Techni-<br>cally, this is unnecessary, as Dispose methods must tolerate repeated calls. However,<br>doing so improves performance because it allows the object (and its referenced ob-<br>jects) to be garbage-collected in a single cycle.<br>
This pattern is intended more as a backup than a replacement<br>for calling Dispose. A difficulty with relying on it completely is<br>that  you  couple  resource  deallocation  to  memory<br>deallocation--two things with potentially divergent interests.<br>You also increase the burden on the finalization thread.<br>
<b>Resurrection<br></b>Suppose a finalizer modifies a living object such that it refers back to the dying object.<br>When the next garbage collection happens (for the object's generation), the CLR<br>will see the previously dying object as no longer orphaned--and so it will evade<br>garbage collection. This is an advanced scenario, and is called <i>resurrection</i>.<br>
To illustrate, suppose we want to write a class that manages a temporary file. When<br>an instance of that class is garbage-collected, we'd like the finalizer to delete the<br>temporary file. It sounds easy:<br>
public class TempFileRef<br>{<br>  public readonly string FilePath;<br>  public TempFileRef (string filePath) { FilePath = filePath; }<br>
  ~TempFileRef() { File.Delete (FilePath); }<br>}<br>
Unfortunately, this has a bug: File.Delete might throw an exception (due to a lack<br>of permissions, perhaps, or the file being in use). Such an exception would take down<br>the whole application (as well as preventing other finalizers from running). We could<br>simply "swallow" the exception with an empty catch block, but then we'd never<br>know that anything went wrong. Calling some elaborate error reporting API would<br>also be undesirable because it would burden the finalizer thread, hindering garbage<br>
<b>Finalizers | 485</b><br>
<hr>
<A name=506></a>collection for other objects. We want to restrict finalization actions to those that are<br>simple, reliable, and quick.<br>
A better option is to record the failure to a static collection as follows:<br>
public class TempFileRef<br>{<br>  static ConcurrentQueue&lt;TempFileRef&gt; _failedDeletions<br>
    = new ConcurrentQueue&lt;TempFileRef&gt;();<br>
  public readonly string FilePath;<br>  public Exception DeletionError { get; private set; }<br>
  public TempFileRef (string filePath) { FilePath = filePath; }<br>
  ~TempFileRef()<br>  {<br>
    try { File.Delete (FilePath); }<br>    catch (Exception ex)<br>
    {<br>      DeletionError = ex;<br>
      <b>_failedDeletions.Enqueue (this);   // Resurrection<br></b>    }<br>
  }<br>}<br>
Enqueuing the object to the static _failedDeletions collection gives the object an-<br>other referee, ensuring that it remains alive until the object is eventually dequeued.<br>
ConcurrentQueue&lt;T&gt; is a thread-safe version of Queue&lt;T&gt; and is<br>defined  in  System.Collections.Concurrent  (see  Chapter  22).<br>There are a couple of reasons for using a thread-safe collection.<br>First, the CLR reserves the right to execute finalizers on more<br>than  one  thread  in  parallel.  This  means  that  when  accessing<br>shared state such as a static collection, we must consider the<br>possibility  of  two  objects  being  finalized  at  once.  Second,  at<br>some point we're going to want to dequeue items from _failed<br>Deletions so that we can do something about them. This also<br>has to be done in a thread-safe fashion, because it could happen<br>while the finalizer is concurrently enqueuing another object.<br>
<b>GC.ReRegisterForFinalize<br></b>A  resurrected  object's  finalizer  will  not  run  a  second  time--unless  you  call<br>GC.ReRegisterForFinalize.<br>
In the following example, we try to delete a temporary file in a finalizer (as in the<br>last example). But if the deletion fails, we reregister the object so as to try again in<br>the next garbage collection:<br>
<b>486 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=507></a>public class TempFileRef<br>
{<br>  public readonly string FilePath;<br>  int _deleteAttempt;<br>
  public TempFileRef (string filePath) { FilePath = filePath; }<br>
  ~TempFileRef()<br>
  {<br>
    try { File.Delete (FilePath); }<br>    catch<br>    {<br>
      if (_deleteAttempt++ &lt; 3) GC.ReRegisterForFinalize (this);<br>
    }<br>
<b>Disposal and GC</b><br>
  }<br>}<br>
After the third failed attempt, our finalizer will silently give up trying to delete the<br>file. We could enhance this by combining it with the previous example--in other<br>words, adding it to the _failedDeletions queue after the third failure.<br>
Be careful to call ReRegisterForFinalize just once in the finalizer<br>method. If you call it twice, the object will be reregistered twice<br>and will have to undergo two more finalizations!<br>
<b>How the Garbage Collector Works<br></b>The CLR uses a generational mark-and-compact GC that performs automatic mem-<br>ory management for objects stored on the managed heap. The GC is considered to<br>be a <i>tracing</i> garbage collector in that it doesn't interfere with every access to an object,<br>but rather wakes up intermittently and traces the graph of objects stored on the<br>managed heap to determine which objects can be considered garbage and therefore<br>collected.<br>
The GC initiates a garbage collection upon performing a memory allocation (via the<br>new keyword) either after a certain threshold of memory has been allocated, or at<br>other times to reduce the application's memory footprint. This process can also be<br>initiated manually by calling System.GC.Collect. During a garbage collection, all<br>threads may by frozen (more on this in the next section).<br>
The GC begins with its root object references, and walks the object graph, marking<br>all the objects it touches as reachable. Once this process is complete, all objects that<br>have not been marked are considered unused, and are subject to garbage collection.<br>
Unused objects without finalizers are immediately discarded; unused objects with<br>finalizers are enqueued for processing on the finalizer thread after the GC is com-<br>plete. These objects then become eligible for collection in the next GC for the object's<br>generation (unless resurrected).<br>
The remaining "live" objects are then shifted to the start of the heap (compacted),<br>freeing  space  for  more  objects.  This  compaction  serves  two  purposes:  it  avoids<br>
<b>How the Garbage Collector Works | 487</b><br>
<hr>
<A name=508></a>memory fragmentation, and it allows the GC to employ a very simple strategy when<br>allocating new objects, which is to always allocate memory at the end of the heap.<br>This avoids the potentially time-consuming task of maintaining a list of free memory<br>segments.<br>
If  there  is  insufficient  space  to  allocate  memory  for  a  new  object  after  garbage<br>collection,  and  the  operating  system  is  unable  to  grant  further  memory,  an<br>OutOfMemoryException is thrown.<br>
<b>Optimization Techniques<br></b>The GC incorporates various optimization techniques to reduce the garbage collec-<br>tion time.<br>
<b>Generational collection<br></b>The most important optimization is that the GC is generational. This takes advant-<br>age of the fact that although many objects are allocated and discarded rapidly, certain<br>objects are long-lived and thus don't need to be traced during every collection.<br>
Basically, the GC divides the managed heap into three generations. Objects that have<br>just been allocated are in <i>Gen0</i> and objects that have survived one collection cycle<br>are in <i>Gen1</i>; all other objects are in <i>Gen2</i>.<br>
The CLR keeps the Gen0 section relatively small (a maximum of 16 MB on the 32-<br>bit workstation CLR, with a typical size of a few hundred KB to a few MB). When<br>the Gen0 section fills up, the GC instigates a Gen0 collection--which happens rel-<br>atively often. The GC applies a similar memory threshold to Gen1 (which acts as a<br>buffer to Gen2), and so Gen1 collections are relatively quick and frequent too. Full<br>collections  that  include  Gen2,  however,  take  much  longer  and  so  happen  infre-<br>quently. Figure 12-2 shows the effect of a full collection.<br>
To give some very rough ballpark figures, a Gen0 collection might take less than 1<br>ms, which is not enough to be noticed in a typical application. A full collection,<br>however, might take as long as 100 ms on a program with large object graphs. These<br>figures depend on numerous factors and so may vary considerably--particularly in<br>the case of Gen2 whose size is <i>unbounded</i> (unlike Gen0 and Gen1).<br>
The upshot is that short-lived objects are very efficient in their use of the GC. The<br>StringBuilders created in the following method would almost certainly be collected<br>in a fast Gen0:<br>
string Foo()<br>{<br>  var sb1 = new StringBuilder (&quot;test&quot;);<br>  sb1.Append (&quot;...&quot;);<br>  var sb2 = new StringBuilder (&quot;test&quot;);<br>  sb2.Append (sb1.ToString());<br>  return sb2.ToString();<br>}<br>
<b>488 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=509></a><b>Disposal and GC</b><br>
<i>Figure 12-2. Heap generations</i><br>
<b>The large object heap<br></b>The GC uses a separate heap called the Large Object Heap (LOH) for objects larger<br>than  a  certain  threshold  (currently  85,000  bytes).  This  avoids  excessive  Gen0<br>collections--without the LOH, allocating a series of 16 MB objects might trigger a<br>Gen0 collection after every allocation.<br>
The LOH is not subject to compaction, because moving large blocks of memory<br>during  garbage  collection  would  be  prohibitively  expensive.  This  has  two<br>consequences:<br>
· Allocations can be slower, because the GC can't always simply allocate objects<br>
at the end of the heap--it must also look in the middle for gaps, and this requires<br>maintaining a linked list of free memory blocks.<br>
· The LOH is subject to <i>fragmentation</i>. This means that the freeing of an object<br>
can create a hole in the LOH that may be hard to fill later. For instance, a hole<br>left by an 86,000-byte object can be filled only by an object of between 85,000<br>bytes and 86,000 bytes (unless adjoined by another hole).<br>
The large object heap is also nongenerational: all objects are treated as Gen2.<br>
 The same thing may occur occasionally in the generational heap due to pinning (see "The fixed<br>
Statement" on page 171 in Chapter 4).<br>
<b>How the Garbage Collector Works | 489</b><br>
<hr>
<A name=510></a><b>Concurrent and background collection<br></b>The GC must freeze (block) your execution threads for periods during a collection.<br>This includes the entire period during which a Gen0 or Gen1 collection takes place.<br>
The GC makes a special attempt, though, at allowing threads to run during a Gen2<br>collection, as it's undesirable to freeze an application for a potentially long period.<br>This optimization applies to the workstation version of the CLR only, which is used<br>on desktop versions of Windows (and on all versions of Windows with standalone<br>applications). The rationale is that the latency from a blocking collection is less likely<br>to be a problem for server applications thats don't have a user interface.<br>
A mitigating factor is that the server CLR leverages all available<br>cores to perform GCs, so an eight-core server will perform a full<br>GC  many  times  faster.  In  effect,  the  server  GC  is  tuned  for<br>throughput rather than latency.<br>
The  workstation  optimization  has  historically  been  called  <i>concurrent  collection</i>.<br>From CLR 4.0, it's been revamped and renamed to <i>background collection</i>. Back-<br>ground collection removes a limitation whereby a concurrent collection would cease<br>to be concurrent if the Gen0 section filled up while a Gen2 collection was running.<br>This means that from CLR 4.0, applications that continually allocate memory will<br>be more responsive.<br>
<b>GC notifications (server CLR)<br></b>From Framework 3.5 SP1, the server version of the CLR can notify you just before<br>a full GC will occur. This is intended for server farm configurations: the idea is that<br>you divert requests to another server just before a collection. You then instigate the<br>collection immediately and wait for it to complete before rerouting requests back to<br>that server.<br>
To start notification, call GC.RegisterForFullGCNotification. Then start up another<br>thread (see Chapter 21) that first calls GC.WaitForFullGCApproach. When this method<br>returns a GCNotificationStatus indicating that a collection is near, you can reroute<br>requests to other servers and force a manual collection (see the following section).<br>You then call GC.WaitForFullGCComplete: when this method returns, GC is complete<br>and you can again accept requests. You then repeat the whole cycle.<br>
<b>Forcing Garbage Collection<br></b>You  can  manually  force  a  GC  at  any  time,  by  calling  GC.Collect.  Calling<br>GC.Collect without an argument instigates a full collection. If you pass in an integer<br>value, only generations to that value are collected, so GC.Collect(0) performs only<br>a fast Gen0 collection.<br>
In general, you get the best performance by allowing the GC to decide when to<br>collect: forcing collection can hurt performance by unnecessarily promoting Gen0<br>objects  to  Gen1.  It  can  also  upset  the  GC's  <i>self-tuning</i>  ability,  whereby  the  GC<br>
<b>490 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=511></a>dynamically tweaks the thresholds for each generation to maximize performance as<br>the application executes.<br>
There are exceptions, however. The most common case for intervention is when an<br>application goes to sleep for a while: a good example is a Windows Service that<br>performs a daily activity (checking for updates, perhaps). Such an application might<br>use a System.Timers.Timer to initiate the activity every 24 hours. After completing<br>the activity, no further code executes for 24 hours, which means that for this period,<br>no memory allocations are made and so the GC has no opportunity to activate.<br>Whatever memory the service consumed in performing its activity, it will continue<br>to consume for the following 24 hours--even with an empty object graph! The sol-<br>ution is to call GC.Collect right after the daily activity completes.<br>
<b>Disposal and GC</b><br>
To ensure the collection of objects for which collection is delayed by finalizers, you<br>can take the additional step of calling WaitForPendingFinalizers and re-collecting:<br>
GC.Collect();<br>
GC.WaitForPendingFinalizers();<br>GC.Collect();<br>
<b>Memory Pressure<br></b>The runtime decides when to initiate collections based on a number of factors, in-<br>cluding the total memory load on the machine. If your program allocates unmanaged<br>memory (Chapter 25), the runtime will get an unrealistically optimistic perception<br>of its memory usage, because the CLR knows only about managed memory. You<br>can mitigate this by telling the CLR to <i>assume</i> a specified quantity of unmanaged<br>memory has been allocated, by calling GC.AddMemoryPressure. To undo this (when<br>the unmanaged memory is released) call GC.RemoveMemoryPressure.<br>
<b>Managed Memory Leaks<br></b>In unmanaged languages such as C++, you must remember to manually deallocate<br>memory when an object is no longer required; otherwise, a <i>memory leak</i> will result.<br>In the managed world, this kind of error is impossible due to the CLR's automatic<br>garbage collection system.<br>
Nonetheless, large and complex .NET applications can exhibit a milder form of the<br>same syndrome with the same end result: the application consumes more and more<br>memory over its lifetime, until it eventually has to be restarted. The good news is<br>that managed memory leaks are usually easier to diagnose and prevent.<br>
Managed memory leaks are caused by unused objects remaining alive by virtue of<br>unused or forgotten references. A common candidate is event handlers--these hold<br>a reference to the target object (unless the target is a static method). For instance,<br>consider the following classes:<br>
class Host<br>{<br>  public event EventHandler Click;<br>}<br>
<b>Managed Memory Leaks | 491</b><br>
<hr>
<A name=512></a>class Client<br>
{<br>  Host _host;<br>  public Client (Host host)<br>
  {<br>
    _host = host;<br>    _host.Click += HostClicked;<br>  }<br>
  void HostClicked (object sender, EventArgs e) { ... }<br>}<br>
The following test class contains a method that instantiates 1,000 clients:<br>
class Test<br>{<br>  static Host _host = new Host();<br>
  public static void CreateClients()<br>  {<br>
    Client[] clients = Enumerable.Range (0, 1000)<br>     .Select (i =&gt; new Client (_host))<br>
     .ToArray();<br>
    // Do something with clients ...<br>
  }<br>
}<br>
You might expect that after CreateClients finishes executing, the 1,000 Client ob-<br>jects will become eligible for collection. Unfortunately, each client has another ref-<br>eree: the _host object whose Click event now references each Client instance. This<br>may  go  unnoticed  if  the  Click  event  doesn't  fire--or  if  the  HostClicked  method<br>doesn't do anything to attract attention.<br>
One  way  to  solve  this  is  to  make  Client  implement  IDisposable,  and  in  the<br>Dispose method, unhook the event handler:<br>
public void Dispose() { _host.Click -= HostClicked; }<br>
Consumers of Client then dispose of the instances when they're done with them:<br>
Array.ForEach (clients, c =&gt; c.Dispose());<br>
In "Weak References" on page 494, we'll describe another sol-<br>ution  to  this  problem,  which  can  be  useful  in  environments<br>which tend not to use disposable objects (an example is WPF).<br>In fact, the WPF framework offers a class called WeakEventMan<br>ager that leverages a pattern employing weak references.<br>
On the topic of WPF, <i>data binding</i> is another common cause for<br>memory leaks: the issue is described at <i>http://support.microsoft<br>.com/kb/938416</i>.<br>
<b>492 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=513></a><b>Timers<br></b>Forgotten timers can also cause memory leaks (we discuss timers in Chapter 21).<br>There are two distinct scenarios, depending on the kind of timer. Let's first look at<br>the timer in the System.Timers namespace. In the following example, the Foo class<br>(when instantiated) calls the tmr_Elapsed method once every second:<br>
using System.Timers;<br>
class Foo<br>
{<br>  Timer _timer;<br>
  Foo()<br>
<b>Disposal and GC</b><br>
  {<br>
    _timer = new System.Timers.Timer { Interval = 1000 };<br>
    _timer.Elapsed += tmr_Elapsed;<br>
    _timer.Start();<br>
  }<br>
  void tmr_Elapsed (object sender, ElapsedEventArgs e) { ... }<br>
}<br>
Unfortunately,  instances  of  Foo  can  never  be  garbage-collected!  The  problem  is<br>the .NET Framework itself holds references to active timers so that it can fire their<br>Elapsed events. Hence:<br>
· The .NET Framework will keep _timer alive.<br>· _timer will keep the Foo instance alive, via the tmr_Elapsed event handler.<br>
The solution is obvious when you realize that Timer implements IDisposable. Dis-<br>posing of the timer stops it and ensures that the .NET Framework no longer refer-<br>ences the object:<br>
class Foo : IDisposable<br>
{<br>  ...<br>  public void Dispose() { _timer.Dispose(); }<br>}<br>
A good guideline is to implement IDisposable yourself if any<br>field  in  your  class  is  assigned  an  object  that  implements<br>IDisposable.<br>
The WPF and Windows Forms timers behave in exactly the same way, with respect<br>to what's just been discussed.<br>
The timer in the System.Threading namespace, however, is special. The .NET Frame-<br>work doesn't hold references to active threading timers; it instead references the<br>callback delegates directly. This means that if you forget to dispose of a threading<br>timer, a finalizer can (and will) fire--and this will automatically stop and dispose<br>
<b>Managed Memory Leaks | 493</b><br>
<hr>
<A name=514></a>the timer. This can create a different problem, however, which we can illustrate as<br>follows:<br>
static void Main()<br>{<br>  var tmr = new System.Threading.Timer (TimerTick, null, 1000, 1000);<br>
  GC.Collect();<br>  System.Threading.Thread.Sleep (10000);    // Wait 10 seconds<br>}<br>
static void TimerTick (object notUsed) { Console.WriteLine (&quot;tick&quot;); }<br>
If this example is compiled in "release" mode (debugging disabled and optimizations<br>enabled), the timer will be collected and finalized before it has a chance to fire even<br>once! Again, we can fix this by disposing of the timer when we're done with it:<br>
using (var tmr = new System.Threading.Timer (TimerTick, null, 1000, 1000))<br>
{<br>  GC.Collect();<br>
  System.Threading.Thread.Sleep (10000);    // Wait 10 seconds<br>
}<br>
The implicit call to tmr.Dispose at the end of the using block ensures that the tmr<br>variable is "used" and so not considered dead by the GC until the end of the block.<br>Ironically, this call to Dispose actually keeps the object alive <i>longer</i>!<br>
<b>Diagnosing Memory Leaks<br></b>The easiest way to avoid managed memory leaks is to proactively monitor memory<br>consumption  as  an  application  is  written.  You  can  obtain  the  current  memory<br>consumption of a program's objects as follows (the true argument tells the GC to<br>perform a collection first):<br>
long memoryUsed = GC.GetTotalMemory (true);<br>
If you're practicing test-driven development, one possibility is to use unit tests to<br>assert that memory is reclaimed as expected. If such an assertion fails, you then have<br>to examine only the changes that you've made recently.<br>
If  you  already  have  a  large  application  with  a  managed  memory  leak,  the<br><i>windbg.exe</i> tool can assist in finding it. There are also friendlier graphical tools such<br>as  Microsoft's  CLR  Profiler,  SciTech's  Memory  Profiler,  and  Red  Gate's  ANTS<br>Memory Profiler.<br>
The CLR also exposes numerous Windows WMI counters to assist with resource <br>monitoring.<br>
<b>Weak References<br></b>Occasionally, it's useful to hold a reference to an object that's "invisible" to the GC<br>in terms of keeping the object alive. This is called a <i>weak reference</i>, and is imple-<br>mented by the System.WeakReference class.<br>To use WeakReference, construct it with a target object as follows:<br>
<b>494 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=515></a>var sb = new StringBuilder (&quot;this is a test&quot;);<br>
var weak = new WeakReference (sb);<br>Console.WriteLine (weak.Target);     // This is a test<br>
If a target is referenced <i>only</i> by one or more weak references, the GC will consider<br>the target eligible for collection. When the target gets collected, the Target property<br>of the WeakReference will be null:<br>
var weak = new WeakReference (new StringBuilder (&quot;weak&quot;));<br>
Console.WriteLine (weak.Target);   // weak<br>
GC.Collect();<br>
Console.WriteLine (weak.Target);   // <i>(nothing)</i><br>
To avoid the target being collected in between testing for it being null and consuming<br>
<b>Disposal and GC</b><br>
it, assign the target to a local variable:<br>
var weak = new WeakReference (new StringBuilder (&quot;weak&quot;));<br>
var sb = (StringBuilder) weak.Target;<br>if (sb != null) { /* Do something with sb */ }<br>
Once a target's been assigned to a local variable, it has a strong root and so cannot<br>be collected while that variable's in use.<br>
The following class uses weak references to keep track of all Widget objects that have<br>been instantiated, without preventing those objects from being collected:<br>
class Widget<br>{<br>  static List&lt;WeakReference&gt; _allWidgets = new List&lt;WeakReference&gt;();<br>
  public readonly string Name;<br>
  public Widget (string name)<br>  {<br>    Name = name;<br>    _allWidgets.Add (new WeakReference (this));<br>  }<br>
  public static void ListAllWidgets()<br>  {<br>    foreach (WeakReference weak in _allWidgets)<br>    {<br>      Widget w = (Widget)weak.Target;<br>      if (w != null) Console.WriteLine (w.Name);<br>    }<br>  }<br>}<br>
The only proviso with such a system is that the static list will grow over time, accu-<br>mulating weak references with null targets. So you need to implement some cleanup<br>strategy.<br>
<b>Weak References and Caching<br></b>One use for WeakReference is to cache large object graphs. This allows memory-<br>intensive data to be cached briefly without causing excessive memory consumption:<br>
<b>Weak References | 495</b><br>
<hr>
<A name=516></a>_weakCache = new WeakReference (...);   // _weakCache is a field<br>
...<br>var cache = _weakCache.Target;<br>if (cache == null) { /* Re-create cache &amp; assign it to _weakCache */ }<br>
This strategy may be only mildly effective in practice, because you have little control<br>over when the GC fires and what generation it chooses to collect. In particular, if<br>your cache remains in Gen0, it may be collected within microseconds (and remember<br>that the GC doesn't collect only when memory is low--it collects regularly under<br>normal memory conditions). So at a minimum, you should employ a two-level cache<br>whereby you start out by holding strong references that you convert to weak refer-<br>ences over time.<br>
<b>Weak References and Events<br></b>We saw earlier how events can cause managed memory leaks. The simplest solution<br>is to either avoid subscribing in such conditions, or implement a Dispose method to<br>unsubscribe. Weak references offer another solution.<br>
Imagine a delegate that holds only weak references to its targets. Such a delegate<br>would not keep its targets alive--unless those targets had independent referees. Of<br>course, this wouldn't prevent a firing delegate from hitting an unreferenced target--<br>in the time between the target being eligible for collection and the GC catching up<br>with it. For such a solution to be effective, your code must be robust in that scenario.<br>Assuming that is the case, a <i>weak delegate</i> class can be implemented as follows:<br>
class WeakDelegate&lt;TDelegate&gt; where TDelegate : class<br>{<br>  List&lt;WeakReference&gt; _targets = new List&lt;WeakReference&gt;();<br>
  public WeakDelegate()<br>  {<br>    if (!typeof (TDelegate).IsSubclassOf (typeof (Delegate)))<br>      throw new InvalidOperationException<br>       (&quot;TDelegate must be a delegate type&quot;);<br>  }<br>
  public void Combine (TDelegate target)<br>  {<br>    if (target == null) return;<br>    foreach (Delegate d in (target as Delegate).GetInvocationList())<br>      _targets.Add (new WeakReference (d));<br>  }<br>
  public void Remove (TDelegate target)<br>  {<br>    if (target == null) return;<br>    foreach (Delegate d in (target as Delegate).GetInvocationList())<br>    {<br>      WeakReference weak = _targets.Find (w =&gt; d.Equals (w.Target));<br>      if (weak != null) _targets.Remove (weak);<br>    }<br>  }<br>
<b>496 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=517></a>  public TDelegate Target<br>
  {<br>    get<br>    {<br>
      var deadRefs = new List&lt;WeakReference&gt;();<br>
      Delegate combinedTarget = null;<br>
      foreach (WeakReference weak in _targets)<br>
      {<br>
        Delegate target = (Delegate)weak.Target;<br>        if (target != null)<br>          combinedTarget = Delegate.Combine (combinedTarget, target);<br>
        else<br>
          deadRefs.Add (weak);<br>
<b>Disposal and GC</b><br>
      }<br>      foreach (WeakReference weak in deadRefs)   // Remove dead references<br>
        _targets.Remove (weak);                  // from _targets.<br>
      return combinedTarget as TDelegate;<br>    }<br>
    set<br>    {<br>
      _targets.Clear();<br>      Combine (value);<br>
    }<br>  }<br>
}<br>
This code illustrates a number of interesting points in C# and the CLR. First, note<br>that we check that TDelegate is a delegate type in the constructor. This is because<br>of a limitation in C#--the following type constraint is illegal because C# considers<br>System.Delegate a special type for which constraints are not supported:<br>
 ... where TDelegate : <b>Delegate</b>   // Compiler doesn't allow this<br>
Instead, we must choose a class constraint, and perform a runtime check in the<br>constructor.<br>
In  the  Combine  and  Remove  methods,  we  perform  the  reference  conversion  from<br>target to Delegate via the as operator, rather than the more usual cast operator. This<br>is because C# disallows the cast operator with this type parameter--because of a<br>potential ambiguity between a <i>custom conversion</i> and a <i>reference conversion</i>.<br>
We then call GetInvocationList because these methods might be called with mul-<br>ticast delegates--delegates with more than one method recipient.<br>
In the Target property, we build up a multicast delegate that combines all the dele-<br>gates referenced by weak references whose targets are alive. We then clear out the<br>remaining (dead) references from the list--to avoid the _targets list endlessly grow-<br>ing. (We could improve our class by doing the same in the Combine method; yet<br>another improvement would be to add locks for thread safety [Chapter 21]).<br>
<b>Weak References | 497</b><br>
<hr>
<A name=518></a>The following illustrates how to consume this delegate in implementing an event:<br>
public class Foo<br>
{<br>  WeakDelegate&lt;EventHandler&gt; _click = new WeakDelegate&lt;EventHandler&gt;();<br>
  public event EventHandler Click<br>
  {<br>
    add { _click.Combine (value); } remove { _click.Remove (value); }<br>  }<br>
  protected virtual void OnClick (EventArgs e)<br>  {<br>
    EventHandler target = _click.Target;<br>    if (target != null) target (this, e);<br>
  }<br>}<br>
Notice  that  in  firing  the  event,  we  assign  _click.Target  to  a  temporary  variable<br>before checking and invoking it. This avoids the possibility of targets being collected<br>in the interim.<br>
<b>498 | Chapter 12:</b><b>Disposal and Garbage Collection</b><br>
<hr>
<A name=519></a><b>13</b><br>
<b>Diagnostics and Code Contracts</b><br>
When things go wrong, it's important that information is available to aid in diag-<br>nosing the problem. An IDE or debugger can assist greatly to this effect--but it is<br>usually available only during development. Once an application ships, the applica-<br>tion itself must gather and record diagnostic information. To meet this requirement,<br>the .NET Framework provides a set of facilities to log diagnostic information, mon-<br>itor application behavior, detect runtime errors, and integrate with debugging tools<br>if available.<br>
From Framework 4.0, there are also a new set of types to enforce <i>code contracts</i>.<br>These allow methods to interact through a set of mutual obligations, and fail <i>early<br></i>if those obligations are violated.<br>
The  types  in  this  chapter  are  defined  primarily  in  the  System.Diagnostics  and<br>System.Diagnostics.Contracts namespaces.<br>
<b>Conditional Compilation<br></b>You can conditionally compile any section of code in C# with <i>preprocessor direc-<br>tives</i>. Preprocessor directives are special instructions to the compiler that begin with<br>the # symbol (and, unlike other C# constructs, must appear on a line of their own).<br>The preprocessor directives for conditional compilation are #if, #else, #endif, and<br>#elif.<br>
The #if directive instructs the compiler to ignore a section of code unless a specified<br><i>symbol</i> has been defined. You can define a symbol with either the #define directive<br>or a compilation switch. #define applies to a particular <i>file</i>; a compilation switch<br>applies to a whole <i>assembly</i>:<br>
<b>#define TESTMODE            // #define directives must be at top of file<br></b>                            // Symbol names are uppercase by convention.<br>using System;<br>
class Program<br>{<br>
<b>499</b><br>
<hr>
<A name=520></a>  static void Main()<br>
  {<br><b>#if TESTMODE<br></b>    Console.WriteLine (&quot;in test mode!&quot;);     // OUTPUT: in test mode!<br>
<b>#endif</b><br>
  }<br>}<br>
If we deleted the first line, the program would compile with the Console.WriteLine<br>statement completely eliminated from the executable.<br>
The #else statement is analogous to C#'s else statement, and #elif is equivalent<br>to #else followed by #if. The ||, &amp;&amp;, and ! operators can be used to perform <i>or</i>,<br><i>and</i>, and <i>not</i> operations:<br>
#if TESTMODE &amp;&amp; !PLAYMODE      // if TESTMODE and not PLAYMODE<br>
  ...<br>
Bear in mind, however, that you're not building an ordinary C# expression, and the<br>symbols upon which you operate have absolutely no connection to <i>variables</i>--static<br>or otherwise.<br>
To define a symbol assembly-wide, specify the /define switch when compiling:<br>
csc Program.cs <b>/define:TESTMODE,PLAYMODE</b><br>
Visual Studio provides an option to enter conditional compilation symbols under<br>Project Properties.<br>
If you've defined a symbol at the assembly level and then want to "undefine" it for<br>a particular file, you can do so with the #undef directive.<br>
<b>Conditional Compilation Versus Static Variable Flags<br></b>The preceding example could instead be implemented with a simple static field:<br>
static internal bool TestMode = true;<br>
static void Main()<br>{<br>  if (TestMode) Console.WriteLine (&quot;in test mode!&quot;);<br>}<br>
This has the advantage of allowing runtime configuration. So, why choose condi-<br>tional compilation? The reason is that conditional compilation can take you places<br>variable flags cannot, such as:<br>
· Conditionally including an attribute<br>· Changing the declared type of variable<br>· Switching between different namespaces or type aliases in a using directive--<br>
for example:<br>
using TestType =<br>  #if V2<br>
     MyCompany.Widgets.GadgetV2;<br>  #else<br>
<b>500 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=521></a>     MyCompany.Widgets.Gadget;<br>
  #endif<br>
You can even perform major refactoring under a conditional compilation directive,<br>so you can instantly switch between old and new versions, and write libraries that<br>can compile against multiple Framework versions, leveraging the latest Framework<br>features where available.<br>
Another advantage of conditional compilation is that debugging code can refer to<br>types in assemblies that are not included in deployment.<br>
<b>The Conditional Attribute<br></b>The Conditional attribute instructs the compiler to ignore any calls to a particular<br>class or method, if the specified symbol has not been defined.<br>
To see how this is useful, suppose you write a method for logging status information<br>as follows:<br>
static void LogStatus (string msg)<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
{<br>  string logFilePath = ...<br>
  System.IO.File.AppendAllText (logFilePath, msg + &quot;\r\n&quot;);<br>
}<br>
Now imagine you wanted this to execute only if the LOGGINGMODE symbol is defined.<br>The first solution is to wrap all calls to LogStatus around an #if directive:<br>
<b>#if LOGGINGMODE</b><br>
LogStatus (&quot;Message Headers: &quot; + GetMsgHeaders());<br><b>#endif</b><br>
This  gives  an  ideal  result,  but  it  is  tedious.  The  second  solution  is  to  put  the<br>#if directive inside  the  LogStatus  method. This, however, is problematic should<br>LogStatus be called as follows:<br>
LogStatus (&quot;Message Headers: &quot; + GetComplexMessageHeaders());<br>
GetComplexMessageHeaders would always get called--which might incur a perform-<br>ance hit.<br>
We can combine the functionality of the first solution with the convenience of the<br>second by attaching the Conditional attribute (defined in System.Diagnostics) to the<br>LogStatus method:<br>
<b>[Conditional (&quot;LOGGINGMODE&quot;)]<br></b>static void LogStatus (string msg)<br>{<br>  ...<br>}<br>
This  instructs  the  compiler  to  implicitly  wrap  any  calls  to  LogStatus  in  an  #if<br>LOGGINGMODE directive. If the symbol is not defined, any calls to LogStatus get elimi-<br>nated  entirely  in  compilation--including  their  argument  evaluation  expressions.<br>This works even if LogStatus and the caller are in different assemblies.<br>
<b>Conditional Compilation | 501</b><br>
<hr>
<A name=522></a>Another  benefit  of  [Conditional]  is  that  the  conditionality<br>check  is  performed  when  the  <i>caller</i>  is  compiled,  rather  than<br>when the <i>called method</i> is compiled. This is beneficial because<br>it  allows  you  to  write  a  library  containing  methods  such  as<br>LogStatus--and build just one version of that library.<br>
The Conditional attribute is ignored at runtime--it's purely an instruction to the<br>compiler.<br>
<b>Alternatives to the Conditional attribute<br></b>The Conditional attribute is useless if you need to dynamically enable or disable<br>functionality  at  runtime:  instead,  you  must  use  a  variable-based  approach.  This<br>leaves the question of how to elegantly circumvent the evaluation of arguments when<br>calling conditional logging methods. A functional approach solves this:<br>
using System;<br>using System.Linq;<br>
class Program<br>
{<br>  public static bool EnableLogging;<br>
  static void LogStatus (Func&lt;string&gt; message)<br>  {<br>
    string logFilePath = ...<br>
    if (EnableLogging)<br>
      System.IO.File.AppendAllText (logFilePath, message() + &quot;\r\n&quot;);<br>  }<br>}<br>
A lambda expression lets you call this method without syntax bloat:<br>
LogStatus ( () =&gt; &quot;Message Headers: &quot; + GetComplexMessageHeaders() );<br>
If EnableLogging is false, GetComplexMessageHeaders is never evaluated.<br>
<b>Debug and Trace Classes<br></b>Debug and Traceare static classes that provide basic logging and assertion capabilities.<br>The two classes are very similar; the main differentiator is their intended use. The<br>Debug class is intended for debug builds; the Trace class is intended for both debug<br>and release builds. To this effect:<br>
All methods of the Debug class are defined with [Conditional(&quot;DEBUG&quot;)].<br>All methods of the Trace class are defined with [Conditional(&quot;TRACE&quot;)].<br>
This  means  that  all  calls  that  you  make  to  Debug  or  Trace  are  eliminated  by  the<br>compiler unless you define DEBUG or TRACE symbols. By default, Visual Studio defines<br>both  DEBUG  and  TRACE  symbols  in  a  project's  <i>debug</i>  configuration--and  just  the<br>TRACE symbol in the <i>release</i> configuration.<br>
<b>502 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=523></a>Both the Debug and Trace classes provide Write, WriteLine, and WriteIf methods. By<br>default, these send messages to the debugger's output window:<br>
Debug.Write     (&quot;Data&quot;);<br>Debug.WriteLine (23 * 34);<br>
int x = 5, y = 3;<br>
Debug.WriteIf   (x &gt; y, &quot;x is greater than y&quot;);<br>
The  Trace  class  also  provides  the  methods  TraceInformation,  TraceWarning,  and<br>TraceError. The difference in behavior between these and the Write methods de-<br>pends  on  the  active  TraceListeners  (we  will  cover  this  in  the  section  "TraceLis-<br>tener" on page 504).<br>
<b>Fail and Assert<br></b>The Debug and Trace classes both provide Fail and Assert methods. Fail sends the<br>message to each TraceListener in the Debug or Trace class's Listeners collection (see<br>the following section), which by default writes the message to the debug output as<br>well as displaying it in a dialog:<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
Debug.Fail (&quot;File data.txt does not exist!&quot;);<br>
The dialog that appears asks you whether to ignore, abort, or retry. The latter then<br>lets you attach a debugger, which is useful in instantly diagnosing the problem.<br>
Assert simply calls Fail if the bool argument is false--this is called <i>making an as-<br>sertion</i>. Specifying a failure message is optional:<br>
Debug.Assert (File.Exists (&quot;data.txt&quot;), &quot;File data.txt does not exist!&quot;);<br>var result = ...<br>
Debug.Assert (result != null);<br>
The Write, Fail, and Assert methods are also overloaded to accept a string category<br>in addition to the message, which can be useful in processing the output.<br>
An alternative way to make an assertion is to throw an exception if the opposite<br>condition is true. This is a common practice when validating method arguments:<br>
public void ShowMessage (string message)<br>{<br>  if (message != null) throw new ArgumentNullException (&quot;message&quot;);<br>  ...<br>}<br>
Assertions made in this way are compiled unconditionally and are less flexible in<br>that you can't control the outcome of a failed assertion via TraceListeners.<br>
We'll  see  soon  how  <i>code  contracts</i>  extend  the  principles  of<br>Fail and Assert, providing more power and flexibility.<br>
<b>Debug and Trace Classes | 503</b><br>
<hr>
<A name=524></a><b>TraceListener<br></b>The Debug and Trace classes each have a Listeners property, comprising a static<br>collection of TraceListener instances. These are responsible for processing the con-<br>tent emitted by the Write, Fail, and Trace methods.<br>By default, the Listeners collection of each includes a single listener (DefaultTrace<br>Listener). The default listener has two key features:<br>
· When connected to a debugger such as Visual Studio, messages are written to<br>
the debug output window; otherwise, message content is ignored.<br>
· When the Fail method is called (or an assertion fails), a dialog appears asking<br>
the  user  whether  to  continue,  abort,  or  retry  (attach/debug)--regardless  of<br>whether a debugger is attached.<br>
You can change this behavior by (optionally) removing the default listener, and then<br>adding one or more of your own. You can write trace listeners from scratch (by<br>subclassing TraceListener) or use one of the predefined types:<br>
· TextWriterTraceListener writes to a Stream or TextWriter or appends to a file.<br>· EventLogTraceListener writes to the Windows event log.<br>· EventProviderTraceListener writes to the Event Tracing for Windows (ETW)<br>
subsystem in Windows Vista and later.<br>
· WebPageTraceListener writes to an ASP.NET web page.<br>
TextWriterTraceListener is further subclassed to ConsoleTraceListener, Delimited<br>ListTraceListener, XmlWriterTraceListener, and EventSchemaTraceListener.<br>
None of these listeners display a dialog when Fail is called--<br>only DefaultTraceListener has this behavior.<br>
The following example clears Trace's default listener, then adds three listeners--one<br>that appends to a file, one that writes to the console, and one that writes to the<br>Windows event log:<br>
// Clear the default listener:<br>Trace.Listeners.Clear();<br>
// Add a writer that appends to the trace.txt file:<br>Trace.Listeners.Add (new TextWriterTraceListener (&quot;trace.txt&quot;));<br>
// Obtain the Console's output stream, then add that as a listener:<br>System.IO.TextWriter tw = Console.Out;<br>Trace.Listeners.Add (new TextWriterTraceListener (tw));<br>
// Set up a Windows Event log source and then create/add listener.<br>// CreateEventSource requires administrative elevation, so this would<br>
// typically be done in application setup.<br>if (!EventLog.SourceExists (&quot;DemoApp&quot;))<br>
<b>504 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=525></a>  EventLog.CreateEventSource (&quot;DemoApp&quot;, &quot;Application&quot;);<br>
Trace.Listeners.Add (new EventLogTraceListener (&quot;DemoApp&quot;));<br>
In the case of the Windows event log, messages that you write with the Write, Fail, or<br>Assert method always display as "Information" messages in the Windows event<br>viewer.  Messages  that  you  write  via  the  TraceWarning  and  TraceError  methods,<br>however, show up as warnings or errors.<br>
TraceListener  also  has  a  Filter  of  type  TraceFilter  that  you  can  set  to<br>control  whether  a  message  gets  written  to  that  listener.  To  do  this,  you  either<br>instantiate one of the predefined subclasses (EventTypeFilter or SourceFilter), or<br>subclass TraceFilter and override the ShouldTrace method. You could use this to<br>filter by category, for instance.<br>
TraceListener also defines IndentLevel and IndentSize properties for controlling<br>indentation, and the TraceOutputOptions property for writing extra data:<br>
TextWriterTraceListener tl = new TextWriterTraceListener (Console.Out);<br>tl.TraceOutputOptions = TraceOptions.DateTime | TraceOptions.Callstack;<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
TraceOutputOptions are applied when using the Trace methods:<br>
Trace.TraceWarning (&quot;Orange alert&quot;);<br>
<i>DiagTest.vshost.exe Warning: 0 : Orange alert</i><br>
     <i>DateTime=2007-03-08T05:57:13.6250000Z</i><br>
     <i>Callstack=   at System.Environment.GetStackTrace(Exception e, Boolean<br>needFileInfo)</i><br>
     <i>at System.Environment.get_StackTrace()     at ...</i><br>
<b>Flushing and Closing Listeners<br></b>Some listeners, such as TextWriterTraceListener, ultimately write to a stream that<br>is subject to caching. This has two implications:<br>
· A message may not appear in the output stream or file immediately.<br>· You must close--or at least flush--the listener before your application ends;<br>
otherwise, you lose what's in the cache (up to 4 KB, by default, if you're writing<br>to a file).<br>
The Trace and Debug classes provide static Close and Flush methods that call Close<br>or Flush on all listeners (which in turn calls Close or Flush on any underlying writers<br>and streams). Close implicitly calls Flush, closes file handles, and prevents further<br>data from being written.<br>
As a general rule, call Close before an application ends and call Flush anytime you<br>want to ensure that current message data is written. This applies if you're using<br>stream- or file-based listeners.<br>
Trace and Debug also provide an AutoFlush property, which, if true, forces a Flush<br>after every message.<br>
<b>Debug and Trace Classes | 505</b><br>
<hr>
<A name=526></a>It's a good policy to set AutoFlush to true on Debug and Trace if<br>you're using any file- or stream-based listeners. Otherwise, if an<br>unhandled exception or critical error occurs, the last 4 KB of<br>diagnostic information may be lost.<br>
<b>Code Contracts Overview<br></b>We mentioned previously the concept of an <i>assertion</i>, whereby you check that cer-<br>tain conditions are met throughout your program. If a condition fails, it indicates a<br>bug, which should typically be handled by invoking a debugger (in debug builds) or<br>throwing an exception (in release builds).<br>
Assertions follow the principle that if something goes wrong, it's best to fail early<br>and close to the source of the error. This is usually better than trying to continue<br>with invalid data--which can result in incorrect results or an exception later on in<br>the program (which is harder to diagnose).<br>
Historically, there have been two ways to enforce assertions:<br>
· By calling the Assert method on Debug or Trace<br>· By throwing exceptions (such as ArgumentNullException)<br>
Framework 4.0 provides a new feature called <i>code contracts</i>, which replaces both of<br>these approaches with a unified system. That system allows you to make not only<br>simple assertions but also more powerful <i>contract</i>-based assertions.<br>
Code contracts derive from the principle of "Design by Contract" from the Eiffel<br>programming language, where functions interact with each other through a system<br>of mutual obligations and benefits. Essentially, a function specifies <i>preconditions<br></i>that must be met by the client (caller), and in return guarantees <i>postconditions</i> which<br>the client can depend on when the function returns.<br>
The types for code contracts live in the System.Diagnostics.Contracts namespace.<br>
Although  the  types  that  support  code  contracts  are  built<br>into .NET Framework 4.0, the binary rewriter and the static<br>checking  tools  are  available  as  a  separate  download  at  the<br>Microsoft DevLabs site. You must install these tools before you<br>can use code contracts in Visual Studio 2010.<br>
<b>Why Use Code Contracts?<br></b>To illustrate, we'll write a method that adds an item to a list only if it's not already<br>present--with two <i>preconditions</i> and a <i>postcondition</i>:<br>
public static bool AddIfNotPresent&lt;T&gt; (IList&lt;T&gt; list, T item)<br>{<br>  <b>Contract.Requires (list != null);          // Precondition</b><br>
  <b>Contract.Requires (!list.IsReadOnly);      // Precondition<br></b>  <b>Contract.Ensures (list.Contains (item));   // Postcondition</b><br>
<b>506 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=527></a>  if (list.Contains(item)) return false;<br>
  list.Add (item);<br>  return true;<br>}<br>
The  preconditions  are  defined  by  Contract.Requires  and  are  verified  when  the<br>method starts. The postcondition is defined by Contract.Ensures and is verified not<br>where it appears in the code, but <i>when the method exits</i>.<br>
Preconditions and postconditions act like assertions and, in this case, detect the<br>following errors:<br>
· Calling the method with a null or read-only list<br>· A bug in the method whereby we forgot to add the item to the list<br>
Preconditions and postconditions must appear at the start of<br>the method. This is conducive to good design: if you fail to fulfill<br>the contract in subsequently writing the method, the error will<br>be detected.<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
Moreover,  these  conditions  form  a  discoverable  <i>contract</i>  for  that  method.<br>AddIfNotPresent advertises to consumers:<br>
· "You must call me with a non-null writable list."<br>· "When I return, that list will contain the item you specified."<br>
These facts can be emitted into the assembly's XML documentation file (you can do<br>this in Visual Studio by going to the Code Contracts tab of the Project Properties<br>window,  enabling  the  building  of  a  contracts  reference  assembly,  and  checking<br>"Emit Contracts into XML doc file"). Tools such as SandCastle can then incorporate<br>contract details into documentation files.<br>
Contracts also enable your program to be analyzed for correctness by static contract<br>validation tools. If you try to call AddIfNotPresent with a list whose value might be<br>null, for example, a static validation tool could warn you before you even run the<br>program.<br>
Another  benefit  of  contracts  is  ease  of  use.  In  our  example,  it's  easier  to  code<br>the postcondition upfront than at both exit points. Contracts also support <i>object<br>invariants</i>--which  further  reduce  repetitive  coding  and  make  for  more  reliable<br>enforcement.<br>
Conditions can also be placed on interface members and abstract methods, some-<br>thing that is impossible with standard validation approaches. And conditions on<br>virtual methods cannot be accidentally circumvented by subclasses.<br>
Yet another benefit of code contracts is that contract violation behavior can be cus-<br>tomized easily and in more ways than if you rely on calling Debug.Assert or throwing<br>exceptions.  And  it's  possible  to  ensure  that  contract  violations  are  always<br>recorded--even if contract violation exceptions are swallowed by exception han-<br>dlers higher in the call stack.<br>
<b>Code Contracts Overview | 507</b><br>
<hr>
<A name=528></a>The disadvantage of using code contracts is that the .NET implementation relies on<br>a <i>binary rewriter</i>--a tool that mutates the assembly after compilation. This slows<br>the build process, as well as complicating services that rely on calling the C# com-<br>piler (whether explicitly or via the CSharpCodeProvider class).<br>The enforcing of code contracts may also incur a runtime performance hit, although<br>this is easily mitigated by scaling back contract checking in release builds.<br>
Another limitation of code contracts is that you can't use them<br>to  enforce  security-sensitive  checks,  because  they  can  be  cir-<br>cumvented at runtime (by handling the ContractFailed event).<br>
<b>Contract Principles<br></b>Code contracts comprise <i>preconditions</i>, <i>postconditions</i>, <i>assertions</i>, and <i>object invar-<br>iants</i>.  These  are  all  discoverable  assertions.  They  differ  based  on  when  they  are<br>verified:<br>
· <i>Preconditions</i> are verified when a function starts.<br>· <i>Postconditions</i> are verified before a function exits.<br>· <i>Assertions</i> are verified wherever they appear in the code.<br>· <i>Object invariants</i> are verified after every public function in a class.<br>
Code contracts are defined entirely by calling (static) methods in the Contract class.<br>This makes contracts <i>language-independent</i>.<br>
Contracts can appear not only in methods, but in other functions as well, such as<br>constructors, properties, indexers, and operators.<br>
<b>Compilation<br></b>Almost all methods in the Contract class are defined with the [Conditional(&quot;CON<br>TRACTS_FULL&quot;)]  attribute.  This  means  that  unless  you  define  the  CONTRACTS_FULL<br>symbol,  (most)  contract  code  is  stripped  out.  Visual  Studio  defines  the<br>CONTRACTS_FULL symbol automatically if you enable contract checking in the Code<br>Contracts  tab  of  the  Project  Properties  page.  (For  this  tab  to  appear,  you  must<br>download and install the Contracts tools from the Microsoft DevLabs site.)<br>
Removing the CONTRACTS_FULL symbol might seem like an easy<br>way to disable all contract checking. However, it doesn't apply<br>to  Requires&lt;TException&gt;  conditions  (which  we'll  describe  in<br>detail soon).<br>
The only way to disable contracts in code that uses Requires&lt;TEx<br>ception&gt; is to enable the CONTRACTS_FULL symbol and then get<br>the binary rewriter to strip out contract code by choosing an<br>enforcement level of "none".<br>
<b>508 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=529></a><b>The binary rewriter<br></b>After compiling code that contains contracts, you must call the binary rewriter tool,<br><i>ccrewrite.exe</i> (Visual Studio does this automatically if contract checking is enabled).<br>The  binary  rewriter  moves  postconditions  (and  object  invariants)  into  the  right<br>place, calls any conditions and object invariants in overridden methods, and replaces<br>calls to Contract with calls to a <i>contracts runtime class</i>. Here's a (simplified) version<br>of what our earlier example would look like after rewriting:<br>
static bool AddIfNotPresent&lt;T&gt; (IList&lt;T&gt; list, T item)<br>
{<br>  __ContractsRuntime.Requires (list != null);<br>
  __ContractsRuntime.Requires (!list.IsReadOnly);<br>
  bool result;<br>
  if (list.Contains (item))<br>    result = false;<br>
  else<br>
  {<br>
    list.Add (item);<br>    result = true;<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
  }<br>
  <b>__ContractsRuntime.Ensures (list.Contains (item));   // Postcondition</b><br>
  return result;<br>
}<br>
If  you  fail  to  call  the  binary  rewriter,  Contract  won't  get  replaced  with<br>__ContractsRuntime and the former will end up throwing exceptions.<br>
The __ContractsRuntime type is the default contracts runtime<br>class. In advanced scenarios, you can specify your own contracts<br>runtime class via the /rw switch or Visual Studio's Code Con-<br>tracts tab in Project Properties.<br>
Because __ContractsRuntime is shipped with the binary rewriter<br>(which is not a standard part of the .NET Framework), the bi-<br>nary rewriter actually injects the __ContractsRuntime class into<br>your compiled assembly. You can examine its code by disas-<br>sembling any assembly that enables code contracts.<br>
The binary rewriter also offers switches to strip away some or all contract checking:<br>we describe these in "Selectively Enforcing Contracts" on page 521. You typically<br>enable full contract checking in debug build configurations and a subset of contract<br>checking in release configurations.<br>
<b>Asserting versus throwing on failure<br></b>The binary rewriter also lets you choose between displaying a dialog and throwing<br>a ContractException upon contract failure. The former is typically used for debug<br>builds; the latter for release builds. To enable the latter, specify /throwonfailure<br>when calling the binary rewriter, or uncheck the "Assert on contract failure" check-<br>box in Visual Studio's Code Contracts tab in Project Properties.<br>
<b>Code Contracts Overview | 509</b><br>
<hr>
<A name=530></a>See "Dealing with Contract Failure" on page 519 for more detail.<br>
<b>Purity<br></b>All functions that you call from arguments passed to contract methods (Requires,<br>Assumes, Assert, etc.) must be <i>pure</i>--that is, side-effect-free (they must not alter the<br>values of fields). You must signal to the binary rewriter that any functions you call<br>are pure by applying the [Pure] attribute:<br>
<b>[Pure]</b><br>
public static bool IsValidUri (string uri) { ... }<br>
This makes the following legal:<br>
Contract.Requires (IsValidUri (uri));<br>
The contract tools implicitly assume that all property get accessors are pure, as are<br>all C# operators (+, *, %, etc.) and members on selected Framework types, including<br>string, Contract, Type, System.IO.Path, and LINQ's query operators. It also assumes<br>that methods invoked via delegates marked with the [Pure] attribute are pure (the<br>Comparison&lt;T&gt; and Predicate&lt;T&gt; attributes are marked with this attribute).<br>
<b>Preconditions<br></b>You  can  define  code  contract  preconditions  by  calling  Contract.Requires,<br>Contract.Requires&lt;TException&gt;, or Contract.EndContractBlock.<br>
<b>Contract.Requires<br></b>Calling Contract.Requires at the start of a function enforces a precondition:<br>
static string ToProperCase (string s)<br>{<br>  <b>Contract.Requires (!string.IsNullOrEmpty(s));<br></b>  ...<br>}<br>
This is like making an assertion, except that the precondition forms a discoverable<br>fact about your function that can be extracted from the compiled code and con-<br>sumed by documentation or static checking tools (so that they can warn you should<br>they see some code elsewhere in your program that tries to call ToProperCase with a<br>null or empty string).<br>
A further benefit of preconditions is that subclasses that override virtual methods<br>with preconditions cannot prevent the base class method's preconditions from being<br>checked. And preconditions defined on <i>interface</i> members will be implicitly woven<br>into the concrete implementations (see "Contracts on Interfaces and Abstract Meth-<br>ods" on page 518).<br>
<b>510 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=531></a>Preconditions should access only members that are at least as<br>accessible as the function itself--this ensures that callers can<br>make sense of the contract. If you need to read or call less ac-<br>cessible  members,  it's  likely  that  you're  validating  <i>internal<br>state</i> rather than enforcing the <i>calling contract</i>, in which case<br>you should make an assertion instead.<br>
You can call Contract.Requires as many times as necessary at the start of the method<br>to enforce different conditions.<br>
<b>What Should You Put in Preconditions?</b><br>
The guideline from the Code Contracts team is that preconditions should:<br>
· Be possible for the client (caller) to easily validate<br>· Rely only on data &amp; functions at least as accessible as the method itself<br>· Always indicate a <i>bug</i> if violated<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
A consequence of the last point is that a client should never specifically "catch" a<br>contract failure (the ContractException type, in fact, is internal to help enforce that<br>principle). Instead, the client should call the target properly; if it fails, this indicates<br>a bug that should be handled via your general exception backstop (which may<br>include terminating the application). In other words, if you decide control-flow<br>or do other things based on a precondition failure, it's not really a contract because<br>you can continue executing if it fails.<br>
This leads to the following advice, when choosing between preconditions and<br>throwing ordinary exceptions:<br>
· If failure <i>always</i> indicates a bug in the client, favor a precondition.<br>· If failure indicates an <i>abnormal condition</i>, which <i>may</i> mean a bug in the client,<br>
throw a (catchable) exception instead.<br>
To illustrate, suppose we're writing the Int32.Parse function. It's reasonable to<br>assume that a null input string always indicates a bug in the caller, so we'd enforce<br>this with a precondition:<br>
public static int Parse (string s)<br>{<br>  Contract.Requires (s != null);<br>}<br>
Next, we need to check that the string contains only digits and symbols such as<br>+ and - (in the right place). It would place an unreasonable burden on the caller<br>to validate this and so we'd enforce it not as a precondition, but a manual check<br>that throws a (catchable) FormatException if violated.<br>
<b>Preconditions | 511</b><br>
<hr>
<A name=532></a>To illustrate the member accessibility issue, consider the following code, which<br>often appears in types implementing the IDisposable interface:<br>
public void Foo()<br>
{<br>  if (_isDisposed)  // _isDisposed is a private field<br>    throw new ObjectDisposedException();<br>
  ...<br>
}<br>
This check should not be made into a precondition unless we make _isDisposed<br>accessible  to  the  caller  (by  refactoring  it  into  a  publicly  readable  property,  for<br>instance).<br>
Finally, consider the File.ReadAllText method. The following would be <i>inappro-<br>priate</i> use of a precondition:<br>
public static string ReadAllText (string path)<br>{<br>    Contract.Requires (File.Exists (path));<br>
    ...<br>
}<br>
The caller cannot reliably know that the file exists before calling this method (it<br>could be deleted between making that check and calling the method). So, we'd<br>enforce this in the old-fashioned way--by throwing a catchable FileNotFoundEx<br>ception instead.<br>
<b>Contract.Requires&lt;TException&gt;<br></b>The introduction of code contracts challenges the following deeply entrenched pat-<br>tern established in the .NET Framework from version 1.0:<br>
static void SetProgress (string message, int percent)  // <b>Classic approach<br></b>{<br>  <b>if (message == null)<br></b>    <b>throw new ArgumentNullException (&quot;message&quot;);</b><br>
  <b>if (percent &lt; 0 || percent &gt; 100)<br></b>    <b>throw new ArgumentOutOfRangeException (&quot;percent&quot;);<br></b>  ...<br>}<br>
static void SetProgress (string message, int percent)  // <b>Modern approach<br></b>{<br>  <b>Contract.Requires (message != null);<br></b>  <b>Contract.Requires (percent &gt;= 0 &amp;&amp; percent &lt;= 100);<br></b>  ...<br>}<br>
If you have a large assembly that enforces classic argument checking, writing new<br>methods with preconditions will create an inconsistent library: some methods will<br>throw argument exceptions whereas others will throw a ContractException. One<br>solution is to update all existing methods to use contracts, but this has two problems:<br>
<b>512 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=533></a>· It's time-consuming.<br>· Callers may have come to <i>depend</i> on an exception type such as ArgumentNullEx<br>
ception being thrown. (This almost certainly indicates bad design, but may be<br>the reality nonetheless.)<br>
The solution is to call the generic version of Contract.Requires. This lets you specify<br>an exception type to throw upon failure:<br>
Contract.Requires<b>&lt;ArgumentNullException&gt;</b> (message != null, &quot;message&quot;);<br>
Contract.Requires<b>&lt;ArgumentOutOfRangeException&gt;</b><br>
 (percent &gt;= 0 &amp;&amp; percent &lt;= 100, &quot;percent&quot;);<br>
(The second argument gets passed to the constructor of the exception class).<br>
This results in the same behavior as with old-fashioned argument checking, while<br>delivering  the  benefits  of  contracts  (conciseness,  support  for  interfaces,  implicit<br>documentation, static checking, and runtime customization).<br>
The  specified  exception  is  thrown  only  if  you  spec-<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
ify /throwonfailure when rewriting the assembly (or <i>uncheck<br></i>the  <i>Assert  on  Contract  Failure</i>  checkbox  in  Visual  Studio).<br>Otherwise, a dialog appears.<br>
It's also possible to specify a contract-checking level of <i>ReleaseRequires</i> in the binary<br>rewriter (see "Selectively Enforcing Contracts" on page 521). Calls to the generic<br>Contract.Requires&lt;TException&gt;  then  remain  in  place  while  all  other  checks  are<br>stripped away: this results in an assembly that behaves just as in the past.<br>
<b>Contract.EndContractBlock<br></b>The Contract.EndContractBlock method lets you get the benefit of code contracts<br>with traditional argument-checking code--avoiding the need to refactor code that<br>you wrote prior to Framework 4.0. All you do is call this method after performing<br>manual argument checks:<br>
static void Foo (string name)<br>{<br>  if (name == null) throw new ArgumentNullException (&quot;name&quot;);<br>  <b>Contract.EndContractBlock();<br></b>  <b>...<br></b>}<br>
The binary rewriter then converts this code into something equivalent to:<br>
static void Foo (string name)<br>{<br>  <b>Contract.Requires&lt;ArgumentNullException&gt;</b> <b>(name != null, &quot;name&quot;);<br></b>  <b>...<br></b>}<br>
<b>Preconditions | 513</b><br>
<hr>
<A name=534></a>The code that precedes EndContractBlock must comprise simple statements of the<br>form:<br>
if <i>&lt;condition&gt;</i> throw <i>&lt;expression&gt;</i>;<br>
You can mix traditional argument checking with code contract calls: simply put the<br>latter after the former:<br>
static void Foo (string name)<br>
{<br>  if (name == null) throw new ArgumentNullException (&quot;name&quot;);<br>
  <b>Contract.Requires (name.Length &gt;= 2);</b><br>
  <b>...</b><br>
}<br>
Calling any of the contract-enforcing methods implicitly ends the contract block.<br>
The point is to define a region at the beginning of the method where the contract<br>rewriter  knows  that  every  if  statement  is  part  of  a  contract.  Calling  any  of  the<br>contract-enforcing methods implicitly extends the contract block, so you don't need<br>to use EndContractBlock if you use another method such as Contract.Ensures, etc.<br>
<b>Preconditions and Overridden Methods<br></b>An  overridden  method  cannot  add  preconditions,  because  doing  so  would<br><i>change  the  contract</i>  (by  making  it  more  restrictive)--breaking  the  principles  of<br>polymorphism.<br>
(Technically, the designers could have allowed overridden methods to <i>weaken</i> pre-<br>conditions; they decided against this because the scenarios weren't sufficiently com-<br>pelling to justify adding this complexity).<br>
The binary rewriter ensures that a base method's preconditions<br>are always enforced in subclasses--whether or not the overrid-<br>den method calls the base method.<br>
<b>Postconditions<br>Contract.Ensures<br></b>Contract.Ensures enforces a postcondition: something which must be true when the<br>method exits. We saw an example earlier:<br>
static bool AddIfNotPresent&lt;T&gt; (IList&lt;T&gt; list, T item)<br>{<br>  Contract.Requires (list != null);          // Precondition<br>  <b>Contract.Ensures (list.Contains (item));   // Postcondition<br></b>  if (list.Contains(item)) return false;<br>  list.Add (item);<br>
  return true;<br>}<br>
<b>514 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=535></a>The binary rewriter moves postconditions to the exit points of the method. Post-<br>conditions are checked if you return early from a method (as in this example)--but<br>not if you return early via an unhandled exception.<br>
Unlike preconditions, which detect misuse by the <i>caller</i>, postconditions detect an<br>error in the function itself (rather like assertions). Therefore, postconditions may<br>access  private  state  (subject  to  the  caveat  stated  shortly,  in  "Postconditions  and<br>Overridden Methods" on page 516).<br>
<b>Postconditions and Thread Safety</b><br>
Multithreaded scenarios (Chapter 21) challenge the usefulness of postconditions.<br>For instance, suppose we wrote a thread-safe wrapper for a List&lt;T&gt; with a method<br>as follows:<br>
public class ThreadSafeList&lt;T&gt;<br>
{<br>  List&lt;T&gt; _list = new List&lt;T&gt;();<br>
  object _locker = new object();<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
  public bool AddIfNotPresent (T item)<br>
  {<br>
    Contract.Ensures (_list.Contains (item));<br>
    lock (_locker)<br>
    {<br>
      if (_list.Contains(item)) return false;<br>      _list.Add (item);<br>      return true;<br>
    }<br>
  }<br>
  public void Remove (T item)<br>
  {<br>    lock (_locker)<br>      _list.Remove (item);<br>  }<br>}<br>
The  postcondition  in  the  AddIfNotPresent  method  is  checked  <i>after</i>  the  lock  is<br>released--at which point the item may no longer exist in the list if another thread<br>called Remove right then. There is currently no workaround for this problem, other<br>than  to  enforce  such  conditions  as  assertions  (see  next  section)  rather  than<br>postconditions.<br>
<b>Contract.EnsuresOnThrow&lt;TException&gt;<br></b>Occasionally, it's useful to ensure that a certain condition holds should a particular<br>type of exception be thrown. The EnsuresOnThrow method does exactly this:<br>
Contract.EnsuresOnThrow&lt;WebException&gt; (this.ErrorMessage != null);<br>
<b>Postconditions | 515</b><br>
<hr>
<A name=536></a><b>Contract.Result&lt;T&gt; and Contract.ValueAtReturn&lt;T&gt;<br></b>Because postconditions are not evaluated until a function ends, it's reasonable to<br>want to access the return value of a method. The Contract.Result&lt;T&gt; method does<br>exactly that:<br>
Random _random = new Random();<br>int GetOddRandomNumber()<br>
{<br>  Contract.Ensures (<b>Contract.Result&lt;int&gt;()</b> % 2 == 1);<br>
  return _random.Next (100) * 2 + 1;<br>
}<br>
The Contract.ValueAtReturn&lt;T&gt; method fulfills the same function--but for ref and<br>out parameters.<br>
<b>Contract.OldValue&lt;T&gt;<br></b>Contract.OldValue&lt;T&gt; returns the original value of a method parameter. This is use-<br>ful  with  postconditions  because  the  latter  are  checked  at  the  <i>end</i>  of  a  function.<br>Therefore, any expressions in postconditions that incorporate parameters will read<br>the <i>modified</i> parameter values.<br>
For example, the postcondition in the following method will always fail:<br>
static string Middle (string s)<br>{<br>  Contract.Requires (s != null &amp;&amp; s.Length &gt;= 2);<br>
  Contract.Ensures (Contract.Result&lt;string&gt;().Length &lt; <b>s.Length</b>);<br>  s = s.Substring (1, s.Length - 2);<br>
  return s.Trim();<br>}<br>
Here's how we can correct it:<br>
static string Middle (string s)<br>{<br>  Contract.Requires (s != null &amp;&amp; s.Length &gt;= 2);<br>  Contract.Ensures (Contract.Result&lt;string&gt;().Length &lt;<br>                    <b>Contract.OldValue (s).Length</b>);<br>  s = s.Substring (1, s.Length - 2);<br>  return s.Trim();<br>}<br>
<b>Postconditions and Overridden Methods<br></b>An overridden method cannot circumvent postconditions defined by its base, but it<br>can add new ones. The binary rewriter ensures that a base method's postconditions<br>are  always  checked--even  if  the  overridden  method  doesn't  call  the  base<br>implementation.<br>
<b>516 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=537></a>For the reason just stated, postconditions on virtual methods<br>should not access private members. Doing so will result in the<br>binary rewriter weaving code into the subclass that will try to<br>access private members in the base class--causing a runtime<br>error.<br>
<b>Assertions and Object Invariants<br></b>In addition to preconditions and postconditions, the code contracts API lets you<br>make assertions and define <i>object invariants</i>.<br>
<b>Assertions</b><br>
<b>Contract.Assert<br></b>You can make assertions anywhere in a function by calling Contract.Assert. You<br>can optionally specify an error message if the assertion fails:<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
...<br>
int x = 3;<br>
...<br>
Contract.Assert (x == 3);                 // Fail unless x is 3<br>Contract.Assert (x == 3, &quot;x must be 3&quot;);<br>...<br>
The binary rewriter doesn't move assertions around. There are two reasons for fa-<br>voring Contract.Assert over Debug.Assert:<br>
· You can leverage the more flexible failure-handling mechanisms offered by code<br>
contracts<br>
· Static checking tools can attempt to validate Contract.Asserts<br>
<b>Contract.Assume<br></b>Contract.Assume behaves exactly like Contract.Assert at runtime, but has slightly<br>different  implications  for  static  checking  tools.  Essentially,  static  checking  tools<br>won't <i>challenge</i> an assumption, whereas they may challenge an assertion. This is<br>useful in that there will always be things a static checker is unable to prove, and this<br>may lead to it "crying wolf" over a valid assertion. Changing the assertion to an<br>assumption keeps the static checker quiet.<br>
<b>Object Invariants<br></b>For a class, you can specify one or more <i>object invariant</i> methods. These methods<br>run automatically after every <i>public</i> function in the class, and allow you to assert<br>that the object is in an internally consistent state.<br>
<b>Assertions and Object Invariants | 517</b><br>
<hr>
<A name=538></a>Support for multiple object invariant methods was included to<br>make object invariants work well with partial classes.<br>
To define an object invariant method, write a parameterless void method and an-<br>notate  it  with  the  [ContractInvariantMethod]  attribute.  In  that  method,  call<br>Contract.Invariant to enforce each condition that should hold true if your object is<br>a valid state:<br>
class Test<br>{<br>  int _x, _y;<br>
  <b>[ContractInvariantMethod]<br></b>  void ObjectInvariant()<br>  {<br>
    <b>Contract.Invariant (_x &gt;= 0);</b><br>
    <b>Contract.Invariant (_y &gt;= _x);</b><br>
  }<br>
  public int X { get { return _x; } set { _x = value; } }<br>
  public void Test1() { _x = -3; }<br>
  void Test2()        { _x = -3; }<br>
}<br>
The binary rewriter translates the X property, Test1 method, and Test2 method to<br>something equivalent to this:<br>
public void X { get { return _x; } set { _x = value; <b>ObjectInvariant();</b> } }<br>public void Test1() { _x = -3; <b>ObjectInvariant();</b> }<br>void Test2()        { _x = -3; }    // No change because it's private<br>
Object invariants don't <i>prevent</i> an object from entering an in-<br>valid state: they merely <i>detect</i> when that condition has occurred.<br>
Contract.Invariant is rather like Contract.Assert, except that it can appear only in<br>a method marked with the [ContractInvariantMethod] attribute. And conversely, a<br>contract invariant method can only contain calls to Contract.Invariant.<br>A  subclass  can  introduce  its  own  object  invariant  method,  too,  and  this  will  be<br>checked in addition to the base class's invariant method. The caveat, of course, is<br>that the check will take place only after a public method is called.<br>
<b>Contracts on Interfaces and Abstract Methods<br></b>A powerful feature of code contracts is that you can attach conditions to interface<br>members and abstract methods. The binary rewriter then automatically weaves these<br>conditions into the members' concrete implementations.<br>
<b>518 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=539></a>A special mechanism lets specify a separate contract class for interfaces and abstract<br>methods, so that you can write method bodies to house the contract conditions.<br>Here's how it works:<br>
<b>[ContractClass (typeof (ContractForITest))]</b><br>
interface ITest<br>{<br>  int Process (string s);<br>
}<br>
<b>[ContractClassFor (typeof (ITest))]<br></b>sealed class ContractForITest : ITest<br>
{<br>  int ITest.Process (string s)     // <b>Must use explicit implementation</b>.<br>
  {<br>    Contract.Requires (s != null);<br>    return 0;                      // Dummy value to satisfy compiler.<br>
  }<br>
}<br>
Notice that we had to return a value when implementing ITest.Process to satisfy<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
the compiler. The code that returns 0 will not run, however. Instead, the binary<br>rewriter extracts just the conditions from that method, and weaves them into the<br>real implementations of ITest.Process. This means that the contract class is never<br>actually instantiated (and any constructors that you write will not execute).<br>
You can assign a temporary variable within the contract block to make it easier<br>to reference other members of the interface. For instance, if our ITest interface also<br>defined  a  Message  property  of  type  string,  we  could  write  the  following  in<br>ITest.Process:<br>
int ITest.Process (string s)<br>{<br>  <b>ITest test = this;<br></b>  Contract.Requires (s != <b>test</b>.Message);<br>  ...<br>}<br>
This is easier than:<br>
Contract.Requires (s != <b>((ITest)this)</b>.Message);<br>
(Simply using this.Message won't work because Message must be explicitly imple-<br>mented.) The process of defining contract classes for abstract classes is exactly the<br>same, except that the contract class should be marked abstract instead of sealed.<br>
<b>Dealing with Contract Failure<br></b>The binary rewriter lets you specify what happens when a contract condition fails,<br>via the /throwonfailure switch (or the <i>Assert on Contract Failure</i> checkbox in Visual<br>Studio's <i>Contracts</i> tab in <i>Project Properties</i>).<br>
If you don't specify /throwonfailure--or check <i>Assert on Contract Failure</i>--a dialog<br>appears upon contract failure, allowing you to abort, debug or ignore the error.<br>
<b>Dealing with Contract Failure | 519</b><br>
<hr>
<A name=540></a>There are a couple of nuances to be aware of:<br>
· If the CLR is hosted (i.e., in SQL Server or Exchange), the<br>
host's  escalation  policy  is  triggered  instead  of  a  dialog<br>appearing.<br>
· Otherwise, if the current process can't pop up a dialog box<br>
to the user, Environment.FailFast is called.<br>
The dialog is useful in debug builds for a couple of reasons:<br>
· It makes it easy to diagnose and debug contract failures on the spot--without<br>
having to re-run the program. This works regardless of whether Visual Studio<br>is configured to break on first-chance exceptions. And unlike with exceptions<br>in general, contract failure almost certainly means a bug in your code.<br>
· It lets you know about contract failure--even if a caller higher up in the stack<br>
"swallows" exceptions as follows:<br>
try<br>
{<br>  // Call some method whose contract fails<br>
}<br>catch { }<br>
The code above is considered an antipattern in most scenarios<br>because it <i>masks</i> failures, including conditions that the author<br>never anticipated.<br>
If you specify the /throwonfailure switch--or uncheck <i>Assert on Contract Failure<br></i>in Visual Studio--a ContractException is thrown upon failure. This is desirable for:<br>
· Release builds--where you would let the exception bubble up the stack and be<br>
treated like any other unexpected exception (perhaps by having a top-level ex-<br>ception handler log the error or invite the user to report it).<br>
· Unit testing environments-- where the process of logging errors is automated.<br>
ContractException cannot appear in a catch block because this<br>type is not public. The rationale is that there's no reason that<br>you'd  want  to  <i>specifically</i>  catch  a  ContractException--you'd<br>want to catch it only as part of a general exception backstop.<br>
<b>The ContractFailed Event<br></b>When a contract fails, the static Contract.ContractFailed event fires before any fur-<br>ther action is taken. If you handle this event, you can query the event arguments<br>object for details of the error. You can also call SetHandled to prevent a ContractEx<br>ception from being subsequently thrown (or a dialog appearing).<br>
<b>520 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=541></a>Handling this event is particularly useful when /throwonfailure is specified, because<br>it lets you log <i>all</i> contract failures--even if code higher in the call stack swallows<br>exceptions  as  we  described  just  before.  A  great  example  is  with  automated  unit<br>testing:<br>
Contract.ContractFailed += (sender, args) =&gt;<br>{<br>  string failureMessage = args.FailureKind + &quot;: &quot; + args.Message;<br>  // Log failureMessage with unit testing framework:<br>
  // ...<br>
  args.SetUnwind();<br>
};<br>
This  handler  logs  all  contract  failures,  while  allowing  the  normal  ContractExcep<br>tion (or contract failure dialog) to run its course after the event handler has finished.<br>Notice  that  we  also  call  SetUnwind:  this  neutralizes  the  effect  of  any  calls  to<br>SetHandled  from  other  event  subscribers.  In  other  words,  it  ensures  that  a<br>ContractException (or dialog) will always follow after all event handlers have run.<br>
If you throw an exception from within this handler, any other event handlers will<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
still execute. The exception that you threw then populates the InnerException prop-<br>erty of the ContractException that's eventually thrown.<br>
<b>Exceptions Within Contract Conditions<br></b>If  an  exception  is  thrown  within  a  contract  condition  itself,  then  that  exception<br>propagates like any other--regardless of whether /throwonfailure is specified. The<br>following method throws a NullReferenceException if called with a null string:<br>
string Test (string s)<br>{<br>  Contract.Requires (s.Length &gt; 0);<br>  ...<br>}<br>
This precondition is essentially faulty. It should instead be:<br>
Contract.Requires (!string.IsNullOrEmpty (s));<br>
<b>Selectively Enforcing Contracts<br></b>The binary rewriter offers two switches that strip away some or all contract check-<br>ing: /publicsurface and /level. You can control these from Visual Studio via the<br><i>Code Contracts</i> tab of <i>Project Properties</i>. The /publicsurface switch tells the rewriter<br>to check contracts only on public members. The /level switch has the following<br>options:<br>
<i>None (Level 0)</i><br>
Strips out <i>all</i> contract verification<br>
<i>ReleaseRequires (Level 1)</i><br>
Enables only calls to the generic version of Contract.Requires&lt;TException&gt;<br>
<b>Selectively Enforcing Contracts | 521</b><br>
<hr>
<A name=542></a><i>Preconditions (Level 2)</i><br>
Enables all preconditions (Level 1 plus normal preconditions)<br>
<i>Pre and Post (Level 3)</i><br>
Enables Level2 checking plus postconditions<br>
<i>Full (Level 4)</i><br>
Enables Level 3 checking plus object invariants and assertions (i.e., everything)<br>
You typically enable full contract checking in debug build configurations.<br>
<b>Contracts in Release Builds<br></b>When it comes to making release builds, there are two general philosophies:<br>
· Favor safety and enable full contract checking<br>· Favor performance and disable all contract checking<br>
If you're building a library for public consumption, though, the second approach<br>creates a problem. Imagine that you compile and distribute library L in release mode<br>with contract checking disabled. A client then builds project C in <i>debug</i> mode that<br>references library L. Assembly C can then call members of L incorrectly without<br>contract violations! In this situation, you actually want to enforce the parts of L's<br>contract that ensure correct usage of L--in other words, the <i>preconditions</i> in L's<br><i>public</i> members.<br>
The simplest way to resolve this is to enable /publicsurface checking in L with a<br>level of <i>Preconditions</i> or <i>ReleaseRequires</i>. This ensures that the essential precondi-<br>tions are enforced for the benefit of consumers, while incurring the performance<br>cost of only those preconditions.<br>
In extreme cases, you might not want to pay even this small performance price--in<br>which case, you can take the more elaborate approach of <i>call-site checking</i>.<br>
<b>Call-Site Checking<br></b>Call-site  checking  moves  precondition  validation  from  <i>called</i>  methods  into<br><i>calling</i> methods (call sites). This solves the problem just described--by enabling<br>consumers of library L to perform L's precondition validation themselves in debug<br>configurations.<br>
To  enable  call-site  checking,  you  must  first  build  a  separate  <i>contracts  reference<br>assembly</i>--a supplementary assembly that contains just the preconditions for the<br>referenced assembly. To do this, you can either use the <i>ccrefgen</i> command-line tool,<br>or proceed in Visual Studio as follows:<br>
1. In the release configuration of the <i>referenced library</i> (L), go to the <i>Code Con-</i><br>
<i>tracts</i>  tab  of  <i>Project  Properties</i>  and  disable  runtime  contract  checking  while<br>ticking "Build a Contract Reference Assembly". This then generates a supple-<br>mentary contracts reference assembly (with the suffix <i>.contracts.dll</i>).<br>
2. In the <i>release</i> configuration of the <i>referencing</i> assemblies, disable all contract<br>
checking.<br>
<b>522 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=543></a>3. In the <i>debug</i> configuration of the <i>referencing</i> assemblies, tick "Call-site Requires<br>
Checking."<br>
The third step is equivalent to calling <i>ccrewrite</i> with the /callsiterequires switch.<br>It reads the preconditions from the contracts reference assembly and weaves them<br>into the calling sites in the referencing assembly.<br>
<b>Static Contract Checking<br></b>Code contracts permit <i>static contract checking</i>, whereby a tool analyzes contract<br>conditions to find potential bugs in your program before it's run. For example, stat-<br>ically checking the following code generates a warning:<br>
static void Main()<br>
{<br>  string message = null;<br>
  <b>WriteLine (message);     // Static checking tool will generate warning<br></b>}<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
static void WriteLine (string s)<br>
{<br>  Contract.Requires (s != null);<br>  Console.WriteLine (s);<br>
}<br>
You  can  run  Microsoft's  static  contracts  tool  either  from  the  command  line  via<br><i>cccheck</i>, or by enabling static contract checking in Visual Studio's project properties<br>dialog (the commercial version is supported with Visual Studio <i>Premium and Ulti-<br>mate editions</i> only).<br>
For static checking to work, you may need to add preconditions and postconditions<br>to your methods. To give a simple example, the following will generate a warning:<br>
static void WriteLine (string s, bool b)<br>{<br>  if (b)<br>    <b>WriteLine (s);    // Warning: requires unproven<br></b>}<br>
static void WriteLine (string s)<br>{<br>  Contract.Requires (s != null);<br>  Console.WriteLine (s);<br>}<br>
Because we're calling a method that requires the parameter to be non-null, we must<br>prove that the argument is non-null. To do this, we can add a precondition to the<br>first method as follows:<br>
static void WriteLine (string s, bool b)<br>{<br>  <b>Contract.Requires (s != null);<br></b>  if (b)<br>    WriteLine (s);    // OK<br>}<br>
<b>Static Contract Checking | 523</b><br>
<hr>
<A name=544></a><b>The ContractVerification Attribute<br></b>Static checking is easiest if instigated from the beginning of a project's lifecycle--<br>otherwise you're likely to get overwhelmed with warnings.<br>
If you do want to apply static contract checking to an existing codebase, it can help<br>by initially applying it just to selective parts of a program--via the ContractVerifi<br>cation attribute (in System.Diagnostics.Contracts). This attribute can be applied at<br>the assembly, type, and member level. If you apply it at multiple levels, the more<br>granular wins. Therefore, to enable static contract verification just for a particular<br>class, start by disabling verification at the assembly-level as follows:<br>
[assembly: ContractVerification (false)]<br>
and then enable it just for the desired class:<br>
[ContractVerification (true)]<br>class Foo { ... }<br>
<b>Baselines<br></b>Another tactic in applying static contract verification to an existing codebase is to<br>run the static checker with the <i>Baseline</i> option checked in Visual Studio. All the<br>warnings that are produced are then written to a specified XML file. Next time you<br>run static verification, all the warnings in that that file are ignored--so you see only<br>messages generated as a result of <i>new</i> code that you've written.<br>
<b>The SuppressMessage Attribute<br></b>You  can  also  tell  the  static  checker  to  ignore  certain  types  of  warnings  via  the<br>SuppressMessage attribute (in System.Diagnostics.CodeAnalysis):<br>
[SuppressMessage (&quot;Microsoft.Contracts&quot;, <i>warningFamily</i>)]<br>
where <i>warningFamily</i> is one of the following values:<br>
Requires Ensures Invariant NonNull DivByZero MinValueNegation<br>ArrayCreation ArrayLowerBound ArrayUpperBound<br>
You can apply this attribute at an assembly or type level.<br>
<b>Debugger Integration<br></b>Sometimes it's useful for an application to interact with a debugger if one is available.<br>During development, the debugger is usually your IDE (e.g., Visual Studio); in de-<br>ployment, the debugger is more likely to be:<br>
· DbgCLR<br>· One of the lower-level debugging tools, such as WinDbg, Cordbg, or Mdbg<br>
DbgCLR is Visual Studio stripped of everything but the debugger, and it is a free<br>download with the .NET Framework SDK. It's the easiest debugging option when<br>an IDE is not available, although it requires that you download the whole SDK.<br>
<b>524 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=545></a><b>Attaching and Breaking<br></b>The static Debugger class in System.Diagnostics provides basic functions for inter-<br>acting with a debugger--namely Break, Launch, Log, and IsAttached.<br>A debugger must first attach to an application in order to debug it. If you start an<br>application  from  within  an  IDE,  this  happens  automatically,  unless  you  request<br>otherwise (by choosing "Start without debugging"). Sometimes, though, it's incon-<br>venient or impossible to start an application in debug mode within the IDE. An<br>example is a Windows Service application or (ironically) a Visual Studio designer.<br>One solution is to start the application normally, and then choose Debug Process in<br>your IDE. This doesn't allow you to set breakpoints early in the program's execution,<br>however.<br>
The  workaround  is  to  call  Debugger.Break  from  within  your  application.  This<br>method launches a debugger, attaches to it, and suspends execution at that point.<br>(Launch does the same, but without suspending execution.) Once attached, you can<br>log messages directly to the debugger's output window with the Log method. You<br>can tell whether you're attached to a debugger with the IsAttached property.<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
<b>Debugger Attributes<br></b>The DebuggerStepThrough and DebuggerHidden attributes provide suggestions to the<br>debugger on how to handle single-stepping for a particular method, constructor, or<br>class.<br>
DebuggerStepThrough requests that the debugger step through a function without any<br>user interaction. This attribute is useful in automatically generated methods and in<br>proxy methods that forward the real work to a method somewhere else. In the latter<br>case, the debugger will still show the proxy method in the call stack if a breakpoint<br>is set within the "real" method--unless you also add the DebuggerHidden attribute.<br>These two attributes can be combined on proxies to help the user focus on debugging<br>the application logic rather than the plumbing:<br>
[DebuggerStepThrough, DebuggerHidden]<br>void DoWorkProxy()<br>{<br>  // setup...<br>  DoWork();<br>  // teardown...<br>}<br>
void DoWork() {...}   // Real method...<br>
<b>Processes and Process Threads<br></b>In the last section of Chapter 6, we described how to launch a new process with<br>Process.Start. The Process class also allows you to query and interact with other<br>processes running on the same, or another, computer.<br>
<b>Processes and Process Threads | 525</b><br>
<hr>
<A name=546></a><b>Examining Running Processes<br></b>The Process.GetProcess<i>XXX</i> methods retrieve a specific process by name or process<br>ID, or all processes running on the current or nominated computer. This includes<br>both managed and unmanaged processes. Each Process instance has a wealth of<br>properties  mapping  statistics  such  as  name,  ID,  priority,  memory  and  processor<br>utilization, window handles, and so on. The following sample enumerates all the<br>running processes on the current computer:<br>
foreach (Process p in Process.GetProcesses())<br>
using (p)<br>
{<br>  Console.WriteLine (p.ProcessName);<br>
  Console.WriteLine (&quot;   PID:      &quot; + p.Id);<br>
  Console.WriteLine (&quot;   Memory:   &quot; + p.WorkingSet64);<br>
  Console.WriteLine (&quot;   Threads:  &quot; + p.Threads.Count);<br>
}<br>
Process.GetCurrentProcess returns the current process. If you've created additional<br>application domains, all will share the same process.<br>
You can terminate a process by calling its Kill method.<br>
<b>Examining Threads in a Process<br></b>You  can  also  enumerate  over  the  threads  of  other  processes,  with  the<br>Process.Threads property. The objects that you get, however, are not System.Thread<br>ing.Thread  objects,  but  rather  ProcessThread  objects,  and  are  intended  for<br>administrative  rather  than  synchronization  tasks.  A  ProcessThread  object<br>provides  diagnostic  information  about  the  underlying  thread  and  allows  you  to<br>control some aspects of it such as its priority and processor affinity:<br>
public void EnumerateThreads (Process p)<br>{<br>  foreach (ProcessThread pt in p.Threads)<br>  {<br>    Console.WriteLine (pt.Id);<br>    Console.WriteLine (&quot;   State:    &quot; + pt.ThreadState);<br>    Console.WriteLine (&quot;   Priority: &quot; + pt.PriorityLevel);<br>    Console.WriteLine (&quot;   Started:  &quot; + pt.StartTime);<br>    Console.WriteLine (&quot;   CPU time: &quot; + pt.TotalProcessorTime);<br>  }<br>}<br>
<b>StackTrace and StackFrame<br></b>The StackTrace and StackFrame classes provide a read-only view of an execution call<br>stack. You can obtain stack traces for the current thread, another thread in the same<br>process, or an Exception object. Such information is useful mostly for diagnostic<br>purposes, though it can also be used in programming (hacks). StackTrace represents<br>a complete call stack; StackFrame represents a single method call within that stack.<br>
<b>526 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=547></a>If  you  instantiate  a  StackTrace  object  with  no  arguments--or  with  a  bool<br>argument--you get a snapshot of the current thread's call stack. The bool argument,<br>if true, instructs StackTrace to read the assembly <i>.pdb</i> (project debug) files if they<br>are present, giving you access to filename, line number, and column offset data.<br>
Project  debug  files  are  generated  when  you  compile  with<br>the /debug switch. Visual Studio compiles with this switch un-<br>less you request otherwise via <i>Advanced Build Settings</i>.<br>
Once you've obtained a StackTrace, you can examine a particular frame by calling<br>GetFrame--or obtain the whole lot with GetFrames:<br>
static void Main() { A (); }<br>static void A()    { B (); }<br>
static void B()    { C (); }<br>static void C()<br>
{<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
  StackTrace s = new StackTrace (true);<br>
  Console.WriteLine (&quot;Total frames:   &quot; + s.FrameCount);<br>  Console.WriteLine (&quot;Current method: &quot; + s.GetFrame(0).GetMethod().Name);<br>
  Console.WriteLine (&quot;Calling method: &quot; + s.GetFrame(1).GetMethod().Name);<br>
  Console.WriteLine (&quot;Entry method:   &quot; + s.GetFrame<br>
                                       (s.FrameCount-1).GetMethod().Name);<br>  Console.WriteLine (&quot;Call Stack:&quot;);<br>
  foreach (StackFrame f in s.GetFrames())<br>
    Console.WriteLine (<br>      &quot;  File: &quot;   + f.GetFileName() +<br>      &quot;  Line: &quot;   + f.GetFileLineNumber() +<br>      &quot;  Col: &quot;    + f.GetFileColumnNumber() +<br>
      &quot;  Offset: &quot; + f.GetILOffset() +<br>      &quot;  Method: &quot; + f.GetMethod().Name);<br>}<br>
Here's the output:<br>
Total frames:   4<br>Current method: C<br>Calling method: B<br>Entry method: Main<br>Call stack:<br>  File: C:\Test\Program.cs  Line: 15  Col: 4  Offset: 7  Method: C<br>  File: C:\Test\Program.cs  Line: 12  Col: 22  Offset: 6  Method: B<br>  File: C:\Test\Program.cs  Line: 11  Col: 22  Offset: 6  Method: A<br>  File: C:\Test\Program.cs  Line: 10  Col: 25  Offset: 6  Method: Main<br>
A shortcut to obtaining the essential information for an entire StackTrace is to call<br>ToString on it. Here's what the result looks like:<br>
   at DebugTest.Program.C() in C:\Test\Program.cs:line 16<br>   at DebugTest.Program.B() in C:\Test\Program.cs:line 12<br>   at DebugTest.Program.A() in C:\Test\Program.cs:line 11<br>   at DebugTest.Program.Main() in C:\Test\Program.cs:line 10<br>
<b>StackTrace and StackFrame | 527</b><br>
<hr>
<A name=548></a>To  obtain  the  stack  trace  for  another  thread,  pass  the  other  Thread  into<br>StackTrace's constructor. This can be a useful strategy for profiling a program. The<br>one proviso is that you suspend the thread first, by calling its Suspend method (and<br>Resume  when  you're  done).  This  is  the  one  valid  use  for  Thread's  deprecated<br>Suspend and Resume methods!<br>
You can also obtain the stack trace for an Exception object (showing what led up to<br>the exception being thrown) by passing the Exception into StackTrace's constructor.<br>
Exception  already  has  a  StackTrace  property;  however,  this<br>property returns a simple string--not a  StackTrace object. A<br>StackTrace object is far more useful in logging exceptions that<br>occur  after  deployment--where  no  <i>.pdb</i>  files  are  available--<br>because  you  can  log  the  <i>IL  offset</i>  in  lieu  of  line  and  column<br>numbers. With an IL offset and <i>ildasm</i>, you can pinpoint where<br>within a method an error occurred.<br>
<b>Windows Event Logs<br></b>The Win32 platform provides a centralized logging mechanism, in the form of the<br>Windows event logs.<br>
The Debug and Trace classes we used earlier write to a Windows event log if you<br>register an EventLogTraceListener. With the EventLog class, however, you can write<br>directly to a Windows event log without using Trace or Debug. You can also use this<br>class to read and monitor event data.<br>
Writing to the Windows event log makes sense in a Windows<br>Service application, because if something goes wrong, you can't<br>pop up a user interface directing the user to some special file<br>where diagnostic information has been written. Also, because<br>it's common practice for services to write to the Windows event<br>log, this is the first place an administrator is likely to look if your<br>service falls over.<br>
There are three standard Windows event logs, identified by these names:<br>
· Application<br>· System<br>· Security<br>
The <i>Application</i> log is where most applications normally write.<br>
<b>Writing to the Event Log<br></b>To write to a Windows event log:<br>
1. Choose one of the three event logs (usually <i>Application</i>).<br>
<b>528 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=549></a>2. Decide on a <i>source name</i> and create it if necessary.<br>3. Call EventLog.WriteEntry with the log name, source name, and message data.<br>
The <i>source name</i> is an easily identifiable name for your application. You must register<br>a  source  name  before  you  use  it--the  CreateEventSource  method  performs  this<br>function. You can then call WriteEntry:<br>
const string SourceName = &quot;MyCompany.WidgetServer&quot;;<br>
// CreateEventSource requires administrative permissions, so this would<br>
// typically be done in application setup.<br>if (!EventLog.SourceExists (SourceName))<br>
  EventLog.CreateEventSource (SourceName, &quot;Application&quot;);<br>
EventLog.WriteEntry (SourceName,<br>  &quot;Service started; using configuration file=...&quot;,<br>  EventLogEntryType.Information);<br>
EventLogEntryType can be Information, Warning, Error, SuccessAudit, or FailureAu<br>dit. Each displays with a different icon in the Windows event viewer. You can also<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
optionally specify a category and event ID (each is a number of your own choosing)<br>and provide optional binary data.<br>
CreateEventSource also allows you to specify a machine name: this is to write to<br>another computer's event log, if you have sufficient permissions.<br>
<b>Reading the Event Log<br></b>To read an event log, instantiate the EventLog class with the name of the log you<br>wish to access and optionally the name of another computer on which the log resides.<br>Each log entry can then be read via the Entries collection property:<br>
EventLog log = new EventLog (&quot;Application&quot;);<br>
Console.WriteLine (&quot;Total entries: &quot; + log.Entries.Count);<br>
EventLogEntry last = log.Entries [log.Entries.Count - 1];<br>Console.WriteLine (&quot;Index:   &quot; + last.Index);<br>Console.WriteLine (&quot;Source:  &quot; + last.Source);<br>Console.WriteLine (&quot;Type:    &quot; + last.EntryType);<br>Console.WriteLine (&quot;Time:    &quot; + last.TimeWritten);<br>Console.WriteLine (&quot;Message: &quot; + last.Message);<br>
You can enumerate over all logs for the current (or another) computer with the static<br>method EventLog.GetEventLogs (this requires administrative privileges):<br>
foreach (EventLog log in EventLog.GetEventLogs())<br>  Console.WriteLine (log.LogDisplayName);<br>
This normally prints, at a minimum, <i>Application</i>, <i>Security</i>, and <i>System</i>.<br>
<b>Windows Event Logs | 529</b><br>
<hr>
<A name=550></a><b>Monitoring the Event Log<br></b>You can be alerted whenever an entry is written to a Windows event log, via the<br>EntryWritten event. This works for event logs on the local computer, and it fires<br>regardless of what application logged the event.<br>
To enable log monitoring:<br>
1. Instantiate an EventLog and set its EnableRaisingEvents property to true.<br>2. Handle the EntryWritten event.<br>
For example:<br>
static void Main()<br>
{<br>  using (var log = new EventLog (&quot;Application&quot;))<br>
  {<br>    log.EnableRaisingEvents = true;<br>
    log.EntryWritten += DisplayEntry;<br>
    Console.ReadLine();<br>
  }<br>
}<br>
static void DisplayEntry (object sender, EntryWrittenEventArgs e)<br>{<br>  EventLogEntry entry = e.Entry;<br>
  Console.WriteLine (entry.Message);<br>
}<br>
<b>Performance Counters<br></b>The logging mechanisms we've discussed to date are useful for capturing informa-<br>tion for future analysis. However, to gain insight into the current state of an appli-<br>cation (or the system as a whole), a more real-time approach is needed. The Win32<br>solution to this need is the performance-monitoring infrastructure, which consists<br>of a set of performance counters that the system and applications expose, and the<br>Microsoft Management Console (MMC) snap-ins used to monitor these counters<br>in real time.<br>
Performance counters are grouped into categories such as "System," "Processor,"<br>".NET CLR Memory," and so on. These categories are sometimes also referred to<br>as "performance objects" by the GUI tools. Each category groups a related set of<br>performance counters that monitor one aspect of the system or application. Exam-<br>ples of performance counters in the ".NET CLR Memory" category include "% Time<br>in GC," "# Bytes in All Heaps," and "Allocated bytes/sec."<br>
Each category may optionally have one or more instances that can be monitored<br>independently. For example, this is useful in the "% Processor Time" performance<br>counter in the "Processor" category, which allows one to monitor CPU utilization.<br>On a multiprocessor machine, this counter supports an instance for each CPU, al-<br>lowing one to monitor the utilization of each CPU independently.<br>
<b>530 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=551></a>The following sections illustrate how to perform commonly needed tasks, such as<br>determining which counters are exposed, monitoring a counter, and creating your<br>own counters to expose application status information.<br>
Reading  performance  counters  or  categories  may  require  ad-<br>ministrator privileges on the local or target computer, depend-<br>ing on what is accessed.<br>
<b>Enumerating the Available Counters<br></b>The following example enumerates over all of the available performance counters<br>on the computer. For those that have instances, it enumerates the counters for each<br>instance:<br>
PerformanceCounterCategory[] cats =<br>
  PerformanceCounterCategory.GetCategories();<br>
foreach (PerformanceCounterCategory cat in cats)<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
{<br>  Console.WriteLine (&quot;Category: &quot; + cat.CategoryName);<br>
  string[] instances = cat.GetInstanceNames();<br>
  if (instances.Length == 0)<br>
  {<br>    foreach (PerformanceCounter ctr in cat.GetCounters())<br>      Console.WriteLine (&quot;  Counter: &quot; + ctr.CounterName);<br>
  }<br>
  else   // Dump counters with instances<br>  {<br>    foreach (string instance in instances)<br>    {<br>      Console.WriteLine (&quot;  Instance: &quot; + instance);<br>      if (cat.InstanceExists (instance))<br>        foreach (PerformanceCounter ctr in cat.GetCounters (instance))<br>          Console.WriteLine (&quot;    Counter: &quot; + ctr.CounterName);<br>    }<br>  }<br>}<br>
The result is more than 10,000 lines long! It also takes a while<br>to  execute  because  PerformanceCounterCategory.InstanceEx<br>ists has an inefficient implementation. In a real system, you'd<br>want to retrieve the more detailed information only on demand.<br>
The next example uses a LINQ query to retrieve just .NET performance counters,<br>writing the result to an XML file:<br>
var x =<br>  new XElement (&quot;counters&quot;,<br>    from PerformanceCounterCategory cat in<br>         PerformanceCounterCategory.GetCategories()<br>    where cat.CategoryName.StartsWith (&quot;.NET&quot;)<br>
<b>Performance Counters | 531</b><br>
<hr>
<A name=552></a>    let instances = cat.GetInstanceNames()<br>
    select new XElement (&quot;category&quot;,<br>      new XAttribute (&quot;name&quot;, cat.CategoryName),<br>      instances.Length == 0<br>
      ?<br>
        from c in cat.GetCounters()<br>        select new XElement (&quot;counter&quot;,<br>          new XAttribute (&quot;name&quot;, c.CounterName))<br>
      :<br>
        from i in instances<br>        select new XElement (&quot;instance&quot;, new XAttribute (&quot;name&quot;, i),<br>          !cat.InstanceExists (i)<br>
          ?<br>
            null<br>          :<br>            from c in cat.GetCounters (i)<br>
            select new XElement (&quot;counter&quot;,<br>
              new XAttribute (&quot;name&quot;, c.CounterName))<br>        )<br>    )<br>
  );<br>
x.Save (&quot;counters.xml&quot;);<br>
<b>Reading Performance Counter Data<br></b>To retrieve the value of a performance counter, instantiate a PerformanceCounter<br>object and then call the NextValue or NextSample method. NextValue returns a simple<br>float value; NextSample returns a CounterSample object that exposes a more advanced<br>set of properties, such as CounterFrequency, TimeStamp, BaseValue, and RawValue.<br>
PerformanceCounter's  constructor  takes  a  category  name,  counter  name,  and  op-<br>tional instance. So, to display the current processor utilization for all CPUs, you<br>would do the following:<br>
using (PerformanceCounter pc = new PerformanceCounter (&quot;Processor&quot;,<br>                                                       &quot;% Processor Time&quot;,<br>                                                       &quot;_Total&quot;))<br>  Console.WriteLine (pc.NextValue());<br>
Or to display the "real" (i.e., private) memory consumption of the current process:<br>
string procName = Process.GetCurrentProcess().ProcessName;<br>using (PerformanceCounter pc = new PerformanceCounter (&quot;Process&quot;,<br>                                                       &quot;Private Bytes&quot;,<br>                                                       procName))<br>  Console.WriteLine (pc.NextValue());<br>
PerformanceCounter doesn't expose a ValueChanged event, so if you want to monitor<br>for changes, you must poll. In the next example, we poll every 200 ms--until sig-<br>naled to quit by an EventWaitHandle:<br>
// need to import System.Threading as well as System.Diagnostics<br>
static void Monitor (string category, string counter, string instance,<br>                     EventWaitHandle stopper)<br> <br>
<b>532 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=553></a>{<br>  if (!PerformanceCounterCategory.Exists (category))<br>    throw new InvalidOperationException (&quot;Category does not exist&quot;);<br>
  if (!PerformanceCounterCategory.CounterExists (counter, category))<br>
    throw new InvalidOperationException (&quot;Counter does not exist&quot;);<br>
  if (instance == null) instance = &quot;&quot;;   // &quot;&quot; == no instance (not null!)<br>
  if (instance != &quot;&quot; &amp;&amp;<br>
      !PerformanceCounterCategory.InstanceExists (instance, category))<br>    throw new InvalidOperationException (&quot;Instance does not exist&quot;);<br>
  float lastValue = 0f;<br>  using (PerformanceCounter pc = new PerformanceCounter (category,<br>
                                                      counter, instance))<br>    while (!stopper.WaitOne (200, false))<br>
    {<br>      float value = pc.NextValue();<br>
      if (value != lastValue)         // Only write out the value<br>      {                               // if it has changed.<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
        Console.WriteLine (value);<br>        lastValue = value;<br>
      }<br>    }<br>
}<br>
Here's how we can use this method to simultaneously monitor processor and hard-<br>disk activity:<br>
static void Main()<br>{<br>  EventWaitHandle stopper = new ManualResetEvent (false);<br>
  new Thread (() =&gt;<br>    Monitor (&quot;Processor&quot;, &quot;% Processor Time&quot;, &quot;_Total&quot;, stopper)<br>  ).Start();<br>
  new Thread (() =&gt;<br>    Monitor (&quot;LogicalDisk&quot;, &quot;% Idle Time&quot;, &quot;C:&quot;, stopper)<br>  ).Start();<br>
  Console.WriteLine (&quot;Monitoring - press any key to quit&quot;);<br>  Console.ReadKey();<br>  stopper.Set();<br>}<br>
<b>Creating Counters and Writing Performance Data<br></b>Before writing performance counter data, you need to create a performance category<br>and counter. You must create the performance category along with all the counters<br>that belong to it in one step, as follows:<br>
string category = &quot;Nutshell Monitoring&quot;;<br>
// We'll create two counters in this category:<br>
<b>Performance Counters | 533</b><br>
<hr>
<A name=554></a><IMG src="c#-4-nutshell-554_1.jpg"><br>
string eatenPerMin = &quot;Macadamias eaten so far&quot;;<br>
string tooHard = &quot;Macadamias deemed too hard&quot;;<br>
if (!PerformanceCounterCategory.Exists (category))<br>
{<br>  CounterCreationDataCollection cd = new CounterCreationDataCollection();<br>
  cd.Add (new CounterCreationData (eatenPerMin,<br>
          &quot;Number of macadamias consumed, including shelling time&quot;,<br>
          PerformanceCounterType.NumberOfItems32));<br>
  cd.Add (new CounterCreationData (tooHard,<br>
          &quot;Number of macadamias that will not crack, despite much effort&quot;,<br>          PerformanceCounterType.NumberOfItems32));<br>
  PerformanceCounterCategory.Create (category, &quot;Test Category&quot;,<br>    PerformanceCounterCategoryType.SingleInstance, cd);<br>
}<br>
The new counters then show up in the Windows performance-monitoring tool when<br>you choose Add Counters, as shown in Figure 13-1.<br>
<i>Figure 13-1. Custom performance counter</i><br>
<b>534 | Chapter 13:</b><b>Diagnostics and Code Contracts</b><br>
<hr>
<A name=555></a>If you later want to define more counters in the same category, you must first delete<br>the old category by calling PerformanceCounterCategory.Delete.<br>
Creating and deleting performance counters requires adminis-<br>trative privileges. For this reason, it's usually done as part of the<br>application setup.<br>
Once a counter is created, you can update its value by instantiating a Performance<br>Counter,  setting  ReadOnly  to  false,  and  setting  RawValue.  You  can  also  use  the<br>Increment and IncrementBy methods to update the existing value:<br>
string category = &quot;Nutshell Monitoring&quot;;<br>
string eatenPerMin = &quot;Macadamias eaten so far&quot;;<br>
using (PerformanceCounter pc = new PerformanceCounter (category,<br>
                                                       eatenPerMin, &quot;&quot;))<br>
{<br>  pc.ReadOnly = false;<br>
<b>Code Contracts</b><br>
<b>Diagnostics and</b><br>
  pc.RawValue = 1000;<br>  pc.Increment();<br>
  pc.IncrementBy (10);<br>
  Console.WriteLine (pc.NextValue());    // 1011<br>
}<br>
<b>The Stopwatch Class<br></b>The  Stopwatch  class  provides  a  convenient  mechanism  for  measuring  execution<br>times. Stopwatch uses the highest-resolution mechanism that the operating system<br>and  hardware  provide,  which  is  typically  less  than  a  microsecond.  (In  contrast,<br>DateTime.Now and Environment.TickCount have a resolution of about 15 ms.)<br>
To use Stopwatch, call StartNew--this instantiates a Stopwatch and starts it ticking.<br>(Alternatively, you can instantiate it manually and then call  Start.) The Elapsed<br>property returns the elapsed interval as a TimeSpan:<br>
Stopwatch s = Stopwatch.StartNew();<br>System.IO.File.WriteAllText (&quot;test.txt&quot;, new string ('*', 30000000));<br>Console.WriteLine (s.Elapsed);       // 00:00:01.4322661<br>
Stopwatch  also  exposes  an  ElapsedTicks  property,  which  returns  the  number  of<br>elapsed "ticks" as a long. To convert from ticks to seconds, divide by StopWatch.Fre<br>quency.  There's  also  an  ElapsedMilliseconds  property,  which  is  often  the  most<br>convenient.<br>
Calling Stop freezes Elapsed and ElapsedTicks. There's no background activity in-<br>curred by a "running" Stopwatch, so calling Stop is optional.<br>
<b>The Stopwatch Class | 535</b><br>
<hr>
<A name=556></a><hr>
<A name=557></a><b>14</b><br>
<b>Streams and I/O</b><br>
This chapter describes the fundamental types for input and output in .NET, with<br>emphasis on the following topics:<br>
· The .NET stream architecture and how it provides a consistent programming<br>
interface for reading and writing across a variety of I/O types<br>
· Manipulating files and directories on disk<br>· Isolated storage and its role in segregating data by program and user<br>
This  chapter  concentrates  on  the  types  in  the  System.IO  namespace,  the  home<br>of lower-level I/O functionality. The .NET Framework also provides higher-level<br>I/O functionality in the form of SQL connections and commands, LINQ to SQL<br>and  LINQ  to  XML,  Windows  Communication  Foundation,  Web  Services,  and<br>Remoting.<br>
<b>Stream Architecture<br></b>The .NET stream architecture centers on three concepts: backing stores, decorators,<br>and adapters, as shown in Figure 14-1.<br>
A <i>backing store</i> is the endpoint that makes input and output useful, such as a file or<br>network connection. Precisely, it is either or both of the following:<br>
· A source from which bytes can be sequentially read<br>· A destination to which bytes can be sequentially written<br>
A backing store is of no use, though, unless exposed to the programmer. A Stream<br>is the standard .NET class for this purpose; it exposes a standard set of methods for<br>reading, writing, and positioning. Unlike an array, where all the backing data exists<br>in memory at once, a stream deals with data serially--either one byte at a time or in<br>blocks of a manageable size. Hence, a stream can use little memory regardless of the<br>size of its backing store.<br>
<b>537</b><br>
<hr>
<A name=558></a><i>Figure 14-1. Stream architecture</i><br>
Streams fall into two categories:<br>
<i>Backing store streams</i><br>
These are hard-wired to a particular type of backing store, such as FileStream<br>or NetworkStream<br>
<i>Decorator streams</i><br>
These  feed  off  another  stream,  transforming  the  data  in  some  way,  such  as<br>DeflateStream or CryptoStream<br>
Decorator streams have the following architectural benefits:<br>
· They liberate backing store streams from needing to implement such features<br>
as compression and encryption themselves.<br>
· Streams don't suffer a change of interface when decorated.<br>· You connect decorators at runtime.<br>· You  can  chain  decorators  together  (e.g.,  a  compressor  followed  by  an<br>
encryptor).<br>
Both backing store and decorator streams deal exclusively in bytes. Although this is<br>flexible and efficient, applications often work at higher levels such as text or XML. <br><i>Adapters</i> bridge this gap by wrapping a stream in a class with specialized methods<br>typed to a particular format. For example, a text reader exposes a ReadLine method;<br>an XML writer exposes a WriteAttributes method.<br>
<b>538 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=559></a>An adapter wraps a stream, just like a decorator. Unlike a dec-<br>orator, however, an adapter is not <i>itself</i> a stream; it typically<br>hides the byte-oriented methods completely.<br>
To summarize, backing store streams provide the raw data; decorator streams pro-<br>vide transparent binary transformations such as encryption; adapters offer typed<br>methods for dealing in higher-level types such as strings and XML. Figure 14-1 il-<br>lustrates their associations. To compose a chain, you simply pass one object into<br>another's constructor.<br>
<b>Using Streams<br></b>The abstract Stream class is the base for all streams. It defines methods and properties<br>for three fundamental operations, <i>reading</i>, <i>writing</i>, and <i>seeking</i>, as well as for ad-<br>ministrative  tasks  such  as  closing,  flushing,  and  configuring  timeouts  (see  Ta-<br>ble 14-1).<br>
<i>Table 14-1. Stream class members</i><br>
<b>Category</b><br>
<b>Members</b><br>
Reading<br>
public abstract bool CanRead { get; }<br>
 <br>
public abstract int Read (byte[] buffer, int offset, int count)<br>
<b>Streams and I/O</b><br>
 <br>
public virtual int ReadByte();<br>
Writing<br>
public abstract bool CanWrite { get; }<br>
 <br>
public abstract void Write (byte[] buffer, int offset, int count);<br>
 <br>
public virtual void WriteByte (byte value);<br>
Seeking<br>
public abstract bool CanSeek { get; }<br>
 <br>
public abstract long Position { get; set; }<br>
 <br>
public abstract void SetLength (long value);<br>
 <br>
public abstract long Length { get; }<br>
 <br>
public abstract long Seek (long offset, SeekOrigin origin);<br>
Closing/flushing<br>
public virtual void Close();<br>
 <br>
public void Dispose();<br>
 <br>
public abstract void Flush();<br>
Timeouts<br>
public virtual bool CanTimeout { get; }<br>
 <br>
public virtual int ReadTimeout { get; set; }<br>
 <br>
public virtual int WriteTimeout { get; set; }<br>
Other<br>
public static readonly Stream Null; // &quot;Null&quot; stream<br>
 <br>
public static Stream Synchronized (Stream stream);<br>
<b>Using Streams | 539</b><br>
<hr>
<A name=560></a>In the following example, we use a file stream to read, write, and seek:<br>
using System;<br>
using System.IO;<br>
class Program<br>{<br>  static void Main()<br>
  {<br>    // Create a file called test.txt in the current directory:<br>    using (Stream s = new FileStream (&quot;test.txt&quot;, FileMode.Create))<br>
    {<br>
      Console.WriteLine (s.CanRead);       // True<br>      Console.WriteLine (s.CanWrite);      // True<br>      Console.WriteLine (s.CanSeek);       // True<br>
      s.WriteByte (101);<br>
      s.WriteByte (102);<br>      byte[] block = { 1, 2, 3, 4, 5 };<br>
      s.Write (block, 0, block.Length);     // Write block of 5 bytes<br>
      Console.WriteLine (s.Length);         // 7<br>      Console.WriteLine (s.Position);       // 7<br>      s.Position = 0;                       // Move back to the start<br>
      Console.WriteLine (s.ReadByte());     // 101<br>
      Console.WriteLine (s.ReadByte());     // 102<br>
      // Read from the stream back into the block array:<br>      Console.WriteLine (s.Read (block, 0, block.Length));   // 5<br>
      // Assuming the last Read returned 5, we'll be at<br>      // the end of the file, so Read will now return 0:<br>      Console.WriteLine (s.Read (block, 0, block.Length));   // 0<br>    }<br>  }<br>}<br>
<b>Reading and Writing<br></b>A stream may support reading, writing, or both. If CanWrite returns false, the stream<br>is read-only; if CanRead returns false, the stream is write-only.<br>
Read receives a block of data from the stream into an array. It returns the number of<br>bytes received, which is always either less than or equal to the count argument. If<br>it's less than count, it means either that the end of the stream has been reached or<br>the stream is giving you the data in smaller chunks (as is often the case with network<br>streams). In either case, the balance of bytes in the array will remain unwritten, their<br>previous values preserved.<br>
<b>540 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=561></a>With  Read,  you  can  be  certain  you've  reached  the  end  of<br>the stream only when the method returns 0. So, if you have a<br>1,000-byte stream, the following code may fail to read it all into<br>memory:<br>
// Assuming <b>s</b> is a stream:<br>byte[] data = new byte [1000];<br>
s.Read (data, 0, data.Length);<br>
The Read method could read anywhere from 1 to 1,000 bytes,<br>leaving the balance of the stream unread.<br>
Here's the correct way to read a 1,000-byte stream:<br>
byte[] data = new byte [1000];<br>
// bytesRead will always end up at 1000, unless the stream is<br>
// itself smaller in length:<br>
int bytesRead = 0;<br>int chunkSize = 1;<br>
while (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; 0)<br>
  bytesRead +=<br>
    chunkSize = s.Read (data, bytesRead, data.Length - bytesRead);<br>
Fortunately, the BinaryReader type provides a simpler way to<br>
<b>Streams and I/O</b><br>
achieve the same result:<br>
byte[] data = new BinaryReader (s).ReadBytes (1000);<br>
If the stream is less than 1,000 bytes long, the byte array returned<br>reflects the actual stream size. If the stream is seekable, you can<br>read its entire contents by replacing 1000 with (int)s.Length.<br>
We  describe  the  BinaryReader  type  further  in  the  section<br>"Stream Adapters" on page 552, later in this chapter.<br>
The ReadByte method is simpler: it reads just a single byte, returning -1 to indicate<br>the end of the stream. ReadByte actually returns an int rather than a byte, as the<br>latter cannot return -1.<br>
The Write and WriteByte methods send data to the stream. If they are unable to send<br>the specified bytes, an exception is thrown.<br>
In the Read and Write methods, the offset argument refers to<br>the index in the buffer array at which reading or writing begins,<br>not the position within the stream.<br>
Streams also support asynchronous reading and writing through the methods Begin<br>Read  and  BeginWrite.  Asynchronous  methods  are  intended  for  high-throughput<br>server applications, and we describe them in Chapter 23.<br>
<b>Using Streams | 541</b><br>
<hr>
<A name=562></a><b>Seeking<br></b>A stream is seekable if CanSeek returns true. With a seekable stream (such as a file<br>stream), you can query or modify its Length (by calling SetLength), and at any time<br>change the Position at which you're reading or writing. The Position property is<br>relative to the beginning of the stream; the Seek method, however, allows you to<br>move relative to the current position or the end of the stream.<br>
Changing  the  Position  on  a  FileStream  typically  takes  a  few<br>microseconds. If you're doing this millions of times in a loop,<br>Framework 4.0's new MemoryMappedFile class may be a better<br>choice  than  a  FileStream  (for  more,  see  "Memory-Mapped<br>Files" on page 569, later in this chapter).<br>
With a nonseekable stream (such as an encryption stream), the only way to deter-<br>mine  its  length  is  to  read  it  right  through.  Furthermore,  if  you  need  to  reread  a<br>previous section, you must close the stream and start afresh with a new one.<br>
<b>Closing and Flushing<br></b>Streams must be disposed after use to release underlying resources such as file and<br>socket handles. A simple way to guarantee this is by instantiating streams within<br>using blocks. In general, streams follow standard disposal semantics:<br>
· Dispose and Close are identical in function.<br>· Disposing or closing a stream repeatedly causes no error.<br>
Closing a decorator stream closes both the decorator and its backing store stream.<br>With a chain of decorators, closing the outermost decorator (at the head of the chain)<br>closes the whole lot.<br>
Some streams internally buffer data to and from the backing store to lessen round-<br>tripping and so improve performance (file streams are a good example of this). This<br>means data you write to a stream may not hit the backing store immediately; it can<br>be delayed as the buffer fills up. The Flush method forces any internally buffered<br>data to be written immediately. Flush is called automatically when a stream is closed,<br>so you never need to do the following:<br>
s.Flush(); s.Close();<br>
<b>Timeouts<br></b>A  stream  supports  read  and  write  timeouts  if  CanTimeout  returns  true.  Network<br>streams support timeouts; file and memory streams do not. For streams that support<br>timeouts, the ReadTimeout and WriteTimeout properties determine the desired time-<br>out in milliseconds, where 0 means no timeout. The Read and Write methods indicate<br>that a timeout has occurred by throwing an exception.<br>
<b>542 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=563></a><b>Thread Safety<br></b>As a rule, streams are not thread-safe, meaning that two threads cannot concurrently<br>read or write to the same stream without possible error. The Stream class offers a<br>simple  workaround  via  the  static  Synchronized  method.  This  method  accepts  a<br>stream of any type and returns a thread-safe wrapper. The wrapper works by ob-<br>taining an exclusive lock around each read, write, or seek, ensuring that only one<br>thread can perform such an operation at a time. In practice, this allows multiple<br>threads to simultaneously append data to the same stream--other kinds of activities<br>(such as concurrent reading) require additional locking to ensure that each thread<br>accesses the desired portion of the stream. We discuss thread safety fully in Chap-<br>ter 21.<br>
<b>Backing Store Streams<br></b>Figure 14-2 shows the key backing store streams provided by the .NET Framework.<br>A "null stream" is also available, via the Stream's static Null field.<br>In the following sections, we describe FileStream and MemoryStream; in the final sec-<br>tion in this chapter, we describe IsolatedStorageStream. In Chapter 15, we cover<br>NetworkStream.<br>
<b>Streams and I/O</b><br>
<i>Figure 14-2. Backing store streams</i><br>
<b>FileStream<br></b>Earlier in this section, we demonstrated the basic use of a FileStream to read and<br>write bytes of data. We'll now examine the special features of this class.<br>
<b>Constructing a FileStream<br></b>The simplest way to instantiate a FileStream is to use one of the following static<br>façade methods on the File class:<br>
FileStream fs1 = File.OpenRead  (&quot;readme.bin&quot;);            // Read-only<br>FileStream fs2 = File.OpenWrite (@&quot;c:\temp\writeme.tmp&quot;);  // Write-only<br>FileStream fs3 = File.Create    (@&quot;c:\temp\writeme.tmp&quot;);  // Read/write<br>
<b>Using Streams | 543</b><br>
<hr>
<A name=564></a>OpenWrite and Create differ in behavior if the file already exists. Create truncates any<br>existing content; OpenWrite leaves existing content intact with the stream positioned<br>at zero. If you write fewer bytes than were previously in the file, OpenWrite leaves<br>you with a mixture of old and new content.<br>
You can also instantiate a FileStream directly. Its constructors provide access to<br>every feature, allowing you to specify a filename or low-level file handle, file creation<br>and access modes, and options for sharing, buffering, and security. The following<br>opens an existing file for read/write access without overwriting it:<br>
var fs = new FileStream (&quot;readwrite.tmp&quot;, FileMode.Open);  // Read/write<br>
More on FileMode shortly.<br>
<b>Shortcut Methods on the File Class</b><br>
The following static methods read an entire file into memory in one step:<br>
· File.ReadAllText (returns a string)<br>· File.ReadAllLines (returns an array of strings)<br>· File.ReadAllBytes (returns a byte array)<br>
The following static methods write an entire file in one step:<br>
· File.WriteAllText<br>· File.WriteAllLines<br>· File.WriteAllBytes<br>· File.AppendAllText (great for appending to a log file)<br>
From Framework 4.0 there's also a static method called File.ReadLines: this is<br>like ReadAllLines except that it returns a lazily-evaluated IEnumerable&lt;string&gt;.<br>This is more efficient because it doesn't load the entire file into memory at once.<br>LINQ is ideal for consuming the results: the following calculates the number of<br>lines greater than 80 characters in length:<br>
int longLines = File.ReadLines (&quot;<i>filePath</i>&quot;)<br>
                    .Count (l =&gt; l.Length &gt; 80);<br>
<b>Specifying a filename<br></b>A filename can be either absolute (e.g., <i>c:\temp\test.txt</i>) or relative to the current<br>directory (e.g., <i>test.txt</i> or <i>temp\test.txt</i>). You can access or change the current direc-<br>tory via the static Environment.CurrentDirectory property.<br>
When a program starts, the current directory may or may not<br>coincide with that of the program's executable. For this reason,<br>you should never rely on the current directory for locating ad-<br>ditional runtime files packaged along with your executable.<br>
<b>544 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=565></a><IMG src="c#-4-nutshell-565_1.jpg"><br>
AppDomain.CurrentDomain.BaseDirectory  returns  the  <i>application  base  directory</i>,<br>which in normal cases is the folder containing the program's executable. To specify<br>a filename relative to this directory, you can call Path.Combine:<br>
string baseFolder = AppDomain.CurrentDomain.BaseDirectory;<br>
string logoPath = Path.Combine (baseFolder, &quot;logo.jpg&quot;);<br>Console.WriteLine (File.Exists (logoPath));<br>
You can read and write across a network via a UNC path, such as <i>\\JoesPC\PicShare<br>\pic.jpg</i> or <i>\\10.1.1.2\PicShare\pic.jpg</i>.<br>
<b>Specifying a FileMode<br></b>All of FileStream's constructors that accept a filename also require a FileMode enum<br>argument. Figure 14-3 shows how to choose a FileMode, and the choices yield results<br>akin to calling a static method on the File class.<br>
<b>Streams and I/O</b><br>
<i>Figure 14-3. Choosing a FileMode</i><br>
File.Create  and  FileMode.Create  will  throw  an  exception  if<br>used on hidden files. To overwrite a hidden file, you must delete<br>and re-create it:<br>
if (File.Exists (&quot;hidden.txt&quot;)) File.Delete (&quot;hidden.txt&quot;);<br>
Constructing a FileStream with just a filename and FileMode gives you (with just one<br>exception) a readable writable stream. You can request a downgrade if you also<br>supply a FileAccess argument:<br>
<b>Using Streams | 545</b><br>
<hr>
<A name=566></a>[Flags]<br>
public enum FileAccess { Read = 1, Write = 2, ReadWrite = 3 }<br>
The following returns a read-only stream, equivalent to calling File.OpenRead:<br>
using (var fs = new FileStream (&quot;x.bin&quot;, FileMode.Open, FileAccess.Read))<br>  ...<br>
FileMode.Append is the odd one out: with this mode, you get a <i>write-only</i> stream. To<br>append  with  read-write  support,  you  must  instead  use  FileMode.Open  or  File<br>Mode.OpenOrCreate, and then seek the end of the stream:<br>
using (var fs = new FileStream (&quot;myFile.bin&quot;, FileMode.Open))<br>
{<br>  fs.Seek (0, SeekOrigin.End);<br>  ...<br>
<b>Advanced FileStream features<br></b>Here are other optional arguments you can include when constructing a FileStream:<br>
· A FileShare enum describing how much access to grant other processes wanting<br>
to  dip  into  the  same  file  before  you've  finished  (None,  Read  [default],<br>ReadWrite, or Write).<br>
· The size, in bytes, of the internal buffer (default is currently 4 KB).<br>· A flag indicating whether to defer to the operating system for asynchronous I/O.<br>· A FileSecurity object describing what user and role permissions to assign a<br>
new file.<br>
· A  FileOptions  flags  enum  for  requesting  operating  system  encryption<br>
(Encrypted),  automatic  deletion  upon  closure  for  temporary  files  (DeleteOn<br>Close), and optimization hints (RandomAccess and SequentialScan). There is also<br>a WriteThrough flag that requests that the operating system disable write-behind<br>caching; this is for transactional files or logs.<br>
Opening a file with FileShare.ReadWrite allows other processes or users to simul-<br>taneously read and write to the same file. To avoid chaos, you can all agree to lock<br>specified portions of the file before reading or writing, using these methods:<br>
// Defined on the FileStream class:<br>public virtual void Lock   (long position, long length);<br>public virtual void Unlock (long position, long length);<br>
Lock throws an exception if part or all of the requested file section has already been<br>locked. This is the system used in file-based databases such as Access and FoxPro.<br>
<b>MemoryStream<br></b>MemoryStream uses an array as a backing store. This partly defeats the purpose of<br>having a stream, because the entire backing store must reside in memory at once.<br>MemoryStream still has uses, however; an example is when you need random access<br>to a nonseekable stream. If you know the source stream will be of a manageable size,<br>you can copy it into a MemoryStream as follows:<br>
<b>546 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=567></a>static MemoryStream ToMemoryStream (this Stream input, bool closeInput)<br>
{<br>  try<br>  {                                         // Read and write in<br>
    byte[] block = new byte [0×1000];       // blocks of 4K.<br>
    MemoryStream ms = new MemoryStream();<br>    while (true)<br>    {<br>
      int bytesRead = input.Read (block, 0, block.Length);<br>
      if (bytesRead == 0) return ms;<br>      ms.Write (block, 0, bytesRead);<br>    }<br>
  }<br>
  finally { if (closeInput) input.Close (); }<br>}<br>
The reason for the closeInput argument is to avoid a situation where the method<br>author and consumer each think the other will close the stream.<br>
You can convert a MemoryStream to a byte array by calling ToArray. The GetBuffer<br>method does the same job more efficiently by returning a direct reference to the<br>underlying storage array; unfortunately, this array is usually longer than the stream's<br>real length.<br>
Closing and flushing a MemoryStream is optional. If you close a<br>MemoryStream, you can no longer read or write to it, but you are<br>
<b>Streams and I/O</b><br>
still  permitted  to  call  ToArray  to  obtain  the  underlying  data.<br>Flush does absolutely nothing on a memory stream.<br>
You  can  find  further  MemoryStream  examples  in  the  section  "Compres-<br>sion" on page 571 later in this chapter, and in the section "Cryptography Over-<br>view" on page 776 in Chapter 20.<br>
<b>PipeStream<br></b>PipeStream was introduced in Framework 3.5. It provides a simple means by which<br>one process can communicate with another through the Windows <i>pipes</i> protocol.<br>There are two kinds of pipe:<br>
<i>Anonymous pipe</i><br>
Allows  one-way  communication  between  a  parent  and  child  process  on  the<br>same computer.id<br>
<i>Named pipe</i><br>
Allows two-way communication between arbitrary processes on the same com-<br>puter--or different computers across a Windows network.<br>
A pipe is good for interprocess communication (IPC) on a single computer: it doesn't<br>rely on a network transport, which equates to good performance and no issues with<br>firewalls.<br>
<b>Using Streams | 547</b><br>
<hr>
<A name=568></a>Pipes are stream-based, so one process waits to receive a series<br>of bytes while another process sends them. An alternative is for<br>processes to communicate via a block of shared memory--we<br>describe how to do this later, in the section "Memory-Mapped<br>Files" on page 569.<br>
PipeStream is an abstract class with four concrete subtypes. Two are used for anon-<br>ymous pipes and the other two for named pipes:<br>
<i>Anonymous pipes</i><br>
AnonymousPipeServerStream and AnonymousPipeClientStream<br>
<i>Named pipes</i><br>
NamedPipeServerStream and NamedPipeClientStream<br>
Named pipes are simpler to use, so we'll describe them first.<br>
A  pipe  is  a  low-level  construct  that  allows  just  the  sending<br>and receiving of bytes (or <i>messages</i>, which are groups of bytes).<br>The  WCF  and  Remoting  APIs  offer  higher-level  messaging<br>frameworks  with  the  option  of  using  an  IPC  channel  for<br>communication.<br>
<b>Named pipes<br></b>With named pipes, the parties communicate through a pipe of the same name. The<br>protocol defines two distinct roles: the client and server. Communication happens<br>between the client and server as follows:<br>
· The  server  instantiates  a  NamedPipeServerStream  and  then  calls<br>
WaitForConnection.<br>
· The client instantiates a NamedPipeClientStream and then calls Connect (with an<br>
optional timeout).<br>
The two parties then read and write the streams to communicate.<br>
The following example demonstrates a server that sends a single byte (100), and<br>then waits to receive a single byte:<br>
using (var s = new NamedPipeServerStream (&quot;pipedream&quot;))<br>{<br>  s.WaitForConnection();<br>  s.WriteByte (100);<br>  Console.WriteLine (s.ReadByte());<br>}<br>
Here's the corresponding client code:<br>
using (var s = new NamedPipeClientStream (&quot;pipedream&quot;))<br>{<br>  s.Connect();<br>  Console.WriteLine (s.ReadByte());<br>
<b>548 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=569></a>  s.WriteByte (200);                 // Send the value 200 back.<br>
}<br>
Named pipe streams are bidirectional by default, so either party can read or write<br>their stream. This means the client and server must agree on some protocol to co-<br>ordinate their actions, so both parties don't end up sending or receiving at once.<br>
There also needs to be agreement on the length of each transmission. Our example<br>was trivial in this regard, because we bounced just a single byte in each direction.<br>To help with messages longer than one byte, pipes provide a <i>message</i> transmission<br>mode. If this is enabled, a party calling Read can know when a message is complete<br>by checking the IsMessageComplete property. To demonstrate, we'll start by writing<br>a helper method that reads a whole message from a message-enabled PipeStream--<br>in other words, reads until IsMessageComplete is true:<br>
static byte[] ReadMessage (PipeStream s)<br>{<br>  MemoryStream ms = new MemoryStream();<br>
  byte[] buffer = new byte [0×1000];      // Read in 4 KB blocks<br>
  do    { ms.Write (buffer, 0, s.Read (buffer, 0, buffer.Length)); }<br>
  while (!s.<b>IsMessageComplete</b>);<br>
  return ms.ToArray();<br>
}<br>
<b>Streams and I/O</b><br>
You cannot determine whether a PipeStream has finished read-<br>ing a message simply by waiting for Read to return 0. This is<br>because, unlike most other kinds of stream, pipe streams and<br>network streams have no definite end. Instead, they temporarily<br>"dry up" between message transmissions.<br>
Now we can activate message transmission mode. On the server, this is done by<br>specifying PipeTransmissionMode.Message when constructing the stream:<br>
using (var s = new NamedPipeServerStream (&quot;pipedream&quot;, PipeDirection.InOut,<br>                                          1, <b>PipeTransmissionMode.Message</b>))<br>{<br>  s.WaitForConnection();<br>
  byte[] msg = Encoding.UTF8.GetBytes (&quot;Hello&quot;);<br>  s.Write (msg, 0, msg.Length);<br>
  Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));<br>}<br>
On the client, we activate message transmission mode by setting ReadMode after call-<br>ing Connect:<br>
using (var s = new NamedPipeClientStream (&quot;pipedream&quot;))<br>{<br>  s.Connect();<br>  <b>s.ReadMode = PipeTransmissionMode.Message;</b><br>
<b>Using Streams | 549</b><br>
<hr>
<A name=570></a>  Console.WriteLine (Encoding.UTF8.GetString (ReadMessage (s)));<br>
  byte[] msg = Encoding.UTF8.GetBytes (&quot;Hello right back!&quot;);<br>  s.Write (msg, 0, msg.Length);<br>
}<br>
<b>Anonymous pipes<br></b>An anonymous pipe provides a one-way communication stream between a parent<br>and child process. Instead of using a system-wide name, anonymous pipes tune in<br>through a private handle.<br>
As with named pipes, there are distinct client and server roles. The system of com-<br>munication is a little different, however, and proceeds as follows:<br>
1. The  server  instantiates  an  AnonymousPipeServerStream,  committing  to  a<br>
PipeDirection of In or Out.<br>
2. The server calls GetClientHandleAsString to obtain an identifier for the pipe,<br>
which it then passes to the client (typically as an argument when starting the<br>child process).<br>
3. The  child  process  instantiates  an  AnonymousPipeClientStream,  specifying  the<br>
opposite PipeDirection.<br>
4. The server releases the local handle that was generated in step 2, by calling<br>
DisposeLocalCopyOfClientHandle.<br>
5. The parent and child processes communicate by reading/writing the stream.<br>
Because  anonymous  pipes  are  unidirectional,  a  server  must  create  two  pipes  for<br>bidirectional communication. The following demonstrates a server that sends a sin-<br>gle byte to the child process, and then receives a single byte back from that process:<br>
string clientExe = @&quot;d:\PipeDemo\ClientDemo.exe&quot;;<br>
HandleInheritability inherit = HandleInheritability.Inheritable;<br>
using (var tx = new AnonymousPipeServerStream (PipeDirection.Out, inherit))<br>using (var rx = new AnonymousPipeServerStream (PipeDirection.In, inherit))<br>{<br>  string txID = tx.GetClientHandleAsString();<br>  string rxID = rx.GetClientHandleAsString();<br>
  var startInfo = new ProcessStartInfo (clientExe, txID + &quot; &quot; + rxID);<br>  startInfo.UseShellExecute = false;      // Required for child process<br>  Process p = Process.Start (startInfo);<br>
  tx.DisposeLocalCopyOfClientHandle();    // Release unmanaged<br>  rx.DisposeLocalCopyOfClientHandle();    // handle resources.<br>
  tx.WriteByte (100);<br>  Console.WriteLine (&quot;Server received: &quot; + rx.ReadByte());<br>
  p.WaitForExit();<br>}<br>
<b>550 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=571></a>Here's the corresponding client code that would be compiled to <i>d:\PipeDemo\Cli-<br>entDemo.exe</i>:<br>
string rxID = args[0];    // Note we're reversing the<br>string txID = args[1];    // receive and transmit roles.<br>
using (var rx = new AnonymousPipeClientStream (PipeDirection.In, rxID))<br>using (var tx = new AnonymousPipeClientStream (PipeDirection.Out, txID))<br>{<br>  Console.WriteLine (&quot;Client received: &quot; + rx.ReadByte());<br>
  tx.WriteByte (200);<br>}<br>
As with named pipes, the client and server must coordinate their sending and re-<br>ceiving and agree on the length of each transmission. Anonymous pipes don't, un-<br>fortunately, support message mode, so you must implement your own protocol for<br>message length agreement. One solution is to send, in the first four bytes of each<br>transmission, an integer value defining the length of the message to follow. The<br>BitConverter class provides methods for converting between an integer and an array<br>of four bytes.<br>
<b>BufferedStream<br></b>BufferedStream decorates, or wraps, another stream with buffering capability, and<br>it is one of a number of decorator stream types in the core .NET Framework, all of<br>which are illustrated in Figure 14-4.<br>
<b>Streams and I/O</b><br>
<i>Figure 14-4. Decorator streams</i><br>
Buffering improves performance by reducing round trips to the backing store. Here's<br>how we wrap a FileStream in a 20 KB BufferedStream:<br>
// Write 100K to a file:<br>File.WriteAllBytes (&quot;myFile.bin&quot;, new byte [100000]);<br>
using (FileStream fs = File.OpenRead (&quot;myFile.bin&quot;))<br>using (BufferedStream bs = new BufferedStream (fs, 20000))  //20K buffer<br>{<br>  bs.ReadByte();<br>
<b>Using Streams | 551</b><br>
<hr>
<A name=572></a>  Console.WriteLine (fs.Position);         // 20000<br>
}<br>
In this example, the underlying stream advances 20,000 bytes after reading just 1<br>byte, thanks to the read-ahead buffering. We could call ReadByte another 19,999<br>times before the FileStream would be hit again.<br>Coupling a BufferedStream to a FileStream, as in this example, is of limited value<br>because FileStream already has built-in buffering. Its only use might be in enlarging<br>the buffer on an already constructed FileStream.<br>Closing a BufferedStream automatically closes the underlying backing store stream.<br>
<b>Stream Adapters<br></b>A Stream deals only in bytes; to read or write data types such as strings, integers, or<br>XML elements, you must plug in an adapter. Here's what the Framework provides:<br>
<i>Text adapters (for string and character data)</i><br>
TextReader, TextWriter<br>StreamReader, StreamWriter<br>StringReader, StringWriter<br>
<i>Binary adapters (for primitive types such as </i>int<i>, </i>bool<i>, </i>string<i>, and </i>float<i>)</i><br>
BinaryReader, BinaryWriter<br>
<i>XML adapters (covered in Chapter 11)</i><br>
XmlReader, XmlWriter<br>
The relationships between these types are illustrated in Figure 14-5.<br>
<i>Figure 14-5. Readers and writers</i><br>
<b>552 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=573></a><b>Text Adapters<br></b>TextReader and TextWriter are the abstract base classes for adapters that deal ex-<br>clusively with characters and strings. Each has two general-purpose implementa-<br>tions in the framework:<br>
StreamReader<i>/</i>StreamWriter<br>
Uses a Stream for its raw data store, translating the stream's bytes into characters<br>or strings<br>
StringReader<i>/</i>StringWriter<br>
Implements TextReader/TextWriter using in-memory strings<br>
Table 14-2 lists TextReader's members by category. Peek returns the next character<br>in  the  stream  without  advancing  the  position.  Both  Peek  and  the  zero-argument<br>version of Read return -1 if at the end of the stream; otherwise, they return an integer<br>that can be cast directly to a char. The overload of Read that accepts a char[] buffer<br>is identical in functionality to the ReadBlock method. ReadLine reads until reaching<br>either a CR (character 13) or LF (character 10), or a CR+LF pair in sequence. It then<br>returns a string, discarding the CR/LF characters.<br>
<i>Table 14-2. TextReader members</i><br>
<b>Category</b><br>
<b>Members</b><br>
Reading one char<br>
public virtual int Peek(); // Cast the result to a char<br>
<b>Streams and I/O</b><br>
 <br>
public virtual int Read(); // Cast the result to a char<br>
Reading many<br>
public virtual int Read (char[] buffer, int index, int count);<br>
chars<br> <br>
public virtual int ReadBlock (char[] buffer, int index, int count);<br>
 <br>
public virtual string ReadLine();<br>
 <br>
public virtual string ReadToEnd();<br>
Closing<br>
public virtual void Close();<br>
 <br>
public void Dispose(); // Same as Close<br>
Other<br>
public static readonly TextReader Null;<br>
 <br>
public static TextReader Synchronized (TextReader reader);<br>
The  new  line  sequence  in  Windows  is  loosely  modeled  on  a<br>mechanical typewriter: a carriage return (character 13) followed<br>by  a  line  feed  (character  10).  The  C#  string  is  &quot;\r\n&quot;  (think<br>"ReturN"). Reverse the order and you'll get either two new lines<br>or none!<br>
TextWriter has analogous methods for writing, as shown in Table 14-3. The Write<br>and WriteLine methods are additionally overloaded to accept every primitive type,<br>plus the object type. These methods simply call the ToString method on whatever<br>
<b>Stream Adapters | 553</b><br>
<hr>
<A name=574></a>is passed in (optionally through an IFormatProvider specified either when calling the<br>method or when constructing the TextWriter).<br>
<i>Table 14-3. TextWriter members</i><br>
<b>Category</b><br>
<b>Members</b><br>
Writing one char<br>
public virtual void Write (char value);<br>
Writing many chars<br>
public virtual void Write (string value);<br>
 <br>
public virtual void Write (char[] buffer, int index, int count);<br>
 <br>
public virtual void Write (string format, params object[] arg);<br>
 <br>
public virtual void WriteLine (string value);<br>
Closing and flushing<br>
public virtual void Close();<br>
 <br>
public void Dispose(); // Same as Close<br>
 <br>
public virtual void Flush();<br>
Formatting and<br>
public virtual IFormatProvider FormatProvider { get; }<br>
encoding<br> <br>
public virtual string NewLine { get; set; }<br>
 <br>
public abstract Encoding Encoding { get; }<br>
Other<br>
public static readonly TextWriter Null;<br>
 <br>
public static TextWriter Synchronized (TextWriter writer);<br>
WriteLine simply appends the given text with CR+LF. You can change this via the<br>NewLine property (this can be useful for interoperability with Unix file formats).<br>
<b>StreamReader and StreamWriter<br></b>In the following example, a StreamWriter writes two lines of text to a file, and then<br>a StreamReader reads the file back:<br>
using (FileStream fs = File.Create (&quot;test.txt&quot;))<br>using (TextWriter writer = new StreamWriter (fs))<br>{<br>  writer.WriteLine (&quot;Line1&quot;);<br>
  writer.WriteLine (&quot;Line2&quot;);<br>}<br>
using (FileStream fs = File.OpenRead (&quot;test.txt&quot;))<br>using (TextReader reader = new StreamReader (fs))<br>{<br>  Console.WriteLine (reader.ReadLine());       // Line1<br>  Console.WriteLine (reader.ReadLine());       // Line2<br>}<br>
Because text adapters are so often coupled with files, the File class provides the<br>static methods CreateText, AppendText, and OpenText to shortcut the process:<br>
using (TextWriter writer = File.CreateText (&quot;test.txt&quot;))<br>{<br>  writer.WriteLine (&quot;Line1&quot;);<br>
<b>554 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=575></a>  writer.WriteLine (&quot;Line2&quot;);<br>
}<br>
using (TextWriter writer = File.AppendText (&quot;test.txt&quot;))<br>
  writer.WriteLine (&quot;Line3&quot;);<br>
using (TextReader reader = File.OpenText (&quot;test.txt&quot;))<br>  while (reader.Peek() &gt; -1)<br>
    Console.WriteLine (reader.ReadLine());     // Line1<br>
                                               // Line2<br>                                               // Line3<br>
This also illustrates how to test for the end of a file (viz. reader.Peek()). Another<br>option is to read until reader.ReadLine returns null.<br>You can also read and write other types such as integers, but because TextWriter<br>invokes ToString on your type, you must parse a string when reading it back:<br>
using (TextWriter w = File.CreateText (&quot;data.txt&quot;))<br>
{<br>  w.WriteLine (123);          // Writes &quot;123&quot;<br>
  w.WriteLine (true);         // Writes the word &quot;true&quot;<br>
}<br>
using (TextReader r = File.OpenText (&quot;data.txt&quot;))<br>{<br>  int myInt = int.Parse (r.ReadLine());     // myInt == 123<br>
  bool yes = bool.Parse (r.ReadLine());     // yes == true<br>
<b>Streams and I/O</b><br>
}<br>
<b>Character encodings<br></b>TextReader and TextWriter are by themselves just abstract classes with no connection<br>to a stream or backing store. The StreamReader and StreamWriter types, however,<br>are connected to an underlying byte-oriented stream, so they must convert between<br>characters and bytes. They do so through an Encoding class from the System.Text<br>namespace,  which  you  choose  when  constructing  the  StreamReader  or  Stream<br>Writer. If you choose none, the default UTF-8 encoding is used.<br>
A  StreamReader or StreamWriter will throw an exception if it<br>encounters bytes that do not have a valid string translation for<br>their encoding.<br>
The simplest of the encodings is ASCII, because each character is represented by<br>one byte. The ASCII encoding maps the first 127 characters of the Unicode set into<br>its single byte, covering what you see on a U.S.-style keyboard. Most other charac-<br>ters, including specialized symbols and non-English characters, cannot be repre-<br>sented and are converted to the  character. The default UTF-8 encoding can map<br>all allocated Unicode characters, but it is more complex. The first 127 characters<br>encode to a single byte, for ASCII compatibility; the remaining characters encode to<br>a variable number of bytes (most commonly two or three). Consider this:<br>
<b>Stream Adapters | 555</b><br>
<hr>
<A name=576></a>using (TextWriter w = File.CreateText (&quot;but.txt&quot;))    // Use default UTF-8<br>
  w.WriteLine (&quot;but-&quot;);                               // encoding.<br>
using (Stream s = File.OpenRead (&quot;but.txt&quot;))<br>
  for (int b; (b = s.ReadByte()) &gt; -1;)<br>
    Console.WriteLine (b);<br>
The word "but" is followed not by a stock-standard hyphen, but by the longer em<br>dash (--) character, U+2014. This is the one that won't get you into trouble with<br>your book editor! Let's examine the output:<br>
98     // b<br>
117    // u<br>
116    // t<br>
226    // em dash byte 1       Note that the byte values<br>
128    // em dash byte 2       are &gt;= 128 for each part<br>
148    // em dash byte 3       of the multibyte sequence.<br>13     // &lt;CR&gt;<br>
10     // &lt;LF&gt;<br>
Because the em dash is outside the first 127 characters of the Unicode set, it requires<br>more than a single byte to encode in UTF-8 (in this case, three). UTF-8 is efficient<br>with the Western alphabet, as most popular characters consume just one byte. It<br>also downgrades easily to ASCII simply by ignoring all bytes above 127. Its disad-<br>vantage is that seeking within a stream is troublesome, since a character's position<br>does not correspond to its byte position in the stream. An alternative is UTF-16<br>(labeled just "Unicode" in the Encoding class). Here's how we write the same string<br>with UTF-16:<br>
using (Stream s = File.Create (&quot;but.txt&quot;))<br>using (TextWriter w = new StreamWriter (s, Encoding.Unicode))<br>  w.WriteLine (&quot;but-&quot;);<br>
foreach (byte b in File.ReadAllBytes (&quot;but.txt&quot;))<br>  Console.WriteLine (b);<br>
The output is then:<br>
255    // Byte-order mark 1<br>254    // Byte-order mark 2<br>98     // 'b' byte 1<br>0      // 'b' byte 2<br>117    // 'u' byte 1<br>0      // 'u' byte 2<br>116    // 't' byte 1<br>0      // 't' byte 2<br>20     // '--' byte 1<br>32     // '--' byte 2<br>13     // &lt;CR&gt; byte 1<br>0      // &lt;CR&gt; byte 2<br>10     // &lt;LF&gt; byte 1<br>0      // &lt;LF&gt; byte 2<br>
Technically, UTF-16 uses either two or four bytes per character (there are close to<br>a million Unicode characters allocated or reserved, so 2 bytes is not always enough).<br>However, because the C# char type is itself only 16 bits wide, a UTF-16 encoding<br>
<b>556 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=577></a>will always use exactly two bytes per .NET char. This makes it easy to jump to a<br>particular character index within a stream.<br>
UTF-16 uses a two-byte prefix to identify whether the byte pairs are written in a<br>"little-endian" or "big-endian" order (the least significant byte first or the most sig-<br>nificant byte first). The default little-endian order is standard for Windows-based<br>systems.<br>
<b>StringReader and StringWriter<br></b>The StringReader and StringWriter adapters don't wrap a stream at all; instead, they<br>use a string or StringBuilder as the underlying data source. This means no byte<br>translation is required--in fact, the classes do nothing you couldn't easily achieve<br>with a string or StringBuilder coupled with an index variable. Their advantage,<br>though, is that they share a base class with StreamReader/StreamWriter. For instance,<br>suppose we have a string containing XML and want to parse it with an XmlReader.<br>The XmlReader.Create method accepts one of the following:<br>
· A URI<br>· A Stream<br>· A TextReader<br>
So,  how  do  we  XML-parse  our  string?  Because  StringReader  is  a  subclass  of<br>TextReader, we're in luck. We can instantiate and pass in a StringReader as follows:<br>
<b>Streams and I/O</b><br>
XmlReader r = XmlReader.Create (new StringReader (myString));<br>
<b>Binary Adapters<br></b>BinaryReader and BinaryWriter read and write native data types: bool, byte, char,<br>decimal, float, double, short, int, long, sbyte, ushort, uint, and ulong, as well as<br>strings and arrays of the primitive data types.<br>
Unlike StreamReader and StreamWriter, binary adapters store primitive data types<br>efficiently, as they are represented in memory. So, an int uses four bytes; a double<br>eight bytes. Strings are written through a text encoding (as with StreamReader and<br>StreamWriter) but are length-prefixed, in order to make it possible to read back a<br>series of strings without needing special delimiters.<br>
Imagine we have a simple type, defined as follows:<br>
public class Person<br>{<br>  public string Name;<br>  public int    Age;<br>  public double Height;<br>}<br>
We can add the following methods to Person to save/load its data to/from a stream<br>using binary adapters:<br>
<b>Stream Adapters | 557</b><br>
<hr>
<A name=578></a>public void SaveData (Stream s)<br>
{<br>  var w = new BinaryWriter (s);<br>  w.Write (Name);<br>
  w.Write (Age);<br>
  w.Write (Height);<br>  w.Flush();         // Ensure the BinaryWriter buffer is cleared.<br>                     // We won't dispose/close it, so more data<br>
}                    // can be written to the stream.<br>
public void LoadData (Stream s)<br>{<br>  var r = new BinaryReader (s);<br>  Name   = r.ReadString();<br>
  Age    = r.ReadInt32();<br>  Height = r.ReadDouble();<br>
}<br>
BinaryReader can also read into byte arrays. The following reads the entire contents<br>of a seekable stream:<br>
byte[] data = new BinaryReader (s).ReadBytes ((int) s.Length);<br>
This  is  more  convenient  than  reading  directly  from  a  stream,  because  it  doesn't<br>require a loop to ensure that all data has been read.<br>
<b>Closing and Disposing Stream Adapters<br></b>You have four choices in tearing down stream adapters:<br>
1. Close the adapter only.<br>2. Close the adapter, and then close the stream.<br>3. (For writers) Flush the adapter, and then close the stream.<br>4. (For readers) Close just the stream.<br>
Close and Dispose are synonymous with adapters, just as they<br>are with streams.<br>
Options 1 and 2 are semantically identical, because closing an adapter automatically<br>closes the underlying stream. Whenever you nest using statements, you're implicitly<br>taking option 2:<br>
using (FileStream fs = File.Create (&quot;test.txt&quot;))<br>using (TextWriter writer = new StreamWriter (fs))<br>  writer.WriteLine (&quot;Line&quot;);<br>
Because the nest disposes from the inside out, the adapter is first closed, and then<br>the stream. Furthermore, if an exception is thrown within the adapter's constructor,<br>the stream still closes. It's hard to go wrong with nested using statements!<br>
<b>558 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=579></a>Never close a stream before closing or flushing its writer--you'll<br>amputate any data that's buffered in the adapter.<br>
Options 3 and 4 work because adapters are in the unusual category of <i>optionally<br></i>disposable objects. An example of when you might choose not to dispose an adapter<br>is when you've finished with the adapter, but you want to leave the underlying stream<br>open for subsequent use:<br>
using (FileStream fs = new FileStream (&quot;test.txt&quot;, FileMode.Create))<br>
{<br>  StreamWriter writer = new StreamWriter (fs);<br>  writer.WriteLine (&quot;Hello&quot;);<br>
  writer.Flush();<br>
  fs.Position = 0;<br>  Console.WriteLine (fs.ReadByte());<br>
}<br>
Here we write to a file, reposition the stream, and then read the first byte before<br>closing the stream. If we disposed the StreamWriter, it would also close the under-<br>lying FileStream, causing the subsequent read to fail. The proviso is that we call<br>Flush to ensure that the StreamWriter's buffer is written to the underlying stream.<br>
<b>Streams and I/O</b><br>
Stream adapters--with their optional disposal semantics--do<br>not implement the extended disposal pattern where the finalizer<br>calls Dispose. This allows an abandoned adapter to evade au-<br>tomatic disposal when the garbage collector catches up with it.<br>
<b>File and Directory Operations<br></b>The System.IO namespace provides a set of types for performing "utility" file and <br>directory operations, such as copying and moving, creating directories, and setting<br>file attributes and permissions. For most features, you can choose between two <br>classes, one offering static methods and the other instance methods:<br>
<i>Static classes</i><br>
File and Directory<br>
<i>Instance method classes (constructed with a file or directory name)</i><br>
FileInfo and DirectoryInfo<br>
Additionally, there's a static class called Path. This does nothing to files or directo-<br>ries; instead, it provides string manipulation methods for filenames and directory<br>paths. Path also assists with temporary files.<br>
<b>File and Directory Operations | 559</b><br>
<hr>
<A name=580></a><b>The File Class<br></b>File is a static class whose methods all accept a filename. The filename can be either<br>relative to the current directory or fully qualified with a directory. Here are its meth-<br>ods (all public and static):<br>
bool Exists (string path);      // Returns true if the file is present<br>
void Delete  (string path);<br>
void Copy    (string sourceFileName, string destFileName);<br>
void Move    (string sourceFileName, string destFileName);<br>
void Replace (string sourceFileName, string destinationFileName,<br>                                     string destinationBackupFileName);<br>
FileAttributes GetAttributes (string path);<br>
void SetAttributes           (string path, FileAttributes fileAttributes);<br>
void Decrypt (string path);<br>void Encrypt (string path);<br>
DateTime GetCreationTime   (string path);      // UTC versions are<br>
DateTime GetLastAccessTime (string path);      // also provided.<br>DateTime GetLastWriteTime  (string path);<br>
void SetCreationTime   (string path, DateTime creationTime);<br>
void SetLastAccessTime (string path, DateTime lastAccessTime);<br>
void SetLastWriteTime  (string path, DateTime lastWriteTime);<br>
FileSecurity GetAccessControl (string path);<br>
FileSecurity GetAccessControl (string path,<br>                               AccessControlSections includeSections);<br>void SetAccessControl (string path, FileSecurity fileSecurity);<br>
Move throws an exception if the destination file already exists; Replace does not. Both<br>methods allow the file to be renamed as well as moved to another directory.<br>
Delete throws an UnauthorizedAccessException if the file is marked read-only; you<br>can tell this in advance by calling GetAttributes. Here are all the members of the<br>FileAttribute enum that GetAttributes returns:<br>
Archive, Compressed, Device, Directory, Encrypted,<br>Hidden, Normal, NotContentIndexed, Offline, ReadOnly,<br>ReparsePoint, SparseFile, System, Temporary<br>
Members in this enum are combinable. Here's how to toggle a single file attribute<br>without upsetting the rest:<br>
string filePath = @&quot;c:\temp\test.txt&quot;;<br>
FileAttributes fa = File.GetAttributes (filePath);<br>if ((fa &amp; FileAttributes.ReadOnly) &gt; 0)<br>{<br>    fa ^= FileAttributes.ReadOnly;<br>    File.SetAttributes (filePath, fa);<br>}<br>
<b>560 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=581></a>// Now we can delete the file, for instance:<br>
File.Delete (filePath);<br>
FileInfo offers an easier way to change a file's read-only flag:<br>
new FileInfo (@&quot;c:\temp\test.txt&quot;).IsReadOnly = false;<br>
<b>Compression and encryption attributes<br></b>The Compressed and Encrypted file attributes correspond to the compression and<br>encryption checkboxes on a file or directory's  <i>properties</i> dialog in Windows Ex-<br>plorer. This type of compression and encryption is <i>transparent</i> in that the operating<br>system does all the work behind the scenes, allowing you to read and write plain data.<br>
You cannot use SetAttributes to change a file's Compressed or Encrypted attributes--<br>it fails silently if you try! The workaround is simple in the latter case: you instead<br>call the Encrypt() and Decrypt() methods in the File class. With compression, it's<br>more complicated; one solution is to use the Windows Management Instrumenta-<br>tion (WMI) API in System.Management. The following method compresses a direc-<br>tory, returning 0 if successful (or a WMI error code if not):<br>
static uint CompressFolder (string folder, bool recursive)<br>{<br>  string path = &quot;Win32_Directory.Name='&quot; + folder + &quot;'&quot;;<br>
<b>Streams and I/O</b><br>
  using (ManagementObject dir = new ManagementObject (path))<br>  using (ManagementBaseObject p = dir.GetMethodParameters (&quot;CompressEx&quot;))<br>  {<br>
    p [&quot;Recursive&quot;] = recursive;<br>    using (ManagementBaseObject result = dir.InvokeMethod (&quot;CompressEx&quot;,<br>                                                             p, null))<br>      return (uint) result.Properties [&quot;ReturnValue&quot;].Value;<br>  }<br>}<br>
To uncompress, replace CompressEx with UncompressEx.<br>Transparent encryption relies on a key seeded from the logged-in user's password.<br>The system is robust to password changes performed by the authenticated user, but<br>if a password is reset via an administrator, data in encrypted files is unrecoverable.<br>
Transparent encryption and compression require special file-<br>system support. NTFS (used most commonly on hard drives)<br>supports  these  features;  CDFS  (on  CD-ROMs)  and  FAT  (on<br>removable media cards) do not.<br>
You can determine whether a volume supports compression and encryption with<br>Win32 interop:<br>
using System;<br>using System.IO;<br>using System.Text;<br>
<b>File and Directory Operations | 561</b><br>
<hr>
<A name=582></a>using System.Runtime.InteropServices;<br>
class SupportsCompressionEncryption<br>{<br>  const int SupportsCompression = 0×10;<br>
  const int SupportsEncryption = 0×20000;<br>
  [DllImport (&quot;Kernel32.dll&quot;, SetLastError = true)]<br>
  extern static bool GetVolumeInformation (string vol, StringBuilder name,<br>
    int nameSize, out uint serialNum, out uint maxNameLen, out uint flags,<br>    StringBuilder fileSysName, int fileSysNameSize);<br>
  static void Main()<br>  {<br>
    uint serialNum, maxNameLen, flags;<br>    bool ok = GetVolumeInformation (@&quot;C:\&quot;, null, 0, out serialNum,<br>
                                    out maxNameLen, out flags, null, 0);<br>    if (!ok)<br>
      throw new Win32Exception();<br>
    bool canCompress = (flags &amp; SupportsCompression) &gt; 0;<br>
    bool canEncrypt = (flags &amp; SupportsEncryption) &gt; 0;<br>
  }<br>}<br>
<b>File security<br></b>The  GetAccessControl  and  SetAccessControl  methods  allow  you  to  query<br>and  change  the  operating  system  permissions  assigned  to  users  and  roles  via  a<br>FileSecurity object (namespace System.Security.AccessControl). You can also pass<br>a FileSecurity object to a FileStream's constructor to specify permissions when<br>creating a new file.<br>
In this example, we list a file's existing permissions, and then assign execution per-<br>mission to the "Users" group:<br>
using System;<br>using System.IO;<br>using System.Security.AccessControl;<br>using System.Security.Principal;<br>
...<br>
FileSecurity sec = File.GetAccessControl (@&quot;c:\temp\test.txt&quot;);<br>AuthorizationRuleCollection rules = sec.GetAccessRules (true, true,<br>                                                     typeof (NTAccount));<br>foreach (FileSystemAccessRule rule in rules)<br>{<br>  Console.WriteLine (rule.AccessControlType);         // Allow or Deny<br>  Console.WriteLine (rule.FileSystemRights);          // e.g., FullControl<br>  Console.WriteLine (rule.IdentityReference.Value);   // e.g., MyDomain/Joe<br>}<br>
FileSystemAccessRule newRule = new FileSystemAccessRule<br>  (&quot;Users&quot;, FileSystemRights.ExecuteFile, AccessControlType.Allow);<br>
<b>562 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=583></a>sec.AddAccessRule (newRule);<br>
File.SetAccessControl (@&quot;c:\temp\test.txt&quot;, sec);<br>
<b>The Directory Class<br></b>The static Directory class provides a set of methods analogous to those in the File<br>class--for checking whether a directory exists (Exists), moving a directory (Move),<br>deleting a directory (Delete), getting/setting times of creation or last access, and<br>getting/setting security permissions. Furthermore, Directory exposes the following<br>static methods:<br>
string GetCurrentDirectory ();<br>
void   SetCurrentDirectory (string path);<br>
DirectoryInfo CreateDirectory  (string path);<br>
DirectoryInfo GetParent        (string path);<br>
string        GetDirectoryRoot (string path);<br>
string[] GetLogicalDrives();<br>
// The following methods all return full paths:<br>
string[] GetFiles             (string path);<br>string[] GetDirectories       (string path);<br>
string[] GetFileSystemEntries (string path);<br>
IEnumerable&lt;string&gt; EnumerateFiles             (string path);<br>
<b>Streams and I/O</b><br>
IEnumerable&lt;string&gt; EnumerateDirectories       (string path);<br>IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);<br>
The last three methods were added in Framework 4.0. They're<br>potentially more efficient than the Get* variants, because they're<br>lazily evaluated--fetching data from the filesystem as you enu-<br>merate the sequence. They're particularly well-suited to LINQ<br>queries.<br>
The  Enumerate*  and  Get*  methods  are  overloaded  to  also  accept  searchPattern<br>(string) and searchOption (enum) parameters. If you specify SearchOption.Search<br>AllSubDirectories,  a  recursive  subdirectory  search  is  performed.  The  *FileSyste<br>mEntries methods combine the results of *Files with *Directories.<br>
Here's how to create a directory if it doesn't already exist:<br>
if (!Directory.Exists (@&quot;c:\temp&quot;))<br>  Directory.CreateDirectory (@&quot;c:\temp&quot;);<br>
<b>FileInfo and DirectoryInfo<br></b>The static methods on File and Directory are convenient for executing a single file<br>or  directory  operation.  If  you  need  to  call  a  series  of  methods  in  a  row,  the<br>FileInfo  and  DirectoryInfo  classes  provide  an  object  model  that  makes  the  job<br>easier.<br>
<b>File and Directory Operations | 563</b><br>
<hr>
<A name=584></a>FileInfo offers most of the File's static methods in instance form--with some ad-<br>ditional properties such as Extension, Length, IsReadOnly, and Directory--for re-<br>turning a DirectoryInfo object. For example:<br>
FileInfo fi = new FileInfo (@&quot;c:\temp\FileInfo.txt&quot;);<br>
Console.WriteLine (fi.Exists);         // false<br>
using (TextWriter w = fi.CreateText())<br>
  w.Write (&quot;Some text&quot;);<br>
Console.WriteLine (fi.Exists);         // false (still)<br>fi.Refresh();<br>
Console.WriteLine (fi.Exists);         // true<br>
Console.WriteLine (fi.Name);           // FileInfo.txt<br>Console.WriteLine (fi.FullName);       // c:\temp\FileInfo.txt<br>Console.WriteLine (fi.DirectoryName);  // c:\temp<br>
Console.WriteLine (fi.Directory.Name); // temp<br>
Console.WriteLine (fi.Extension);      // .txt<br>
Console.WriteLine (fi.Length);         // 9<br>
fi.Encrypt();<br>
fi.Attributes ^= FileAttributes.Hidden;   // (Toggle hidden flag)<br>
fi.IsReadOnly = true;<br>
Console.WriteLine (fi.Attributes);    // ReadOnly,Archive,Hidden,Encrypted<br>
Console.WriteLine (fi.CreationTime);<br>
fi.MoveTo (@&quot;c:\temp\FileInfoX.txt&quot;);<br>
DirectoryInfo di = fi.Directory;<br>Console.WriteLine (di.Name);             // temp<br>Console.WriteLine (di.FullName);         // c:\temp<br>Console.WriteLine (di.Parent.FullName);  // c:\<br>di.CreateSubdirectory (&quot;SubFolder&quot;);<br>
Here's how to use DirectoryInfo to enumerate files and subdirectories:<br>
DirectoryInfo di = new DirectoryInfo (@&quot;e:\photos&quot;);<br>
foreach (FileInfo fi in di.GetFiles (&quot;*.jpg&quot;))<br>  Console.WriteLine (fi.Name);<br>
foreach (DirectoryInfo subDir in di.GetDirectories())<br>  Console.WriteLine (subDir.FullName);<br>
<b>Path<br></b>The  static  Path  class  defines  methods  and  fields  for  working  with  paths  and<br>filenames. Assuming this setup code:<br>
string dir  = @&quot;c:\mydir&quot;;<br>string file = &quot;myfile.txt&quot;;<br>string path = @&quot;c:\mydir\myfile.txt&quot;;<br>
Directory.SetCurrentDirectory (@&quot;k:\demo&quot;);<br>
<b>564 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=585></a>we can demonstrate Path's methods and fields with the following expressions:<br>
<b>Expression:</b><br>
<b>Result</b><br>
Directory.GetCurrentDirectory()<br>
k:\demo\<br>
Path.IsPathRooted (file)<br>
False<br>
Path.IsPathRooted (path)<br>
True<br>
Path.GetPathRoot (path)<br>
c:\<br>
Path.GetDirectoryName (path)<br>
c:\mydir<br>
Path.GetFileName (path)<br>
myfile.txt<br>
Path.GetFullPath (file)<br>
k:\demo\myfile.txt<br>
Path.Combine (dir, file)<br>
c:\mydir\myfile.txt<br>
<b>File extensions:</b><br>
<b> </b><br>
Path.HasExtension (file)<br>
True<br>
Path.GetExtension (file)<br>
.txt<br>
Path.GetFileNameWithoutExtension (file)<br>
myfile<br>
Path.ChangeExtension (file, &quot;.log&quot;)<br>
myfile.log<br>
<b>Separators and characters:</b><br>
<b> </b><br>
Path.AltDirectorySeparatorChar<br>
/<br>
Path.PathSeparator<br>
;<br>
<b>Streams and I/O</b><br>
Path.VolumeSeparatorChar<br>
:<br>
Path.GetInvalidPathChars()<br>
chars 0 to 31 and &quot;&lt;&gt;|<br>
Path.GetInvalidFileNameChars()<br>
chars 0 to 31 and &quot;&lt;&gt;|:*?\/<br>
<b>Temporary files:</b><br>
<b> </b><br>
Path.GetTempPath()<br>
&lt;local user folder&gt;\Temp<br>
Path.GetRandomFileName()<br>
<i>d2dwuzjf.dnp</i><br>
Path.GetTempFileName()<br>
&lt;local user folder&gt;\Temp\<i>tmp14B.tmp</i><br>
Combine is particularly useful: it allows you to combine a directory and filename--<br>or two directories--without first having to check whether a trailing backslash is<br>present.<br>
GetFullPath converts a path relative to the current directory to an absolute path. It<br>accepts values such as <i>..\..\file.txt</i>.<br>
GetRandomFileName returns a genuinely unique 8.3 character filename, without ac-<br>tually creating any file. GetTempFileName generates a temporary filename using an<br>auto-incrementing counter that repeats every 65,000 files. It then creates a zero-byte<br>file of this name in the local temporary directory.<br>
<b>File and Directory Operations | 565</b><br>
<hr>
<A name=586></a>You  must  delete  the  file  generated  by  GetTempFileName  when<br>you're done; otherwise, it will eventually throw an exception<br>(after your 65,000th call to GetTempFileName). If this is a prob-<br>lem, you can instead Combine GetTempPath with GetRandomFile<br>Name. Just be careful not to fill up the user's hard drive!<br>
<b>Special Folders<br></b>One thing missing from Path and Directory is a means to locate folders such as <i>My<br>Documents</i>, <i>Program Files</i>, <i>Application Data</i>, and so on. This is provided instead by<br>the GetFolderPath method in the System.Environment class:<br>
string myDocPath = Environment.GetFolderPath<br>  (Environment.SpecialFolder.MyDocuments);<br>
Environment.SpecialFolder is an enum whose values encompass all special directo-<br>ries in Windows:<br>
AdminTools<br>
CommonVideos<br>
Personal<br>
ApplicationData<br>
Cookies<br>
PrinterShortcuts<br>
CDBurning<br>
Desktop<br>
ProgramFiles<br>
CommonAdminTools<br>
DesktopDirectory<br>
ProgramFilesX86<br>
CommonApplicationData<br>
Favorites<br>
Programs<br>
CommonDesktopDirectory<br>
Fonts<br>
Recent<br>
CommonDocuments<br>
History<br>
Resources<br>
CommonMusic<br>
InternetCache<br>
SendTo<br>
CommonOemLinks<br>
LocalApplicationData<br>
StartMenu<br>
CommonPictures<br>
LocalizedResources<br>
Startup<br>
CommonProgramFiles<br>
MyComputer<br>
System<br>
CommonProgramFilesX86<br>
MyDocuments<br>
SystemX86<br>
CommonPrograms<br>
MyMusic<br>
Templates<br>
CommonStartMenu<br>
MyPictures<br>
UserProfile<br>
CommonStartup<br>
MyVideos<br>
Windows<br>
CommonTemplates<br>
NetworkShortcuts<br>
 <br>
Of particular value is ApplicationData: this is where you can store settings that travel<br>with  a  user  across  a  network  (if  roaming  profiles  are  enabled  on  the  network<br>domain). LocalApplicationData is for non-roaming data; CommonApplicationData is<br>shared by every user of the computer. Writing application data to these folders is<br>considered preferable to using the Windows Registry. A better option still, in most<br>cases, is to use isolated storage (described in the final section of this chapter).<br>
<b>566 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=587></a>The simplest place to write configuration and log files is to the<br>application's base directory, which you can obtain with AppDo<br>main.CurrentDomain.BaseDirectory. This is not recommended,<br>however, because the operating system is likely to deny your<br>application permissions to write to this folder after initial in-<br>stallation (without administrative elevation).<br>
The following method returns the .NET Framework directory:<br>
System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory()<br>
<b>Querying Volume Information<br></b>You can query the drives on a computer with the DriveInfo class:<br>
DriveInfo c = new DriveInfo (&quot;C&quot;);       // Query the C: drive.<br>
long totalSize = c.TotalSize;            // Size in bytes.<br>
long freeBytes = c.TotalFreeSpace;       // Ignores disk quotas.<br>long freeToMe  = c.AvailableFreeSpace;   // Takes quotas into account.<br>
foreach (DriveInfo d in DriveInfo.GetDrives())    // All defined drives.<br>
{<br>  Console.WriteLine (d.Name);             // C:\<br>  Console.WriteLine (d.DriveType);        // Fixed<br>
  Console.WriteLine (d.RootDirectory);    // C:\<br>
<b>Streams and I/O</b><br>
  if (d.IsReady)   // If the drive is not ready, the following two<br>                   // properties will throw exceptions:<br>  {<br>    Console.WriteLine (d.VolumeLabel);    // The Sea Drive<br>    Console.WriteLine (d.DriveFormat);    // NTFS<br>  }<br>}<br>
The static GetDrives method returns all mapped drives, including CD-ROMs, media<br>cards, and network connections. DriveType is an enum with the following values:<br>
Unknown, NoRootDirectory, Removable, Fixed, Network, CDRom, Ram<br>
<b>Catching Filesystem Events<br></b>The FileSystemWatcher class lets you monitor a directory (and optionally, subdir-<br>ectories) for activity. FileSystemWatcher has events that fire when files or subdirec-<br>tories are created, modified, renamed, and deleted, as well as when their attributes<br>change. These events fire regardless of the user or process performing the change.<br>Here's an example:<br>
static void Main() { Watch (@&quot;c:\temp&quot;, &quot;*.txt&quot;, true); }<br>
static void Watch (string path, string filter, bool includeSubDirs)<br>{<br>  using (var watcher = new FileSystemWatcher (path, filter))<br>  {<br>
<b>File and Directory Operations | 567</b><br>
<hr>
<A name=588></a>    watcher.Created += FileCreatedChangedDeleted;<br>
    watcher.Changed += FileCreatedChangedDeleted;<br>    watcher.Deleted += FileCreatedChangedDeleted;<br>    watcher.Renamed += FileRenamed;<br>
    watcher.Error   += FileError;<br>
    watcher.IncludeSubdirectories = includeSubDirs;<br>    watcher.EnableRaisingEvents = true;<br>
    Console.WriteLine (&quot;Listening for events - press &lt;enter&gt; to end&quot;);<br>    Console.ReadLine();<br>  }<br>
  // Disposing the FileSystemWatcher stops further events from firing.<br>
}<br>
static void FileCreatedChangedDeleted (object o, FileSystemEventArgs e)<br>
{<br>  Console.WriteLine (&quot;File {0} has been {1}&quot;, e.FullPath, e.ChangeType);<br>
}<br>
static void FileRenamed (object o, RenamedEventArgs e)<br>
{<br>  Console.WriteLine (&quot;Renamed: {0}-&gt;{1}&quot;, e.OldFullPath, e.FullPath);<br>}<br>
static void FileError (object o, ErrorEventArgs e)<br>{<br>  Console.WriteLine (&quot;Error: &quot; + e.GetException().Message);<br>}<br>
Because FileSystemWatcher raises events on a separate thread,<br>you must exception-handle the event handling code to prevent<br>an  error  from  taking  down  the  application.  See  "Exception<br>Handling" on page 591 for more information on this.<br>
The Error event does not inform you of filesystem errors; instead, it indicates that<br>the FileSystemWatcher's event buffer overflowed because it was overwhelmed by<br>Changed, Created, Deleted, or Renamed events. You can change the buffer size via the<br>InternalBufferSize property.<br>
IncludeSubdirectories applies recursively. So, if you create a FileSystemWatcher on<br><i>C:\</i> with IncludeSubdirectories true, its events will fire when a file or directory<br>changes anywhere on the hard drive.<br>
A trap in using FileSystemWatcher is to open and read newly<br>created or updated files before the file has been fully populated<br>or updated. If you're working in conjunction with some other<br>software that's creating files, you might need to consider a strat-<br>egy to mitigate this, such as creating files with an unwatched<br>extension and then renaming them once fully written.<br>
<b>568 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=589></a><b>Memory-Mapped Files<br></b><i>Memory-mapped files</i> are new to Framework 4.0. They provide two key features:<br>
· Efficient random access to file data<br>· The ability to share memory between different processes on the same computer<br>
The  types  for  memory-mapped  files  reside  in  the  System.IO.MemoryMappedFiles<br>namespace. Internally, they work by wrapping the Win32 API for memory-mapped<br>files.<br>
<b>Memory-Mapped Files and Random File I/O<br></b>Although an ordinary FileStream allows random file I/O (by setting the stream's<br>Position property), it's optimized for sequential I/O. As a rough rule of thumb:<br>
· FileStreams are 10 times faster than memory-mapped files for sequential I/O.<br>· Memory-mapped files are 10 times faster than FileStreams for random I/O.<br>
Changing a FileStream's Position can cost several microseconds--which adds up<br>if done within a loop. A FileStream is also unsuitable for multithreaded access--<br>because its position changes as it is read or written.<br>
To create a memory-mapped file:<br>
1. Obtain a FileStream as you would ordinarily.<br>
<b>Streams and I/O</b><br>
2. Instantiate a MemoryMappedFile, passing in the file stream.<br>3. Call CreateViewAccessor on the memory-mapped file object.<br>
The last step gives you a MemoryMappedViewAccessor object, which provides methods<br>for randomly reading and writing simple types, structures, and arrays (more on this<br>in "Working with View Accessors" on page 570).<br>
The following creates a 1 million-byte file and then uses the memory-mapped file<br>API to read and then write a byte at position 500,000:<br>
File.WriteAllBytes (&quot;long.bin&quot;, new byte [1000000]);<br>
using (MemoryMappedFile mmf = MemoryMappedFile.CreateFromFile (&quot;long.bin&quot;))<br>using (MemoryMappedViewAccessor accessor = mmf.CreateViewAccessor())<br>{<br>  accessor.Write (500000, (byte) 77);<br>  Console.WriteLine (accessor.ReadByte (500000));   // 77<br>}<br>
You can also specify a map name and capacity when calling CreateFromFile. Spec-<br>ifying a non-null map name allows the memory block to be shared with other pro-<br>cesses (see the following section); specifying a capacity automatically enlarges the<br>file to that value. The following creates a 1,000-byte file:<br>
using (var mmf = MemoryMappedFile.CreateFromFile<br>                 (&quot;long.bin&quot;, FileMode.Create, null, <b>1000</b>))<br>
  ...<br>
<b>Memory-Mapped Files | 569</b><br>
<hr>
<A name=590></a><b>Memory-Mapped Files and Shared Memory<br></b>You  can  also  use  memory-mapped  files  as  a  means  of  sharing  memory  between<br>processes on the same computer. One process creates a shared memory block by<br>calling MemoryMappedFile.CreateNew, while other processes subscribe to that same<br>memory block by calling MemoryMappedFile.OpenExisting with the same name. Al-<br>though it's still referred to as a memory-mapped "file," it lives entirely in memory<br>and has no disk presence.<br>
The following creates a 500-byte shared memory-mapped file, and writes the integer<br>12345 at position 0:<br>
using (MemoryMappedFile mmFile = MemoryMappedFile.CreateNew (&quot;Demo&quot;, 500))<br>
using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())<br>
{<br>  accessor.Write (0, 12345);<br>
  Console.ReadLine();   // Keep shared memory alive until user hits Enter.<br>}<br>
while the following opens that same memory-mapped file and reads that integer:<br>
// This can run in a separate EXE:<br>
using (MemoryMappedFile mmFile = MemoryMappedFile.OpenExisting (&quot;Demo&quot;))<br>using (MemoryMappedViewAccessor accessor = mmFile.CreateViewAccessor())<br>
  Console.WriteLine (accessor.ReadInt32 (0));   // 12345<br>
<b>Working with View Accessors<br></b>Calling CreateViewAccessor on a MemoryMappedFile gives you a view accessor that<br>lets you read/write values at random positions.<br>
The Read*/Write* methods accept numeric types, bool, and char, as well as arrays<br>and structs that contain value-type elements or fields. Reference types--and arrays<br>or structs that contain reference types--are prohibited because they cannot map<br>into unmanaged memory. So if you want to write a string, you must encode it into<br>an array of bytes:<br>
byte[] data = Encoding.UTF8.GetBytes (&quot;This is a test&quot;);<br>accessor.Write (0, data.Length);<br>accessor.WriteArray (4, data, 0, data.Length);<br>
Notice that we wrote the length first. This means we know how many bytes to read<br>back later:<br>
byte[] data = new byte [accessor.ReadInt32 (0)];<br>accessor.ReadArray (4, data, 0, data.Length);<br>Console.WriteLine (Encoding.UTF8.GetString (data));   // This is a test<br>
Here's an example of reading/writing a struct:<br>
struct Data { public int X, Y; }<br>...<br>var data = new Data { X = 123, Y = 456 };<br>accessor.Write (0, ref data);<br>accessor.Read (0, out data);<br>
Console.WriteLine (data.X + &quot; &quot; + data.Y);   // 123 456<br>
<b>570 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=591></a>You can also directly access the underlying unmanaged memory via a pointer. Fol-<br>lowing on from the previous example:<br>
unsafe<br>{<br>  byte* pointer = null;<br>
  accessor.SafeMemoryMappedViewHandle.AcquirePointer (ref pointer);<br>  int* intPointer = (int*) pointer;<br>  Console.WriteLine (*intPointer);               // 123<br>
}<br>
Pointers can be advantageous when working with large structures: they let you work<br>directly with the raw data rather than using Read/Write to <i>copy</i> data between man-<br>aged and unmanaged memory. We explore this further in Chapter 25.<br>
<b>Compression<br></b>Two general-purpose compression streams are provided in the System.IO.Compres<br>sion namespace: DeflateStream and GZipStream. Both use a popular compression<br>algorithm similar to that of the ZIP format. They differ in that GZipStream writes an<br>additional  protocol  at  the  start  and  end--including  a  CRC  to  detect  for  errors.<br>GZipStream also conforms to a standard recognized by other software.<br>
Both streams allow reading and writing, with the following provisos:<br>
· You always <i>write</i> to the stream when compressing.<br>
<b>Streams and I/O</b><br>
· You always <i>read</i> from the stream when decompressing.<br>
DeflateStream and GZipStream are decorators; they compress or decompress data<br>from another stream that you supply in construction. In the following example, we<br>compress and decompress a series of bytes, using a FileStream as the backing store:<br>
using (Stream s = File.Create (&quot;compressed.bin&quot;))<br>using (Stream ds = new DeflateStream (s, CompressionMode.Compress))<br>  for (byte i = 0; i &lt; 100; i++)<br>    ds.WriteByte (i);<br>
using (Stream s = File.OpenRead (&quot;compressed.bin&quot;))<br>using (Stream ds = new DeflateStream (s, CompressionMode.Decompress))<br>  for (byte i = 0; i &lt; 100; i++)<br>    Console.WriteLine (ds.ReadByte());     // Writes 0 to 99<br>
Even with the smaller of the two algorithms, the compressed file is 241 bytes long:<br>more than double the original! Compression works poorly with "dense," nonrepe-<br>titive binary files. It works well with most text files; in the next example, we compress<br>and decompress a text stream composed of 1,000 words chosen randomly from a<br>small sentence. This also demonstrates chaining a backing store stream, a decorator<br>stream, and an adapter, as depicted at the start of the chapter in Figure 14-1:<br>
string[] words = &quot;The quick brown fox jumps over the lazy dog&quot;.Split();<br>Random rand = new Random();<br>
using (Stream s = File.Create (&quot;compressed.bin&quot;))<br>using (Stream ds = new DeflateStream (s, CompressionMode.Compress))<br>
<b>Compression | 571</b><br>
<hr>
<A name=592></a>using (TextWriter w = new StreamWriter (ds))<br>
  for (int i = 0; i &lt; 1000; i++)<br>    w.Write (words [rand.Next (words.Length)] + &quot; &quot;);<br>
Console.WriteLine (new FileInfo (&quot;compressed.bin&quot;).Length);      // 1073<br>
using (Stream s = File.OpenRead (&quot;compressed.bin&quot;))<br>using (Stream ds = new DeflateStream (s, CompressionMode.Decompress))<br>
using (TextReader r = new StreamReader (ds))<br>
  Console.Write (r.ReadToEnd());                 // Output below:<br>
lazy lazy the fox the quick The brown fox jumps over fox over fox The<br>
brown brown brown over brown quick fox brown dog dog lazy fox dog brown<br>over fox jumps lazy lazy quick The jumps fox jumps The over jumps dog...<br>
In this case, DeflateStream compresses efficiently to 1,073 bytes--slightly more than<br>1 byte per word.<br>
<b>Compressing in Memory<br></b>Sometimes  you  need  to  compress  entirely  in  memory.  Here's  how  to  use  a<br>MemoryStream for this purpose:<br>
byte[] data = new byte[1000];          // We can expect a good compression<br>
                                       // ratio from an empty array!<br>
var ms = new MemoryStream();<br>
using (Stream ds = new DeflateStream (ms, CompressionMode.Compress))<br>  ds.Write (data, 0, data.Length);<br>
byte[] compressed = ms.ToArray();<br>
Console.WriteLine (compressed.Length);       // 113<br>
// Decompress back to the data array:<br>ms = new MemoryStream (compressed);<br>using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))<br>  for (int i = 0; i &lt; 1000; i += ds.Read (data, i, 1000 - i));<br>
The using statement around the DeflateStream closes it in a textbook fashion, flush-<br>ing any unwritten buffers in the process. This also closes the MemoryStream it wraps--<br>meaning we must then call ToArray to extract its data.<br>Here's an alternative that avoids closing the MemoryStream:<br>
byte[] data = new byte[1000];<br>
MemoryStream ms = new MemoryStream();<br>using (Stream ds = new DeflateStream (ms, CompressionMode.Compress, true))<br>  ds.Write (data, 0, data.Length);<br>
Console.WriteLine (ms.Length);             // 113<br>ms.Position = 0;<br>using (Stream ds = new DeflateStream (ms, CompressionMode.Decompress))<br>  for (int i = 0; i &lt; 1000; i += ds.Read (data, i, 1000 - i));<br>
<b>572 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=593></a>The additional flag sent to DeflateStream's constructor tells it not to follow the usual<br>protocol of taking the underlying stream with it in disposal. In other words, the<br>MemoryStream is left open, allowing us to position it back to zero and reread it.<br>
<b>Isolated Storage<br></b>Each .NET program has access to a special filesystem unique to that program, called<br><i>isolated storage</i>. Isolated storage is useful and important for a number of reasons:<br>
· Your application, if subject to code access security, is more likely to be granted<br>
permission to isolated storage than any other form of file I/O (by default, even<br>applications running from an Internet URI or Silverlight sandbox have some<br>access to isolated storage).<br>
· Data that you create is segregated from other applications.<br>· Isolated storage is UAC-friendly.<br>
In terms of security, isolated storage is a fence designed more to keep you in than to<br>keep other applications out! Data in isolated storage is strongly protected against<br>intrusion from other .NET applications running under the most restricted permis-<br>sion set (i.e., the "Internet" zone). In other cases, there's no hard security preventing<br>another application from accessing your isolated storage <i>if it really wants to</i>. The<br>benefit  of  using  isolated  storage  over  CommonApplicationData  is  that  applications<br>must go out of their way to interfere with each other--it cannot happen through<br>
<b>Streams and I/O</b><br>
carelessness or by accident.<br>
Applications running in a sandbox can have their quota of isolated storage limited<br>via permissions. The default, for Internet and Silverlight applications, is 1MB in<br>Framework 4.0.<br>
From Framework 4.0, a hosted UI-based application (e.g., Sil-<br>verlight) can ask the user for permission to increase the isolated<br>storage  quota  by  calling  the  IncreaseQuotaTo  method  on  an<br>IsolatedStorageFile  object.  This  must  be  called  from  a<br>user-initiated event, such as a button click. If the user agrees,<br>the method returns true.<br>
You can query the current allowance via the Quota property.<br>
Isolated storage also has disadvantages:<br>
· The API is somewhat awkward to use--particularly when accessing roaming<br>
stores.<br>
· You can read/write only with an IsolatedStorageStream; you cannot obtain a<br>
file or directory path and then use ordinary file I/O.<br>
<b>Isolated Storage | 573</b><br>
<hr>
<A name=594></a><b>Isolation Types<br></b>Isolated storage can separate by both program and user. This results in three basic<br>types of compartments:<br>
<i>Local user compartments</i><br>
One per user, per program, per computer<br>
<i>Roaming user compartments</i><br>
One per user, per program<br>
<i>Machine compartments</i><br>
One per program, per computer (shared by all users of a program)<br>
The data in a roaming user compartment follows the user across a network--with<br>appropriate operating system and domain support. If this support is unavailable, it<br>behaves like a local user compartment.<br>
So far, we've talked about how isolated storage separates by "program." Isolated<br>storage considers a program to be one of two things, depending on which mode you<br>choose:<br>
· An assembly<br>· An assembly running within the context of a particular application<br>
The  latter  is  called  <i>domain  isolation</i>  and  is  more  commonly  used  than  <i>assembly<br>isolation</i>. Domain isolation segregates according to two things: the currently exe-<br>cuting assembly and the executable or web application that originally started it. <br>Assembly isolation segregates only according to the currently executing assembly--<br>so different applications calling the same assembly will share the same store.<br>
Assemblies and applications are identified by their strong name.<br>If no strong name is present, the assembly's full file path or URI<br>is used instead. This means that if you move or rename a weakly<br>named assembly, its isolated storage is reset.<br>
In total, then, there are six kinds of isolated storage compartments. Table 14-4 com-<br>pares the isolation provided by each.<br>
<i>Table 14-4. Isolated storage containers</i><br>
<b>Type</b><br>
<b>Computer?</b><br>
<b>Application?</b><br>
<b>Assembly?</b><br>
<b>User?</b><br>
<b>Method to obtain store</b><br>
Domain User<br>
<br>
<br>
<br>
<br>
GetUserStoreForDomain<br>
(default)<br>Domain<br>
 <br>
<br>
<br>
<br>
 <br>
Roaming<br>Domain<br>
<br>
<br>
<br>
 <br>
GetMachineStoreForDomain<br>
Machine<br>Assembly User<br>
<br>
 <br>
<br>
<br>
GetUserStoreForAssembly<br>
<b>574 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=595></a><b>Type</b><br>
<b>Computer?</b><br>
<b>Application?</b><br>
<b>Assembly?</b><br>
<b>User?</b><br>
<b>Method to obtain store</b><br>
Assembly<br>
 <br>
 <br>
<br>
<br>
 <br>
Roaming<br>Assembly<br>
<br>
 <br>
<br>
 <br>
GetMachineStoreForAssembly<br>
Machine<br>
There is no such thing as domain-only isolation. If you want to share an isolated<br>store across all assemblies within an application, there's a simple workaround, how-<br>ever. Just expose a public method in one of the assemblies that instantiates and<br>returns an IsolatedStorageFileStream object. Any assembly can access any isolated<br>store  if  given  an  IsolatedStorageFile  object--isolation  restrictions  are  imposed<br>upon construction, not subsequent use.<br>
Similarly, there's no such thing as machine-only isolation. If you want to share an<br>isolated store across a variety of applications, the workaround is to write a common<br>assembly that all applications reference, and then expose a method on the common<br>assembly  that  creates  and  returns  an  assembly-isolated  IsolatedStorageFile<br>Stream. The common assembly must be strongly named for this to work.<br>
<b>Reading and Writing Isolated Storage<br></b>Isolated storage uses streams that work much like ordinary file streams. To obtain<br>an isolated storage stream, you first specify the kind of isolation you want by calling<br>
<b>Streams and I/O</b><br>
one  of  the  static  methods  on  IsolatedStorageFile--as  shown  previously  in  Ta-<br>ble 14-4. You then use it to construct an IsolatedStorageFileStream, along with a<br>filename and FileMode:<br>
// IsolatedStorage classes live in System.IO.IsolatedStorage<br>
using (IsolatedStorageFile f =<br>       IsolatedStorageFile.GetMachineStoreForDomain())<br>using (var s = new IsolatedStorageFileStream (&quot;hi.txt&quot;,FileMode.Create,f))<br>using (var writer = new StreamWriter (s))<br>  writer.WriteLine (&quot;Hello, World&quot;);<br>
// Read it back:<br>
using (IsolatedStorageFile f =<br>       IsolatedStorageFile.GetMachineStoreForDomain())<br>using (var s = new IsolatedStorageFileStream (&quot;hi.txt&quot;, FileMode.Open, f))<br>using (var reader = new StreamReader (s))<br>  Console.WriteLine (reader.ReadToEnd());        // Hello, world<br>
You can optionally omit the first step, and then the default isolation (Domain User)<br>is used:<br>
using (var s = new IsolatedStorageFileStream (&quot;a.txt&quot;, FileMode.Create))<br>using (var writer = new StreamWriter (s))<br>  ...<br>
<b>Isolated Storage | 575</b><br>
<hr>
<A name=596></a>IsolatedStorageFile is poorly named in that it doesn't represent<br>a file, but rather a <i>container</i> for files (basically, a directory).<br>
IsolatedStorageFile  doesn't  provide  methods  to  directly  access  the  roaming<br>stores:  you  must  instead  call  GetStore  with  an  IsolatedStorageScope  argument.<br>IsolatedStorageScope is a flags enum whose members you must combine in exactly<br>the right way to get a valid store. Figure 14-6 lists all the valid combinations.<br>
<i>Figure 14-6. Valid IsolatedStorageScope combinations</i><br>
Here's how to write to a store isolated by assembly and roaming user:<br>
var flags = IsolatedStorageScope.Assembly<br>
          | IsolatedStorageScope.User<br>          | IsolatedStorageScope.Roaming;<br>
using (IsolatedStorageFile f = IsolatedStorageFile.GetStore (flags,<br>
                                                             null, null))<br>using (var s = new IsolatedStorageFileStream (&quot;a.txt&quot;, FileMode.Create, f))<br>using (var writer = new StreamWriter (s))<br>  writer.WriteLine (&quot;Hello, World&quot;);<br>
<b>Store Location<br></b>Here's where .NET writes isolated storage files:<br>
<b>Scope</b><br>
<b>Location</b><br>
Local user<br>
[LocalApplicationData]\IsolatedStorage<br>
Roaming user<br>
[ApplicationData]\IsolatedStorage<br>
Machine<br>
[CommonApplicationData]\IsolatedStorage<br>
You can obtain the locations of each of the folders in square brackets by calling the<br>Environment.GetFolderPath method. Here are the defaults for Windows Vista and<br>above:<br>
<b>576 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=597></a><b>Scope</b><br>
<b>Location</b><br>
Local user<br>
\Users\&lt;user&gt;\AppData\Local\IsolatedStorage<br>
Roaming user<br>
\Users\&lt;user&gt;\AppData\Roaming\IsolatedStorage<br>
Machine<br>
\ProgramData\IsolatedStorage<br>
For Windows XP:<br>
<b>Scope</b><br>
<b>Location</b><br>
Local user<br>
\Documents and Settings\&lt;user&gt;\Local Settings\Application Data\Isolated-<br>Storage<br>
Roaming user<br>
\Documents and Settings\&lt;user&gt;\Application Data\IsolatedStorage<br>
Machine<br>
\Documents and Settings\All Users\Application Data\IsolatedStorage<br>
These are merely the base folders; the data files themselves are buried deep in a<br>labyrinth of subdirectories whose names derive from hashed assembly names. This<br>is both a reason to use--and not to use--isolated storage. On the one hand, it makes<br>isolation possible: a permission-restricted application wanting to interfere with an-<br>other can be stumped by being denied a directory listing--despite having the same<br>filesystem rights as its peers. On the other hand, it makes administration impractical<br>from outside the application. Sometimes it's handy--or essential--to edit an XML<br>configuration file in Notepad so that an application can start up properly. Isolated<br>
<b>Streams and I/O</b><br>
storage makes this impractical.<br>
<b>Enumerating Isolated Storage<br></b>An IsolatedStorageFile object also provides methods for listing files in the store:<br>
using (IsolatedStorageFile f = IsolatedStorageFile.GetUserStoreForDomain())<br>{<br>  using (var s = new IsolatedStorageFileStream (&quot;f1.x&quot;,FileMode.Create,f))<br>
    s.WriteByte (123);<br>
  using (var s = new IsolatedStorageFileStream (&quot;f2.x&quot;,FileMode.Create,f))<br>    s.WriteByte (123);<br>
  foreach (string s in f.GetFileNames (&quot;*.*&quot;))<br>    Console.Write (s + &quot; &quot;);                   // f1.x f2.x<br>
}<br>
You can also create and remove subdirectories, as well as files:<br>
using (IsolatedStorageFile f = IsolatedStorageFile.GetUserStoreForDomain())<br>{<br>  f.CreateDirectory (&quot;subfolder&quot;);<br>
  foreach (string s in f.GetDirectoryNames (&quot;*.*&quot;))<br>    Console.WriteLine (s);                             // subfolder<br>
  using (var s = new IsolatedStorageFileStream (@&quot;subfolder\sub1.txt&quot;,<br>
<b>Isolated Storage | 577</b><br>
<hr>
<A name=598></a>                                                 FileMode.Create, f))<br>
    s.WriteByte (100);<br>
  f.DeleteFile (@&quot;subfolder\sub1.txt&quot;);<br>
  f.DeleteDirectory (&quot;subfolder&quot;);<br>
}<br>
With sufficient permissions, you can also enumerate over all isolated stores created<br>by the current user, as well as all machine stores. This function can violate program<br>privacy, but not user privacy. Here's an example:<br>
System.Collections.IEnumerator rator =<br>  IsolatedStorageFile.GetEnumerator (IsolatedStorageScope.User);<br>
while (rator.MoveNext())<br>
{<br>  var isf = (IsolatedStorageFile) rator.Current;<br>
  Console.WriteLine (isf.AssemblyIdentity);      // Strong name or URI<br>
  Console.WriteLine (isf.CurrentSize);<br>
  Console.WriteLine (isf.Scope);                 // User + ...<br>}<br>
The GetEnumerator method is unusual in accepting an argument (this makes its con-<br>taining class foreach-unfriendly). GetEnumerator accepts one of three values:<br>
IsolatedStorageScope.User<br>
Enumerates all local stores belonging to the current user<br>
IsolatedStorageScope.User | IsolatedStorageScope.Roaming<br>
Enumerates all roaming stores belonging to the current user<br>
IsolatedStorageScope.Machine<br>
Enumerates all machine stores on the computer<br>
Once you have the IsolatedStorageFile object, you can list its content by calling<br>GetFiles and GetDirectories.<br>
<b>578 | Chapter 14:</b><b>Streams and I/O</b><br>
<hr>
<A name=599></a><b>15</b><br>
<b>Networking</b><br>
The Framework offers a variety of classes in the System.Net.* namespaces for com-<br>municating via standard network protocols, such as HTTP, TCP/IP, and FTP. Here's<br>a summary of the key components:<br>
· A WebClient façade class for simple download/upload operations via HTTP or<br>
FTP<br>
· WebRequest and WebResponse classes for more control over client-side HTTP or<br>
FTP operations<br>
· HttpListener for writing an HTTP server<br>· SmtpClient for constructing and sending mail messages via SMTP<br>· Dns for converting between domain names and addresses<br>· TcpClient, UdpClient, TcpListener, and Socket classes for direct access to the<br>
transport and network layers<br>
The Framework supports primarily Internet-based protocols, although this doesn't<br>limit applicability to the Internet; protocols such as TCP/IP also dominate local area<br>networks.<br>
The  types  described  in  this  chapter  are  defined  mostly  in  the  System.Net  and<br>System.Net.Sockets namespaces; however, many of the examples also use types in<br>System.IO.<br>
<b>Network Architecture<br></b>Figure 15-1 illustrates the .NET networking types and the communication layers in<br>which they reside. Most types reside in the <i>transport layer</i> or <i>application layer</i>. The<br>transport layer defines basic protocols for sending and receiving bytes (TCP and<br>UDP); the application layer defines higher-level protocols designed for specific ap-<br>plications such as retrieving web pages (HTTP), transferring files (FTP), sending<br>mail (SMTP), and converting between domain names and IP addresses (DNS).<br>
<b>579</b><br>
<hr>
<A name=600></a><i>Figure 15-1. Network architecture</i><br>
It's usually most convenient to program at the application layer; however, there are<br>a couple of reasons you might want to work directly at the transport layer. One is if<br>you need an application protocol not provided in the Framework, such as POP3 for<br>retrieving mail. Another is if you want to invent a custom protocol for a special<br>application, such as a peer-to-peer client.<br>
Of the application protocols, HTTP is special in that its use has extended to general-<br>purpose communication. Its basic mode of operation--"give me the web page with<br>this URL"--adapts nicely to "give me the return value from calling this method with<br>these arguments." HTTP has a rich set of features that are useful in multitier business<br>applications and service-oriented architectures, such as protocols for authentication<br>and encryption, message chunking, extensible headers and cookies, and the ability<br>to have many server applications share a single port and IP address. For these rea-<br>sons, HTTP is well supported in the Framework--both directly, as described in this<br>chapter, and at a higher level, through such technologies as WCF, Web Services,<br>and ASP.NET.<br>
The Framework provides client-side support for FTP, the popular Internet protocol<br>for sending and receiving files. Server-side support comes in the form of IIS or Unix-<br>based server software.<br>
As the preceding discussion makes clear, networking is a field that is awash in ac-<br>ronyms. Table 15-1 is a handy Network TLA (three-letter and more acronym buster).<br>
<b>580 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=601></a><i>Table 15-1. Network TLA (three-letter acronym) buster</i><br>
<b>Acronym</b><br>
<b>Expansion</b><br>
<b>Notes</b><br>
DNS<br>
Domain Name Service<br>
Converts between domain names (e.g., ebay.com) and IP addresses<br>(e.g., 199.54.213.2)<br>
FTP<br>
File Transfer Protocol<br>
Internet-based protocol for sending and receiving files<br>
HTTP<br>
Hypertext Transfer Protocol<br>
Retrieves web pages and runs web services<br>
IIS<br>
Internet Information Services<br>
Microsoft's web server software<br>
IP<br>
Internet Protocol<br>
Network-layer protocol below TCP and UDP<br>
LAN<br>
Local Area Network<br>
Most LANs use Internet-based protocols such as TCP/IP<br>
POP<br>
Post Office Protocol<br>
Retrieves Internet mail<br>
SMTP<br>
Simple Mail Transfer Protocol<br>
Sends Internet mail<br>
TCP<br>
Transmission and Control<br>
Transport-layer Internet protocol on top of which most higher-layer<br>
Protocol<br>
services are built<br>
UDP<br>
Universal Datagram Protocol<br>
Transport-layer Internet protocol used for low-overhead services such<br>as VoIP<br>
UNC<br>
Universal Naming Convention<br>
\\computer\sharename\filename<br>
URI<br>
Uniform Resource Identifier<br>
Ubiquitous resource naming system (e.g., http://www.amazon.com<br>or mailto:joe@bloggs.org)<br>
URL<br>
Uniform Resource Locator<br>
Technical meaning (fading from use): subset of URI; popular meaning:<br>synonym of URI<br>
<b>Addresses and Ports<br></b>For communication to work, a computer or device requires an address. The Internet<br>uses two addressing systems:<br>
<b>Networking</b><br>
<i>IPv4</i><br>
Currently the dominant addressing system; IPv4 addresses are 32 bits wide.<br>When string-formatted, IPv4 addresses are written as four dot-separated deci-<br>mals  (e.g.,  101.102.103.104).  An  address  can  be  unique  in  the  world--or<br>unique within a particular <i>subnet</i> (such as on a corporate network).<br>
<i>IPv6</i><br>
The newer 128-bit addressing system. Addresses are string-formatted in hexa-<br>decimal  with  a  colon  separator  (e.g.,  [3EA0:FFFF:198A:E4A3:4FF2:54f-A:<br>41BC:8D31]).  The  .NET  Framework  requires  that  you  add  square  brackets<br>around the address.<br>
The IPAddress class in the System.Net namespace represents an address in either<br>protocol.  It  has  a  constructor  accepting  a  byte  array,  and  a  static  Parse  method<br>accepting a correctly formatted string:<br>
IPAddress a1 = new IPAddress (new byte[] { 101, 102, 103, 104 });<br>IPAddress a2 = IPAddress.Parse (&quot;101.102.103.104&quot;);<br>Console.WriteLine (a1.Equals (a2));                     // True<br>Console.WriteLine (a1.AddressFamily);                   // InterNetwork<br>
<b>Addresses and Ports | 581</b><br>
<hr>
<A name=602></a>IPAddress a3 = IPAddress.Parse<br>
  (&quot;[3EA0:FFFF:198A:E4A3:4FF2:54fA:41BC:8D31]&quot;);<br>Console.WriteLine (a3.AddressFamily);   // InterNetworkV6<br>
The TCP and UDP protocols break out each IP address into 65,535 ports, allowing<br>a computer on a single address to run multiple applications, each on its own port.<br>Many applications have standard port assignments; for instance, HTTP uses port<br>80; SMTP uses port 25.<br>
The  TCP  and  UDP  ports  from  49152  to  65535  are  officially<br>unassigned,  so  they  are  good  for  testing  and  small-scale<br>deployments.<br>
An IP address and port combination is represented in the .NET Framework by the <br>IPEndPoint class:<br>
IPAddress a = IPAddress.Parse (&quot;101.102.103.104&quot;);<br>
IPEndPoint ep = new IPEndPoint (a, 222);           // Port 222<br>
Console.WriteLine (ep.ToString());                 // 101.102.103.104:222<br>
Firewalls block ports. In many corporate environments, only a<br>few ports are in fact open--typically, port 80 (for unencrypted<br>HTTP) and port 443 (for secure HTTP).<br>
<b>URIs<br></b>A URI is a specially formatted string that describes a resource on the Internet or a<br>LAN, such as a web page, file, or email address. Examples include <i>http://www.ietf<br>.org</i>, <i>ftp://myisp/doc.txt</i>, and <i>mailto:joe@bloggs.com</i>. The exact formatting is defined<br>by the Internet Engineering Task Force (<i>http://www.ietf.org/</i>).<br>
A URI can be broken up into a series of elements--typically, <i>scheme</i>, <i>authority</i>, and<br><i>path</i>. The Uri class in the System namespace performs just this division, exposing a<br>property for each element. This is illustrated in Figure 15-2.<br>
The Uri class is useful when you need to validate the format of<br>a URI string or to split a URI into its component parts. Other-<br>wise, you can treat a URI simply as a string--most networking<br>methods are overloaded to accept either a Uri object or a string.<br>
You  can  construct  a  Uri  object  by  passing  any  of  the  following  strings  into  its<br>constructor:<br>
· A  URI  string,  such  as  <i>http://www.ebay.com</i>  or  <i>file://janespc/sharedpics/dol-</i><br>
<i>phin.jpg</i><br>
<b>582 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=603></a>· An absolute path to a file on your hard disk, such as <i>c:\myfiles\data.xls<br></i>· A UNC path to a file on the LAN, such as <i>\\janespc\sharedpics\dolphin.jpg</i><br>
<i>Figure 15-2. URI properties</i><br>
File  and  UNC  paths  are  automatically  converted  to  URIs:  the  "file:"  protocol  is<br>added, and backslashes are converted to forward slashes. The Uri constructors also<br>perform some basic cleanup on your string before creating the Uri, including con-<br>verting the scheme and hostname to lowercase and removing default and blank port<br>numbers. If you supply a URI string without the scheme, such as "<i>www.test.com</i>",<br>a UriFormatException is thrown.<br>
Uri has an IsLoopback property, which indicates whether the Uri references the local<br>host (IP address 127.0.0.1), and an IsFile property, which indicates whether the<br>Uri references a local or UNC (IsUnc) path. If IsFile returns true, the LocalPath<br>property returns a version of  AbsolutePath that is friendly to the local operating<br>system (with backslashes), on which you can call File.Open.<br>
<b>Networking</b><br>
Instances of Uri have read-only properties. To modify an existing Uri, instantiate a<br>UriBuilder object--this has writable properties and can be converted back via its<br>Uri property.<br>
Uri also provides methods for comparing and subtracting paths:<br>
Uri info = new Uri (&quot;http://www.domain.com:80/info/&quot;);<br>Uri page = new Uri (&quot;http://www.domain.com/info/page.html&quot;);<br>
Console.WriteLine (info.Host);     // www.domain.com<br>Console.WriteLine (info.Port);     // 80<br>Console.WriteLine (page.Port);     // 80  (Uri knows the default HTTP port)<br>
Console.WriteLine (info.IsBaseOf (page));         // True<br>Uri relative = info.MakeRelativeUri (page);<br>Console.WriteLine (relative.IsAbsoluteUri);       // False<br>Console.WriteLine (relative.ToString());          // page.html<br>
A relative Uri, such as <i>page.html</i> in this example, will throw an exception if you call<br>almost any property or method other than IsAbsoluteUri and ToString(). You can<br>instantiate a relative Uri directly as follows:<br>
<b>URIs | 583</b><br>
<hr>
<A name=604></a>Uri u = new Uri (&quot;page.html&quot;, UriKind.Relative);<br>
A trailing slash is significant in a URI and makes a difference as<br>to  how  a  server  processes  a  request  if  a  path  component  is<br>present.<br>
For instance, given the URI <i>http://www.albahari.com/nutshell/</i>,<br>you can expect an HTTP web server to look in the <i>nutshell</i> sub-<br>directory in the site's web folder and return the default docu-<br>ment (usually <i>index.html</i>).<br>
Without the trailing slash, the web server will instead look for<br>a file called <i>nutshell</i> (without an extension) directly in the site's<br>root folder--which is usually not what you want. If no such file<br>exists, most web servers will assume the user mistyped and will<br>return a 301 <i>Permanent Redirect</i> error, suggesting the client re-<br>tries with the trailing slash. A .NET HTTP client, by default,<br>will respond transparently to a 301 in the same way as a web<br>browser--by retrying with the suggested URI. This means that<br>if you omit a trailing slash when it should have been included,<br>your request will still work--but will suffer an unnecessary ex-<br>tra round trip.<br>
The Uri class also provides static helper methods such as EscapeUriString(), which<br>converts a string to a valid URL by converting all characters with an ASCII value<br>greater  than  127  to  hexadecimal  representation.  The  CheckHostName()  and<br>CheckSchemeName() methods accept a string and check whether it is syntactically valid<br>for the given property (although they do not attempt to determine whether a host<br>or URI exists).<br>
<b>Request/Response Architecture<br></b>WebRequest and WebResponse are the common base classes for managing both HTTP<br>and FTP client-side activity, as well as the "file:" protocol. They encapsulate the<br>"request/response" model that these protocols all share: the client makes a request,<br>and then awaits a response from a server.<br>
WebClient  is  simply  a  façade  class  that  does  the  work  of  calling  WebRequest  and<br>WebResponse, saving you some coding. WebClient gives you a choice of dealing in<br>strings,  byte  arrays,  files,  or  streams;  WebRequest  and  WebResponse  support  just<br>streams. Unfortunately, you cannot rely entirely on WebClient; some features (such<br>as cookies) are available only through WebRequest and WebResponse.<br>
<b>WebClient<br></b>Here are the steps in using WebClient:<br>
1. Instantiate a WebClient object.<br>2. Assign the Proxy property.<br>3. Assign the Credentials property if authentication is required.<br>
<b>584 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=605></a>4. Call a Download<i>XXX</i> or Upload<i>XXX</i> method with the desired URI.<br>
Its download methods are as follows:<br>
public void   DownloadFile   (string address, string fileName);<br>public string DownloadString (string address);<br>
public byte[] DownloadData   (string address);<br>
public Stream OpenRead       (string address);<br>
Each is overloaded to accept a Uri object instead of a string address. The upload<br>methods are similar; their return values contain the response (if any) from the server:<br>
public byte[] UploadFile  (string address, string fileName);<br>
public byte[] UploadFile  (string address, string method, string fileName);<br>
public string UploadString(string address, string data);<br>
public string UploadString(string address, string method, string data);<br>public byte[] UploadData  (string address, byte[] data);<br>
public byte[] UploadData  (string address, string method, byte[] data);<br>
public byte[] UploadValues(string address, NameValueCollection data);<br>
public byte[] UploadValues(string address, string method,<br>                                            NameValueCollection data);<br>public Stream OpenWrite    (string address);<br>
public Stream OpenWrite    (string address, string method);<br>
The UploadValues methods can be used to post values to an HTTP form, with a<br>method argument of "POST". WebClient also has a BaseAddress property; this allows<br>you to specify a string to be prefixed to all addresses, such as <i>http://www.mysite.com/<br>data/</i>.<br>
Here's how to download the code samples page for this book to a file in the current<br>folder, and then display it in the default web browser:<br>
WebClient wc = new WebClient();<br>wc.Proxy = null;<br>wc.DownloadFile (&quot;http://www.albahari.com/nutshell/code.aspx&quot;, &quot;code.htm&quot;);<br>System.Diagnostics.Process.Start (&quot;code.htm&quot;);<br>
<b>Networking</b><br>
WebClient implements IDisposable under <i>duress</i>--by virtue of<br>deriving  from  Component  (this  allows  it  to  be  sited  in  Visual<br>Studio's designer). Its Dispose method does nothing useful at<br>run-time,  however,  so  you  don't  need  to  dispose  WebClient<br>instances.<br>
You can use the same WebClient object to perform many tasks in sequence. It will<br>crash, however, if you try to make it do two things at once with multithreading.<br>Instead, you must create a separate WebClient object for each thread.<br>
<b>WebRequest and WebResponse<br></b>WebRequest and WebResponse are more complex to use than WebClient, but also more<br>flexible. Here's how to get started:<br>
1. Call WebRequest.Create with a URI to instantiate a web request.<br>
<b>Request/Response Architecture | 585</b><br>
<hr>
<A name=606></a>2. Assign the Proxy property.<br>3. Assign the Credentials property if authentication is required.<br>
To upload data:<br>
4. Call GetRequestStream on the request object, and then write to the stream. Go<br>
to step 5 if a response is expected.<br>
To download data:<br>
5. Call GetResponse on the request object to instantiate a web response.<br>6. Call GetResponseStream on the response object, and then read the stream (a<br>
StreamReader can help!).<br>
The following downloads and displays the code samples web page (a rewrite of the<br>preceding example):<br>
WebRequest req = WebRequest.Create<br>
                (&quot;http://www.albahari.com/nutshell/code.html&quot;);<br>
req.Proxy = null;<br>using (WebResponse res = req.GetResponse())<br>
using (Stream s = res.GetResponseStream())<br>
using (StreamReader sr = new StreamReader(s))<br>
  File.WriteAllText (&quot;code.html&quot;, sr.ReadToEnd());<br>
System.Diagnostics.Process.Start (&quot;code.html&quot;);<br>
The web response object has a ContentLength property, indi-<br>cating the length of the response stream in bytes, as reported by<br>the server. This value comes from the response headers and may<br>be missing or incorrect. In particular, if an HTTP server chooses<br>the "chunked" mode to break up a large response, the Conten<br>tLength value is usually -1. The same can apply with dynami-<br>cally generated pages.<br>
The static Create method instantiates a subclass of the WebRequest type, such as<br>HttpWebRequest or FtpWebRequest. Its choice of subclass depends on the URI's prefix,<br>and is shown in Table 15-2.<br>
<i>Table 15-2. URI prefixes and web request types</i><br>
<b>Prefix</b><br>
<b>Web request type</b><br>
http: or https:<br>
HttpWebRequest<br>
ftp:<br>
FtpWebRequest<br>
file:<br>
FileWebRequest<br>
Casting  a  web  request  object  to  its  concrete  type<br>(HttpWebRequest  or  FtpWebRequest)  allows  you  to  access  its<br>protocol-specific features.<br>
<b>586 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=607></a>You can also register your own prefixes by calling WebRequest.RegisterPrefix. This<br>requires a prefix along with a factory object with a Create method that instantiates<br>an appropriate web request object.<br>
The "https:" protocol is for secure (encrypted) HTTP, via Secure Sockets Layer or<br>SSL.  Both  WebClient  and  WebRequest  activate  SSL  transparently  upon  seeing  this<br>prefix (see "SSL" on page 596 under "HTTP-Specific Support" on page 592, later<br>in this chapter). The "file:" protocol simply forwards requests to a FileStream object.<br>Its purpose is in meeting a consistent protocol for reading a URI, whether it be a<br>web page, FTP site, or file path.<br>
WebRequest  has  a  Timeout  property,  in  milliseconds.  If  a  timeout  occurs,  a<br>WebException  is  thrown  with  a  Status  property  of  WebExceptionStatus.Timeout.<br>The default timeout is 100 seconds for HTTP and infinite for FTP.<br>
You cannot recycle a WebRequest object for multiple requests--each instance is good<br>for one job only.<br>
<b>Proxies<br></b>A <i>proxy server</i> is an intermediary through which HTTP and FTP requests can be<br>routed. Organizations sometimes set up a proxy server as the only means by which<br>employees can access the Internet--primarily because it simplifies security. A proxy<br>has an address of its own and can demand authentication so that only selected users<br>on the local area network can access the Internet.<br>
You can instruct a WebClient or WebRequest object to route requests through a proxy<br>server with a WebProxy object:<br>
// Create a WebProxy with the proxy's IP address and port. You can<br>// optionally set Credentials if the proxy needs a username/password.<br>
WebProxy p = new WebProxy (&quot;192.178.10.49&quot;, 808);<br>
<b>Networking</b><br>
p.Credentials = new NetworkCredential (&quot;username&quot;, &quot;password&quot;);<br>// or:<br>p.Credentials = new NetworkCredential (&quot;username&quot;, &quot;password&quot;, &quot;domain&quot;);<br>
WebClient wc = new WebClient();<br>wc.Proxy = p;<br>  ...<br>
// Same procedure with a WebRequest object:<br>WebRequest req = WebRequest.Create (&quot;...&quot;);<br>req.Proxy = p;<br>
If you supply a domain when constructing the NetworkCredential, Windows-based<br>authentication  protocols  are  used.  To  use  the  currently  authenticated  Windows<br>user,  assign  the  static  CredentialCache.DefaultNetworkCredentials  value  to  the<br>proxy's Credentials property.<br>
<b>Request/Response Architecture | 587</b><br>
<hr>
<A name=608></a>If you don't have a proxy, you must set the Proxy property to<br>null on all WebClient and WebRequest objects. Otherwise, the<br>Framework may attempt to "auto-detect" your proxy settings,<br>adding up to 30 seconds to your request. If you're wondering<br>why your web requests execute slowly, this is probably it!<br>
As an alternative to setting the Proxy on every WebClient and WebRequest object, you<br>can set the global default as follows:<br>
WebRequest.DefaultWebProxy = myWebProxy;<br>
or:<br>
WebRequest.DefaultWebProxy = null;<br>
Whatever you set applies for the life of the application domain (unless some other<br>code changes it!).<br>
<b>Authentication<br></b>You can supply a username and password to an HTTP or FTP site by creating a<br>NetworkCredential  object  and  assigning  it  to  the  Credentials  property  of<br>WebClient or WebRequest:<br>
WebClient wc = new WebClient();<br>
wc.Proxy = null;<br>
wc.BaseAddress = &quot;ftp://ftp.albahari.com&quot;;<br>
// Authenticate, then upload and download a file to the FTP server.<br>// The same approach also works for HTTP and HTTPS.<br>
string username = &quot;nutshell&quot;;<br>string password = &quot;oreilly&quot;;<br><b>wc.Credentials = new NetworkCredential (username, password);</b><br>
wc.DownloadFile (&quot;guestbook.txt&quot;, &quot;guestbook.txt&quot;);<br>
string data = &quot;Hello from &quot; + Environment.UserName + &quot;!\r\n&quot;;<br>File.AppendAllText (&quot;guestbook.txt&quot;, data);<br>
wc.UploadFile (&quot;guestbook.txt&quot;, &quot;guestbook.txt&quot;);<br>
This works with dialog-based authentication protocols, such as Basic and Digest,<br>and is extensible through the AuthenticationManager class. It also supports Windows<br>NTLM  and  Kerberos  (if  you  include  a  domain  name  when  constructing  the<br>NetworkCredential object). If you want to use the currently authenticated Windows<br>user, you can leave the Credentials property null and instead set UseDefaultCreden<br>tials true.<br>
Assigning  Credentials  is  useless  for  getting  through  forms-<br>based authentication. We discuss forms-based authentication<br>separately, in "HTTP-Specific Support" on page 592.<br>
<b>588 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=609></a>The  authentication  is  ultimately  handled  by  a  WebRequest  subtype  (in  this  case,<br>FtpWebRequest), which automatically negotiates a compatible protocol. In the case<br>of HTTP, there can be a choice: if you examine the initial response from a Microsoft<br>Exchange server web mail page, for instance, it might contain the following headers:<br>
HTTP/1.1 401 Unauthorized<br>Content-Length: 83<br>
Content-Type: text/html<br>Server: Microsoft-IIS/6.0<br>
WWW-Authenticate: Negotiate<br>
WWW-Authenticate: NTLM<br>
WWW-Authenticate: Basic realm=&quot;exchange.somedomain.com&quot;<br>
X-Powered-By: ASP.NET<br>Date: Sat, 05 Aug 2006 12:37:23 GMT<br>
The  401  code  signals  that  authorization  is  required;  the  "WWW-Authenticate"<br>headers indicate what authentication protocols are understood. If you configure a<br>WebClient or WebRequest object with the correct username and password, however,<br>this message will be hidden from you because the Framework responds automati-<br>cally by choosing a compatible authentication protocol, and then resubmitting the<br>original request with an extra header. For example:<br>
Authorization: Negotiate TlRMTVNTUAAABAAAt5II2gjACDArAAACAwACACgAAAAQ<br>
ATmKAAAAD0lVDRdPUksHUq9VUA==<br>
This mechanism provides transparency, but generates an extra round trip with each<br>request. You can avoid the extra round trips on subsequent requests to the same<br>URI by setting the PreAuthenticate property to true. This property is defined on the<br>WebRequest class (and works only in the case of HttpWebRequest). WebClient doesn't<br>support this feature at all.<br>
<b>CredentialCache<br></b>You can force a particular authentication protocol with a CredentialCache object. A<br>
<b>Networking</b><br>
credential cache contains one or more NetworkCredential objects, each keyed to a<br>particular protocol and URI prefix. For example, you might want to avoid the Basic<br>protocol when logging into an Exchange Server, as it transmits passwords in plain<br>text:<br>
CredentialCache cache = new CredentialCache();<br>Uri prefix = new Uri (&quot;http://exchange.somedomain.com&quot;);<br>cache.Add (prefix, &quot;Digest&quot;,  new NetworkCredential (&quot;joe&quot;, &quot;passwd&quot;));<br>cache.Add (prefix, &quot;Negotiate&quot;, new NetworkCredential (&quot;joe&quot;, &quot;passwd&quot;));<br>
WebClient wc = new WebClient();<br>wc.Credentials = cache;<br>...<br>
An authentication protocol is specified as a string. The valid values are as follows:<br>
Basic, Digest, NTLM, Kerberos, Negotiate<br>
In this particular example, WebClient will choose Negotiate, because the server didn't<br>indicate  that  it  supported  Digest  in  its  authentication  headers.  Negotiate  is  a<br>
<b>Request/Response Architecture | 589</b><br>
<hr>
<A name=610></a>Windows protocol that boils down to either Kerberos or NTLM, depending on the<br>capabilities of the server.<br>
The static CredentialCache.DefaultNetworkCredentials property allows you to add<br>the currently authenticated Windows user to the credential cache without having<br>to specify a password:<br>
cache.Add (prefix, &quot;Negotiate&quot;, CredentialCache.DefaultNetworkCredentials);<br>
<b>Concurrency<br></b>Because communicating across a network can be time-consuming, it makes sense<br>to run WebClient or WebRequest on a parallel execution path. This allows you to do<br>other things at the same time, and also maintain a responsive user interface. There<br>are a number of ways to achieve parallel execution:<br>
· Create a new thread.<br>· Use the Task Parallel Library's Task class.<br>· Use asynchronous delegates.<br>· Use BackgroundWorker.<br>
We describe each in Chapter 21. Creating a new thread is simplest, although you<br>must deal with exceptions explicitly on the worker thread:<br>
using System;<br>
using System.Net;<br>using System.Threading;<br>
class ThreadTest<br>
{<br>  static void Main()<br>  {<br>    new Thread (Download).Start();<br>    Console.WriteLine (&quot;I'm still here while the download's happening!&quot;);<br>    Console.ReadLine();<br>  }<br>
  static void Download()<br>  {<br>    WebClient wc = new WebClient();<br>    try<br>    {<br>      wc.Proxy = null;<br>      wc.DownloadFile (&quot;http://www.oreilly.com&quot;, &quot;oreilly.html&quot;);<br>      Console.WriteLine (&quot;Finished!&quot;);<br>    }<br>    catch (Exception ex)<br>    {<br>      // Process exception...<br>    }<br>  }<br>}<br>
<b>590 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=611></a>You  can  cancel  an  active  WebClient  operation  from  another  thread  by  calling<br>CancelAsync. (This works whether or not you used an "asynchronous" method to<br>initiate the download or upload.) You can cancel a WebRequest in a similar manner,<br>by calling its Abort method from another thread.<br>
Another way to achieve parallel execution is to call the asyn-<br>chronous event methods on WebClient (ending in "Asynch"),<br>such  as  DownloadFileAsynch.  In  theory,  these  methods  return<br>instantly, allowing the caller to do other things while they run.<br>Unfortunately, these methods are flawed--they block the caller<br>for a portion of the download or upload.<br>
The  asynchronous  <i>methods</i>  on  WebRequest  and  WebResponse<br>(starting in "Begin" and "End") should also be avoided if you're<br>simply after parallel execution--these methods serve a subtly<br>different purpose, described in Chapter 23.<br>
When a WebClient or WebRequest is canceled, a WebException is thrown on its thread.<br>The exception has a Status property of WebExceptionStatus.RequestCanceled. You<br>can catch and deal with this exception just as you would any other, such as an invalid<br>domain name.<br>
<b>Exception Handling<br></b>WebRequest, WebResponse, WebClient, and their streams all throw a WebException in<br>the case of a network or protocol error. You can determine the specific error via the<br>WebException's Status property; this returns a WebExceptionStatus enum that has the<br>following members:<br>
CacheEntryNotFound<br>
PipelineFailure<br>
SecureChannelFailure<br>
<b>Networking</b><br>
ConnectFailure<br>
ProtocolError<br>
SendFailure<br>
ConnectionClosed<br>
ProxyNameResolutionFailure<br>
ServerProtocolViolation<br>
KeepAliveFailure<br>
ReceiveFailure<br>
Success<br>
MessageLengthLimitExceeded<br>
RequestCanceled<br>
Timeout<br>
NameResolutionFailure<br>
RequestProhibitedByCachePolicy<br>
TrustFailure<br>
Pending<br>
RequestProhibitedByProxy<br>
UnknownError<br>
An invalid domain name causes a NameResolutionFailure; a dead network causes a<br>ConnectFailure;  a  request  exceeding  WebRequest.Timeout  milliseconds  causes  a<br>Timeout.<br>
Errors such as "Page not found," "Moved Permanently," and "Not Logged In" are<br>specific to the HTTP or FTP protocols, and so are all lumped together under the<br>ProtocolError status. To get a more specific code:<br>
1. Cast  the  WebException's  Response  property  to  HttpWebResponse  or<br>
FtpWebResponse.<br>
<b>Request/Response Architecture | 591</b><br>
<hr>
<A name=612></a>2. Examine  the  response  object's  Status  property  (an  HttpStatusCode  or<br>
FtpStatusCode enum) and/or its StatusDescription property (string).<br>
For example:<br>
WebClient wc = new WebClient();<br>
try<br>{<br>  wc.Proxy = null;<br>
  string s = wc.DownloadString (&quot;http://www.albahari.com/notthere&quot;);<br>
}<br>catch (WebException ex)<br>{<br>  if (ex.Status == WebExceptionStatus.NameResolutionFailure)<br>    Console.WriteLine (&quot;Bad domain name&quot;);<br>
  else if (ex.Status == WebExceptionStatus.ProtocolError)<br>  {<br>    HttpWebResponse response = (HttpWebResponse) ex.Response;<br>
    Console.WriteLine (response.StatusDescription);      // &quot;Not Found&quot;<br>
    if (response.StatusCode == HttpStatusCode.NotFound)<br>
      Console.WriteLine (&quot;Not there!&quot;);                  // &quot;Not there!&quot;<br>  }<br>
  else throw;<br>
}<br>
If  you  want  the  three-digit  status  code,  such  as  401  or  404,<br>simply  cast  the  HttpStatusCode or  FtpStatusCode enum to an<br>integer.<br>
By  default,  you'll  never  get  a  redirection  error  because<br>WebClient and WebRequest automatically follow redirection re-<br>sponses. You can switch off this behavior in a WebRequest object<br>by setting AllowAutoRedirect to false.<br>
The  redirection  errors  are  301  (Moved  Permanently),  302<br>(Found/Redirect), and 307 (Temporary Redirect).<br>
If  an  exception  is  thrown  because  you've  incorrectly  used  the  WebClient  or<br>WebRequest classes, it will more likely be an InvalidOperationException or Protocol<br>ViolationException than a WebException.<br>
<b>HTTP-Specific Support<br></b>This section describes HTTP-specific request and response features.<br>
<b>Headers<br></b>Both WebClient and WebRequest allow you to add custom HTTP headers, as well as<br>enumerate the headers in a response. A header is simply a key/value pair containing<br>metadata, such as the message content type or server software. Here's how to add<br>a custom header to a request, then list all headers in a response message:<br>
<b>592 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=613></a>WebClient wc = new WebClient();<br>
wc.Proxy = null;<br>wc.Headers.Add (&quot;CustomHeader&quot;, &quot;JustPlaying/1.0&quot;);<br>wc.DownloadString (&quot;http://www.oreilly.com&quot;);<br>
foreach (string name in wc.ResponseHeaders.Keys)<br>  Console.WriteLine (name + &quot;=&quot; + wc.ResponseHeaders [name]);<br>
<i>Age=51</i><br>
<i>X-Cache=HIT from oregano.bp<br>X-Cache-Lookup=HIT from oregano.bp:3128<br>Connection=keep-alive</i><br>
<i>Accept-Ranges=bytes</i><br>
<i>Content-Length=95433<br>Content-Type=text/html<br>...</i><br>
<b>Query Strings<br></b>A query string is simply a string appended to a URI with a question mark, used to<br>send simple data to the server. You can specify multiple key/value pairs in a query<br>string with the following syntax:<br>
<b>?</b>key1<b>=</b>value1<b>&amp;</b>key2<b>=</b>value2<b>&amp;</b>key3<b>=</b>value3...<br>
WebClient  provides  an  easy  way  to  add  query  strings  through  a  dictionary-style<br>property. The following searches Google for the word "WebClient", displaying the<br>result page in French:<br>
WebClient wc = new WebClient();<br>wc.Proxy = null;<br><b>wc.QueryString.Add (&quot;q&quot;, &quot;WebClient&quot;);</b>     // Search for &quot;WebClient&quot;<br><b>wc.QueryString.Add (&quot;hl&quot;, &quot;fr&quot;);</b>           // Display page in French<br>wc.DownloadFile (&quot;http://www.google.com/search&quot;, &quot;results.html&quot;);<br>System.Diagnostics.Process.Start (&quot;results.html&quot;);<br>
<b>Networking</b><br>
To achieve the same result with WebRequest, you must manually append a correctly<br>formatted string to the request URI:<br>
string requestURI = &quot;http://www.google.com/search<b>?q=WebClient&amp;hl=fr</b>&quot;;<br>
<b>Uploading Form Data<br></b>WebClient provides UploadValues methods for posting data to an HTML form. Here's<br>how to query the Safari website for books containing the term "WebClient":<br>
WebClient wc = new WebClient();<br>wc.Proxy = null;<br>
var data = new System.Collections.Specialized.NameValueCollection();<br>data.Add (&quot;searchtextbox&quot;, &quot;webclient&quot;);<br>data.Add (&quot;searchmode&quot;, &quot;simple&quot;);<br>
byte[] result = wc.UploadValues (&quot;http://my.safaribooksonline.com/search&quot;,<br>                                 &quot;POST&quot;, data);<br>
<b>HTTP-Specific Support | 593</b><br>
<hr>
<A name=614></a>System.IO.File.WriteAllBytes (&quot;SearchResults.html&quot;, result);<br>
System.Diagnostics.Process.Start (&quot;SearchResults.html&quot;);<br>
The keys in the NameValueCollection, such as searchtextbox and searchMode, corre-<br>spond to the names of input boxes on the HTML form.<br>
Uploading form data is more work via WebRequest. (You'll need to take this route if<br>you need to use features such as cookies.) Here's the procedure:<br>
1. Set the request's ContentType to "application/x-www-form-urlencoded" and its<br>
Method to "POST".<br>
2. Build a string containing the data to upload, encoded as follows:<br>
name1=value1&amp;name2=value2&amp;name3=value3...<br>
3. Convert the string to a byte array, with Encoding.UTF8.GetBytes.<br>4. Set the web request's ContentLength property to the byte array length.<br>5. Call GetRequestStream on the web request and write the data array.<br>6. Call GetResponse to read the server's response.<br>
Here's the previous example written with WebRequest:<br>
WebRequest req = WebRequest.Create (&quot;http://safari.oreilly.com/search&quot;);<br>
req.Proxy = null;<br>
req.Method = &quot;POST&quot;;<br>
req.ContentType = &quot;application/x-www-form-urlencoded&quot;;<br>
string reqString = &quot;searchtextbox=webclient&amp;searchmode=simple&quot;;<br>byte[] reqData = Encoding.UTF8.GetBytes (reqString);<br>
req.ContentLength = reqData.Length;<br>
using (Stream reqStream = req.GetRequestStream())<br>  reqStream.Write (reqData, 0, reqData.Length);<br>
using (WebResponse res = req.GetResponse())<br>using (Stream resSteam = res.GetResponseStream())<br>using (StreamReader sr = new StreamReader (resSteam))<br>  File.WriteAllText (&quot;SearchResults.html&quot;, sr.ReadToEnd());<br>
System.Diagnostics.Process.Start (&quot;SearchResults.html&quot;);<br>
<b>Cookies<br></b>A  cookie  is  a  name/value  string  pair  that  an  HTTP  server  sends  to  a  client  in  a<br>response header. A web browser client typically remembers cookies, and replays<br>them to the server in each subsequent request (to the same address) until their expiry.<br>A cookie allows a server to know whether it's talking to the same client it was a<br>minute ago--or yesterday--without needing a messy query string in the URI.<br>
By default, HttpWebRequest ignores any cookies received from the server. To accept<br>cookies, create a CookieContainer object and assign it to the WebRequest. The cookies<br>received in a response can then be enumerated:<br>
<b>594 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=615></a>var cc = new CookieContainer();<br>
var request = (HttpWebRequest) WebRequest.Create (&quot;http://www.google.com&quot;);<br>request.Proxy = null;<br>
request.CookieContainer = cc;<br>
using (var response = (HttpWebResponse) request.GetResponse())<br>{<br>  foreach (Cookie c in response.Cookies)<br>
  {<br>
    Console.WriteLine (&quot; Name:   &quot; + c.Name);<br>    Console.WriteLine (&quot; Value:  &quot; + c.Value);<br>    Console.WriteLine (&quot; Path:   &quot; + c.Path);<br>
    Console.WriteLine (&quot; Domain: &quot; + c.Domain);<br>
  }<br>  // Read response stream...<br>}<br>
 Name:   PREF<br>
 Value:  ID=6b10df1da493a9c4:TM=1179025486:LM=1179025486:S=EJCZri0aWEHlk4tt<br> Path:   /<br>
 Domain: .google.com<br>
The WebClient façade class does not provide direct support for<br>cookies.<br>
To replay the received cookies in future requests, simply assign the same CookieCon<br>tainer object to each new WebRequest object. (CookieContainer is serializable, so it<br>can be written to disk--see Chapter 16.) Alternatively, you can start with a fresh<br>CookieContainer, and then add cookies manually as follows:<br>
Cookie c = new Cookie (&quot;PREF&quot;,<br>
<b>Networking</b><br>
                       &quot;ID=6b10df1da493a9c4:TM=1179...&quot;,<br>                       &quot;/&quot;,<br>
                       &quot;.google.com&quot;);<br>freshCookieContainer.Add (c);<br>
The third and fourth arguments indicate the path and domain of the originator.<br>A  CookieContainer  on  the  client  can  house  cookies  from  many  different  places;<br>WebRequest sends only those cookies whose path and domain match those of the<br>server.<br>
<b>Forms Authentication<br></b>We saw in the previous section how a NetworkCredentials object can satisfy au-<br>thentication systems such as Basic or NTLM (that pop up a dialog in a web browser).<br>Most  websites  requiring  authentication,  however,  use  some  type  of  forms-based<br>approach. Enter your username and password into text boxes that are part of an<br>HTML form decorated in appropriate corporate graphics, press a button to post the<br>data, and then receive a cookie upon successful authentication. The cookie allows<br>
<b>HTTP-Specific Support | 595</b><br>
<hr>
<A name=616></a>you greater privileges in browsing pages in the website. With WebRequest, you can<br>do all this with the features discussed in the preceding two sections.<br>
A typical website that implements forms authentication will contain HTML like this:<br>
&lt;form action=&quot;http://<i>www.somesite.com/login</i>&quot; method=&quot;post&quot;&gt;<br>
  &lt;input type=&quot;text&quot; id=&quot;user&quot; <b>name=&quot;username&quot;</b>&gt;<br>  &lt;input type=&quot;password&quot; id=&quot;pass&quot; <b>name=&quot;password&quot;</b>&gt;<br>
  &lt;button type=&quot;submit&quot; id=&quot;login-btn&quot;&gt;Log In&lt;/button&gt;<br>
&lt;/form&gt;<br>
Here's how to log into such a site:<br>
string loginUri = &quot;http://<i>www.somesite.com/login</i>&quot;;<br>
string username = &quot;<i>username</i>&quot;;<br>
string password = &quot;<i>password</i>&quot;;<br>string reqString = &quot;username=&quot; + username + &quot;&amp;password=&quot; + password;<br>
byte[] requestData = Encoding.UTF8.GetBytes (reqString);<br>
CookieContainer cc = new CookieContainer();<br>var request = (HttpWebRequest)WebRequest.Create (loginUri);<br>request.Proxy = null;<br>
request.CookieContainer = cc;<br>
request.Method = &quot;POST&quot;;<br>
request.ContentType = &quot;application/x-www-form-urlencoded&quot;;<br>
request.ContentLength = requestData.Length;<br>
using (Stream s = request.GetRequestStream())<br>
  s.Write (requestData, 0, requestData.Length);<br>
using (var response = (HttpWebResponse) request.GetResponse())<br>  foreach (Cookie c in response.Cookies)<br>
    Console.WriteLine (c.Name + &quot; = &quot; + c.Value);<br>
// We're now logged in. As long as we assign <b>cc</b> to subsequent WebRequest<br>// objects, we'll be treated as an authenticated user.<br>
<b>SSL<br></b>Both WebClient and WebRequest use SSL automatically when you specify an "https:"<br>prefix. The only complication that can arise relates to bad X.509 certificates. If the<br>server's site certificate is invalid in any way (for instance, if it's a test certificate), an<br>exception is thrown when you attempt to communicate. To work around this, you<br>can attach a custom certificate validator to the static ServicePointManager class:<br>
using System.Net;<br>using System.Net.Security;<br>using System.Security.Cryptography.X509Certificates;<br>...<br>static void ConfigureSSL()<br>{<br>  <b>ServicePointManager.ServerCertificateValidationCallback = CertChecker;<br></b>}<br>
ServerCertificateValidationCallback is a delegate. If it returns true, the certificate<br>is accepted:<br>
<b>596 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=617></a>static bool CertChecker (object sender, X509Certificate certificate,<br>
                         X509Chain chain, SslPolicyErrors errors)<br>{<br>  // Return true if you're happy with the certificate<br>
  ...<br>
}<br>
<b>Writing an HTTP Server<br></b>You can write your own HTTP server with the HttpListener class. The following is<br>a simple server that listens on port 51111, waits for a single client request, and then<br>returns a one-line reply.<br>
HttpListener does not work on operating systems prior to Win-<br>dows XP.<br>
static void Main()<br>
{<br>  new System.Threading.Thread (Listen).Start(); // Run server in parallel.<br>
  Thread.Sleep (500);                           // Wait half a second.<br>
  WebClient wc = new WebClient();               // Make a client request.<br>
  Console.WriteLine (wc.DownloadString<br>    (&quot;http://localhost:51111/MyApp/Request.txt&quot;));<br>
}<br>
static void Listen()<br>
{<br>  HttpListener listener = new HttpListener();<br>  listener.Prefixes.Add (&quot;http://localhost:51111/MyApp/&quot;);  // Listen on<br>  listener.Start();                                         // port 51111.<br>
<b>Networking</b><br>
  // Wait for a client request:<br>  HttpListenerContext context = listener.GetContext();<br>
  // Respond to the request:<br>  string msg = &quot;You asked for: &quot; + context.Request.RawUrl;<br>
  context.Response.ContentLength64 = Encoding.UTF8.GetByteCount (msg);<br>  context.Response.StatusCode = (int) HttpStatusCode.OK;<br>
  using (Stream s = context.Response.OutputStream)<br>  using (StreamWriter writer = new StreamWriter (s))<br>    writer.Write (msg);<br>
  listener.Stop();<br>}<br>
OUTPUT: You asked for: /MyApp/Request.txt<br>
<b>Writing an HTTP Server | 597</b><br>
<hr>
<A name=618></a>In this example, we sleep for 500 ms to give the server time to<br>start before connecting to it. A better solution would be for the<br>server to signal that it's ready with an EventWaitHandle (descri-<br>bed in Chapter 21). An example of when you might consider<br>doing this in real life is if writing a unit testing framework for<br>your HTTP server.<br>
HttpListener does not internally use .NET Socket objects; it instead calls the Win-<br>dows HTTP Server API. This is supported on Windows XP and above and allows<br>many applications on a computer to listen on the same IP address and port--as long<br>as each registers different address prefixes. In our example, we registered the prefix<br><i>http://localhost/myapp</i>, so another application would be free to listen on the same<br>IP and port on another prefix such as <i>http://localhost/anotherapp</i>. This is of value<br>because opening new ports on corporate firewalls can be politically arduous.<br>
HttpListener waits for the next client request when you call GetContext, returning<br>an object with Request and Response properties. Each is analogous to a WebRequest<br>and WebResponse object, but from the server's perspective. You can read and write<br>headers and cookies, for instance, to the request and response objects, much as you<br>would at the client end.<br>
You can choose how fully to support features of the HTTP protocol, based on your<br>anticipated client audience. At a bare minimum, you should set the content length<br>and status code on each request.<br>
Here's a very simple web page server that handles up to 50 concurrent requests:<br>
using System;<br>using System.IO;<br>using System.Net;<br>using System.Text;<br>using System.Threading;<br>
class WebServer<br>{<br>  HttpListener _listener;<br>  string _baseFolder;      // Your web page folder.<br>
  public WebServer (string uriPrefix, string baseFolder)<br>  {<br>    System.Threading.ThreadPool.SetMaxThreads (50, 1000);<br>    System.Threading.ThreadPool.SetMinThreads (50, 50);<br>    _listener = new HttpListener();<br>    _listener.Prefixes.Add (uriPrefix);<br>    _baseFolder = baseFolder;<br>  }<br>
  public void Start()          // Run this on a separate thread, as<br>  {                            // we did before.<br>    _listener.Start();<br>    while (true)<br>      try<br>
      {<br>
<b>598 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=619></a>        HttpListenerContext request = _listener.GetContext();<br>
        ThreadPool.QueueUserWorkItem (ProcessRequest, request);<br>      }<br>      catch (HttpListenerException)     { break; }   // Listener stopped.<br>
      catch (InvalidOperationException) { break; }   // Listener stopped.<br>
  }<br>
  public void Stop() { _listener.Stop(); }<br>
  void ProcessRequest (object listenerContext)<br>  {<br>    try<br>
    {<br>
      var context = (HttpListenerContext) listenerContext;<br>      string filename = Path.GetFileName (context.Request.RawUrl);<br>      string path = Path.Combine (_baseFolder, filename);<br>
      byte[] msg;<br>
      if (!File.Exists (path))<br>      {<br>        context.Response.StatusCode = (int) HttpStatusCode.NotFound;<br>
        msg = Encoding.UTF8.GetBytes (&quot;Sorry, that page does not exist&quot;);<br>
      }<br>      else<br>      {<br>
        context.Response.StatusCode = (int) HttpStatusCode.OK;<br>
        msg = File.ReadAllBytes (path);<br>      }<br>      context.Response.ContentLength64 = msg.Length;<br>      using (Stream s = context.Response.OutputStream)<br>        s.Write (msg, 0, msg.Length);<br>    }<br>    catch (Exception ex) { Console.WriteLine (&quot;Request error: &quot; + ex); }<br>  }<br>}<br>
<b>Networking</b><br>
Here's a main method to set things in motion:<br>
static void Main()<br>{<br>  // Listen on the default port (80), serving files in e:\mydocs\webroot:<br>  var server = new WebServer (&quot;http://localhost/&quot;, @&quot;e:\mydocs\webroot&quot;);<br>
  // Start the server on a parallel thread:<br>  new System.Threading.Thread (server.Start).Start();<br>
  Console.WriteLine (&quot;Server running... press Enter to stop&quot;);<br>
  Console.ReadLine();<br>  server.Stop();<br>}<br>
You can test this at the client end with any web browser; the URI in this case will<br>be <i>http://localhost/</i> plus the name of the web page.<br>
Calling SetMinThreads instructs the thread pool not to delay the allocation of threads<br>in an attempt to save memory. This results in a responsive and performant server,<br>up to its limit of 50 requests. If you want to go higher, you can--much higher, and<br>
<b>Writing an HTTP Server | 599</b><br>
<hr>
<A name=620></a>without needing more threads--by following the asynchronous method pattern.<br>This means calling BeginRead and BeginWrite on the request and response streams,<br>each time exiting with a callback (bringing the investment in programming time<br>almost on par with configuring IIS!). We describe this in detail in Chapter 23.<br>
HttpListener will not start if other software is competing for the<br>same port (unless that software also uses the Windows HTTP<br>Server API). Examples of applications that might listen on port<br>80 include a web server or a peer-to-peer program such as Skype.<br>
<b>Using FTP<br></b>For simple FTP upload and download operations, you can use WebClient as we did<br>previously:<br>
WebClient wc = new WebClient();<br>
wc.Proxy = null;<br>
wc.Credentials = new NetworkCredential (&quot;nutshell&quot;, &quot;oreilly&quot;);<br>
wc.BaseAddress = &quot;ftp://ftp.albahari.com&quot;;<br>
wc.UploadString (&quot;tempfile.txt&quot;, &quot;hello!&quot;);<br>Console.WriteLine (wc.DownloadString (&quot;tempfile.txt&quot;));   // hello!<br>
There's  more  to  FTP,  however,  than  just  uploading  and  downloading  files.  The<br>protocol also lists a set of commands or "methods," defined as string constants in<br>WebRequestMethods.Ftp:<br>
AppendFile<br>
ListDirectory<br>
Rename<br>
DeleteFile<br>
ListDirectoryDetails<br>
UploadFile<br>
DownloadFile<br>
MakeDirectory<br>
UploadFileWithUniqueName<br>
GetDateTimestamp<br>
PrintWorkingDirectory<br>
GetFileSize<br>
RemoveDirectory<br>
To run one of these commands, you assign its string constant to the web request's<br>Method property, and then call GetResponse(). Here's how to get a directory listing:<br>
var req = (FtpWebRequest) WebRequest.Create (&quot;ftp://ftp.albahari.com&quot;);<br>req.Proxy = null;<br>req.Credentials = new NetworkCredential (&quot;nutshell&quot;, &quot;oreilly&quot;);<br><b>req.Method = WebRequestMethods.Ftp.ListDirectory;</b><br>
using (WebResponse resp = req.GetResponse())<br>using (StreamReader reader = new StreamReader (resp.GetResponseStream()))<br>  Console.WriteLine (reader.ReadToEnd());<br>
RESULT:<br>.<br>..<br>guestbook.txt<br>tempfile.txt<br>test.doc<br>
<b>600 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=621></a>In the case of getting a directory listing, we needed to read the response stream<br>to get the result. Most other commands, however, don't require this step. For in-<br>stance,  to  get  the  result  of  the  GetFileSize  command,  just  query  the  response's<br>ContentLength property:<br>
var req = (FtpWebRequest) WebRequest.Create (<br>                          &quot;ftp://ftp.albahari.com/tempfile.txt&quot;);<br>
req.Proxy = null;<br>req.Credentials = new NetworkCredential (&quot;nutshell&quot;, &quot;oreilly&quot;);<br>
req.Method = WebRequestMethods.Ftp.<b>GetFileSize</b>;<br>
using (WebResponse resp = req.GetResponse())<br>
  Console.WriteLine (resp.<b>ContentLength</b>);            // 6<br>
The GetDateTimestamp command works in a similar way, except that you query the<br>response's LastModified property. This requires that you cast to FtpWebResponse:<br>
...<br>
req.Method = WebRequestMethods.Ftp<b>.GetDateTimestamp</b>;<br>
using (var resp = (FtpWebResponse) req.GetResponse() )<br>
  Console.WriteLine (resp.LastModified);<br>
To use the Rename command, you must populate the request's RenameTo property<br>with the new filename (without a directory prefix). For example, to rename a file in<br>the <i>incoming</i> directory from <i>tempfile.txt</i> to <i>deleteme.txt</i>:<br>
var req = (FtpWebRequest) WebRequest.Create (<br>                          &quot;ftp://ftp.albahari.com/tempfile.txt&quot;);<br>req.Proxy = null;<br>req.Credentials = new NetworkCredential (&quot;nutshell&quot;, &quot;oreilly&quot;);<br>
req.Method = WebRequestMethods.Ftp.<b>Rename</b>;<br><b>req.RenameTo = &quot;deleteme.txt&quot;;</b><br>
<b>Networking</b><br>
req.GetResponse().Close();        // Perform the rename<br>
Here's how to delete a file:<br>
var req = (FtpWebRequest) WebRequest.Create (<br>                          &quot;ftp://ftp.albahari.com/deleteme.txt&quot;);<br>req.Proxy = null;<br>req.Credentials = new NetworkCredential (&quot;nutshell&quot;, &quot;oreilly&quot;);<br>
req.Method = WebRequestMethods.Ftp.<b>DeleteFile</b>;<br>
req.GetResponse().Close();        // Perform the deletion<br>
<b>Using FTP | 601</b><br>
<hr>
<A name=622></a>In  all  these  examples,  you  would  typically  use  an  exception<br>handling block to catch network and protocol errors. A typical<br>catch block looks like this:<br>
catch (WebException ex)<br>{<br>   if (ex.Status == WebExceptionStatus.ProtocolError)<br>
   {<br>
     // Obtain more detail on error:<br>     var response = (FtpWebResponse) ex.Response;<br>
     FtpStatusCode errorCode = response.StatusCode;<br>     string errorMessage = response.StatusDescription;<br>     ...<br>
   }<br>   ...<br> }<br>
<b>Using DNS<br></b>The static Dns class encapsulates the Domain Name Service, which converts between<br>a raw IP address, such as 66.135.192.87, and a human-friendly domain name, such<br>as <i>ebay.com</i>.<br>
The  GetHostAddresses  method  converts  from  domain  name  to  IP  address  (or<br>addresses):<br>
foreach (IPAddress a in Dns.GetHostAddresses (&quot;albahari.com&quot;))<br>
  Console.WriteLine (a.ToString());     // 208.43.7.176<br>
The GetHostEntry method goes the other way around, converting from address to<br>domain name:<br>
IPHostEntry entry = Dns.GetHostEntry (&quot;208.43.7.176&quot;);<br>Console.WriteLine (entry.HostName);                    // si-eios.com<br>
GetHostEntry also accepts an IPAddress object, so you can specify an IP address as a<br>byte array:<br>
IPAddress address = new IPAddress (new byte[] { 208, 43, 7, 176 });<br>IPHostEntry entry = Dns.GetHostEntry (address);<br>Console.WriteLine (entry.HostName);                    // si-eios.com<br>
Domain names are automatically resolved to IP addresses when you use a class such<br>as WebRequest or TcpClient. If you plan to make many network requests to the same<br>address over the life of an application, however, you can sometimes improve per-<br>formance by first using Dns to explicitly convert the domain name into an IP address,<br>and then communicating directly with the IP address from that point on. This avoids<br>repeated round-tripping to resolve the same domain name, and it can be of benefit<br>when dealing at the transport layer (via TcpClient, UdpClient, or Socket).<br>The DNS class also provides asynchronous methods for high-concurrency applica-<br>tions (see Chapter 23).<br>
<b>602 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=623></a><b>Sending Mail with SmtpClient<br></b>The SmtpClient class in the System.Net.Mail namespace allows you to send mail<br>messages through the ubiquitous Simple Mail Transfer Protocol. To send a simple<br>text message, instantiate SmtpClient, set its Host property to your SMTP server ad-<br>dress, and then call Send:<br>
SmtpClient client = new SmtpClient();<br>
client.Host = &quot;mail.myisp.net&quot;;<br>
client.Send (&quot;from@adomain.com&quot;, &quot;to@adomain.com&quot;, &quot;subject&quot;, &quot;body&quot;);<br>
To frustrate spammers, most SMTP servers on the Internet will accept connections<br>only from the ISP's subscribers, so you need the SMTP address appropriate to the<br>current connection for this to work.<br>
Constructing a MailMessage object exposes further options, including the ability to<br>add attachments:<br>
SmtpClient client = new SmtpClient();<br>client.Host = &quot;mail.myisp.net&quot;;<br>
MailMessage mm = new MailMessage();<br>
mm.Sender = new MailAddress (&quot;kay@domain.com&quot;, &quot;Kay&quot;);<br>mm.From   = new MailAddress (&quot;kay@domain.com&quot;, &quot;Kay&quot;);<br>
mm.To.Add  (new MailAddress (&quot;bob@domain.com&quot;, &quot;Bob&quot;));<br>
mm.CC.Add  (new MailAddress (&quot;dan@domain.com&quot;, &quot;Dan&quot;));<br>
mm.Subject = &quot;Hello!&quot;;<br>mm.Body = &quot;Hi there. Here's the photo!&quot;;<br>
mm.IsBodyHtml = false;<br>mm.Priority = MailPriority.High;<br>
Attachment a = new Attachment (&quot;photo.jpg&quot;,<br>                               System.Net.Mime.MediaTypeNames.Image.Jpeg);<br>mm.Attachments.Add (a);<br>
<b>Networking</b><br>
client.Send (mm);<br>
SmtpClient allows you to specify Credentials for servers requiring authentication,<br>EnableSsl if supported, and change the TCP Port to a nondefault value. By changing<br>the DeliveryMethod property, you can instruct the SmtpClient to instead use IIS to<br>send mail messages or simply to write each message to an <i>.eml</i> file in a specified<br>directory:<br>
SmtpClient client = new SmtpClient();<br>client.DeliveryMethod = SmtpDeliveryMethod.SpecifiedPickupDirectory;<br>client.PickupDirectoryLocation = @&quot;c:\mail&quot;;<br>
<b>Sending Mail with SmtpClient | 603</b><br>
<hr>
<A name=624></a><b>Using TCP<br></b>TCP  and  UDP  constitute  the  transport  layer  protocols  on  top  of  which  most<br>Internet--and local area network--services are built. HTTP, FTP, and SMTP use<br>TCP; DNS uses UDP. TCP is connection-oriented and includes reliability mecha-<br>nisms; UDP is connectionless, has a lower overhead, and supports broadcasting.<br><i>BitTorrent</i> uses UDP, as does Voice over IP.<br>
The  transport  layer  offers  greater  flexibility--and  potentially  improved<br>performance--over the higher layers, but it requires that you handle such tasks as<br>authentication and encryption yourself.<br>
The good news with the TCP and UDP classes is that you don't<br>have to worry about setting Proxy to null. The bad news is that<br>if your only access to the Internet is through a web proxy, you<br>can forget about working directly at the TCP or UDP layer!<br>
With  TCP,  you  have  a  choice  of  either  the  easier-to-use  TcpClient  and<br>TcpListener façade classes, or the feature-rich Socket class. (In fact, you can mix and<br>match,  because  TcpClient  exposes  the  underlying  Socket  object  through  the<br>Client property.) The Socket class exposes more configuration options and allows<br>direct access to the network layer (IP) and non-Internet-based protocols such as<br>Novell's SPX/IPX.<br>
As with other protocols, TCP differentiates a client and server: the client initiates a<br>request, while the server waits for a request. Here's the basic structure for a TCP<br>client request:<br>
using (TcpClient client = new TcpClient (&quot;address&quot;, port))<br>using (NetworkStream n = client.GetStream())<br>
{<br>  // Read and write to the network stream...<br>}<br>
TcpClient immediately establishes a connection upon construction to a server at the<br>given IP or domain name address and port. The constructor blocks until a connec-<br>tion is established. The NetworkStream then provides a means of two-way commu-<br>nication, for both transmitting and receiving bytes of data from a server.<br>
A simple TCP server looks like this:<br>
TcpListener listener = new TcpListener (<i>&lt;ip address&gt;</i>, port);<br>listener.Start();<br>
while (<i>keepProcessingRequests</i>)<br>  using (TcpClient c = listener.AcceptTcpClient())<br>  using (NetworkStream n = c.GetStream())<br>  {<br>    // Read and write to the network stream...<br>  }<br>
listener.Stop();<br>
<b>604 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=625></a>TcpListener requires the local IP address on which to listen (a computer with two<br>network cards, for instance, may have two addresses). You can use IPAddress.Any<br>to tell it to listen on all (or the only) local IP addresses. AcceptTcpClient blocks until<br>a client request is received, at which point we call GetStream, just as on the client side.<br>When working at the transport layer, you need to decide on a protocol for who talks<br>when, and for how long--rather like with a walkie-talkie. If both parties talk or listen<br>at the same time, communication breaks down!<br>
Let's invent a protocol where the client speaks first, saying "Hello," and then the<br>server responds by saying "Hello right back!" Here's the code:<br>
using System;<br>
using System.IO;<br>using System.Net;<br>
using System.Net.Sockets;<br>
using System.Threading;<br>
class TcpDemo<br>
{<br>  static void Main()<br>
  {<br>
    new Thread (Server).Start();       // Run server method concurrently.<br>
    Thread.Sleep (500);                // Give server time to start.<br>    Client();<br>  }<br>
  static void Client()<br>
  {<br>    using (TcpClient client = new TcpClient (&quot;localhost&quot;, 51111))<br>
    using (NetworkStream n = client.GetStream())<br>    {<br>      BinaryWriter w = new BinaryWriter (n);<br>      w.Write (&quot;Hello&quot;);<br>
<b>Networking</b><br>
      w.Flush();<br>      Console.WriteLine (new BinaryReader (n).ReadString());<br>    }<br>  }<br>
  static void Server()     // Handles a single client request, then exits.<br>  {<br>    TcpListener listener = new TcpListener (IPAddress.Any, 51111);<br>    listener.Start();<br>    using (TcpClient c = listener.AcceptTcpClient())<br>    using (NetworkStream n = c.GetStream())<br>    {<br>      string msg = new BinaryReader (n).ReadString();<br>      BinaryWriter w = new BinaryWriter (n);<br>      w.Write (msg + &quot; right back!&quot;);<br>      w.Flush();                      // Must call Flush because we're not<br>    }                                 // disposing the writer.<br>    listener.Stop();<br>  }<br>}<br>
<b>Using TCP | 605</b><br>
<hr>
<A name=626></a>Hello<br>
Hello right back!<br>
In this example, we're using the localhost loopback to run the client and server on<br>the same machine. We've arbitrarily chosen a port in the unallocated range (above<br>49152)  and  used  a  BinaryWriter  and  BinaryReader  to  encode  the  text  messages.<br>We've avoided closing or disposing the readers and writers in order to keep the<br>underlying NetworkStream open until our conversation completes.<br>
BinaryReader and BinaryWriter might seem like odd choices for reading and writing<br>strings.  However,  they  have  a  major  advantage  over  StreamReader  and  Stream<br>Writer: they prefix strings with an integer indicating the length, so a BinaryReader<br>always knows exactly how many bytes to read. If you call StreamReader.ReadToEnd<br>you might block indefinitely--because a NetworkStream doesn't have an end! As long<br>as the connection is open, the network stream can never be sure that the client isn't<br>going to send more data.<br>
StreamReader  is  in  fact  completely  out  of  bounds  with<br>NetworkStream, even if you plan only to call ReadLine. This is<br>because StreamReader has a read-ahead buffer, which can result<br>in it reading more bytes than are currently available, blocking<br>indefinitely (or until the socket times out). Other streams such<br>as  FileStream  don't  suffer  this  incompatibility  with<br>StreamReader because they have a definite <i>end</i>--at which point<br>Read returns immediately with a value of 0.<br>
<b>Concurrency<br></b>You'll often want to do other things at the same time as reading or writing a TCP<br>stream. If you need to manage just a few concurrent activities, any multithreading<br>option described in Chapters 21 and 22 is viable: a new thread, a TPL Task, asyn-<br>chronous  delegates,  ThreadPool.QueueUserWorkItem  or  BackgroundWorker.  On  a<br>highly concurrent server, however, you need to be choosier. As a simple rule of<br>thumb:<br>
· For less than 50 concurrent connections, think <i>simplicity</i> and use the Task Par-<br>
allel Library or ThreadPool.QueueUserWorkItem.<br>
· For  more  than  50  concurrent  connections,  think  <i>efficiency</i>  and  go  for  asyn-<br>
chronous methods.<br>
Chapter 23 describes how to write a TCP server using each of these models.<br>
<b>Receiving POP3 Mail with TCP<br></b>The .NET Framework provides no application-layer support for POP3, so you have<br>to write at the TCP layer in order to receive mail from a POP3 server. Fortunately,<br>this is a simple protocol; a POP3 conversation goes like this:<br>
<b>606 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=627></a><b>Client</b><br>
<b>Mail server</b><br>
<b>Notes</b><br>
Client connects...<br>
+OK Hello there.<br>
Welcome message<br>
USER joe<br>
+OK Password required.<br>
 <br>
PASS password<br>
+OK Logged in.<br>
 <br>
LIST<br>
+OK<br>
Lists the ID and file size of each message on the server<br>
1 1876<br>
2 5412<br>
3 845<br>
.<br>
RETR 1<br>
+OK 1876 octets<br>
Retrieves the message with the specified ID<br>
Content of message #1...<br>
.<br>
DELE 1<br>
+OK Deleted.<br>
Deletes a message from the server<br>
QUIT<br>
+OK Bye-bye.<br>
 <br>
Each command and response is terminated by a new line (CR + LF) except for the<br>multiline LIST and RETR commands, which are terminated by a single dot on a<br>separate line. Because we can't use StreamReader with NetworkStream, we can start<br>by writing a helper method to read a line of text in a nonbuffered fashion:<br>
static string ReadLine (Stream s)<br>
{<br>  List&lt;byte&gt; lineBuffer = new List&lt;byte&gt;();<br>
  while (true)<br>  {<br>    int b = s.ReadByte();<br>    if (b == 10 || b &lt; 0) break;<br>
<b>Networking</b><br>
    if (b != 13) lineBuffer.Add ((byte)b);<br>  }<br>  return Encoding.UTF8.GetString (lineBuffer.ToArray());<br>}<br>
We also need a helper method to send a command. Because we always expect to<br>receive a response starting with "+OK," we can read and validate the response at<br>the same time:<br>
static void SendCommand (Stream stream, string line)<br>{<br>  byte[] data = Encoding.UTF8.GetBytes (line + &quot;\r\n&quot;);<br>  stream.Write (data, 0, data.Length);<br>  string response = ReadLine (stream);<br>  if (!response.StartsWith (&quot;+OK&quot;))<br>    throw new Exception (&quot;POP Error: &quot; + response);<br>}<br>
With these methods written, the job of retrieving mail is easy. We establish a TCP<br>connection on port 110 (the default POP3 port), and then start talking to the server.<br>
<b>Receiving POP3 Mail with TCP | 607</b><br>
<hr>
<A name=628></a>In  this  example,  we  write  each  mail  message  to  a  randomly  named  file  with<br>an <i>.eml</i> extension, before deleting the message off the server:<br>
using (TcpClient client = new TcpClient (&quot;<i>mail.isp.com</i>&quot;, 110))<br>using (NetworkStream n = client.GetStream())<br>
{<br>  ReadLine (n);                             // Read the welcome message.<br>  SendCommand (n, &quot;USER username&quot;);<br>  SendCommand (n, &quot;PASS password&quot;);<br>
  SendCommand (n, &quot;LIST&quot;);                  // Retrieve message IDs<br>
  List&lt;int&gt; messageIDs = new List&lt;int&gt;();<br>  while (true)<br>  {<br>
    string line = ReadLine (n);             // e.g.,  &quot;1 1876&quot;<br>
    if (line == &quot;.&quot;) break;<br>    messageIDs.Add (int.Parse (line.Split (' ')[0] ));   // Message ID<br>  }<br>
  foreach (int id in messageIDs)         // Retrieve each message.<br>
  {<br>    SendCommand (n, &quot;RETR &quot; + id);<br>
    string randomFile = Guid.NewGuid().ToString() + &quot;.eml&quot;;<br>    using (StreamWriter writer = File.CreateText (randomFile))<br>
      while (true)<br>      {<br>
        string line = ReadLine (n);      // Read next line of message.<br>        if (line == &quot;.&quot;) break;          // Single dot = end of message.<br>
        if (line == &quot;..&quot;) line = &quot;.&quot;;    // &quot;Escape out&quot; double dot.<br>        writer.WriteLine (line);         // Write to output file.<br>
      }<br>    SendCommand (n, &quot;DELE &quot; + id);       // Delete message off server.<br>
  }<br>  SendCommand (n, &quot;QUIT&quot;);<br>}<br>
<b>608 | Chapter 15:</b><b>Networking</b><br>
<hr>
<A name=629></a><b>16</b><br>
<b>Serialization</b><br>
This chapter introduces serialization and deserialization, the mechanism by which<br>objects can be represented in a flat text or binary form. Unless otherwise stated, the<br>types in this chapter all exist in the following namespaces:<br>
System.Runtime.Serialization<br>
System.Xml.Serialization<br>
<b>Serialization Concepts<br></b><i>Serialization</i> is the act of taking an in-memory object or <i>object graph</i> (set of objects<br>that reference each other) and flattening it into a stream of bytes or XML nodes that<br>can be stored or transmitted. <i>Deserialization</i> works in reverse, taking a data stream<br>and reconstituting it into an in-memory object or object graph.<br>
Serialization and deserialization are typically used to:<br>
· Transmit objects across a network or application boundary.<br>· Store representations of objects within a file or database.<br>
Another, less common use is to deep-clone objects. The data contract and XML<br>serialization engines can also be used as general-purpose tools for loading and saving<br>XML files of a known structure.<br>
The  .NET  Framework  supports  serialization  and  deserialization  both  from  the<br>perspective of clients wanting to serialize and deserialize objects, and from the per-<br>spective of types wanting some control over how they are serialized.<br>
<b>609</b><br>
<hr>
<A name=630></a><b>Serialization Engines<br></b>There are four serialization mechanisms in the .NET Framework:<br>
· The data contract serializer<br>· The binary serializer<br>· The (attribute-based) XML serializer (XmlSerializer)<br>· The IXmlSerializable interface<br>
Of these, the first three are serialization "engines" that do most or all of the seriali-<br>zation work for you. The last is just a hook for doing the serialization yourself, using<br>XmlReader and XmlWriter. IXmlSerializable can work in conjunction with the data<br>contract serializer or XmlSerializer, to handle the more complicated XML seriali-<br>zation tasks.<br>
Table 16-1 compares each of the engines.<br>
<i>Table 16-1. Serialization engine comparison</i><br>
<b>Data contract</b><br>
<b>Binary</b><br>
<b>Feature</b><br>
<b>serializer</b><br>
<b>serializer</b><br>
<b>XmlSerializer</b><br>
<b>IXmlSerializable</b><br>
Level of automation<br>
***<br>
*****<br>
****<br>
*<br>
Type coupling<br>
Choice<br>
Tight<br>
Loose<br>
Loose<br>
Version tolerance<br>
*****<br>
***<br>
*****<br>
*****<br>
Preserves object references<br>
Choice<br>
Yes<br>
No<br>
Choice<br>
Can serialize nonpublic fields<br>
Yes<br>
Yes<br>
No<br>
Yes<br>
Suitability for interoperable messaging<br>
*****<br>
**<br>
****<br>
****<br>
Flexibility in reading/writing XML files<br>
**<br>
-<br>
****<br>
*****<br>
Compact output<br>
**<br>
****<br>
**<br>
**<br>
Performance<br>
***<br>
****<br>
* to ***<br>
***<br>
The  scores  for  IXmlSerializable  assume  you've  (hand)  coded  optimally  using<br>XmlReader and XmlWriter. The XML serialization engine requires that you recycle the<br>same XmlSerializer object for good performance.<br>
<b>Why three engines?<br></b>The reason for three engines is partly historical. The Framework started out with<br>two distinct goals in serialization:<br>
· Serializing .NET object graphs with type and reference fidelity<br>· Interoperating with XML and SOAP messaging standards<br>
The first was led by the requirements of Remoting; the second, by Web Services.<br>The job of writing one serialization engine to do both was too daunting, so Microsoft<br>wrote two engines: the binary serializer and the XML serializer.<br>
<b>610 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=631></a>When Windows Communication Foundation (WCF) was later written, as part of<br>Framework 3.0, part of the goal was to unify Remoting and Web Services. This<br>required a new serialization engine--hence, the <i>data contract serializer</i>. The data<br>contract serializer unifies the features of the older two engines <i>relevant to (intero-<br>perable) messaging</i>. Outside of this context, however, the two older engines are still<br>important.<br>
<b>The data contract serializer<br></b>The data contract serializer is the newest and the most versatile of the three seriali-<br>zation  engines  and  is  used  by  WCF.  The  serializer  is  particularly  strong  in  two<br>scenarios:<br>
· When  exchanging  information  through  standards-compliant  messaging<br>
protocols<br>
· When you need good version tolerance, plus the option of preserving object<br>
references<br>
The data contract serializer supports a <i>data contract</i> model that helps you decouple<br>the  low-level  details  of  the  types  you  want  to  serialize  from  the  structure  of  the<br>serialized data. This provides excellent version tolerance, meaning you can deseri-<br>alize data that was serialized from an earlier or later version of a type. You can even<br>deserialize types that have been renamed or moved to a different assembly.<br>
The data contract serializer can cope with most object graphs, although it can require<br>more assistance than the binary serializer. It can also be used as a general-purpose<br>tool for reading/writing XML files, if you're flexible on how the XML is structured.<br>(If you need to store data in attributes or cope with XML elements presenting in a<br>random order, you cannot use the data contract serializer.)<br>
<b>The binary serializer<br></b>The binary serialization engine is easy to use, highly automatic, and well supported<br>throughout the .NET Framework. Remoting uses binary serialization--including<br>when communicating between two application domains in the same process (see<br>Chapter 24).<br>
The binary serializer is highly automated: quite often, a single attribute is all that's<br>
<b>Serialization</b><br>
required to make a complex type fully serializable. The binary serializer is also faster<br>than the data contract serializer when full type fidelity is needed. However, it tightly<br>couples a type's internal structure to the format of the serialized data, resulting in<br>poor version tolerance. (Prior to Framework 2.0, even adding a simple field was a<br>version-breaking change.) The binary engine is also not really designed to produce<br>XML, although it offers a formatter for SOAP-based messaging that provides limited<br>interoperability with simple types.<br>
<b>XmlSerializer<br></b>The XML serialization engine can <i>only</i> produce XML, and it is less powerful than<br>other  engines  in  saving  and  restoring  a  complex  object  graph  (it  cannot  restore<br>shared object references). It's the most flexible of the three, however, in following<br>
<b>Serialization Concepts | 611</b><br>
<hr>
<A name=632></a>an arbitrary XML structure. For instance, you can choose whether properties are<br>serialized to elements or attributes and the handling of a collection's outer element.<br>The XML engine also provides excellent version tolerance.<br>
XmlSerializer is used by ASMX Web Services.<br>
<b>IXmlSerializable<br></b>Implementing  IXmlSerializable  means  to  do  the  serialization  yourself  with  an<br>XmlReader  and  XmlWriter.  The  IXmlSerializable  interface  is  recognized  both  by<br>XmlSerializer and by the data contract serializer, so it can be used selectively to<br>handle the more complicated types. (It also can be used directly by WCF and ASMX<br>Web Services.) We describe XmlReader and XmlWriter in detail in Chapter 11.<br>
<b>Formatters<br></b>The  output  of  the  data  contract  and  binary  serializers  is  shaped  by  a  pluggable<br><i>formatter</i>. The role of a formatter is the same with both serialization engines, al-<br>though they use completely different classes to do the job.<br>
A formatter shapes the final presentation to suit a particular medium or context of<br>serialization. In general, you can choose between XML and binary formatters. An<br>XML formatter is designed to work within the context of an XML reader/writer, text<br>file/stream, or SOAP messaging packet. A binary formatter is designed to work in a<br>context where an arbitrary stream of bytes will do--typically a file/stream or pro-<br>prietary messaging packet. Binary output is usually smaller than XML--sometimes<br>radically so.<br>
The term "binary" in the context of a formatter is unrelated to<br>the "binary" serialization engine. Each of the two engines ships<br>with both XML and binary formatters!<br>
In theory, the engines are decoupled from their formatters. In practice, the design<br>of each engine is geared toward one kind of formatter. The data contract serializer<br>is geared toward the interoperability requirements of XML messaging. This is good<br>for the XML formatter but means its binary formatter doesn't always achieve the<br>gains you might hope. In contrast, the binary engine provides a relatively good binary<br>formatter,  but  its  XML  formatter  is  highly  limited,  offering  only  crude  SOAP<br>interoperability.<br>
<b>Explicit Versus Implicit Serialization<br></b>Serialization and deserialization can be initiated in two ways.<br>
The first is <i>explicitly</i>, by requesting that a particular object be serialized or deserial-<br>ized. When you serialize or deserialize explicitly, you choose both the serialization<br>engine and the formatter.<br>
<b>612 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=633></a>In contrast, <i>implicit</i> serialization is initiated by the Framework. This happens when:<br>
· A serializer recurses a child object.<br>· You use a feature that relies on serialization, such as WCF, Remoting, or Web<br>
Services.<br>
WCF always uses the data contract serializer, although it can interoperate with the<br>attributes and interfaces of the other engines.<br>
Remoting always uses the binary serialization engine.<br>
Web Services always uses XmlSerializer.<br>
<b>The Data Contract Serializer<br></b>Here are the basic steps in using the data contract serializer:<br>
1. Decide  whether  to  use  the  DataContractSerializer  or  the  NetDataContract-<br>
Serializer.<br>
2. Decorate the types and members you want to serialize with [DataContract] and<br>
[DataMember] attributes, respectively.<br>
3. Instantiate the serializer and call WriteObject or ReadObject.<br>
If  you  chose  the  DataContractSerializer,  you  will  also  need  to  register  "known<br>types" (subtypes that can also be serialized), and decide whether to preserve object<br>references.<br>
You may also need to take special action to ensure that collections are properly<br>serialized.<br>
Types  for  the  data  contract  serializer  are  defined  in  the<br>System.Runtime.Serialization  namespace,  in  an  assembly  of<br>the same name.<br>
<b>DataContractSerializer Versus NetDataContractSerializer</b><br>
<b>Serialization</b><br>
There are two data contract serializers:<br>
DataContractSerializer<br>
Loosely couples .NET types to data contract types<br>
NetDataContractSerializer<br>
Tightly couples .NET types to data contract types<br>
The DataContractSerializer can produce interoperable standards-compliant XML<br>such as this:<br>
&lt;Person xmlns=&quot;...&quot;&gt;<br>  ...<br>&lt;/Person&gt;<br>
<b>The Data Contract Serializer | 613</b><br>
<hr>
<A name=634></a>It requires, however, that you explicitly register serializable subtypes in advance so<br>that it can map a data contract name such as "Person" to the correct .NET type. The<br>NetDataContractSerializer requires no such assistance, because it writes the full<br>type and assembly names of the types it serializes, rather like the binary serialization<br>engine:<br>
&lt;Person z:Type=&quot;SerialTest.Person&quot; z:Assembly=<br>
  <b>&quot;SerialTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;</b>&gt;<br>  ...<br>
&lt;/Person&gt;<br>
Such output, however, is proprietary. It also relies on the presence of a specific.NET<br>type in a specific namespace and assembly in order to deserialize.<br>
If you're saving an object graph to a "black box," you can choose either serializer,<br>depending on what benefits are more important to you. If you're communicating<br>through  WCF,  or  reading/writing  an  XML  file,  you'll  most  likely  want  the<br>DataContractSerializer.<br>
Another difference between the two serializers is that NetDataContractSerializer<br>always  preserves  referential  equality;  DataContractSerializer  does  so  only  upon<br>request.<br>
We'll go into each of these topics in more detail in the following sections.<br>
<b>Using the Serializers<br></b>After  choosing  a  serializer,  the  next  step  is  to  attach  attributes  to  the  types  and<br>members you want to serialize. At a minimum:<br>
· Add the [DataContract] attribute to each type.<br>· Add the [DataMember] attribute to each member that you want to include.<br>
Here's an example:<br>
namespace SerialTest<br>{<br>  <b>[DataContract]</b> public class Person<br>  {<br>    <b>[DataMember]</b> public string Name;<br>    <b>[DataMember]</b> public int Age;<br>  }<br>}<br>
These attributes are enough to make a type <i>implicitly</i> serializable through the data<br>contract engine.<br>
You can then <i>explicitly</i> serialize or deserialize an object instance by instantiating a<br>DataContractSerializer or NetDataContractSerializer and calling WriteObject or<br>ReadObject:<br>
Person p = new Person { Name = &quot;Stacey&quot;, Age = 30 };<br>
var ds = new DataContractSerializer (typeof (Person));<br>
<b>614 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=635></a>using (Stream s = File.Create (&quot;person.xml&quot;))<br>
  ds.WriteObject (s, p);                            // Serialize<br>
Person p2;<br>
using (Stream s = File.OpenRead (&quot;person.xml&quot;))<br>
  p2 = (Person) ds.ReadObject (s);                  // Deserialize<br>
Console.WriteLine (p2.Name + &quot; &quot; + p2.Age);         // Stacey 30<br>
DataContractSerializer's constructor requires the <i>root object</i> type (the type of the<br>object  you're  explicitly  serializing).  In  contrast,  NetDataContractSerializer  does<br>not:<br>
var ns = new NetDataContractSerializer();<br>
// NetDataContractSerializer is otherwise the same to use<br>
// as DataContractSerializer.<br>
...<br>
Both types of serializer use the XML formatter by default. With an XmlWriter, you<br>can request that the output be indented for readability:<br>
Person p = new Person { Name = &quot;Stacey&quot;, Age = 30 };<br>
var ds = new DataContractSerializer (typeof (Person));<br>
XmlWriterSettings settings = new XmlWriterSettings() { <b>Indent = true</b> };<br>
using (XmlWriter w = XmlWriter.Create (&quot;person.xml&quot;, settings))<br>
  ds.WriteObject (w, p);<br>
System.Diagnostics.Process.Start (&quot;person.xml&quot;);<br>
Here's the result:<br>
&lt;Person xmlns=&quot;http://schemas.datacontract.org/2004/07/SerialTest&quot;<br>        xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>  &lt;Age&gt;30&lt;/Age&gt;<br>  &lt;Name&gt;Stacey&lt;/Name&gt;<br>&lt;/Person&gt;<br>
The XML element name &lt;Person&gt; reflects the <i>data contract name</i>, which, by default,<br>is the .NET type name. You can override this and explicitly state a data contract<br>name as follows:<br>
<b>Serialization</b><br>
[DataContract (<b>Name=&quot;Candidate&quot;</b>)]<br>public class Person { ... }<br>
The  XML  namespace  reflects  the  <i>data  contract  namespace</i>,  which,  by  default,  is<br><i>http://schemas.datacontract.org/2004/07/</i>, plus the .NET type namespace. You can<br>override this in a similar fashion:<br>
[DataContract (<b>Namespace=&quot;http://oreilly.com/nutshell&quot;</b>)]<br>public class Person { ... }<br>
<b>The Data Contract Serializer | 615</b><br>
<hr>
<A name=636></a>Specifying a name and namespace decouples the contract iden-<br>tity from the .NET type name. It ensures that, should you later<br>refactor and change the type's name or namespace, serialization<br>is unaffected.<br>
You can also override names for data members:<br>
[DataContract (Name=&quot;Candidate&quot;, Namespace=&quot;http://oreilly.com/nutshell&quot;)]<br>
public class Person<br>
{<br>  [DataMember (<b>Name=&quot;FirstName&quot;</b>)]  public string Name;<br>
  [DataMember (<b>Name=&quot;ClaimedAge&quot;</b>)] public int Age;<br>}<br>
Here's the output:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>
&lt;Candidate xmlns=&quot;http://oreilly.com/nutshell&quot;<br>
           xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &gt;<br>
  &lt;ClaimedAge&gt;30&lt;/ClaimedAge&gt;<br>  &lt;FirstName&gt;Stacey&lt;/FirstName&gt;<br>&lt;/Candidate&gt;<br>
[DataMember] supports both fields and properties--public and private. The field or<br>property's data type can be any of the following:<br>
· Any primitive type<br>· DateTime, TimeSpan, Guid, Uri, or an Enum value<br>· Nullable versions of the above<br>· byte[] (serializes in XML to base 64)<br>· Any "known" type decorated with DataContract<br>· Any IEnumerable type (see the section "Serializing Collections" on page 642,<br>
later in this chapter)<br>
· Any type with the [Serializable] attribute or implementing ISerializable (see<br>
the section "Extending Data Contracts" on page 625 later in this chapter)<br>
· Any type implementing IXmlSerializable<br>
<b>Specifying a binary formatter<br></b>You can use a binary formatter with DataContractSerializer or NetDataContract<br>Serializer. The process is the same:<br>
Person p = new Person { Name = &quot;Stacey&quot;, Age = 30 };<br>var ds = new DataContractSerializer (typeof (Person));<br>
var s = new MemoryStream();<br><b>using (XmlDictionaryWriter w = XmlDictionaryWriter.CreateBinaryWriter (s))<br></b>  ds.WriteObject (w, p);<br>
 <br>var s2 = new MemoryStream (s.ToArray());<br>Person p2;<br>
<b>616 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=637></a><b>using (XmlDictionaryReader r = XmlDictionaryReader.CreateBinaryReader (s2,</b><br>
                               <b>XmlDictionaryReaderQuotas.Max))<br></b>  p2 = (Person) ds.ReadObject (r);<br>
The output varies between being slightly smaller than that of the XML formatter,<br>and radically smaller if your types contain large arrays.<br>
<b>Serializing Subclasses<br></b>You don't need to do anything special to handle the serializing of subclasses with<br>the NetDataContractSerializer. The only requirement is that subclasses have the<br>DataContract attribute. The serializer will write the fully qualified names of the actual<br>types that it serializes as follows:<br>
&lt;Person ... z:Type=&quot;SerialTest.Person&quot; z:Assembly=<br>  <b>&quot;SerialTest, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot;</b>&gt;<br>
A DataContractSerializer, however, must be informed about all subtypes that it<br>may have to serialize or deserialize. To illustrate, suppose we subclass Person as<br>follows:<br>
[DataContract] public class Person<br>{<br>  [DataMember] public string Name;<br>
  [DataMember] public int Age;<br>
}<br><b>[DataContract] public class Student : Person { }</b><br>
<b>[DataContract] public class Teacher : Person { }</b><br>
and then write a method to clone a Person:<br>
static Person DeepClone (Person p)<br>{<br>  var ds = new DataContractSerializer (typeof (Person));<br>  MemoryStream stream = new MemoryStream();<br>  ds.WriteObject (stream, p);<br>  stream.Position = 0;<br>  return (Person) ds.ReadObject (stream);<br>}<br>
which we call as follows:<br>
<b>Serialization</b><br>
Person  person  = new Person  { Name = &quot;Stacey&quot;, Age = 30 };<br>Student student = new Student { Name = &quot;Stacey&quot;, Age = 30 };<br>Teacher teacher = new Teacher { Name = &quot;Stacey&quot;, Age = 30 };<br>
Person  p2 =           DeepClone (person);     // OK<br>Student s2 = (Student) DeepClone (student);    // SerializationException<br>Teacher t2 = (Teacher) DeepClone (teacher);    // SerializationException<br>
DeepClone works if called with a Person but throws an exception with a Student or<br>Teacher, because the deserializer has no way of knowing what .NET type (or as-<br>sembly) a "Student" or "Teacher" should resolve to. This also helps with security,<br>in that it prevents the deserialization of unexpected types.<br>
<b>The Data Contract Serializer | 617</b><br>
<hr>
<A name=638></a>The solution is to specify all permitted or "known" subtypes. You can do this either<br>when constructing the DataContractSerializer:<br>
var ds = new DataContractSerializer (typeof (Person),<br>  <b>new Type[] { typeof (Student), typeof (Teacher) }</b> );<br>
or in the type itself, with the KnownType attribute:<br>
[DataContract, <b>KnownType (typeof (Student)), KnownType (typeof (Teacher))</b>]<br>
public class Person<br>
...<br>
Here's what a serialized Student now looks like:<br>
&lt;Person xmlns=&quot;...&quot;<br>        xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>        <b>i:type=&quot;Student&quot;</b> &gt;<br>
  ...<br>
&lt;Person&gt;<br>
Because we specified Person as the root type, the root element still has that name.<br>The actual subclass is described separately--in the type attribute.<br>
The NetDataContractSerializer suffers a performance hit when<br>serializing subtypes--with either formatter. It seems that when<br>it encounters a subtype, it has to stop and think for a while!<br>
Serialization  performance  matters  on  an  application  server<br>that's handling many concurrent requests.<br>
<b>Object References<br></b>References to other objects are serialized, too. Consider the following classes:<br>
[DataContract] public class Person<br>{<br>  [DataMember] public string Name;<br>  [DataMember] public int Age;<br>  <b>[DataMember] public Address HomeAddress;<br></b>}<br>
[DataContract] public class Address<br>{<br>  [DataMember] public string Street, Postcode;<br>}<br>
Here's the result of serializing this to XML using the DataContractSerializer:<br>
&lt;Person...&gt;<br>  &lt;Age&gt;...&lt;/Age&gt;<br>  <b>&lt;HomeAddress&gt;<br></b>    <b>&lt;Street&gt;...&lt;/Street&gt;<br></b>    <b>&lt;Postcode&gt;...&lt;/Postcode&gt;<br></b>  <b>&lt;/HomeAddress&gt;<br></b>  &lt;Name&gt;...&lt;/Name&gt;<br>&lt;/Person&gt;<br>
<b>618 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=639></a>The  DeepClone  method  we  wrote  in  the  preceding  section<br>would clone HomeAddress, too--distinguishing it from a simple<br>MemberwiseClone.<br>
If you're using a DataContractSerializer, the same rules apply when subclassing<br>Address as when subclassing the root type. So, if we define a USAddress class, for<br>instance:<br>
[DataContract]<br>public class USAddress <b>: Address</b> { }<br>
and assign an instance of it to a Person:<br>
Person p = new Person { Name = &quot;John&quot;, Age = 30 };<br>p.HomeAddress = new USAddress { Street=&quot;Fawcett St&quot;, Postcode=&quot;02138&quot; };<br>
p could not be serialized. The solution is either to apply the KnownType attribute to<br>Address, as shown next:<br>
[DataContract, <b>KnownType (typeof (USAddress))</b>]<br>public class Address<br>
{<br>  [DataMember] public string Street, Postcode;<br>
}<br>
or to tell DataContractSerializer about USAddress in construction:<br>
var ds = new DataContractSerializer (typeof (Person),<br>  <b>new Type[] { typeof (USAddress) }</b> );<br>
(We  don't  need  to  tell  it  about  Address  because  it's  the  declared  type  of  the<br>HomeAddress data member.)<br>
<b>Preserving object references<br></b>The  NetDataContractSerializer  always  preserves  referential  equality.  The<br>DataContractSerializer does not, unless you specifically ask it to.<br>
This  means  that  if  the  same  object  is  referenced  in  two  different  places,  a<br>DataContractSerializer ordinarily writes it twice. So, if we modify the preceding<br>
<b>Serialization</b><br>
example so that Person also stores a work address:<br>
[DataContract] public class Person<br>{<br>  ...<br>  [DataMember] public Address HomeAddress<b>, WorkAddress</b>;<br>}<br>
and then serialize an instance as follows:<br>
Person p = new Person { Name = &quot;Stacey&quot;, Age = 30 };<br>p.HomeAddress = new Address { Street = &quot;Odo St&quot;, Postcode = &quot;6020&quot; };<br><b>p.WorkAddress = p.HomeAddress;</b><br>
<b>The Data Contract Serializer | 619</b><br>
<hr>
<A name=640></a>we would see the same address details twice in the XML:<br>
...<br>
&lt;HomeAddress&gt;<br>
  &lt;Postcode&gt;6020&lt;/Postcode&gt;<br>  &lt;Street&gt;Odo St&lt;/Street&gt;<br>&lt;/HomeAddress&gt;<br>
...<br>
&lt;WorkAddress&gt;<br>  &lt;Postcode&gt;6020&lt;/Postcode&gt;<br>  &lt;Street&gt;Odo St&lt;/Street&gt;<br>
&lt;/WorkAddress&gt;<br>
When this was later deserialized, WorkAddress and HomeAddress would be different<br>objects. The advantage of this system is that it keeps the XML simple and standards-<br>compliant. The disadvantages of this system include larger XML, loss of referential<br>integrity, and the inability to cope with cyclical references.<br>
You can request referential integrity by specifying true for preserveObjectReferen<br>ces when constructing a DataContractSerializer:<br>
var ds = new DataContractSerializer (typeof (Person),<br>
                                     null, <b>1000</b>, false, <b>true</b>, null);<br>
The third argument is mandatory when preserveObjectReferences is true: it indi-<br>cates the maximum number of object references that the serializer should keep track<br>of. The serializer throws an exception if this number is exceeded (this prevents a<br>denial of service attack through a maliciously constructed stream).<br>
Here's what the XML then looks like for a Person with the same home and work<br>addresses:<br>
&lt;Person xmlns=&quot;http://schemas.datacontract.org/2004/07/SerialTest&quot;<br>        xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>        xmlns:z=&quot;http://schemas.microsoft.com/2003/10/Serialization/&quot;<br>        z:Id=&quot;1&quot;&gt;<br>  &lt;Age&gt;30&lt;/Age&gt;<br>  &lt;HomeAddress <b>z:Id=&quot;2&quot;</b>&gt;<br>    &lt;Postcode z:Id=&quot;3&quot;&gt;6020&lt;/Postcode&gt;<br>    &lt;Street z:Id=&quot;4&quot;&gt;Odo St&lt;/Street&gt;<br>  &lt;/HomeAddress&gt;<br>  &lt;Name z:Id=&quot;5&quot;&gt;Stacey&lt;/Name&gt;<br>  &lt;WorkAddress <b>z:Ref=&quot;2&quot;</b> i:nil=&quot;true&quot; /&gt;<br>&lt;/Person&gt;<br>
The cost of this is in reduced interoperability (notice the proprietary namespace of<br>the Id and Ref attributes).<br>
<b>Version Tolerance<br></b>You  can  add  and  remove  data  members  without  breaking  forward  or  backward<br>compatibility. By default, the data contract deserializers do the following:<br>
· Skip over data for which there is no [DataMember] in the type.<br>· Don't complain if any [DataMember] is missing in the serialization stream.<br>
<b>620 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=641></a>Rather  than  skipping  over  unrecognized  data,  you  can  instruct  the  deserializer<br>to store unrecognized data members in a black box, and then replay them should<br>the type later be reserialized. This allows you to correctly round-trip data that's been<br>serialized  by  a  later  version  of  your  type.  To  activate  this  feature,  implement<br>IExtensibleDataObject. This interface really means "IBlackBoxProvider." It requires<br>that you implement a single property, to get/set the black box:<br>
[DataContract] public class Person <b>: IExtensibleDataObject</b>{<br>
  [DataMember] public string Name;<br>
  [DataMember] public int Age;<br>
  <b>ExtensionDataObject IExtensibleDataObject.ExtensionData { get; set; }<br></b>}<br>
<b>Required members<br></b>If a member is essential for a type, you can demand that it be present with IsRequired:<br>
[DataMember (<b>IsRequired=true</b>)] public int ID;<br>
If that member is not present, an exception is then thrown upon deserialization.<br>
<b>Member Ordering<br></b>The data contract serializers are extremely fussy about the ordering of data members.<br>The deserializers, in fact, <i>skip over any members considered out of sequence</i>.<br>
Members are written in the following order when serializing:<br>
1. Base class to subclass<br>2. Low Order to high Order (for data members whose Order is set)<br>3. Alphabetical order (using <i>ordinal</i> string comparison)<br>
So, in the preceding examples, Age comes before Name. In the following example,<br>Name comes before Age:<br>
[DataContract] public class Person<br>{<br>  [DataMember (<b>Order=0</b>)] public string Name;<br>  [DataMember (<b>Order=1</b>)] public int Age;<br>}<br>
<b>Serialization</b><br>
If Person has a base class, the base class's data members would all serialize first.<br>The main reason to specify an order is to comply with a particular XML schema.<br>XML element order equates to data member order.<br>
If you don't need to interoperate with anything else, the easiest approach is <i>not</i> to<br>specify a member Order and rely purely on alphabetical ordering. A discrepancy will<br>then never arise between serialization and deserialization as members are added and<br>removed. The only time you'll come unstuck is if you move a member between a<br>base class and a subclass.<br>
<b>The Data Contract Serializer | 621</b><br>
<hr>
<A name=642></a><b>Null and Empty Values<br></b>There are two ways to deal with a data member whose value is null or empty:<br>
1. Explicitly write the null or empty value (the default).<br>2. Omit the data member from the serialization output.<br>
In XML, an explicit null value looks like this:<br>
&lt;Person xmlns=&quot;...&quot;<br>           xmlns:i=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;<br>
  &lt;Name <b>i:nil=&quot;true&quot;</b> /&gt;<br>
&lt;/Person&gt;<br>
Writing null or empty members can waste space, particularly on a type with lots of<br>fields or properties that are usually left empty. More importantly, you may need to<br>follow  an  XML  schema  that  expects  the  use  of  optional  elements  (e.g.,<br>minOccurs=&quot;0&quot;) rather than nil values.<br>
You can instruct the serializer not to emit data members for null/empty values as<br>follows:<br>
[DataContract] public class Person<br>
{<br>  [DataMember (<b>EmitDefaultValue=false</b>)] public string Name;<br>  [DataMember (<b>EmitDefaultValue=false</b>)] public int Age;<br>
}<br>
Name is omitted if its value is null; Age is omitted if its value is 0 (the default value for<br>the int type).<br>
The  data  contract  deserializer,  in  rehydrating  an  object,  by-<br>passes the type's constructors and field initializers. This allows<br>you to omit data members as described without breaking fields<br>that  are  assigned  nondefault  values  through  an  initializer  or<br>constructor. To illustrate, suppose we set the default Age for a<br>Person to 30 as follows:<br>
[DataMember (<b>EmitDefaultValue=false</b>)]<br>public int Age = 30;<br>
Now suppose that we instantiate Person, explicitly set its Age<br>from 30 to 0, and then serialize it. The output won't include<br>Age, because 0 is the default value for the int type. This means<br>that in deserialization, Age will be ignored and the field will re-<br>main at its default value--which fortunately is 0, given that field<br>initializers and constructors were bypassed.<br>
<b>Data Contracts and Collections<br></b>The data contract serializers can save and repopulate any enumerable collection. For<br>instance, suppose we define Person to have a List&lt;&gt; of addresses:<br>
<b>622 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=643></a>[DataContract] public class Person<br>
{<br>  ...<br>  <b>[DataMember] public List&lt;Address&gt; Addresses;</b><br>
}<br>
[DataContract] public class Address<br>{<br>  [DataMember] public string Street, Postcode;<br>
}<br>
Here's the result of serializing a Person with two addresses:<br>
&lt;Person ...&gt;<br>  ...<br>  &lt;Addresses&gt;<br>
    &lt;Address&gt;<br>
      &lt;Postcode&gt;6020&lt;/Postcode&gt;<br>      &lt;Street&gt;Odo St&lt;/Street&gt;<br>    &lt;/Address&gt;<br>
    &lt;Address&gt;<br>
      &lt;Postcode&gt;6152&lt;/Postcode&gt;<br>      &lt;Street&gt;Comer St&lt;/Street&gt;<br>    &lt;/Address&gt;<br>
  &lt;/Addresses&gt;<br>
  ...<br>&lt;/Person&gt;<br>
Notice that the serializer doesn't encode any information about the particular <i>type<br></i>of collection it serialized. If the Addresses field was instead of type Address[], the<br>output would be identical. This allows the collection type to change between seri-<br>alization and deserialization without causing an error.<br>
Sometimes, though, you need your collection to be of a more specific type than you<br>expose. An extreme example is with interfaces:<br>
[DataMember] public <b>IList</b>&lt;Address&gt; Addresses;<br>
This serializes correctly (as before), but a problem arises in deserialization. There's<br>no way the deserializer can know which concrete type to instantiate, so it chooses<br>the simplest option--an array. The deserializer sticks to this strategy even if you<br>initialize the field with a different concrete type:<br>
<b>Serialization</b><br>
[DataMember] public <b>IList</b>&lt;Address&gt; Addresses = new List&lt;Address&gt;();<br>
(Remember that the deserializer bypasses field initializers.) The workaround is to<br>make the data member a private field and add a public property to access it:<br>
[DataMember (Name=&quot;Addresses&quot;)] <b>List</b>&lt;Address&gt; _addresses;<br>
public <b>IList</b>&lt;Address&gt; Addresses { get { return _addresses; } }<br>
In a nontrivial application, you would probably use properties in this manner any-<br>way. The only unusual thing here is that we've marked the private field as the data<br>member, rather than the public property.<br>
<b>Data Contracts and Collections | 623</b><br>
<hr>
<A name=644></a><b>Subclassed Collection Elements<br></b>The serializer handles subclassed collection elements transparently. You must de-<br>clare the valid subtypes just as you would if they were used anywhere else:<br>
[DataContract, <b>KnownType (typeof (USAddress))</b>]<br>
public class Address<br>
{<br>  [DataMember] public string Street, Postcode;<br>}<br>
public class USAddress : Address { }<br>
Adding a USAddress to a Person's address list then generates XML like this:<br>
...<br>
  &lt;Addresses&gt;<br>
    &lt;Address <b>i:type=&quot;USAddress&quot;</b>&gt;<br>      &lt;Postcode&gt;02138&lt;/Postcode&gt;<br>
      &lt;Street&gt;Fawcett St&lt;/Street&gt;<br>
    &lt;/Address&gt;<br>
  &lt;/Addresses&gt;<br>
<b>Customizing Collection and Element Names<br></b>If you subclass a collection class itself, you can customize the XML name used to<br>describe each element by attaching a CollectionDataContract attribute:<br>
<b>[CollectionDataContract (ItemName=&quot;Residence&quot;)]<br></b>public class AddressList : Collection&lt;Address&gt; { }<br>
[DataContract] public class Person<br>{<br>  ...<br>  [DataMember] public AddressList Addresses;<br>}<br>
Here's the result:<br>
...<br>  &lt;Addresses&gt;<br>    <b>&lt;Residence&gt;<br></b>      &lt;Postcode&gt;6020&lt;/Postcode<br>      &lt;Street&gt;Odo St&lt;/Street&gt;<br>    <b>&lt;/Residence&gt;<br></b>    ...<br>
CollectionDataContract also lets you specify a Namespace and Name. The latter is not<br>used when the collection is serialized as a property of another object (such as in this<br>example), but it is when the collection is serialized as the root object.<br>
You can also use CollectionDataContract to control the serialization of dictionaries:<br>
[CollectionDataContract (ItemName=&quot;Entry&quot;,<br>                          KeyName=&quot;Kind&quot;,<br>                        ValueName=&quot;Number&quot;)]<br>public class PhoneNumberList : Dictionary &lt;string, string&gt; { }<br>
<b>624 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=645></a>[DataContract] public class Person<br>
{<br>  ...<br>  [DataMember] public PhoneNumberList PhoneNumbers;<br>
}<br>
Here's how this formats:<br>
...<br>
  &lt;PhoneNumbers&gt;<br>    &lt;Entry&gt;<br>      &lt;Kind&gt;Home&lt;/Kind&gt;<br>
      &lt;Number&gt;08 1234 5678&lt;/Number&gt;<br>
    &lt;/Entry&gt;<br>    &lt;Entry&gt;<br>      &lt;Kind&gt;Mobile&lt;/Kind&gt;<br>
      &lt;Number&gt;040 8765 4321&lt;/Number&gt;<br>
    &lt;/Entry&gt;<br>  &lt;/PhoneNumbers&gt;<br>
<b>Extending Data Contracts<br></b>This section describes how you can extend the capabilities of the data contract se-<br>rializer through serialization hooks, [Serializable] and IXmlSerializable.<br>
<b>Serialization and Deserialization Hooks<br></b>You can request that a custom method be executed before or after serialization, by<br>flagging the method with one of the following attributes:<br>
[OnSerializing]<br>
Indicates a method to be called just <i>before</i> serialization<br>
[OnSerialized]<br>
Indicates a method to be called just <i>after</i> serialization<br>
Similar attributes are supported for deserialization:<br>
[OnDeserializing]<br>
Indicates a method to be called just <i>before</i> deserialization<br>
<b>Serialization</b><br>
[OnDeserialized]<br>
Indicates a method to be called just <i>after</i> deserialization<br>
The custom method must have a single parameter of type StreamingContext. This<br>parameter is required for consistency with the binary engine, and it is not used by<br>the data contract serializer.<br>
[OnSerializing] and [OnDeserialized] are useful in handling members that are out-<br>side the capabilities of the data contract engine, such as a collection that has an extra<br>payload or that does not implement standard interfaces. Here's the basic approach:<br>
[DataContract] public class Person<br>{<br>  public <i>SerializationUnfriendlyType</i> Addresses;<br>
<b>Extending Data Contracts | 625</b><br>
<hr>
<A name=646></a>  [DataMember (Name=&quot;Addresses&quot;)]<br>
  <i>SerializationFriendlyType</i> _serializationFriendlyAddresses;<br>
  <b>[OnSerializing]</b><br>
  void PrepareForSerialization (StreamingContext sc)<br>
  {<br>    // Copy Addresses--&gt; _serializationFriendlyAddresses<br>    // ...<br>
  }<br>
  <b>[OnDeserialized]<br></b>  void CompleteDeserialization (StreamingContext sc)<br>
  {<br>    // Copy _serializationFriendlyAddresses--&gt; Addresses<br>
    // ...<br>  }<br>
}<br>
An [OnSerializing] method can also be used to conditionally serialize fields:<br>
public DateTime DateOfBirth;<br>
[DataMember] public bool Confidential;<br>
[DataMember (Name=&quot;DateOfBirth&quot;, <b>EmitDefaultValue=false</b>)]<br>
DateTime? _tempDateOfBirth;<br>
<b>[OnSerializing]<br></b>void PrepareForSerialization (StreamingContext sc)<br>{<br>  if (Confidential)<br>    _tempDateOfBirth = DateOfBirth;<br>  else<br>    _tempDateOfBirth = null;<br>}<br>
Recall that the data contract deserializers bypass field initializers and constructors.<br>An [OnDeserializing] method acts as a pseudoconstructor for deserialization, and<br>it is useful for initializing fields excluded from serialization:<br>
[DataContract] public class Test<br>{<br>  bool _editable = true;<br>
  public Test() { _editable = true; }<br>
  [OnDeserializing]<br>  void Init (StreamingContext sc)<br>  {<br>    _editable = true;<br>  }<br>}<br>
If it wasn't for the Init method, _editable would be false in a deserialized instance<br>of Test--despite the other two attempts at making it true.<br>
<b>626 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=647></a>Methods decorated with these four attributes can be private. If subtypes need to<br>participate, they can define their own methods with the same attributes, and they<br>will get executed, too.<br>
<b>Interoperating with [Serializable]<br></b>The data contract serializer can also serialize types marked with the binary seriali-<br>zation engine's attributes and interfaces. This ability is important, since support for<br>the binary engine has been woven into much of what was written prior to Framework<br>3.0--including the .NET Framework itself!<br>
The following things flag a type as being serializable for the bi-<br>nary engine:<br>
· The [Serializable] attribute<br>· Implementing ISerializable<br>
Binary interoperability is useful in serializing existing types as well as new types that<br>need to support both engines. It also provides another means of extending the ca-<br>pability of the data contract serializer, because the binary engine's ISerializable is<br>more  flexible  than  the  data  contract  attributes.  Unfortunately,  the  data  contract<br>serializer is inefficient in how it formats data added via ISerializable.<br>A type wanting the best of both worlds cannot define attributes for both engines.<br>This creates a problem for types such as string and DateTime, which for historical<br>reasons  cannot  divorce  the  binary  engine  attributes.  The  data  contract  serializer<br>works around this by filtering out these basic types and processing them specially.<br>For all other types marked for binary serialization, the data contract serializer applies<br>similar rules to what the binary engine would use. This means it honors attributes<br>such as NonSerialized or calls ISerializable if implemented. It does not <i>thunk</i> to<br>the binary engine itself--this ensures that output is formatted in the same style as if<br>data contract attributes were used.<br>
Types designed to be serialized with the binary engine expect<br>object references to be preserved. You can enable this option<br>
<b>Serialization</b><br>
through the DataContractSerializer (or by using the NetData<br>ContractSerializer).<br>
The rules for registering known types also apply to objects and subobjects serialized<br>through the binary interfaces.<br>
<b>Extending Data Contracts | 627</b><br>
<hr>
<A name=648></a>The following example illustrates a class with a [Serializable] data member:<br>
[DataContract] public class Person<br>
{<br>  ...<br>  [DataMember] public Address MailingAddress;<br>}<br><b>[Serializable]</b> public class Address<br>
{<br>  public string Postcode, Street;<br>}<br>
Here's the result of serializing it:<br>
&lt;Person ...&gt;<br>
  ...<br>
  &lt;MailingAddress&gt;<br>    &lt;Postcode&gt;6020&lt;/Postcode&gt;<br>    &lt;Street&gt;Odo St&lt;/Street&gt;<br>
  &lt;/MailingAddress&gt;<br>
  ...<br>
Had  Address  implemented  ISerializable,  the  result  would  be  less  efficiently<br>formatted:<br>
  &lt;MailingAddress&gt;<br>
    &lt;Street xmlns:d3p1=&quot;http://www.w3.org/2001/XMLSchema&quot;<br>      i:type=&quot;d3p1:string&quot; xmlns=&quot;&quot;&gt;str&lt;/Street&gt;<br>
    &lt;Postcode xmlns:d3p1=&quot;http://www.w3.org/2001/XMLSchema&quot;<br>
      i:type=&quot;d3p1:string&quot; xmlns=&quot;&quot;&gt;pcode&lt;/Postcode&gt;<br>
  &lt;/MailingAddress&gt;<br>
<b>Interoperating with IXmlSerializable<br></b>A limitation of the data contract serializer is that it gives you little control over the<br>structure of the XML. In a WCF application, this can actually be beneficial, in that<br>it makes it easier for the infrastructure to comply with standard messaging protocols.<br>
If you do need precise control over the XML, you can implement IXmlSerializa<br>ble and then use XmlReader and XmlWriter to manually read and write the XML. The<br>data contract serializer allows you to do this just on the types for which this level of<br>control is required. We describe the IXmlSerializable interface further in the final<br>section of this chapter.<br>
<b>The Binary Serializer<br></b>The binary serialization engine is used implicitly by Remoting. It can also be used<br>to perform such tasks as saving and restoring objects to disk. The binary serialization<br>is  highly  automated  and  can  handle  complex  object  graphs  with  minimum<br>intervention.<br>
There are two ways to make a type support binary serialization. The first is attribute-<br>based;  the  second  involves  implementing  ISerializable.  Adding  attributes  is<br>
<b>628 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=649></a>simpler;  implementing  ISerializable  is  more  flexible.  You  typically  implement<br>ISerializable to:<br>
· Dynamically control what gets serialized.<br>· Make your serializable type friendly to being subclassed by other parties.<br>
<b>Getting Started<br></b>A type can be made serializable with a single attribute:<br>
<b>[Serializable]</b> public sealed class Person<br>
{<br>  public string Name;<br>
  public int Age;<br>}<br>
The [Serializable] attribute instructs the serializer to include all fields in the type.<br>This includes both private and public fields (but not properties). Every field must<br>itself be serializable; otherwise, an exception is thrown. Primitive .NET types such<br>as string and int support serialization (as do many other .NET types).<br>
The Serializable attribute is not inherited, so subclasses are<br>not  automatically  serializable,  unless  also  marked  with  this<br>attribute.<br>
With automatic properties, the binary serialization engine seri-<br>alizes the underlying compiler-generated field. The name of this<br>field,  unfortunately,  can  change  when  its  type  is  recompiled<br>with more properties, breaking compatibility with existing se-<br>rialized  data.  The  workaround  is  either  to  avoid  automatic<br>properties  in  [Serializable]  types  or  to  implement<br>ISerializable.<br>
To serialize an instance of Person, you instantiate a formatter and call Serialize.<br>There are two formatters for use with the binary engine:<br>
BinaryFormatter<br>
This is the more efficient of the two, producing smaller output in less time. Its<br>
<b>Serialization</b><br>
namespace is System.Runtime.Serialization.Formatters.Binary.<br>
SoapFormatter<br>
This supports basic SOAP-style messaging when used with Remoting. Its name-<br>space is System.Runtime.Serialization.Formatters.Soap.<br>
BinaryFormatter is contained in <i>mscorlib</i>; SoapFormatter is contained in <i>System.Run-<br>time.Serialization.Formatters.Soap.dll</i>.<br>
The SoapFormatter is less functional than the BinaryFormatter.<br>The SoapFormatter doesn't support generic types or the filtering<br>of extraneous data necessary for version tolerant serialization.<br>
<b>The Binary Serializer | 629</b><br>
<hr>
<A name=650></a>The two formatters are otherwise exactly the same to use. The following serializes<br>a Person with a BinaryFormatter:<br>
Person p = new Person() { Name = &quot;George&quot;, Age = 25 };<br>
IFormatter formatter = new BinaryFormatter();<br>
using (FileStream s = File.Create (&quot;serialized.bin&quot;))<br>  formatter.Serialize (s, p);<br>
All the data necessary to reconstruct the Person object is written to the file <i>serial-<br>ized.bin</i>. The Deserialize method restores the object:<br>
using (FileStream s = File.OpenRead (&quot;serialized.bin&quot;))<br>{<br>  Person p2 = (Person) formatter.Deserialize (s);<br>
  Console.WriteLine (p2.Name + &quot; &quot; + p.Age);     // George 25<br>
}<br>
The deserializer bypasses all constructors when re-creating ob-<br>jects. Behind the scenes, it calls FormatterServices.GetUninitia<br>lizedObject to do this job. You can call this method yourself to<br>implement some very grubby design patterns!<br>
The serialized data includes full type and assembly information, so if we try to cast<br>the result of deserialization to a matching Person type in a different assembly, an<br>error would result. The deserializer fully restores object references to their original<br>state upon deserialization. This includes collections, which are just treated as seri-<br>alizable  objects  like  any  other  (all  collection  types  in  System.Collections.*  are<br>marked as serializable).<br>
The  binary  engine  can  handle  large,  complex  object  graphs<br>without special assistance (other than ensuring that all partici-<br>pating members are serializable). One thing to be wary of is that<br>the serializer's performance degrades in proportion to the num-<br>ber of references in your object graph. This can become an issue<br>in  a  Remoting  server  that  has  to  process  many  concurrent<br>requests.<br>
<b>Binary Serialization Attributes<br>[NonSerialized]<br></b>Unlike data contracts, which have an <i>opt-in</i> policy in serializing fields, the binary<br>engine has an <i>opt-out</i> policy. Fields that you don't want serialized, such as those<br>used for temporary calculations, or for storing file or window handles, you must<br>mark explicitly with the [NonSerialized] attribute:<br>
<b>630 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=651></a>[Serializable] public sealed class Person<br>
{<br>  public string Name;<br>  public DateTime DateOfBirth;<br>
  // Age can be calculated, so there's no need to serialize it.<br>  <b>[NonSerialized]</b> public int Age;<br>}<br>
This instructs the serializer to ignore the Age member.<br>
Nonserialized members are always empty or null when deseri-<br>alized--even  if  field  initializers  or  constructors  set  them<br>otherwise.<br>
<b>[OnDeserializing] and [OnDeserialized]<br></b>Deserialization bypasses all your normal constructors, as well as field initializers.<br>This is of little consequence if every field partakes in serialization, but it can be<br>problematic if some fields are excluded via [NonSerialized]. We can illustrate this<br>by adding a bool field called Valid:<br>
public sealed class Person<br>
{<br>  public string Name;<br>  public DateTime DateOfBirth;<br>
  [NonSerialized] public int Age;<br>
  [NonSerialized] public bool Valid = true;<br>
  public Person() { Valid = true; }<br>
}<br>
A deserialized Person will not be Valid--despite the constructor and field initializer.<br>The  solution  is  the  same  as  with  the  data  contract  serializer:  to  define  a  special<br>deserialization "constructor" with the [OnDeserializing] attribute. A method that<br>you flag with this attribute gets called just prior to deserialization:<br>
[OnDeserializing]<br>
<b>Serialization</b><br>
void OnDeserializing (StreamingContext context)<br>{<br>  Valid = true;<br>}<br>
We could also write an [OnDeserialized] method to update the calculated Age field<br>(this fires just <i>after</i> deserialization):<br>
[OnDeserialized]<br>void OnDeserialized (StreamingContext context)<br>{<br>  TimeSpan ts = DateTime.Now - DateOfBirth;<br>  Age = ts.Days / 365;                         // Rough age in years<br>}<br>
<b>Binary Serialization Attributes | 631</b><br>
<hr>
<A name=652></a><b>[OnSerializing] and [OnSerialized]<br></b>The binary engine also supports the [OnSerializing] and [OnSerialized] attributes.<br>These flag a method for execution before or after serialization. To see how they can<br>be useful, we'll define a Team class that contains a generic List of players:<br>
[Serializable] public sealed class Team<br>{<br>  public string Name;<br>
  public List&lt;Person&gt; Players = new List&lt;Person&gt;();<br>
}<br>
This class serializes and deserializes correctly with the binary formatter but not the<br>SOAP formatter. This is because of an obscure limitation: the SOAP formatter re-<br>fuses to serialize generic types! An easy solution is to convert Players to an array just<br>prior to serialization, then convert it back to a generic List upon deserialization. To<br>make this work, we can add another field for storing the array, mark the original<br>Players field as [NonSerialized], and then write the conversion code in as follows:<br>
[Serializable] public sealed class Team<br>{<br>  public string Name;<br>
  Person[] _playersToSerialize;<br>
  <b>[NonSerialized]</b> public List&lt;Person&gt; Players = new List&lt;Person&gt;();<br>
  [OnSerializing]<br>  void OnSerializing (StreamingContext context)<br>  {<br>    _playersToSerialize = Players.ToArray();<br>  }<br>
  [OnSerialized]<br>  void OnSerialized (StreamingContext context)<br>  {<br>    _playersToSerialize = null;   // Allow it to be freed from memory<br>  }<br>
  [OnDeserialized]<br>  void OnDeserialized (StreamingContext context)<br>  {<br>    Players = new List&lt;Person&gt; (_playersToSerialize);<br>  }<br>}<br>
<b>[OptionalField] and Versioning<br></b>By default, adding a field breaks compatibility with data that's already serialized,<br>unless you attach the [OptionalField] attribute to the new field.<br>To illustrate, suppose we start with a Person class that has just one field. Let's call<br>it Version 1:<br>
<b>632 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=653></a>[Serializable] public sealed class Person       // Version 1<br>
{<br>  public string Name;<br>}<br>
Later, we realize we need a second field, so we create Version 2 as follows:<br>
[Serializable] public sealed class Person       // Version 2<br>
{<br>  public string Name;<br>  public DateTime DateOfBirth;<br>}<br>
If  two  computers  were  exchanging  Person  objects  via  Remoting,  deserialization<br>would go wrong unless they both updated to Version 2 at <i>exactly the same time</i>. The<br>OptionalField attribute gets around this problem:<br>
[Serializable] public sealed class Person       // Version 2 Robust<br>
{<br>  public string Name;<br>
  <b>[OptionalField (VersionAdded = 2)]</b> public DateTime DateOfBirth;<br>}<br>
This tells the deserializer not to panic if it sees no DateOfBirth in the data stream,<br>and instead to treat the missing field as nonserialized. This means you end up with<br>an  empty  DateTime  (you  can  assign  a  different  value  in  an  [OnDeserializing]<br>method).<br>
The VersionAdded argument is an integer that you increment each time you augment<br>a type's fields. This serves as documentation, and it has no effect on serialization<br>semantics.<br>
If  versioning  robustness  is  important,  avoid  renaming  and<br>deleting  fields  and  avoid  retrospectively  adding  the<br>NonSerialized attribute. Never change a field's type.<br>
So far we've focused on the backward-compatibility problem: the deserializer failing<br>to find an expected field in the serialization stream. But with two-way communica-<br>tion, a forward-compatibility problem can also arise whereby the deserializer en-<br>counters an extraneous field with no knowledge of how to process it. The binary<br>
<b>Serialization</b><br>
formatter is programmed to automatically cope with this by throwing away the ex-<br>traneous data; the SOAP formatter instead throws an exception! Hence, you must<br>use the binary formatter if two-way versioning robustness is required; otherwise,<br>manually control the serialization by implementing ISerializable.<br>
<b>Binary Serialization Attributes | 633</b><br>
<hr>
<A name=654></a><b>Binary Serialization with ISerializable<br></b>Implementing ISerializable gives a type complete control over its binary serializa-<br>tion and deserialization.<br>
Here's the ISerializable interface definition:<br>
public interface ISerializable<br>
{<br>  void GetObjectData (SerializationInfo info, StreamingContext context);<br>
}<br>
GetObjectData fires upon serialization; its job is to populate the SerializationInfo<br>object (a name-value dictionary) with data from all fields that you want serialized.<br>Here's how we would write a GetObjectData method that serializes two fields, called<br>Name and DateOfBirth:<br>
 public virtual void GetObjectData (SerializationInfo info,<br>
                                     StreamingContext context)<br>  {<br>    info.AddValue (&quot;Name&quot;, Name);<br>
    info.AddValue (&quot;DateOfBirth&quot;, DateOfBirth);<br>
  }<br>
In this example, we've chosen to name each item according to its corresponding<br>field. This is not required; any name can be used, as long as the same name is used<br>upon  deserialization.  The  values  themselves  can  be  of  any  serializable  type;  the<br>Framework will recursively serialize as necessary. It's legal to store null values in the<br>dictionary.<br>
It's a good idea to make the GetObjectData method virtual--<br>unless your class is sealed. This allows subclasses to extend se-<br>rialization without having to reimplement the interface.<br>
SerializationInfo also contains properties that you can use to control the type and<br>assembly that the instance should deserialize as. The StreamingContext parameter is<br>a structure that contains, among other things, an enumeration value indicating to<br>where the serialized instance is heading (disk, Remoting, etc., although this value is<br>not always populated).<br>
In addition to implementing ISerializable, a type controlling its own serialization<br>needs to provide a deserialization constructor that takes the same two parameters<br>as GetObjectData. The constructor can be declared with any accessibility and the<br>runtime will still find it. Typically, though, you would declare it protected so that<br>subclasses can call it.<br>
In the following example, we implement ISerializable in the Team class. When it<br>comes to handling the List of players, we serialize the data as an array rather than<br>a generic list, so as to offer compatibility with the SOAP formatter:<br>
<b>634 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=655></a>[Serializable] public class Team : ISerializable<br>
{<br>  public string Name;<br>  public List&lt;Person&gt; Players;<br>
  public virtual void GetObjectData (SerializationInfo si,<br>                                     StreamingContext sc)<br>  {<br>
    si.AddValue (&quot;Name&quot;, Name);<br>
    si.AddValue (&quot;PlayerData&quot;, Players.ToArray());<br>  }<br>
  public Team() {}<br>
  protected Team (SerializationInfo si, StreamingContext sc)<br>  {<br>    Name = si.GetString (&quot;Name&quot;);<br>
    // Deserialize Players to an array to match our serialization:<br>
    Person[] a = (Person[]) si.GetValue (&quot;PlayerData&quot;, typeof (Person[]));<br>
    // Construct a new List using this array:<br>
    Players = new List&lt;Person&gt; (a);<br>
  }<br>}<br>
For commonly used types, the SerializationInfo class has typed "Get" methods<br>such as GetString, in order to make writing deserialization constructors easier. If<br>you specify a name for which no data exists, an exception is thrown. This happens<br>most often when there's a version mismatch between the code doing the serialization<br>and deserialization. You've added an extra field, for instance, and then forgotten<br>about the implications of deserializing an old instance. To work around this prob-<br>lem, you can either:<br>
· Add exception handling around code that retrieves a data member added in a<br>
later version.<br>
· Implement your own version numbering system. For example:<br>
public string MyNewField;<br>
<b>Serialization</b><br>
public virtual void GetObjectData (SerializationInfo si,<br>                                     StreamingContext sc)<br>{<br>  si.AddValue (&quot;_version&quot;, 2);<br>  si.AddValue (&quot;MyNewField&quot;, MyNewField);<br>  ...<br>}<br>
protected Team (SerializationInfo si, StreamingContext sc)<br>{<br>  int version = si.GetInt32 (&quot;_version&quot;);<br>  if (version &gt;= 2) MyNewField = si.GetString (&quot;MyNewField&quot;);<br>  ...<br>}<br>
<b>Binary Serialization with ISerializable | 635</b><br>
<hr>
<A name=656></a><b>Subclassing Serializable Classes<br></b>In the preceding examples, we sealed the classes that relied on attributes for serial-<br>ization. To see why, consider the following class hierarchy:<br>
[Serializable] public class Person<br>
{<br>  public string Name;<br>
  public int Age;<br>}<br>
[Serializable] public sealed class Student <b>: Person</b><br>
{<br>  public string Course;<br>}<br>
In this example, both Person and Student are serializable, and both classes use the<br>default runtime serialization behavior since neither class implements ISerializable.<br>Now imagine that the developer of Person decides for some reason to implement<br>ISerializable and provide a deserialization constructor to control Person serializa-<br>tion. The new version of Person might look like this:<br>
[Serializable] public class Person : ISerializable<br>
{<br>  public string Name;<br>
  public int Age;<br>
  public virtual void GetObjectData (SerializationInfo si,<br>
                                     StreamingContext sc)<br>  {<br>
    si.AddValue (&quot;Name&quot;, Name);<br>    si.AddValue (&quot;Age&quot;, Age);<br>  }<br>
  protected Person (SerializationInfo si, StreamingContext sc)<br>  {<br>    Name = si.GetString (&quot;Name&quot;);<br>    Age = si.GetInt32 (&quot;Age&quot;);<br>  }<br>
  public Person() {}<br>}<br>
Although  this  works  for  instances  of  Person,  this  change  breaks  serialization  of<br>Student instances. Serializing a Student instance would appear to succeed, but the<br>Course field in the Student type isn't saved to the stream because the implementation<br>of ISerializable.GetObjectData on Person has no knowledge of the members of the<br>Student-derived type. Additionally, deserialization of Student instances throws an<br>exception since the runtime is looking (unsuccessfully) for a deserialization con-<br>structor on Student.<br>The  solution  to  this  problem  is  to  implement  ISerializable from the outset for<br>serializable classes that are public and nonsealed. (With internal classes, it's not so<br>important because you can easily modify the subclasses later if required.)<br>
<b>636 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=657></a>If we started out by writing Person as in the preceding example, Student would then<br>be written as follows:<br>
[Serializable]<br>public class Student : Person<br>
{<br>  public string Course;<br>
  public override void GetObjectData (SerializationInfo si,<br>                                      StreamingContext sc)<br>
  {<br>
    <b>base.GetObjectData (si, sc);</b><br>
    si.AddValue (&quot;Course&quot;, Course);<br>
  }<br>
  protected Student (SerializationInfo si, StreamingContext sc)<br>
    <b>: base (si, sc)</b><br>
  {<br>    Course = si.GetString (&quot;Course&quot;);<br>  }<br>
  public Student() {}<br>
}<br>
<b>XML Serialization<br></b>The  Framework  provides  a  dedicated  XML  serialization  engine  called  XmlSerial<br>izer in the System.Xml.Serialization namespace. It's suitable for serializing .NET<br>types to XML files and is also used implicitly by ASMX Web Services.<br>
As with the binary engine, there are two approaches you can take:<br>
· Sprinkle <br>
attributes <br>
throughout <br>
your <br>
types <br>
(defined <br>
in<br>
System.Xml.Serialization).<br>
· Implement IXmlSerializable.<br>
Unlike  with  the  binary  engine,  however,  implementing  the  interface  (i.e.,<br>IXmlSerializable) eschews the engine completely, leaving you to code the seriali-<br>zation yourself with XmlReader and XmlWriter.<br>
<b>Serialization</b><br>
<b>Getting Started with Attribute-Based Serialization<br></b>To use XmlSerializer, you instantiate it and call Serialize or Deserialize with a<br>Stream and object instance. To illustrate, suppose we define the following class:<br>
public class Person<br>{<br>  public string Name;<br>  public int Age;<br>}<br>
The following saves a Person to an XML file, and then restores it:<br>
Person p = new Person();<br>p.Name = &quot;Stacey&quot;; p.Age = 30;<br>
<b>XML Serialization | 637</b><br>
<hr>
<A name=658></a>XmlSerializer xs = new XmlSerializer (typeof (Person));<br>
using (Stream s = File.Create (&quot;person.xml&quot;))<br>  xs.Serialize (s, p);<br>
Person p2;<br>using (Stream s = File.OpenRead (&quot;person.xml&quot;))<br>  p2 = (Person) xs.Deserialize (s);<br>
Console.WriteLine (p2.Name + &quot; &quot; + p2.Age);   // Stacey 30<br>
Serialize  and  Deserialize  can  work  with  a  Stream,  XmlWriter/XmlReader,  or<br>TextWriter/TextReader. Here's the resultant XML:<br>
&lt;?xml version=&quot;1.0&quot;?&gt;<br>
&lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>
        xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;<br>
  &lt;Name&gt;Stacey&lt;/Name&gt;<br>
  &lt;Age&gt;30&lt;/Age&gt;<br>
&lt;/Person&gt;<br>
XmlSerializer can serialize types without any attributes--such as our Person type.<br>By default, it serializes all <i>public fields and properties</i> on a type. You can exclude<br>members you don't want serialized with the XmlIgnore attribute:<br>
public class Person<br>
{<br>  ...<br>  <b>[XmlIgnore]</b> public DateTime DateOfBirth;<br>}<br>
Unlike the other two engines, XmlSerializer does not recognize the [OnDeserializ<br>ing] attribute and relies instead on a parameterless constructor for deserialization,<br>throwing an exception if one is not present. (In our example, Person has an <i>im-<br>plicit</i> parameterless constructor.) This also means field initializers execute prior to<br>deserialization:<br>
public class Person<br>{<br>  public bool Valid <b>= true;</b>    // Executes before deserialization<br>}<br>
Although XmlSerializer can serialize almost any type, it recognizes the following<br>types and treats them specially:<br>
· The primitive types, DateTime, TimeSpan, Guid, and nullable versions<br>· byte[] (which is converted to base 64)<br>· An XmlAttribute or XmlElement (whose contents are injected into the stream)<br>· Any type implementing IXmlSerializable<br>· Any collection type<br>
The deserializer is version tolerant: it doesn't complain if elements or attributes are<br>missing or if superfluous data is present.<br>
<b>638 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=659></a><b>Attributes, names, and namespaces<br></b>By default, fields and properties serialize to an XML element. You can request an<br>XML attribute be used instead as follows:<br>
<b>[XmlAttribute]</b> public int Age;<br>
You can control an element or attribute's name as follows:<br>
public class Person<br>
{<br>  <b>[XmlElement (&quot;FirstName&quot;)]</b> public string Name;<br>
  <b>[XmlAttribute (&quot;RoughAge&quot;)]</b> public int Age;<br>
}<br>
Here's the result:<br>
&lt;Person RoughAge=&quot;30&quot; ...&gt;<br>
  &lt;FirstName&gt;Stacey&lt;/FirstName&gt;<br>&lt;/Person&gt;<br>
The default XML namespace is blank (unlike the data contract serializer, which uses<br>the  type's  namespace).  To  specify  an  XML  namespace,  [XmlElement]  and<br>[XmlAttribute] both accept a Namespace argument. You can also assign a name and<br>namespace to the type itself with [XmlRoot]:<br>
[XmlRoot (&quot;Candidate&quot;, Namespace = &quot;http://mynamespace/test/&quot;)]<br>
public class Person { ... }<br>
This names the person element "Candidate" as well as assigning a namespace to this<br>element and its children.<br>
<b>XML element order<br></b>XmlSerializer writes elements in the order that they're defined in the class. You can<br>change this by specifying an Order in the XmlElement attribute:<br>
public class Person<br>{<br>  [XmlElement (<b>Order = 2</b>)] public string Name;<br>  [XmlElement (<b>Order = 1</b>)] public int Age;<br>}<br>
If you use <br>
<b>Serialization</b><br>
Order at all, you must use it throughout.<br>
The deserializer is not fussy about the order of elements--they can appear in any<br>sequence and the type will properly deserialize.<br>
<b>Subclasses and Child Objects</b><br>
<b>Subclassing the root type<br></b>Suppose your root type has two subclasses as follows:<br>
public class Person { public string Name; }<br>
public class Student : Person { }<br>public class Teacher : Person { }<br>
<b>XML Serialization | 639</b><br>
<hr>
<A name=660></a>and you write a reusable method to serialize the root type:<br>
public void SerializePerson (Person p, string path)<br>
{<br>  XmlSerializer xs = new XmlSerializer (typeof (Person));<br>  using (Stream s = File.Create (path))<br>    xs.Serialize (s, p);<br>
}<br>
To  make  this  method  work  with  a  Student  or  Teacher,  you  must  inform<br>XmlSerializer about the subclasses. There are two ways to do this. The first is to<br>register each subclass with the XmlInclude attribute:<br>
<b>[XmlInclude (typeof (Student))]<br>[XmlInclude (typeof (Teacher))]</b><br>
public class Person { public string Name; }<br>
The second is to specify each of the subtypes when constructing XmlSerializer:<br>
XmlSerializer xs = new XmlSerializer (typeof (Person),<br>
                     <b>new Type[] { typeof (Student), typeof (Teacher) } );</b><br>
In either case, the serializer responds by recording the subtype in the type attribute<br>(just like with the data contract serializer):<br>
&lt;Person xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>
        <b>xsi:type=&quot;Student&quot;&gt;</b><br>
  &lt;Name&gt;Stacey&lt;/Name&gt;<br>
&lt;/Person&gt;<br>
This deserializer then knows from this attribute to instantiate a Student and not a<br>Person.<br>
You can control the name that appears in the XML type attrib-<br>ute by applying [XmlType] to the subclass:<br>
[XmlType (&quot;<b>Candidate</b>&quot;)]<br>public class Student : Person { }<br>
Here's the result:<br>
&lt;Person xmlns:xsi=&quot;...&quot;<br>        xsi:type=&quot;<b>Candidate</b>&quot;&gt;<br>
<b>Serializing child objects<br></b>XmlSerializer automatically recurses object references such as the HomeAddress field<br>in Person:<br>
public class Person<br>{<br>  public string Name;<br>
  <b>public Address HomeAddress = new Address();<br>}</b><br>
public class Address { public string Street, PostCode; }<br>
<b>640 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=661></a>To demonstrate:<br>
Person p = new Person(); p.Name = &quot;Stacey&quot;;<br>
p.HomeAddress.Street = &quot;Odo St&quot;;<br>
p.HomeAddress.PostCode = &quot;6020&quot;;<br>
Here's the XML to which this serializes:<br>
&lt;Person ... &gt;<br>  &lt;Name&gt;Stacey&lt;/Name&gt;<br>  <b>&lt;HomeAddress&gt;</b><br>
    <b>&lt;Street&gt;Odo St&lt;/Street&gt;</b><br>
    <b>&lt;PostCode&gt;6020&lt;/PostCode&gt;<br></b>  <b>&lt;/HomeAddress&gt;<br></b>&lt;/Person&gt;<br>
If you have two fields or properties that refer to the same object,<br>that object is serialized twice. If you need to preserve referential<br>equality, you must use another serialization engine.<br>
<b>Subclassing child objects<br></b>Suppose you need to serialize a Person that can reference <i>subclasses</i> of Address as<br>follows:<br>
public class Address { public string Street, PostCode; }<br>
public class USAddress : Address {  }<br>
public class AUAddress : Address {  }<br>
public class Person<br>{<br>  public string Name;<br>  public Address HomeAddress = new <b>USAddress</b>();<br>}<br>
There  are  two  distinct  ways  to  proceed,  depending  on  how  you  want  the  XML<br>structured. If you want the element name always to match the field or property name<br>with the subtype recorded in a type attribute:<br>
&lt;Person ...&gt;<br>  ...<br>
<b>Serialization</b><br>
  &lt;HomeAddress <b>xsi:type=&quot;USAddress&quot;</b>&gt;<br>    ...<br>  &lt;/HomeAddress&gt;<br>&lt;/Person&gt;<br>
you use [XmlInclude] to register each of the subclasses with Address as follows:<br>
<b>[XmlInclude (typeof (AUAddress))]<br>[XmlInclude (typeof (USAddress))]<br></b>public class Address<br>{<br>  public string Street, PostCode;<br>}<br>
<b>XML Serialization | 641</b><br>
<hr>
<A name=662></a>If, on the other hand, you want the element name to reflect the name of the subtype,<br>to the following effect:<br>
&lt;Person ...&gt;<br>  ...<br>
  <b>&lt;USAddress&gt;</b><br>
    ...<br>  <b>&lt;/USAddress&gt;<br></b>&lt;/Person&gt;<br>
you instead stack multiple [XmlElement] attributes onto the field or property in the<br>parent type:<br>
public class Person<br>{<br>  public string Name;<br>
  <b>[XmlElement (&quot;Address&quot;, typeof (Address))]<br></b>  <b>[XmlElement (&quot;AUAddress&quot;, typeof (AUAddress))]</b><br>
  <b>[XmlElement (&quot;USAddress&quot;, typeof (USAddress))]<br></b>  public Address HomeAddress = new USAddress();<br>
}<br>
Each XmlElement maps an element name to a type. If you take this approach, you<br>don't require the [XmlInclude] attributes on the Address type (although their pres-<br>ence doesn't break serialization).<br>
If you omit the element name in [XmlElement] (and specify just<br>a type), the type's default name is used (which is influenced by<br>[XmlType] but not [XmlRoot]).<br>
<b>Serializing Collections<br></b>XmlSerializer  recognizes  and  serializes  concrete  collection  types  without<br>intervention:<br>
public class Person<br>{<br>  public string Name;<br>  <b>public List&lt;Address&gt; Addresses = new List&lt;Address&gt;();</b><br>
}<br>
public class Address { public string Street, PostCode; }<br>
Here's the XML to which this serializes:<br>
&lt;Person ... &gt;<br>  &lt;Name&gt;...&lt;/Name&gt;<br>  &lt;Addresses&gt;<br>    &lt;Address&gt;<br>      &lt;Street&gt;...&lt;/Street&gt;<br>      &lt;Postcode&gt;...&lt;/Postcode&gt;<br>    &lt;/Address&gt;<br>    &lt;Address&gt;<br>
<b>642 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=663></a>      &lt;Street&gt;...&lt;/Street&gt;<br>
      &lt;Postcode&gt;...&lt;/Postcode&gt;<br>    &lt;/Address&gt;<br>    ...<br>
  &lt;/Addresses&gt;<br>
&lt;/Person&gt;<br>
The [XmlArray] attribute lets you rename the <i>outer</i> element (i.e., Addresses).<br>The [XmlArrayItem] attribute lets you rename the <i>inner</i> elements (i.e., the Address<br>elements).<br>
For instance, the following class:<br>
public class Person<br>{<br>  public string Name;<br>
  <b>[XmlArray (&quot;PreviousAddresses&quot;)]</b><br>
  <b>[XmlArrayItem (&quot;Location&quot;)]</b><br>
  public List&lt;Address&gt; Addresses = new List&lt;Address&gt;();<br>}<br>
serializes to this:<br>
&lt;Person ... &gt;<br>
  &lt;Name&gt;...&lt;/Name&gt;<br>
  &lt;<b>PreviousAddresses</b>&gt;<br>
    &lt;<b>Location</b>&gt;<br>      &lt;Street&gt;...&lt;/Street&gt;<br>      &lt;Postcode&gt;...&lt;/Postcode&gt;<br>    &lt;/<b>Location</b>&gt;<br>    &lt;<b>Location</b>&gt;<br>      &lt;Street&gt;...&lt;/Street&gt;<br>      &lt;Postcode&gt;...&lt;/Postcode&gt;<br>    &lt;/<b>Location</b>&gt;<br>    ...<br>  &lt;/<b>PreviousAddresses</b>&gt;<br>&lt;/Person&gt;<br>
The  XmlArray  and  XmlArrayItem  attributes  also  allow  you  to  specify  XML<br>namespaces.<br>
<b>Serialization</b><br>
To serialize collections <i>without</i> the outer element, for example:<br>
&lt;Person ... &gt;<br>  &lt;Name&gt;...&lt;/Name&gt;<br>  &lt;Address&gt;<br>    &lt;Street&gt;...&lt;/Street&gt;<br>    &lt;Postcode&gt;...&lt;/Postcode&gt;<br>  &lt;/Address&gt;<br>  &lt;Address&gt;<br>    &lt;Street&gt;...&lt;/Street&gt;<br>    &lt;Postcode&gt;...&lt;/Postcode&gt;<br>  &lt;/Address&gt;<br>&lt;/Person&gt;<br>
<b>XML Serialization | 643</b><br>
<hr>
<A name=664></a>instead add [XmlElement] to the collection field or property:<br>
public class Person<br>
{<br>  ...<br>  <b>[XmlElement (&quot;Address&quot;)]<br></b>  public List&lt;Address&gt; Addresses = new List&lt;Address&gt;();<br>
}<br>
<b>Working with subclassed collection elements<br></b>The rules for subclassing collection elements follow naturally from the other sub-<br>classing rules. To encode subclassed elements with the type attribute, for example:<br>
&lt;Person ... &gt;<br>  &lt;Name&gt;...&lt;/Name&gt;<br>
  &lt;Addresses&gt;<br>
    &lt;Address <b>xsi:type=&quot;AUAddress&quot;</b>&gt;<br>
    ...<br>
add [XmlInclude] attributes to the base (Address) type as we did before. This works<br>whether or not you suppress serialization of the outer element.<br>
If you want subclassed elements to be named according to their type, for example:<br>
&lt;Person ... &gt;<br>
  &lt;Name&gt;...&lt;/Name&gt;<br>
  &lt;!--start of optional outer element--&gt;<br>
  <b>&lt;AUAddress&gt;<br></b>    &lt;Street&gt;...&lt;/Street&gt;<br>    &lt;Postcode&gt;...&lt;/Postcode&gt;<br>  <b>&lt;/AUAddress&gt;</b><br>
  <b>&lt;USAddress&gt;<br></b>    &lt;Street&gt;...&lt;/Street&gt;<br>    &lt;Postcode&gt;...&lt;/Postcode&gt;<br>  <b>&lt;/USAddress&gt;<br></b>  &lt;!--end of optional outer element--&gt;<br>&lt;/Person&gt;<br>
you must stack multiple [XmlArrayItem] or [XmlElement] attributes onto the collec-<br>tion field or property.<br>
Stack multiple [XmlArrayItem] attributes if you want to <i>include</i> the outer collection<br>element:<br>
[XmlArrayItem (&quot;Address&quot;,   typeof (Address))]<br>[XmlArrayItem (&quot;AUAddress&quot;, typeof (AUAddress))]<br>[XmlArrayItem (&quot;USAddress&quot;, typeof (USAddress))]<br>public List&lt;Address&gt; Addresses = new List&lt;Address&gt;();<br>
Stack multiple [XmlElement] attributes if you want to <i>exclude</i> the outer collection <br>element:<br>
[XmlElement (&quot;Address&quot;,   typeof (Address))]<br>[XmlElement (&quot;AUAddress&quot;, typeof (AUAddress))]<br>[XmlElement (&quot;USAddress&quot;, typeof (USAddress))]<br>public List&lt;Address&gt; Addresses = new List&lt;Address&gt;();<br>
<b>644 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=665></a><b>IXmlSerializable<br></b>Although attribute-based XML serialization is flexible, it has limitations. For in-<br>stance, you cannot add serialization hooks--nor can you serialize nonpublic mem-<br>bers. It's also awkward to use if the XML might present the same element or attribute<br>in a number of different ways.<br>
On  that  last  issue,  you  can  push  the  boundaries  somewhat  by  passing  an<br>XmlAttributeOverrides  object  into  XmlSerializer's  constructor.  There  comes  a<br>point, however, when it's easier to take an imperative approach. This is the job of<br>IXmlSerializable:<br>
public interface IXmlSerializable<br>
{<br>  XmlSchema GetSchema();<br>
  void ReadXml (XmlReader reader);<br>
  void WriteXml (XmlWriter writer);<br>}<br>
Implementing  this  interface  gives  you  total  control  over  the  XML  that's  read  or<br>written.<br>
A collection class that implements IXmlSerializable bypasses<br>XmlSerializer's  rules  for  serializing  collections.  This  can  be<br>useful if you need to serialize a collection with a payload--in<br>other words, additional fields or properties that would other-<br>wise be ignored.<br>
The rules for implementing IXmlSerializable are ReadXml should read the outer start<br>element, then the content, and then the outer end element, and WriteXml should<br>write just the content. For example:<br>
using System;<br>using System.Xml;<br>
using System.Xml.Schema;<br>using System.Xml.Serialization;<br>
public class Address : IXmlSerializable<br>
<b>Serialization</b><br>
{<br>  public string Street, PostCode;<br>
  public XmlSchema GetSchema() { return null; }<br>
  public void ReadXml(XmlReader reader)<br>  {<br>    <b>reader.ReadStartElement();<br></b>    Street   = reader.ReadElementContentAsString (&quot;Street&quot;, &quot;&quot;);<br>    PostCode = reader.ReadElementContentAsString (&quot;PostCode&quot;, &quot;&quot;);<br>    <b>reader.ReadEndElement();<br></b>  }<br> <br>
<b>XML Serialization | 645</b><br>
<hr>
<A name=666></a>  public void WriteXml (XmlWriter writer)<br>
  {<br>    writer.WriteElementString (&quot;Street&quot;, Street);<br>    writer.WriteElementString (&quot;PostCode&quot;, PostCode);<br>
  }<br>
}<br>
Serializing and deserializing an instance of Address via XmlSerializer automatically<br>calls the WriteXml and ReadXml methods. Further, if Person was defined as follows:<br>
public class Person<br>
{<br>  public string Name;<br>
  public Address HomeAddress;<br>
}<br>
IXmlSerializable would be called upon selectively to serialize the HomeAddress field.<br>
We describe XmlReader and XmlWriter at length in the first section of Chapter 11.<br>Also in Chapter 11, in "Patterns for Using XmlReader/XmlWriter" on page 459, we<br>provide examples of IXmlSerializable-ready classes.<br>
<b>646 | Chapter 16:</b><b>Serialization</b><br>
<hr>
<A name=667></a><b>17</b><br>
<b>Assemblies</b><br>
An assembly is the basic unit of deployment in .NET and is also the container for<br>all types. An assembly contains compiled types with their IL code, runtime resources,<br>and information to assist with versioning, security, and referencing other assemblies.<br>An assembly also defines a boundary for type resolution and security permissioning.<br>In  general,  an  assembly  comprises  a  single  Windows  <i>Portable  Executable</i>  (PE)<br>file--with an <i>.exe</i> extension in the case of an application, or a <i>.dll</i> extension in the<br>case of a reusable library.<br>
Most of the types in this chapter come from the following namespaces:<br>
System.Reflection<br>System.Resources<br>
System.Globalization<br>
<b>What's in an Assembly?<br></b>An assembly contains four kinds of things:<br>
<i>An assembly manifest</i><br>
Provides information to the .NET runtime, such as the assembly's name, ver-<br>sion, requested permissions, and other assemblies that it references<br>
<i>An application manifest</i><br>
Provides information to the operating system, such as how the assembly should<br>be deployed and whether administrative elevation is required<br>
<i>Compiled types</i><br>
The compiled IL code and metadata of the types defined within the assembly<br>
<i>Resources</i><br>
Other data embedded within the assembly, such as images and localizable text<br>
Of these, only the <i>assembly manifest</i> is mandatory, although an assembly nearly<br>always contains compiled types.<br>
<b>647</b><br>
<hr>
<A name=668></a>Assemblies are structured similarly whether they're executables or libraries. The<br>main difference with an executable is that it defines an entry point.<br>
<b>The Assembly Manifest<br></b>The assembly manifest serves two purposes:<br>
· It describes the assembly to the managed hosting environment.<br>· It acts as a directory to the modules, types, and resources in the assembly.<br>
Assemblies are hence <i>self-describing</i>. A consumer can discover all of an assembly's<br>data, types, and functions--without needing additional files.<br>
An assembly manifest is not something you add explicitly to an<br>assembly--it's  automatically  embedded  into  an  assembly  as<br>part of compilation.<br>
Here's a summary of the functionally significant data stored in the manifest:<br>
· The simple name of the assembly<br>· A version number (AssemblyVersion)<br>· A public key and signed hash of the assembly, if strongly named<br>· A list of referenced assemblies, including their version and public key<br>· A list of modules that comprise the assembly<br>· A list of types defined in the assembly and the module containing each type<br>· An optional set of security permissions requested or refused by the assembly<br>
(SecurityPermission)<br>
· The culture it targets, if a satellite assembly (AssemblyCulture)<br>
The manifest can also store the following informational data:<br>
· A full title and description (AssemblyTitle and AssemblyDescription)<br>· Company and copyright information (AssemblyCompany and AssemblyCopyright)<br>· A display version (AssemblyInformationalVersion)<br>· Additional attributes for custom data<br>
Some of this data is derived from arguments given to the compiler, such as the list<br>of referenced assemblies or the public key with which to sign the assembly. The rest<br>comes from assembly attributes, indicated in parentheses.<br>
You  can  view  the  contents  of  an  assembly's  manifest  with<br>the .NET tool <i>ildasm.exe</i>. In Chapter 18, we describe how to<br>use reflection to do the same programmatically.<br>
<b>648 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=669></a><b>Specifying assembly attributes<br></b>You  can  control  much  of  the  manifest's  content  with  assembly  attributes.  For<br>example:<br>
[assembly: AssemblyCopyright (&quot;\x00a9 Corp Ltd. All rights reserved.&quot;)]<br>
[assembly: AssemblyVersion (&quot;2.3.2.1&quot;)]<br>
These declarations are usually all defined in one file in your project. Visual Studio<br>automatically creates a file called <i>AssemblyInfo.cs</i> in the <i>Properties</i> folder with every<br>new C# project for this purpose, prepopulated with a default set of assembly at-<br>tributes that provide a starting point for further customization.<br>
<b>The Application Manifest<br></b>An application manifest is an XML file that communicates information about the<br>assembly to the operating system. An application manifest, if present, is read and<br>processed before the .NET-managed hosting environment loads the assembly--and<br>can influence how the operating system launches an application's process.<br>
An application manifest has a root element called assembly in the XML namespace<br>urn:schemas-microsoft-com:asm.v1:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>
&lt;assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;<br>
  &lt;!-- contents of manifest --&gt;<br>&lt;/assembly&gt;<br>
The following manifest instructs the OS to request administrative elevation when<br>the assembly runs under Windows Vista:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;<br>  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt;<br>    &lt;security&gt;<br>      &lt;requestedPrivileges&gt;<br>        <b>&lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; /&gt;<br></b>      &lt;/requestedPrivileges&gt;<br>    &lt;/security&gt;<br>  &lt;/trustInfo&gt;<br>&lt;/assembly&gt;<br>
We describe the consequences of requesting administrative elevation in Chapter 20.<br>
<b>Deploying an application manifest<br></b>You can deploy an application manifest in two ways:<br>
· As a specially named file located in the same folder as the assembly<br>
<b>Assemblies</b><br>
· Embedded within the assembly itself<br>
As a separate file, its name must match that of the assembly's, plus <i>.manifest</i>. If an<br>assembly was named <i>MyApp.exe</i>, its manifest would be named <i>MyApp.exe.manifest</i>.<br>
<b>What's in an Assembly? | 649</b><br>
<hr>
<A name=670></a>To embed an application manifest file into an assembly, first build the assembly and<br>then call the .NET mt tool as follows:<br>
mt -manifest MyApp.exe.manifest -outputresource:MyApp.exe;#1<br>
The .NET tool <i>ildasm.exe</i> is blind to the presence of an embed-<br>ded  application  manifest.  Visual  Studio,  however,  indicates<br>whether  an  embedded  application  manifest  is  present  if  you<br>double-click the assembly in Solution Explorer.<br>
<b>Modules<br></b>The contents of an assembly are actually packaged within one or more intermediate<br>containers, called <i>modules</i>. A module corresponds to a file containing the contents<br>of an assembly. The reason for this extra layer of containership is to allow an as-<br>sembly to span multiple files--a feature that's useful when building an assembly<br>containing code compiled in a mixture of programming languages.<br>
Figure  17-1  shows  the  normal  case  of  an  assembly  with  a  single  module.  Fig-<br>ure 17-2 shows a multifile assembly. In a multifile assembly, the "main" module<br>always contains the manifest; additional modules can contain IL and/or resources.<br>The manifest describes the relative location of all the other modules that make up<br>the assembly.<br>
<i>Figure 17-1. Single-file assembly</i><br>
Multifile assemblies have to be compiled from the command line: there's no support<br>in Visual Studio. To do this, you invoke the csc compiler with the /t switch to create<br>each module, and then link them with the assembly linker tool, <i>al.exe</i>.<br>
Although the need for multifile assemblies is rare, at times you need to be aware of<br>the extra level of containership that modules impose--even when dealing just with<br>single-module assemblies. The main scenario is with reflection (see "Reflecting As-<br>semblies"  on  page  700  and  "Emitting  Assemblies  and  Types"  on  page  714  in<br>Chapter 18).<br>
<b>650 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=671></a><i>Figure 17-2. Multifile assembly</i><br>
<b>The Assembly Class<br></b>The Assembly class in System.Reflection is a gateway to accessing assembly metadata<br>at runtime. There are a number of ways to obtain an assembly object: the simplest<br>is via a Type's Assembly property:<br>
Assembly a = typeof (Program).Assembly;<br>
You can also obtain an Assembly object by calling one of Assembly's static methods:<br>
GetExecutingAssembly<br>
Returns the assembly of the type that defines the currently executing function<br>
GetCallingAssembly<br>
Does the same as GetExecutingAssembly, but for the function that called the<br>currently executing function<br>
GetEntryAssembly<br>
Returns the assembly defining the application's original entry method<br>
Once you have an Assembly object, you can use its properties and methods to query<br>the assembly's metadata and reflect upon its types. Table 17-1 shows a summary of<br>these functions.<br>
<b>Assemblies</b><br>
<b>What's in an Assembly? | 651</b><br>
<hr>
<A name=672></a><i>Table 17-1. Assembly members</i><br>
<b>Functions</b><br>
<b>Purpose</b><br>
<b>See the section...</b><br>
FullName, GetName<br>
Returns the fully qualified name or an<br>
"Assembly Names" on page 655<br>
AssemblyName object<br>
CodeBase, Location<br>
Location of the assembly file<br>
"Resolving and Loading Assem-<br>blies" on page 671<br>
Load, LoadFrom, LoadFile<br>
Manually loads an assembly into the<br>
"Resolving and Loading Assem-<br>
current application domain<br>
blies" on page 671<br>
GlobalAssemblyCache<br>
Indicates whether the assembly is de-<br>
"The Global Assembly<br>
fined in the GAC<br>
Cache" on page 661<br>
GetSatelliteAssembly<br>
Locates the satellite assembly of a<br>
"Resources and Satellite Assem-<br>
given culture<br>
blies" on page 663<br>
GetType, GetTypes<br>
Returns a type, or all types, defined in<br>
"Reflecting and Activating<br>
the assembly<br>
Types" on page 682<br>
EntryPoint<br>
Returns the application's entry<br>
"Reflecting and Invoking Mem-<br>
method, as a MethodInfo<br>
bers" on page 688<br>
GetModules,<br>
Returns all modules, or the main mod-<br>
"Reflecting Assemblies"<br>
ManifestModule<br>
ule, of an assembly<br>
on page 700<br>
GetCustomAttributes<br>
Returns the assembly's attributes<br>
"Working with Attrib-<br>utes" on page 701<br>
<b>Strong Names and Assembly Signing<br></b>A <i>strongly named</i> assembly has a unique and untamperable identity. It works by<br>adding two bits of metadata to the manifest:<br>
· A <i>unique number</i> that belongs to the authors of the assembly<br>· A <i>signed hash</i> of the assembly, proving that the unique number holder produced<br>
the assembly<br>
This requires a public/private key pair. The <i>public key</i> provides the unique identi-<br>fying number, and the <i>private key</i> facilitates signing.<br>
<i>Strong-name</i>-signing is different from <i>Authenticode</i>-signing. We<br>cover Authenticode later in this chapter.<br>
The public key is valuable in guaranteeing the uniqueness of assembly references: a<br>strongly named assembly incorporates the public key into its identity. The signature<br>is valuable for security--it prevents a malicious party from tampering with your<br>assembly. Without your private key, no one can release a modified version of the<br>assembly without the signature breaking (causing an error when loaded). Of course,<br>someone could re-sign the assembly with a different key pair--but this would give<br>
<b>652 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=673></a>the assembly a different identity. Any application referencing the original assembly<br>would shun the imposter because public key tokens are written into references.<br>
Adding a strong name to a previously "weak" named assembly<br>changes its identity. For this reason, it pays to give production<br>assemblies strong names from the outset.<br>
A strongly named assembly can also be registered in the GAC.<br>
<b>How to Strongly Name an Assembly<br></b>To give an assembly a strong name, first generate a public/private key pair with the<br><i>sn.exe</i> utility:<br>
sn.exe -k MyKeyPair.snk<br>
This manufactures a new key pair and stores it to a file called <i>MyApp.snk</i>. If you<br>subsequently lose this file, you will permanently lose the ability to recompile your<br>assembly with the same identity.<br>
You then compile with the /keyfile switch:<br>
csc.exe <b>/keyfile:MyKeyPair.snk</b> Program.cs<br>
Visual Studio assists you with both steps in the Project Properties window.<br>
A strongly named assembly cannot reference a weakly named<br>assembly. This is another compelling reason to strongly name<br>all your production assemblies.<br>
The same key pair can sign multiple assemblies--they'll still have distinct identities<br>if their simple names differ. The choice as to how many key pair files to use within<br>an organization depends on a number of factors. Having a separate key pair for every<br>assembly is advantageous should you later transfer ownership of a particular appli-<br>cation (along with its referenced assemblies), in terms of minimum disclosure. But<br>it makes it harder for you to create a security policy that recognizes all of your as-<br>semblies. It also makes it harder to validate dynamically loaded assemblies.<br>
Prior  to  C#  2.0,  the  compiler  did  not  support  the  /keyfile<br>switch and you would specify a key file with the AssemblyKey<br>File attribute instead. This presented a security risk, because<br>the path to the key file would remain embedded in the assem-<br>bly's  metadata.  For  instance,  with  <i>ildasm</i>,  you  can  see  quite<br>
<b>Assemblies</b><br>
easily that the path to the key file used to sign <i>mscorlib</i> in CLR<br>1.1 was as follows:<br>
F:\qfe\Tools\devdiv\EcmaPublicKey.snk<br>
Obviously,  you  need  access  to  that  folder  on  Micro-<br>soft's .NET Framework build machine to take advantage of that<br>information!<br>
<b>Strong Names and Assembly Signing | 653</b><br>
<hr>
<A name=674></a><b>Delay Signing<br></b>In an organization with hundreds of developers, you might want to restrict access<br>to the key pairs used for signing assemblies, for a couple of reasons:<br>
· If a key pair gets leaked, your assemblies are no longer untamperable.<br>· A test assembly, if signed and leaked, could be maliciously propagated as the<br>
real assembly.<br>
Withholding key pairs from developers, though, means they cannot compile and<br>test assemblies with their correct identity.  <i>Delay signing</i> is a system for working<br>around this problem.<br>
A delay-signed assembly is flagged with the correct public key, but not <i>signed</i> with<br>the private key. A delay-signed assembly is equivalent to a tampered assembly and<br>would normally be rejected by the CLR. The developer, however, instructs the CLR<br>to bypass validation for the delay-sign assemblies on <i>that computer</i>, allowing the<br>unsigned assemblies to run. When it comes time for final deployment, the private<br>key holder re-signs the assembly with the real key pair.<br>
To delay-sign, you need a file containing <i>just</i> the public key. You can extract this<br>from a key pair by calling sn with the -p switch:<br>
sn -k KeyPair.snk<br>
sn -p KeyPair.snk PublicKeyOnly.pk<br>
<i>KeyPair.snk</i> is kept secure and <i>PublicKeyOnly.pk</i> is freely distributed.<br>
You can also obtain <i>PublicKeyOnly.pk</i> from an existing signed<br>assembly with the -e switch:<br>
sn -e YourLibrary.dll PublicKeyOnly.pk<br>
You  then  delay-sign  with  <i>PublicKeyOnly.pk</i>  by  calling  csc  with  the  /delaysign+<br>switch:<br>
csc <b>/delaysign+</b> /keyfile: PublicKeyOnly.pk /target:library YourLibrary.cs<br>
Visual Studio does the same if you tick the "Delay sign" checkbox.<br>
The next step is to instruct the .NET runtime to skip assembly identity verification<br>on the development computers running the delay-signed assemblies. This can be<br>done on either a per-assembly or a per-public key basis, by calling the sn tool with<br>the Vr switch:<br>
sn -<b>Vr</b> YourLibrary.dll<br>
Visual  Studio  does  not  perform  this  step  automatically.  You<br>must disable assembly verification manually from the command<br>line. Otherwise, your assembly will not execute.<br>
<b>654 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=675></a>The final step is to fully sign the assembly prior to deployment. This is when you<br>replace the null signature with a real signature that can be generated only with access<br>to the private key. To do this, you call sn with the R switch:<br>
sn -R YourLibrary.dll KeyPair.snk<br>
You can then reinstate assembly verification on development machines as follows:<br>
sn <b>-Vu</b> YourLibrary.dll<br>
You won't need to recompile any applications that reference the delay-signed as-<br>sembly, because you've changed only the assembly's signature, not its <i>identity</i>.<br>
<b>Assembly Names<br></b>An assembly's "identity" comprises four pieces of metadata from its manifest:<br>
· Its simple name<br>· Its version ("0.0.0.0" if not present)<br>· Its culture ("neutral" if not a satellite)<br>· Its public key token ("null" if not strongly named)<br>
The simple name comes not from any attribute, but from the name of the file to<br>which it was originally compiled (less any extension). So, the simple name of the<br><i>System.Xml.dll</i> assembly is "System.Xml". Renaming a file doesn't change the as-<br>sembly's simple name.<br>
The version number comes from the AssemblyVersion attribute. It's a string divided<br>into four parts as follows:<br>
<i>major</i>.<i>minor</i>.<i>build</i>.<i>revision</i><br>
You can specify a version number as follows:<br>
[assembly: AssemblyVersion (&quot;2.5.6.7&quot;)]<br>
The culture comes from the AssemblyCulture attribute and applies to satellite as-<br>semblies,  described  later  in  the  section  "Resources  and  Satellite  Assem-<br>blies" on page 663.<br>
The  public  key  token  comes  from  a  key  pair  supplied  at  compile  time  via<br>the /keyfile switch, as we saw earlier, in the section "Strong Names and Assembly<br>Signing" on page 652.<br>
<b>Fully Qualified Names<br></b>A fully qualified assembly name is a string that includes all four identifying compo-<br>
<b>Assemblies</b><br>
nents, in this format:<br>
<i>simple-name</i>, Version=<i>version</i>, Culture=<i>culture</i>, PublicKeyToken=<i>public-key</i><br>
For example, the fully qualified name of <i>System.Xml.dll</i> is:<br>
&quot;System.Xml, Version=2.0.0.0, Culture=neutral,<br>PublicKeyToken=b77a5c561934e089&quot;<br>
<b>Assembly Names | 655</b><br>
<hr>
<A name=676></a>If the assembly has no AssemblyVersion attribute, the version appears as "0.0.0.0".<br>If it is unsigned, its public key token appears as "null".<br>
An Assembly object's FullName property returns its fully qualified name. The compiler<br>always  uses  fully  qualified  names  when  recording  assembly  references  in  the<br>manifest.<br>
A fully qualified assembly name does not include a directory<br>path to assist in locating it on disk. Locating an assembly resid-<br>ing in another directory is an entirely separate matter that we<br>pick up in "Resolving and Loading Assemblies" on page 671.<br>
<b>The AssemblyName Class<br></b>AssemblyName is a class with a typed property for each of the four components of a<br>fully qualified assembly name. AssemblyName has two purposes:<br>
· It parses or builds a fully qualified assembly name.<br>· It stores some extra data to assist in resolving (finding) the assembly.<br>
You can obtain an AssemblyName object in any of the following ways:<br>
· Instantiate an AssemblyName, providing a fully qualified name.<br>· Call GetName on an existing Assembly.<br>· Call AssemblyName.GetAssemblyName, providing the path to an assembly file on<br>
disk.<br>
You can also instantiate an AssemblyName object without any arguments, and then<br>set each of its properties to build a fully qualified name. An AssemblyName is mutable<br>when constructed in this manner.<br>
Here are its essential properties and methods:<br>
string      FullName    { get; }            // Fully qualified name<br>string      Name        { get; set; }       // Simple name<br>Version     Version     { get; set; }       // Assembly version<br>CultureInfo CultureInfo { get; set; }       // For satellite assemblies<br>string      CodeBase    { get; set; }       // Location<br>
byte[]      GetPublicKey();                 // 160 bytes<br>void        SetPublicKey (byte[] key);<br>byte[]      GetPublicKeyToken();            // 8-byte version<br>void        SetPublicKeyToken (byte[] publicKeyToken);<br>
Version is itself a strongly typed representation, with properties for Major, Minor,<br>Build, and Revision numbers. GetPublicKey returns the full cryptographic public<br>key; GetPublicKeyToken returns the last eight bytes used in establishing identity.<br>To use AssemblyName to obtain the simple name of an assembly:<br>
Console.WriteLine (typeof (string).Assembly.GetName().Name);  // mscorlib<br>
<b>656 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=677></a>To get an assembly version:<br>
string v = myAssembly.GetName().Version.ToString();<br>
We'll examine the CodeBase property in the later section "Resolving and Loading<br>Assemblies" on page 671.<br>
<b>Assembly Informational and File Versions<br></b>Because  an  integral  part  of  an  assembly  name  is  its  version,  changing  the<br>AssemblyVersion attribute changes the assembly's identity. This affects compatibility<br>with referencing assemblies, which can be undesirable when making nonbreaking<br>updates. To address this, there are two other independent assembly-level attributes<br>for expressing version-related information, both of which are ignored by the CLR:<br>
AssemblyInformationalVersion<br>
The version as displayed to the end-user. This is visible in the Windows File<br>Properties dialog as "Product Version". Any string can go here, such as "5.1<br>Beta 2". Typically, all the assemblies in an application would be assigned the<br>same informational version number.<br>
AssemblyFileVersion<br>
This is intended to refer to the build number for that assembly. This is visible<br>in the Windows File Properties dialog as "File Version". As with AssemblyVer<br>sion, it must contain a string consisting of up to four numbers separated by <br>periods.<br>
<b>Authenticode Signing<br></b><i>Authenticode</i> is a code-signing system whose purpose is to prove the identity of the<br>publisher. Authenticode and <i>strong-name</i> signing are independent: you can sign an<br>assembly with either or both systems.<br>
While  strong-name  signing  can  prove  that  assemblies  A,  B,  and  C  came  from<br>the same party (assuming the private key hasn't been leaked), it can't tell you who<br>that party was. In order to know that the party was Joe Albahari--or Microsoft<br>Corporation--you need Authenticode.<br>
Authenticode is useful when downloading programs from the Internet, because it<br>can prove that a program came from whoever was named by the Certificate Au-<br>thority and was not modified in transit. In fact, one of the main benefits of Authen-<br>ticode is that it prevents the "Unknown Publisher" warning shown in Figure 17-3,<br>when running a downloaded application for the first time. This makes Authenticode<br>particularly applicable to setup programs or standalone executables. (A reason to<br>
<b>Assemblies</b><br>
apply Authenticode to assemblies more broadly is that it's a requirement for the<br>Windows Logo program.)<br>
Authenticode works with not only .NET assemblies, but also unmanaged executa-<br>bles and binaries such as ActiveX controls or <i>.msi</i> deployment files. Of course, Au-<br>thenticode doesn't guarantee that a program is free from malware--although it does<br>
<b>Authenticode Signing | 657</b><br>
<hr>
<A name=678></a><IMG src="c#-4-nutshell-678_1.jpg"><br>
<i>Figure 17-3. Unsigned file warning</i><br>
make it less likely. A person or entity has been willing to put its name (backed by a<br>passport or company document) behind the executable or library.<br>
The CLR does not treat an Authenticode signature as part of an<br>assembly's identity. However, it can read and validate Authen-<br>ticode signatures on demand, as we'll see soon.<br>
Signing with Authenticode requires that you contact a <i>Certificate Authority</i> (CA)<br>with evidence of your personal identity or company's identity (articles of incorpo-<br>ration, etc.). Once the CA has checked your documents, it will issue an X.509 code-<br>signing certificate that is typically valid for one to five years. This enables you to sign<br>assemblies with the <i>signtool</i> utility. You can also make a certificate yourself with the<br><i>makecert</i> utility; however, this is useful only for testing because the certificate won't<br>be valid on other computers.<br>
Authenticode relies on a public key infrastructure: essentially, it proves that a pro-<br>gram was signed with a certificate whose credentials were verified by a CA. The CA<br>itself is trusted because all CAs are loaded into the operating system (to see them,<br>go  to  the  Windows  Control  Panel  and  choose  Internet  OptionsContent<br>tabCertificates  buttonTrusted  Root  Certification  Authorities  tab).  A  CA  can<br>revoke a publisher's certificate if leaked, so verifying an Authenticode signature re-<br>quires periodically asking the CA for an up-to-date list of certification revocations.<br>
Because Authenticode uses cryptographic signing, an Authenticode signature is in-<br>valid  if  someone  subsequently  tampers  with  the  file.  We  discuss  cryptography,<br>hashing, and signing in Chapter 20.<br>
<b>658 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=679></a><b>How to Sign with Authenticode</b><br>
<b>Obtaining and installing a certificate<br></b>The first step is to obtain a code-signing certificate from a CA (see sidebar). You can<br>then  either  work  with  the  certificate  as  a  password-protected  file,  or  load  the<br>certificate into the computer's certificate store. The benefit of doing the latter is that<br>you can sign without needing to specify a password. This is advantageous because<br>it avoids having a password visible in automated build scripts or batch files.<br>
<b>Where to Get a Code-Signing Certificate</b><br>
Just a handful of code-signing CAs are preloaded into Windows as root certifica-<br>tion authorities. These include (with prices for one-year code-signing certificates<br>at the time of publication) Comodo ($180), Go Daddy ($200), GlobalSign ($229),<br>thawte ($299), and VeriSign ($499).<br>
There is also a reseller called Ksoftware, which currently offers Comodo code-<br>signing certificates for $99 per year.<br>
The  Authenticode  certificates  issued  by  Ksoftware,  Comodo,  Go  Daddy,  and<br>GlobalSign  are  advertised  as  less  restrictive  in  that  they  will  also  sign<br>non-Microsoft programs such as Java applets. Aside from this, the products from<br>all vendors are functionally equivalent.<br>
Note that a certificate for SSL cannot generally be used for Authenticode signing<br>(despite using the same X.509 infrastructure). This is, in part, because a certificate<br>for SSL is about proving ownership of a domain; Authenticode is about proving<br>who you are.<br>
To load a certificate into the computer's certificate store, go to the Windows Control<br>Panel and select Internet OptionsContent tabCertificates buttonImport. Once<br>the import is complete, click the View button on the certificate, go to the Details<br>tab, and copy the certificate's <i>thumbprint</i>. This is the SHA-1 hash that you'll sub-<br>sequently need to identity the certificate when signing.<br>
If you also want to strong-name-sign your assembly (which is<br>highly  recommended),  you  must  do  so  <i>before</i>  Authenticode<br>signing. This is because the CLR knows about Authenticode<br>signing,  but  not  vice  versa.  So  if  you  strong-name-sign  an<br>assembly <i>after</i> Authenticode-signing it, the latter will see the<br>addition of the CLR's strong name as an unauthorized modifi-<br>
<b>Assemblies</b><br>
cation, and consider the assembly tampered.<br>
<b>Authenticode Signing | 659</b><br>
<hr>
<A name=680></a><b>Signing with signtool.exe<br></b>You can Authenticode-sign your programs with the <i>signtool</i> utility that comes with<br>Visual Studio. It displays a UI if you call it with the signwizard flag; otherwise, you<br>can use it in command-line style as follows:<br>
signtool sign /sha1 <i>(thumbprint)</i> <i>filename</i><br>
The thumbprint is that of the certificate as shown in the computer's certificate store.<br>(If the certificate is in a file instead, specify the filename with /f, and the password<br>with /p.)<br>For example:<br>
signtool sign /sha1 ff813c473dc93aaca4bac681df472b037fa220b3 LINQPad.exe<br>
You can also specify a description and product URL with /d and /du:<br>
 ... <b>/d</b> LINQPad <b>/du</b> http://www.linqpad.net<br>
In most cases, you will also want to specify a <i>time-stamping server</i>.<br>
<b>Time stamping<br></b>After your certificate expires, you'll no longer be able to sign programs. However,<br>programs that you signed <i>before</i> its expiry will still be valid--if you specified a <i>time-<br>stamping server</i> with the /t switch when signing. The CA will provide you with a<br>URI for this purpose: the following is for Comodo (or Ksoftware):<br>
 ... <b>/t</b> http://timestamp.comodoca.com/authenticode<br>
<b>Verifying that a program has been signed<br></b>The  easiest  way  to  view  an  Authenticode  signature  on  a  file  is  to  view  the  file's<br>properties in Windows Explorer (look in the Digital Signatures tab). The <i>signtool<br></i>utility also provides an option for this.<br>
<b>Authenticode Validation<br></b>Both the operating system and the CLR may validate Authenticode signatures.<br>
Windows validates Authenticode signatures before running programs marked as<br>"blocked"--in practice, this means programs run for the first time after having been<br>downloaded from the Internet. The status--or absence--of Authenticode informa-<br>tion is then shown in the dialog we saw in Figure 17-3.<br>
The CLR reads and validates Authenticode signatures when you ask for assembly<br>evidence. Here's how to do that:<br>
Publisher p = <i>someAssembly</i>.Evidence.<b>GetHostEvidence&lt;Publisher&gt;</b>();<br>
The Publisher class (in System.Security.Policy) exposes a Certificate property. If<br>this returns a non-null value, it has been Authenticode-signed. You can then query<br>this object for the details of the certificate.<br>
<b>660 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=681></a>Prior  to  Framework  4.0,  the  CLR  would  read  and  validate<br>Authenticode signatures when an assembly was loaded--rather<br>than  waiting  until  you  called  GetHostEvidence.  This  had<br>potentially disastrous performance consequences, because Au-<br>thenticode validation may round-trip to the CA to update the<br>certificate revocation list--which can take up to 30 seconds (to<br>fail) if there are Internet connectivity problems. For this reason,<br>it's best to avoid Authenticode-signing .NET 3.5 or earlier as-<br>semblies if possible. (Signing <i>.msi</i> setup files, though, is fine.)<br>
Regardless of the Framework version, if a program has a bad or unverifiable Au-<br>thenticode  signature,  the  CLR  will  merely  make  that  information  available  via<br>GetHostEvidence: it will never display a warning to the user or prevent the assembly<br>from running.<br>
As we said previously, an Authenticode signature has no effect on an assembly's<br>identity or <i>name</i>.<br>
<b>The Global Assembly Cache<br></b>As part of the .NET Framework installation, a central repository is created on the<br>computer for storing .NET assemblies, called the <i>Global Assembly Cache</i>, or GAC.<br>The GAC contains a centralized copy of the .NET Framework itself, and it can also<br>be used to centralize your own assemblies.<br>
The main factor in choosing whether to load your assemblies into the GAC relates<br>to versioning. For assemblies in the GAC, versioning is centralized at the machine<br>level and controlled by the computer's administrator. For assemblies outside the<br>GAC, versioning is handled on an application basis, so each application looks after<br>its own dependency and update issues (typically by maintaining its own copy of each<br>assembly that it references).<br>
The GAC is useful in the minority of cases where machine-centralized versioning is<br>genuinely advantageous. For example, consider a suite of interdependent plug-ins,<br>each referencing some shared assemblies. We'll assume each plug-in is in its own<br>directory, and for this reason, there's a possibility of there being multiple copies of<br>a shared assembly (maybe some later than others). Further, we'll assume the hosting<br>application will want to load each shared assembly just once for the sake of efficiency<br>and type compatibility. The task of assembly resolution is now difficult for the host-<br>ing application, requiring careful planning and an understanding of the subtleties<br>of assembly loading contexts. The simple solution here is to put the shared assem-<br>blies into the GAC. This ensures that the CLR always makes straightforward and<br>
<b>Assemblies</b><br>
consistent assembly resolution choices.<br>
In more typical scenarios, however, the GAC is best avoided because it adds the<br>following complications:<br>
· XCOPY or ClickOnce deployment is no longer possible; an administrative setup<br>
is required to install your application.<br>
<b>The Global Assembly Cache | 661</b><br>
<hr>
<A name=682></a>· Updating assemblies in the GAC also requires administrative privileges.<br>· Use of the GAC can complicate development and testing, because <i>fusion</i>, the<br>
CLR's assembly resolution mechanism, always favors GAC assemblies over lo-<br>cal copies.<br>
· Versioning and <i>side-by-side</i> execution require some planning, and a mistake<br>
may break other applications.<br>
On the positive side, the GAC can improve startup time for very large assemblies,<br>because the CLR verifies the signatures of assemblies in the GAC only once upon<br>installation, rather than every time the assembly loads. In percentage terms, this is<br>relevant if you've generated native images for your assemblies with the <i>ngen.exe</i> tool,<br>choosing nonoverlapping base addresses. A good article describing these issues is<br>available online at the MSDN site, titled "The Performance Benefits of NGen."<br>
Assemblies  in  the  GAC  are  always  fully  trusted--even  when<br>called from an assembly running in a limited-permissions sand-<br>box. We discuss this further in Chapter 20.<br>
<b>How to Install Assemblies to the GAC<br></b>To install assemblies to the GAC, the first step is to give your assembly a strong<br>name. Then you can install it using the .NET command-line tool, gacutil:<br>
gacutil /i MyAssembly.dll<br>
If the assembly already exists in the GAC with the <i>same public key and version</i>, it's<br>updated. You don't have to uninstall the old one first.<br>
To uninstall an assembly (note the lack of a file extension):<br>
gacutil /u MyAssembly<br>
You can also specify that assemblies be installed to the GAC as part of a setup project<br>in Visual Studio.<br>
Calling  gacutil  with  the  /l  switch  lists  all  assemblies  in  the  GAC.  You  can  do<br>the  same  with  the  <i>mscorcfg</i>  MMC  snap-in  (from  WindowAdministrative<br>ToolsFramework Configuration).<br>Once an assembly is loaded into the GAC, applications can reference it without<br>needing a local copy of that assembly.<br>
If a local copy <i>is</i> present, it's <i>ignored in favor of the GAC im-<br>age</i>. This means there's no way to reference or test a recompiled<br>version of your library--until you update the GAC. This holds<br>true as long as you preserve the assembly's version and identity.<br>
<b>662 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=683></a><b>GAC and Versioning<br></b>Changing an assembly's AssemblyVersion gives it a brand-new identity. To illustrate,<br>let's say you write a <i>utils</i> assembly, version it "1.0.0.0", strongly name it, and then<br>install it in the GAC. Then suppose later you add some new features, change the<br>version to "1.0.0.1", recompile it, and reinstall it into the GAC. Instead of overwrit-<br>ing the original assembly, the GAC now holds <i>both</i> versions. This means:<br>
· You can choose which version to reference when compiling another application<br>
that uses <i>utils</i>.<br>
· Any application previously compiled to reference <i>utils</i> 1.0.0.0 will <i>continue to</i><br>
<i>do so</i>.<br>
This is called <i>side-by-side</i> execution. Side-by-side execution prevents the "DLL hell"<br>that can otherwise occur when a shared assembly is unilaterally updated: applica-<br>tions designed for the older version might unexpectedly break.<br>
A complication arises, though, when you want to apply bug fixes or minor updates<br>to existing assemblies. You have two options:<br>
· Reinstall the fixed assembly to the GAC with the same version number.<br>· Compile the fixed assembly with a new version number and install that to the<br>
GAC.<br>
The difficulty with the first option is that there's no way to apply the update <i>selec-<br>tively</i> to certain applications. It's all or nothing. The difficulty with the second option<br>is that applications will not normally use the newer assembly version without being<br>recompiled. There is a workaround--you can create a <i>publisher policy</i> allowing as-<br>sembly version redirection--at the cost of increasing deployment complexity.<br>
Side-by-side execution is good for mitigating some of the problems of shared as-<br>semblies. If you avoid the GAC altogether--instead allowing each application to<br>maintain its own private copy of <i>utils</i>--you eliminate <i>all</i> of the problems of shared<br>assemblies!<br>
<b>Resources and Satellite Assemblies<br></b>An application typically contains not only executable code, but also content such<br>as  text,  images,  or  XML  files.  Such  content  can  be  represented  in  an  assembly<br>through a <i>resource</i>. There are two overlapping use cases for resources:<br>
· Incorporating data that cannot go into source code, such as images<br>· Storing data that might need translation in a multilingual application<br>
<b>Assemblies</b><br>
An assembly resource is ultimately a byte stream with a name. You can think of an<br>assembly as containing a dictionary of byte arrays keyed by string. This can be seen<br>in <i>ildasm</i> if we disassemble an assembly that contains a resource called <i>banner.jpg<br></i>and a resource called <i>data.xml</i>:<br>
<b>Resources and Satellite Assemblies | 663</b><br>
<hr>
<A name=684></a>.mresource public <b>banner.jpg</b><br>
{<br>  // Offset: 0x00000F58 Length: 0x000004F6<br>}<br>.mresource public <b>data.xml</b><br>
{<br>  // Offset: 0x00001458 Length: 0x0000027E<br>}<br>
In this case, <i>banner.jpg</i> and <i>data.xml</i> were included directly in the assembly--each<br>as its own embedded resource. This is the simplest way to work.<br>
The Framework also lets you add content through intermediate <i>.resources</i> contain-<br>ers. There are designed for holding content that may require translation into different<br>languages. Localized <i>.resources</i> can be packaged as individual satellite assemblies<br>that are automatically picked up at runtime, based on the user's operating system<br>language.<br>
Figure 17-4 illustrates an assembly that contains two directly embedded resources,<br>plus a <i>.resources</i> container called <i>welcome.resources</i>, for which we've created two<br>localized satellites.<br>
<i>Figure 17-4. Resources</i><br>
<b>Directly Embedding Resources<br></b>To directly embed a resource at the command line, use the /resource switch when<br>compiling:<br>
csc <b>/resource:banner.jpg</b> <b>/resource:data.xml</b> MyApp.cs<br>
You can optionally specify that the resource be given a different name in the assembly<br>as follows:<br>
<b>664 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=685></a>csc /resource:&lt;<i>file-name</i>&gt;,&lt;<i>resource-name</i>&gt;<br>
To directly embed a resource using Visual Studio:<br>
· Add the file to your project.<br>· Set its build action to "Embedded Resource".<br>
Visual Studio always prefixes resource names with the project's default namespace,<br>plus the names of any subfolders in which the file is contained. So, if your project's<br>default namespace was Westwind.Reports and your file was called <i>banner.jpg</i> in the<br>folder <i>pictures</i>, the resource name would be <i>Westwind.Reports.pictures.banner.jpg</i>.<br>
Resource  names  are  case-sensitive.  This  makes  project  sub-<br>folder names in Visual Studio that contain resources effectively<br>case-sensitive.<br>
To retrieve a resource, you call GetManifestResourceStream on the assembly con-<br>taining the resource. This returns a stream, which you can then read as any other:<br>
Assembly a = Assembly.GetEntryAssembly();<br>
<b>using (Stream s = a.GetManifestResourceStream (&quot;TestProject.data.xml&quot;))</b><br>
using (XmlReader r = XmlReader.Create (s))<br>
  ...<br>
System.Drawing.Image image;<br>
<b>using (Stream s = a.GetManifestResourceStream (&quot;TestProject.banner.jpg&quot;))<br></b>  image = System.Drawing.Image.FromStream (s);<br>
The stream returned is seekable, so you can also do this:<br>
<b>byte[] data;<br>using (Stream s = a.GetManifestResourceStream (&quot;TestProject.banner.jpg&quot;))<br></b>  <b>data = new BinaryReader (s).ReadBytes ((int) s.Length);</b><br>
If you've used Visual Studio to embed the resource, you must remember to include<br>the namespace-based prefix. To help avoid error, you can specify the prefix in a<br>separate argument, using a <i>type</i>. The type's namespace is used as the prefix:<br>
using (Stream s = a.GetManifestResourceStream (<b>typeof (X),</b> &quot;XmlData.xml&quot;))<br>
X can be any type with the desired namespace of your resource (typically, a type in<br>the same project folder).<br>
Setting  a  project  item's  build  action  in  Visual  Studio  to<br>"Resource" within a WPF application is <i>not</i> the same as setting<br>its build action to "Embedded Resource". The former actually<br>
<b>Assemblies</b><br>
adds the item to a <i>.resources</i> file called <i>&lt;AssemblyName&gt;.g.re-<br>sources</i>,  whose  content  you  access  through  WPF's<br>Application class, using a URI as a key.<br>
To add to the confusion, WPF further overloads the term "re-<br>source." <i>Static resources</i> and <i>dynamic resources</i> are both unre-<br>lated to assembly resources!<br>
<b>Resources and Satellite Assemblies | 665</b><br>
<hr>
<A name=686></a>GetManifestResourceNames returns the names of all resources in the assembly.<br>
<b>.resources Files<br></b><i>.resources</i> files are containers for potentially localizable content. A <i>.resources</i> file<br>ends up as an embedded resource within an assembly--just like any other kind of<br>file. The difference is that you must:<br>
· Package your content into the <i>.resources</i> file to begin with.<br>· Access  its  content  through  a  ResourceManager  or  <i>pack  URI</i>,  rather  than  a<br>
GetManifestResourceStream.<br>
<i>.resources</i> files are structured in binary and so are not human-editable; therefore,<br>you must rely on tools provided by the Framework and Visual Studio to work with<br>them. The standard approach with strings or simple data types is to use the <i>.resx<br></i>format, which can be converted to a <i>.resources</i> file either by Visual Studio or the<br>resgen tool. The <i>.resx</i> format is also suitable for images intended for a Windows<br>Forms or ASP.NET application.<br>
In a WPF application, you must use Visual Studio's "Resource" build action for<br>images or similar content needing to be referenced by URI. This applies whether<br>localization is needed or not.<br>
We describe how to do each of these in the following sections.<br>
<b>.resx Files<br></b>A <i>.resx</i> file is a design-time format for producing <i>.resources</i> files. A <i>.resx</i> file uses<br>XML and is structured with name/value pairs as follows:<br>
&lt;root&gt;<br>  &lt;data name=&quot;Greeting&quot;&gt;<br>    &lt;value&gt;hello&lt;/value&gt;<br>  &lt;/data&gt;<br>  &lt;data name=&quot;DefaultFontSize&quot; type=&quot;System.Int32, mscorlib&quot;&gt;<br>    &lt;value&gt;10&lt;/value&gt;<br>  &lt;/data&gt;<br>&lt;/root&gt;<br>
To create a <i>.resx</i> file in Visual Studio, add a project item of type "Resources File".<br>The rest of the work is done automatically:<br>
· The correct header is created.<br>· A designer is provided for adding strings, images, files, and other kinds of data.<br>· The <i>.resx</i> file is automatically converted to the <i>.resources</i> format and embedded<br>
into the assembly upon compilation.<br>
· A class is written to help you access the data later on.<br>
<b>666 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=687></a>The  resource  designer  adds  images  as  typed  Image  objects<br>(<i>System.Drawing.dll</i>), rather than as byte arrays, making them<br>unsuitable for WPF applications.<br>
<b>Creating a .resx file at the command line<br></b>If you're working at the command line, you must start with a <i>.resx</i> file that has a<br>valid header. The easiest way to accomplish this is to create a simple <i>.resx</i> file pro-<br>grammatically.  The  System.Resources.ResXResourceWriter class  (which,  pecu-<br>liarly, resides in the <i>System.Windows.Forms.dll</i> assembly) does exactly this job:<br>
using (ResXResourceWriter w = new ResXResourceWriter (&quot;welcome.resx&quot;)) { }<br>
From here, you can either continue to use the ResXResourceWriter to add resources<br>(by calling AddResource) or manually edit the <i>.resx</i> file that it wrote.<br>The easiest way to deal with images is to treat the files as binary data and convert<br>them to an image upon retrieval. This is also more versatile than encoding them as<br>a typed Image object. You can include binary data within a <i>.resx</i> file in base 64 format<br>as follows:<br>
&lt;data name=&quot;flag.png&quot; type=&quot;System.Byte[], mscorlib&quot;&gt;<br>  &lt;value&gt;Qk32BAAAAAAAAHYAAAAoAAAAMAMDAwACAgIAAAAD/AA....&lt;/value&gt;<br>
&lt;/data&gt;<br>
or as a reference to another file that is then read by resgen:<br>
&lt;data name=&quot;flag.png&quot;<br>  type=&quot;System.Resources.ResXFileRef, System.Windows.Forms&quot;&gt;<br>
  &lt;value&gt;<b>flag.png</b>;System.Byte[], mscorlib&lt;/value&gt;<br>&lt;/data&gt;<br>
When you're done, you must convert the <i>.resx</i> file by calling resgen. The following<br>converts <i>welcome.resx</i> into <i>welcome.resources</i>:<br>
resgen welcome.resx<br>
The final step is to include the <i>.resources</i> file when compiling, as follows:<br>
csc /resources:welcome.resources MyApp.cs<br>
<b>Reading .resources files</b><br>
If you create a <i>.resx</i> file in Visual Studio, a class of the same name<br>is generated automatically with properties to retrieve each of its<br>items.<br>
<b>Assemblies</b><br>
The ResourceManager class reads <i>.resources</i> files embedded within an assembly:<br>
ResourceManager r = new ResourceManager (&quot;welcome&quot;,<br>                                         Assembly.GetExecutingAssembly());<br>
<b>Resources and Satellite Assemblies | 667</b><br>
<hr>
<A name=688></a>(The first argument must be namespace-prefixed if the resource was compiled in<br>Visual Studio.)<br>
You can then access what's inside by calling GetStringor GetObject with a cast:<br>
string greeting = r.GetString (&quot;Greeting&quot;);<br>
int fontSize = (int) r.GetObject (&quot;DefaultFontSize&quot;);<br>Image image = (Image) r.GetObject (&quot;flag.png&quot;);       // (Visual Studio)<br>
byte[] imgData = (byte[]) r.GetObject (&quot;flag.png&quot;);   // (Command line)<br>
To enumerate the contents of a <i>.resources</i> file:<br>
ResourceManager r = new ResourceManager (...);<br>
ResourceSet set = r.GetResourceSet (CultureInfo.CurrentUICulture,<br>
                                    true, true);<br>
foreach (System.Collections.DictionaryEntry entry in set)<br>  Console.WriteLine (entry.Key);<br>
<b>Creating a pack URI resource in Visual Studio<br></b>In a WPF application, XAML files need to be able to access resources by URI. For<br>instance:<br>
&lt;Button&gt;<br>
  &lt;Image Height=&quot;50&quot; Source=&quot;flag.png&quot;/&gt;<br>&lt;/Button&gt;<br>
Or, if the resource is in another assembly:<br>
&lt;Button&gt;<br>  &lt;Image Height=&quot;50&quot; Source=&quot;UtilsAssembly;Component/flag.png&quot;/&gt;<br>&lt;/Button&gt;<br>
(Component is a literal keyword.)<br>To create resources that can be loaded in this manner, you cannot use <i>.resx</i> files.<br>Instead, you must add the files to your project and set their build action to "Re-<br>source"  (not  "Embedded  Resource").  Visual  Studio  then  compiles  them  into<br>a <i>.resources</i> file called <i>&lt;AssemblyName&gt;.g.resources</i>--also the home of compiled<br>XAML (<i>.baml</i>) files.<br>
Call  Application.GetResource-Stream  to  load  a  URI-keyed  resource<br>programmatically:<br>
Uri u = new Uri (&quot;flag.png&quot;, UriKind.Relative);<br>using (Stream s = Application.GetResourceStream (u).Stream)<br>
Notice we used a relative URI. You can also use an absolute URI in exactly the<br>following format (the three commas are not a typo):<br>
Uri u = new Uri (&quot;pack://application:,,,/flag.png&quot;);<br>
If you'd rather specify an Assembly object, you can retrieve content instead with a<br>ResourceManager:<br>
Assembly a = Assembly.GetExecutingAssembly();<br>ResourceManager r = new ResourceManager (a.GetName().Name + &quot;.g&quot;, a);<br>using (Stream s = r.GetStream (&quot;flag.png&quot;))<br>  ...<br>
<b>668 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=689></a>A ResourceManager also lets you enumerate the content of a <i>.g.resources</i> container<br>within a given assembly.<br>
<b>Satellite Assemblies<br></b>Data embedded in <i>.resources</i> is localizable.<br>
Resource localization is relevant when your application runs on a version of Win-<br>dows built to display everything in a different language. For consistency, your ap-<br>plication should use that same language too.<br>
A typical setup is as follows:<br>
· The main assembly contains <i>.resources</i> for the default or <i>fallback</i> language.<br>· Separate <i>satellite assemblies</i> contain localized <i>.resources</i> translated to different<br>
languages.<br>
When your application runs, the Framework examines the language of the current<br>operating system (from CultureInfo.CurrentUICulture). Whenever you request a<br>resource using ResourceManager, the Framework looks for a localized satellite as-<br>sembly. If one's available--and it contains the resource key you requested--it's used<br>in place of the main assembly's version.<br>
This means you can enhance language support simply by adding new satellites--<br>without changing the main assembly.<br>
A  satellite  assembly  cannot  contain  executable  code,  only<br>resources.<br>
Satellite  assemblies  are  deployed  in  subdirectories  of  the  assembly's  folder  as<br>follows:<br>
programBaseFolder\MyProgram.exe<br>                 \MyLibrary.exe<br>
                 \<i>XX</i>\MyProgram.resources.dll<br>                 \<i>XX</i>\MyLibrary.resources.dll<br>
<i>XX</i> refers to the two-letter language code (such as "de" for German) or a language<br>and region code (such as "en-GB" for English in Great Britain). This naming system<br>allows the CLR to find and load the correct satellite assembly automatically.<br>
<b>Building satellite assemblies</b><br>
<b>Assemblies</b><br>
Recall our previous <i>.resx</i> example, which included the following:<br>
&lt;root&gt;<br>  ...<br>  &lt;data name=&quot;Greeting&quot;<br>
    &lt;value&gt;hello&lt;/value&gt;<br>  &lt;/data&gt;<br>&lt;/root&gt;<br>
<b>Resources and Satellite Assemblies | 669</b><br>
<hr>
<A name=690></a>We then retrieved the greeting at runtime as follows:<br>
ResourceManager r = new ResourceManager (&quot;welcome&quot;,<br>
                                         Assembly.GetExecutingAssembly());<br>
Console.Write (r.GetString (&quot;Greeting&quot;));<br>
Suppose we want this to instead write "Hallo" if running on the German version of<br>Windows. The first step is to add another  <i>.resx</i> file named  <i>welcome.de.resx</i> that<br>substitutes <i>hello</i> for <i>hallo</i>:<br>
&lt;root&gt;<br>
  &lt;data name=&quot;Greeting&quot;&gt;<br>
    &lt;value&gt;hallo&lt;value&gt;<br>
  &lt;/data&gt;<br>
&lt;/root&gt;<br>
In Visual Studio, this is all you need to do--when you rebuild, a satellite assembly<br>called <i>MyApp.resources.dll</i> is automatically created in a subdirectory called <i>de</i>.<br>
If  you're  using  the  command  line,  you  call  resgen  to  turn  the  <i>.resx</i>  file  into<br>a<i> .resources</i> file:<br>
resgen MyApp.de.resx<br>
and then call al to build the satellite assembly:<br>
al /culture:de /out:MyApp.resources.dll /embed:MyApp.de.resources /t:lib<br>
You can specify /template:MyApp.exe to import the main assembly's strong name.<br>
<b>Testing satellite assemblies<br></b>To simulate running on an operating system with a different language, you must<br>change the CurrentUICulture using the Thread class:<br>
System.Threading.Thread.CurrentThread.CurrentUICulture<br>  = new System.Globalization.CultureInfo (&quot;de&quot;);<br>
CultureInfo.CurrentUICulture is a read-only version of the same property.<br>
<b>Visual Studio designer support<br></b>The designers in Visual Studio provide extended support for localizing components<br>and visual elements. The WPF designer has its own workflow for localization; other<br>Component-based designers use a design-time-only property to make it appear that a<br>component or Windows Forms control has a Language property. To customize for<br>another language, simply change the Language property and then start modifying the<br>component. All properties of controls that are attributed as Localizable will be per-<br>sisted to a <i>.resx</i> file for that language. You can switch between languages at any time<br>just by changing the Language property.<br>
<b>Cultures and Subcultures<br></b>Cultures are split into cultures and subcultures. A culture represents a particular<br>language;  a  subculture  represents  a  regional  variation  of  that  language.  The<br>
<b>670 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=691></a>Framework follows the RFC1766 standard, which represents cultures and subcultures<br>with two-letter codes. Here are the codes for English and German cultures:<br>
en<br>de<br>
Here are the codes for the Australian English and Austrian German subcultures:<br>
en-AU<br>
de-AT<br>
A culture is represented in .NET with the System.Globalization.CultureInfo class.<br>You can examine the current culture of your application as follows:<br>
Console.WriteLine (System.Threading.Thread.CurrentThread.CurrentCulture);<br>
Console.WriteLine (System.Threading.Thread.CurrentThread.CurrentUICulture);<br>
Running this on a computer localized for Australia illustrates the difference between<br>the two:<br>
EN-AU<br>
EN-US<br>
CurrentCulture reflects the regional settings of the Windows control panel, whereas<br>CurrentUICulture reflects the language of the operating system.<br>
Regional settings include such things as time zone and the formatting of currency<br>and  dates.  CurrentCulture  determines  the  default  behavior  of  such  functions  as<br>DateTime.Parse. Regional settings can be customized to the point where they no<br>longer resemble any particular culture.<br>
CurrentUICulture determines the language in which the computer communicates<br>with the user. Australia doesn't need a separate version of English for this purpose,<br>so it just uses the U.S. one. If I spent a couple of months working in Austria, I would<br>go to the control panel and change my CurrentCulture to Austrian-German. How-<br>ever, since I can't speak German, my CurrentUICulture would remain U.S. English.<br>
ResourceManager, by default, uses the current thread's CurrentUICulture property to<br>determine  the  correct  satellite  assembly  to  load.  ResourceManager uses a fallback<br>mechanism when loading resources. If a subculture assembly is defined, that one is<br>used;  otherwise,  it  falls  back  to  the  generic  culture.  If  the  generic  culture  is  not<br>present, it falls back to the default culture in the main assembly.<br>
<b>Resolving and Loading Assemblies<br></b>A typical application comprises a main executable assembly plus a set of referenced<br>library assemblies. For example:<br>
<b>Assemblies</b><br>
AdventureGame.exe<br>Terrain.dll<br>UIEngine.dll<br>
<i>Assembly resolution</i> refers to the process of locating referenced assemblies. Assembly<br>resolution happens both at compile time and at runtime. The compile-time system<br>is simple: the compiler knows where to find referenced assemblies because it's told<br>
<b>Resolving and Loading Assemblies | 671</b><br>
<hr>
<A name=692></a>where to look. You (or Visual Studio) provide the full path to referenced assemblies<br>that are not in the current directory.<br>
Runtime resolution is more complicated. The compiler writes the strong names of<br>referenced assemblies to the manifest--but not any hints as to where to find them.<br>In the simple case where you put all referenced assemblies in the same folder as the<br>main executable, there's no issue because that's (close to) the first place the CLR<br>looks. The complexities arise:<br>
· When you deploy referenced assemblies in other places<br>· When you dynamically load assemblies<br>
<b>Assembly and Type Resolution Rules<br></b>All types are scoped to an assembly. An assembly is like an address for a type. To<br>give an analogy, we can refer to a person as "Joe" (type name without namespace),<br>"Joe Bloggs" (full type name), or "Joe Bloggs of 100 Barker Ave, WA" (assembly-<br>qualified type name).<br>
During compilation, we don't need to go further than a full type name for unique-<br>ness, because you can't reference two assemblies that define the same full type name<br>(at least not without special tricks). At runtime, though, it's possible to have many<br>identically named types in memory. This happens within the Visual Studio designer,<br>for instance, whenever you <i>rebuild</i> the components you're designing. The only way<br>to distinguish such types is by their assembly; therefore, an assembly forms an es-<br>sential part of a type's runtime identity. An assembly is also a type's handle to its<br>code and metadata.<br>
The CLR loads assemblies at the point in execution when they're first needed. This<br>happens when you refer to one of the assembly's types. For example, suppose that<br><i>AdventureGame.exe</i> instantiates a type called TerrainModel.Map. Assuming no ad-<br>ditional configuration files, the CLR answers the following questions:<br>
· What's  the  fully  qualified  name  of  the  assembly  that  contained<br>
TerrainModel.Map when <i>AdventureGame.exe</i> was compiled?<br>
· Have I already loaded an assembly with this fully qualified name into memory<br>
in the same (resolution) context?<br>
If the answer to the second question is yes, it uses the existing copy in memory;<br>otherwise, it goes looking for the assembly. The CLR first checks the GAC, then the<br><i>probing</i> paths (generally the application base directory), and as a final resort, fires<br>the AppDomain.AssemblyResolve event. If none returns a match, the CLR throws an<br>exception.<br>
<b>AssemblyResolve<br></b>The AssemblyResolve event allows you to intervene and manually load an assembly<br>that the CLR can't find. If you handle this event, you can scatter referenced assem-<br>blies in a variety of locations and still have them load.<br>
<b>672 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=693></a>Within the AssemblyResolve event handler, you locate the assembly and load it by<br>calling  one  of  three  static  methods  in  the  Assembly  class:  Load,  LoadFrom,  or<br>LoadFile. These methods return a reference to the newly loaded assembly, which<br>you then return to the caller:<br>
static void Main()<br>{<br>  AppDomain.CurrentDomain.AssemblyResolve += FindAssembly;<br>  ...<br>
}<br>
static Assembly FindAssembly (object sender, ResolveEventArgs args)<br>
{<br>  string fullyQualifiedName = args.Name;<br>
  Assembly a = Assembly.LoadFrom (...);<br>
  return a;<br>
}<br>
The ResolveEventArgs event is unusual in that it has a return type. If there are mul-<br>tiple handlers, the first one to return a non-null Assembly wins.<br>
<b>Loading Assemblies<br></b>The  Load  methods  in  Assembly  are  useful  both  inside  and  outside  an<br>AssemblyResolve  handler.  Outside  the  event  handler,  they  can  load  and  execute<br>assemblies not referenced at compilation. An example of when you might do this is<br>to execute a plug-in.<br>
Think carefully before calling Load, LoadFrom, or LoadFile: these<br>methods permanently load an assembly into the current appli-<br>cation  domain--even  if  you  do  nothing  with  the  resultant<br>Assembly object. Loading an assembly has side effects: it locks<br>the  assembly  files  as  well  as  affecting  subsequent  type<br>resolution.<br>
The only way to unload an assembly is to unload the whole<br>application domain.<br>
If you just want to examine an assembly without executing any<br>of its code, you can instead use the reflection-only context (see<br>Chapter 18).<br>
To  load  an  assembly  from  a  fully  qualified  name  (without  a  location)  call<br>Assembly.Load. This instructs the CLR to find the assembly using its normal auto-<br>matic resolution system. The CLR itself uses Load to find referenced assemblies.<br>
<b>Assemblies</b><br>
To load an assembly from a filename, call LoadFrom or LoadFile.<br>To load an assembly from a URI, call LoadFrom.<br>To load an assembly from a byte array, call Load.<br>
<b>Resolving and Loading Assemblies | 673</b><br>
<hr>
<A name=694></a>You can see what assemblies are currently loaded in memory by<br>calling AppDomain's GetAssemblies method:<br>
foreach (Assembly a in<br>AppDomain.CurrentDomain.GetAssemblies())<br>
{<br>  Console.WriteLine (a.Location);        // file path<br>
  Console.WriteLine (a.GetName().Name);  // simple name<br>
}<br>
<b>Loading from a filename<br></b>LoadFrom and LoadFile can both load an assembly from a filename. They differ in<br>two ways. First, if an assembly with the same identity has already been loaded into<br>memory from another location, LoadFrom gives you the previous copy:<br>
Assembly a1 = Assembly.LoadFrom (@&quot;c:\<b>temp1</b>\lib.dll&quot;);<br>
Assembly a2 = Assembly.LoadFrom (@&quot;c:\<b>temp2</b>\lib.dll&quot;);<br>
Console.WriteLine (a1 == a2);                            // true<br>
LoadFile gives you a fresh copy:<br>
Assembly a1 = Assembly.LoadFile (@&quot;c:\<b>temp1</b>\lib.dll&quot;);<br>
Assembly a2 = Assembly.LoadFile (@&quot;c:\<b>temp2</b>\lib.dll&quot;);<br>Console.WriteLine (a1 == a2);                            // false<br>
If you load twice from an <i>identical</i> location, however, both methods give you the<br>previously cached copy. (In contrast, loading an assembly twice from an identical<br>byte array gives you two distinct Assembly objects.)<br>
Types from two identical assemblies in memory are incompat-<br>ible. This is the primary reason to avoid loading duplicate as-<br>semblies, and hence a reason to favor LoadFrom over LoadFile.<br>
Whether you use LoadFrom or LoadFile, the CLR always looks<br>first for the requested assembly in the GAC, and then the <i>prob-<br>ing  path</i>  (normally  the  application  base  directory).  If  you<br><i>really</i> want to load an assembly from a particular path, the only<br>way to do it is with ReflectionOnlyLoadFrom (which loads the<br>assembly into a reflection-only context). Even loading from a<br>byte array doesn't bypass the GAC, although it does bypass the<br>probing path:<br>
byte[] image = File.ReadAllBytes (assemblyPath);<br>Assembly a = Assembly.Load (image);<br>
Loading from a byte array also gets around the problem of lock-<br>ing assembly files! The drawback is that you must handle the<br>AppDomain's AssemblyResolve event in order to resolve any as-<br>semblies that the loaded assembly itself references.<br>
<b>674 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=695></a>The second difference between LoadFrom and LoadFile is that LoadFrom gives hints to<br>the CLR as to the location of onward references, whereas LoadFile does not. To<br>illustrate, suppose your application in <i>\folder1</i> loads an assembly in <i>\folder2</i> called<br><i>TestLib.dll</i>, which references <i>\folder2\Another.dll</i>:<br>
\folder1\MyApplication.exe<br>
\folder2\TestLib.dll<br>\folder2\Another.dll<br>
If you load <i>TestLib</i> with LoadFrom, the CLR will find and load <i>Another.dll</i>.<br>If you load <i>TestLib</i> with LoadFile, the CLR will be unable to find <i>Another.dll</i> and<br>will throw an exception--unless you also handle the AssemblyResolve event.<br>In the following sections, we demonstrate these methods in the context of some<br>practical applications.<br>
<b>Deploying Assemblies Outside the Base Folder<br></b>Sometimes you might choose to deploy assemblies to locations other than the ap-<br>plication base directory. For instance:<br>
..\MyProgram\<b>Main.exe<br></b>..\MyProgram\Libs\V1.23\GameLogic.dll<br>
..\MyProgram\Libs\V1.23\3DEngine.dll<br>
..\MyProgram\Terrain\Map.dll<br>
..\Common\TimingController.dll<br>
To make this work, you must assist the CLR in finding the assemblies outside the<br>base folder. The easiest solution is to handle the AssemblyResolve event.<br>In  the  following  example,  we  assume  all  additional  assemblies  are  located  in<br><i>c:\ExtraAssemblies</i>:<br>
using System;<br>using System.IO;<br>using System.Reflection;<br>
class Loader<br>{<br>  static void Main()<br>  {<br>    AppDomain.CurrentDomain.AssemblyResolve += FindAssembly;<br>
    // We must switch to another class before attempting to use<br>    // any of the types in c:\ExtraAssemblies:<br>    Program.Go();<br>
<b>Assemblies</b><br>
  }<br>
  static Assembly FindAssembly (object sender, ResolveEventArgs args)<br>  {<br>    string simpleName = new AssemblyName (args.Name).Name;<br>    string path = @&quot;c:\ExtraAssemblies\&quot; + simpleName + &quot;.dll&quot;;<br> <br>
<b>Deploying Assemblies Outside the Base Folder | 675</b><br>
<hr>
<A name=696></a>    if (!File.Exists (path)) return null;     // Sanity check<br>
    return Assembly.LoadFrom (path);          // Load it up!<br>  }<br>}<br>
class Program<br>{<br>  internal static void Go()<br>
  {<br>
    // Now we can reference types defined in c:\ExtraAssemblies<br>  }<br>}<br>
It's vitally important in this example not to reference types in<br><i>c:\ExtraAssemblies</i> directly from the Loader class (e.g., as fields),<br>because the CLR would then attempt to resolve the type before<br>hitting Main().<br>
In this example, we could use either LoadFrom or LoadFile. In either case, the CLR<br>verifies that the assembly that we hand it has the exact identity it requested. This<br>maintains the integrity of strongly named references.<br>
In Chapter 24, we describe another approach that can be used when creating new<br>application  domains.  This  involves  setting  the  application  domain's  PrivateBin<br>Path to include the directories containing the additional assemblies--extending the<br>standard assembly probing locations. A limitation of this is that the additional di-<br>rectories must all be <i>below</i> the application base directory.<br>
<b>Packing a Single-File Executable<br></b>Suppose you've written an application comprising 10 assemblies: 1 main executable<br>file, plus 9 DLLs. Although such granularity can be great for design and debugging,<br>it's  also  good  to  be  able  to  pack  the  whole  thing  into  a  single  "click  and  run"<br>executable--without demanding the user perform some setup or file extraction rit-<br>ual. You can accomplish this by including the compiled assembly DLLs in the main<br>executable  project  as  embedded  resources,  and  then  writing  an  AssemblyResolve<br>event handler to load their binary images on demand. Here's how it's done:<br>
using System;<br>using System.IO;<br>using System.Reflection;<br>using System.Collections.Generic;<br>
public class Loader<br>{<br>  static Dictionary &lt;string, Assembly&gt; _libs<br>   = new Dictionary &lt;string, Assembly&gt;();<br>
 <br>  static void Main()<br>  {<br>
<b>676 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=697></a>    AppDomain.CurrentDomain.AssemblyResolve += FindAssembly;<br>
    Program.Go();<br>  }<br>
  static Assembly FindAssembly (object sender, ResolveEventArgs args)<br>
  {<br>    string shortName = new AssemblyName (args.Name).Name;<br>    if (_libs.ContainsKey (shortName)) return _libs [shortName];<br>
    using (Stream s = Assembly.GetExecutingAssembly().<br>           GetManifestResourceStream (&quot;Libs.&quot; + shortName + &quot;.dll&quot;))<br>    {<br>
       byte[] data = new BinaryReader (s).ReadBytes ((int) s.Length);<br>
       Assembly a = Assembly.Load (data);<br>       _libs [shortName] = a;<br>       return a;<br>
    }<br>
  }<br>}<br>
public class Program<br>{<br>  public static void Go()<br>  {<br>
    // Run main program...<br>  }<br>
}<br>
Because the Loader class is defined in the main executable, the call to Assembly.GetEx<br>ecutingAssembly will always return the main executable assembly, where we've in-<br>cluded the compiled DLLs as embedded resources. In this example, we prefix the<br>name of each embedded resource assembly with &quot;Libs.&quot;. If the Visual Studio IDE<br>was  used,  you  would  change  &quot;Libs.&quot;  to  the  project's  default  namespace  (go  to<br>Project  PropertiesApplication).  You  would  also  need  to  ensure  that  the  "Build<br>Action" IDE property on each of the DLL files included in the main project was set<br>to "Embedded Resource".<br>
The reason for caching requested assemblies in a dictionary is to ensure that if the<br>CLR requests the same assembly again, we return exactly the same object. Other-<br>wise, an assembly's types will be incompatible with those loaded previously (despite<br>their binary images being identical).<br>
A variation of this would be to compress the referenced assemblies at compilation,<br>then decompress them in FindAssembly using a DeflateStream.<br>
<b>Selective Patching</b><br>
<b>Assemblies</b><br>
Suppose in this example that we want the executable to be able to autonomously<br>update itself--perhaps from a network server or website. Directly patching the ex-<br>ecutable not only would be awkward and dangerous, but also the required file I/O<br>permissions may not be forthcoming (if installed in <i>Program Files</i>, for instance). An<br>excellent workaround is to download any updated libraries to isolated storage (each<br>as a separate DLL) and then modify the FindAssembly method such that it first checks<br>
<b>Packing a Single-File Executable | 677</b><br>
<hr>
<A name=698></a>for  the  presence  of  a  library  in  its  isolated  storage  area  before  loading  it  from  a<br>resource in the executable. This leaves the original executable untouched and avoids<br>leaving any unpleasant residue on the user's computer. Security is not compromised<br>if your assemblies are strongly named (assuming they were referenced in compila-<br>tion), and if something goes wrong, the application can always revert to its original<br>state--simply by deleting all files in its isolated storage.<br>
<b>Working with Unreferenced Assemblies<br></b>Sometimes it's useful to explicitly load assemblies that may not have been referenced<br>in compilation.<br>
If the assembly in question is an executable and you simply want to run it, calling<br>ExecuteAssembly on the current application domain does the job. ExecuteAssembly<br>loads the executable using LoadFrom semantics, and then calls its entry method with<br>optional command-line arguments. For instance:<br>
string dir = AppDomain.CurrentDomain.BaseDirectory;<br>AppDomain.CurrentDomain.ExecuteAssembly (Path.Combine (dir, &quot;test.exe&quot;));<br>
ExecuteAssembly works synchronously, meaning the calling method is blocked until<br>the called assembly exits. To work asynchronously, you must call ExecuteAssembly<br>on another thread (see Chapter 21).<br>
In most cases, though, the assembly you'll want to load is a library. The approach<br>then is to call LoadFrom, and then use reflection to work with the assembly's types.<br>For example:<br>
string ourDir = AppDomain.CurrentDomain.BaseDirectory;<br>string plugInDir = Path.Combine (ourDir, &quot;plugins&quot;);<br><b>Assembly a = Assembly.LoadFrom (Path.Combine (plugInDir, &quot;widget.dll&quot;));<br></b>Type t = a.GetType (&quot;Namespace.TypeName&quot;);<br>object widget = Activator.CreateInstance (t);    // (See Chapter 18)<br>...<br>
We  used  LoadFrom  rather  than  LoadFile  to  ensure  that  any  private  assemblies<br><i>widget.dll</i> referenced in the same folder were also loaded. We then retrieved a type<br>from the assembly by name and instantiated it.<br>
The next step could be to use reflection to dynamically call methods and properties<br>on widget; we describe how to do this in the following chapter. An easier--and<br>faster--approach is to cast the object to a type that both assemblies understand.<br>This is often an interface defined in a common assembly:<br>
public interface IPluggable<br>{<br>  void ShowAboutBox();<br>  ...<br>}<br>
<b>678 | Chapter 17:</b><b>Assemblies</b><br>
<hr>
<A name=699></a>This allows us to do this:<br>
Type t = a.GetType (&quot;Namespace.TypeName&quot;);<br>
IPluggable widget = <b>(IPluggable)</b> Activator.CreateInstance (t);<br>
<b>widget.ShowAboutBox();</b><br>
You can use a similar system for dynamically publishing services in a WCF or Re-<br>moting  Server.  The  following  assumes  the  libraries  we  want  to  expose  end  in<br>"server":<br>
using System.IO;<br>
using System.Reflection;<br>
...<br>
string dir = AppDomain.CurrentDomain.BaseDirectory;<br>
foreach (string assFile in Directory.GetFiles (dir, &quot;*Server.dll&quot;))<br>{<br>  Assembly a = Assembly.LoadFrom (assFile);<br>
  foreach (Type t in a.GetTypes())<br>
    if (typeof (<i>MyBaseServerType</i>).IsAssignableFrom (t))<br>    {<br>      // Expose type t<br>
    }<br>
}<br>
This does make it very easy, though, for someone to add rogue assemblies, maybe<br>even  accidentally!  Assuming  no  compile-time  references,  the  CLR  has  nothing<br>against which to check an assembly's identity. If everything that you load is signed<br>with a known public key, the solution is to check that key explicitly. In the following<br>example, we assume that all libraries are signed with the same key pair as the exe-<br>cuting assembly:<br>
<b>byte[] ourPK = Assembly.GetExecutingAssembly().GetName().GetPublicKey();</b><br>
foreach (string assFile in Directory.GetFiles (dir, &quot;*Server.dll&quot;))<br>{<br>  <b>byte[] targetPK = AssemblyName.GetAssemblyName (assFile).GetPublicKey();<br></b>  <b>if (Enumerable.SequenceEqual (ourPK, targetPK))<br></b>  {<br>    Assembly a = Assembly.LoadFrom (assFile);<br>    ...<br>
Notice  how  AssemblyName  allows  you  to  check  the  public  key  <i>before</i>  loading  the<br>assembly.  To  compare  the  byte  arrays,  we  used  LINQ's  SequenceEqual  method<br>(System.Linq).<br>
<b>Assemblies</b><br>
<b>Working with Unreferenced Assemblies | 679</b><br>
<hr>
<A name=700></a><hr>
<A name=701></a><b>18</b><br>
<b>Reflection and Metadata</b><br>
As we saw in the previous chapter, a C# program compiles into an assembly that<br>includes  metadata,  compiled  code,  and  resources.  Inspecting  the  metadata  and<br>compiled code at runtime is called <i>reflection</i>.<br>
The compiled code in an ssembly contains almost all of the content of the original<br>source code. Some information is lost, such as local variable names, comments, and<br>preprocessor  statements.  However,  reflection  can  access  pretty  much  everything<br>else, even making it possible to write a decompiler.<br>
Many of the services available in .NET and exposed via C# (such as dynamic bind-<br>ing, serialization, data binding, and Remoting) depend on the presence of metadata.<br>Your own programs can also take advantage of this metadata, and even extend it<br>with new information using custom attributes. The System.Reflection namespace<br>houses the reflection API. It is also possible at runtime to dynamically create new<br>metadata and executable instructions in IL (Intermediate Language) via the classes<br>in the System.Reflection.Emit namespace.<br>The examples in this chapter assume that you import the System and System.Reflec<br>tion, as well as System.Reflection.Emit namespaces.<br>
When we use the term "dynamically" in this chapter, we mean<br>using reflection to perform some task whose type safety is en-<br>forced only at runtime. This is similar in principle to <i>dynamic<br>binding</i> via C#'s dynamic keyword, although the mechanism and<br>functionality is different.<br>
To compare the two, dynamic binding is much easier to use and<br>leverages the DLR for dynamic language interoperability. Re-<br>flection is relatively clumsy to use, is concerned with the CLR<br>only--but is more flexible in terms of what you can do with the<br>CLR. For instance, reflection lets you obtain lists of types and<br>members,  instantiate  an  object  whose  name  comes  from  a<br>string, and build assemblies on the fly.<br>
<b>681</b><br>
<hr>
<A name=702></a><b>Reflecting and Activating Types<br></b>In this section, we examine how to obtain a Type, inspect its metadata, and use it to<br>dynamically instantiate an object.<br>
<b>Obtaining a Type<br></b>An instance of System.Type represents the metadata for a type. Since Type is widely<br>used, it lives in the System namespace rather than the System.Reflection namespace.<br>You can get an instance of a System.Type by calling GetType on any object or with<br>C#'s typeof operator:<br>
Type t1 = DateTime.Now.GetType();     // Type obtained at runtime<br>Type t2 = typeof (DateTime);          // Type obtained at compile time<br>
You can use typeof to obtain array types and generic types as follows:<br>
Type t3 = typeof (DateTime[]);          // 1-d Array type<br>
Type t4 = typeof (DateTime[,]);         // 2-d Array type<br>
Type t5 = typeof (Dictionary&lt;int,int&gt;); // Closed generic type<br>
Type t6 = typeof (Dictionary&lt;,&gt;);       // Unbound generic type<br>
You can also retrieve a Type by name. If you have a reference to its Assembly, call<br>Assembly.GetType  (we  describe  this  further  in  the  section  "Reflecting  Assem-<br>blies" on page 700 later in this chapter):<br>
Type t = Assembly.GetExecutingAssembly().GetType (&quot;Demos.TestProgram&quot;);<br>
If you don't have an Assembly object, you can obtain a type through its <i>assembly<br>qualified name</i> (the type's full name followed by the assembly's fully qualified name).<br>The assembly implicitly loads as if you called Assembly.Load(string):<br>
Type t = Type.GetType (&quot;System.Int32, mscorlib, Version=2.0.0.0, &quot; +<br>                       &quot;Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;);<br>
Once you have a System.Type object, you can use its properties to access the type's<br>name, assembly, base type, visibility, and so on. For example:<br>
Type stringType = typeof (String);<br>string name     = stringType.Name;          // String<br>Type baseType   = stringType.BaseType;      // typeof(Object)<br>Assembly assem  = stringType.Assembly;      // mscorlib.dll<br>bool isPublic   = stringType.IsPublic;      // true<br>
A System.Type instance is a window into the entire metadata for the type--and the<br>assembly in which it's defined.<br>
System.Type  is  abstract,  so  the  typeof  operator  must  actually<br>give you a subclass of Type. The subclass that the CLR uses is<br>internal to <i>mscorlib</i> and is called RuntimeType.<br>
<b>682 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=703></a><b>Obtaining array types<br></b>As we just saw, typeof and GetType work with array types. You can also obtain an<br>array type by calling MakeArrayType on the <i>element</i> type:<br>
Type tSimpleArray = typeof (int).<b>MakeArrayType()</b>;<br>
Console.WriteLine (tSimpleArray == typeof (int[]));     // True<br>
MakeArray can be passed an integer argument to make multidimensional rectangular<br>arrays:<br>
Type tCube = typeof (int).<b>MakeArrayType (3)</b>;       // cube shaped<br>
Console.WriteLine (tCube == typeof (int[,,]));     // True<br>
GetElementType does the reverse; it retrieves an array type's element type:<br>
Type e = typeof (int[]).GetElementType();     // e == typeof (int)<br>
GetArrayRank returns the number of dimensions of a rectangular array:<br>
int rank = typeof (int[,,]).GetArrayRank();   // 3<br>
<b>Obtaining nested types<br></b>To retrieve nested types, call GetNestedTypes on the containing type. For example:<br>
foreach (Type t in typeof (System.Environment).GetNestedTypes())<br>
  Console.WriteLine (t.FullName);<br>
OUTPUT: System.Environment+SpecialFolder<br>
The one caveat with nested types is that the CLR treats a nested type as having special<br>"nested" accessibility levels. For example:<br>
Type t = typeof (System.Environment.SpecialFolder);<br>Console.WriteLine (t.IsPublic);                      // False<br>Console.WriteLine (t.IsNestedPublic);                // True<br>
<b>Type Names<br></b>A type has Namespace, Name, and FullName properties. In most cases, FullName is a<br>composition of the former two:<br>
Type t = typeof (System.Text.StringBuilder);<br>
Console.WriteLine (t.Namespace);      // System.Text<br>Console.WriteLine (t.Name);           // StringBuilder<br>Console.WriteLine (t.FullName);       // System.Text.StringBuilder<br>
There are two exceptions to this rule: nested types and closed generic types.<br>
Type also has a property called AssemblyQualifiedName, which<br>returns FullName followed by a comma and then the full name<br>of  its  assembly.  This  is  the  same  string  that  you  can  pass  to<br>Type.GetType, and it uniquely identifies a type within the default<br>loading context.<br>
<b>Reflection</b><br>
<b>Reflecting and Activating Types | 683</b><br>
<hr>
<A name=704></a><b>Nested type names<br></b>With nested types, the containing type appears only in FullName:<br>
Type t = typeof (System.Environment.SpecialFolder);<br>
Console.WriteLine (t.Namespace);      // System<br>
Console.WriteLine (t.Name);           // SpecialFolder<br>Console.WriteLine (t.FullName);       // <b>System.Environment+SpecialFolder</b><br>
The + symbol differentiates the containing type from a nested namespace.<br>
<b>Generic type names<br></b>Generic type names are suffixed with the ' symbol, followed by the number of type<br>parameters.  If  the  generic  type  is  unbound,  this  rule  applies  to  both  Name  and<br>FullName:<br>
Type t = typeof (Dictionary&lt;,&gt;); // Unbound<br>
Console.WriteLine (t.Name);      // Dictionary'2<br>
Console.WriteLine (t.FullName);  // System.Collections.Generic.Dictionary'2<br>
If the generic type is closed, however, FullName (only) acquires a substantial extra<br>appendage. Each type parameter's full <i>assembly qualified name</i> is enumerated:<br>
Console.WriteLine (typeof (Dictionary&lt;int,string&gt;).FullName);<br>
// OUTPUT:<br>System.Collections.Generic.Dictionary'2[[System.Int32, mscorlib,<br>
Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],<br>
[System.String, mscorlib, Version=2.0.0.0, Culture=neutral,<br>PublicKeyToken=b77a5c561934e089]]<br>
This ensures that AssemblyQualifiedName (a combination of the type's full name and<br>assembly name) contains enough information to fully identify both the generic type<br>and its type parameters.<br>
<b>Array and pointer type names<br></b>Arrays present with the same suffix that you use in a typeof expression:<br>
Console.WriteLine (typeof ( int[]  ).Name);      // Int32[]<br>Console.WriteLine (typeof ( int[,] ).Name);      // Int32[,]<br>Console.WriteLine (typeof ( int[,] ).FullName);  // System.Int32[,]<br>
Pointer types are similar:<br>
Console.WriteLine (typeof (byte*).Name);     // Byte*<br>
<b>ref and out parameter type names<br></b>A Type describing a ref or out parameter has an &amp; suffix:<br>
Type t = typeof (bool).GetMethod (&quot;TryParse&quot;).GetParameters()[1]<br>                                             .ParameterType;<br>Console.WriteLine (t.Name);    // Boolean&amp;<br>
More on this in "Reflecting and Invoking Members" on page 688.<br>
<b>684 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=705></a><b>Base Types and Interfaces<br></b>Type exposes a BaseType property:<br>
Type base1 = typeof (System.String).BaseType;<br>
Type base2 = typeof (System.IO.FileStream).BaseType;<br>
Console.WriteLine (base1.Name);     // Object<br>Console.WriteLine (base2.Name);     // Stream<br>
The GetInterfaces method returns the interfaces that a type implements:<br>
foreach (Type iType in typeof (Guid).GetInterfaces())<br>
  Console.WriteLine (iType.Name);<br>
<i>IFormattable<br>IComparable</i><br>
<i>IComparable'1<br>IEquatable'1</i><br>
Reflection provides two dynamic equivalents to C#'s static is operator:<br>
IsInstanceOfType<br>
Accepts a type and instance<br>
IsAssignableFrom<br>
Accepts two types<br>
Here's an example of the first:<br>
object obj  = Guid.NewGuid();<br>Type target = typeof (IFormattable);<br>
bool isTrue   = obj is IFormattable;             // Static C# operator<br>bool alsoTrue = target.<b>IsInstanceOfType</b> (obj);   // Dynamic equivalent<br>
IsAssignableFrom is more versatile:<br>
Type target = typeof (IComparable), source = typeof (string);<br>
Console.WriteLine (target.<b>IsAssignableFrom</b> (source));         // True<br>
The IsSubclassOf method works on the same principle as IsAssignableFrom, but<br>excludes interfaces.<br>
<b>Instantiating Types<br></b>There are two ways to dynamically instantiate an object from its type:<br>
· Call the static Activator.CreateInstance method<br>· Call Invoke on a ConstructorInfo object obtained from calling GetConstructor<br>
on a Type (advanced scenarios)<br>
Activator.CreateInstance accepts a Type and optional arguments that get passed to<br>the constructor:<br>
<b>Reflection</b><br>
<b>Reflecting and Activating Types | 685</b><br>
<hr>
<A name=706></a>int i = (int) Activator.CreateInstance (typeof (int));<br>
DateTime dt = (DateTime) Activator.CreateInstance (typeof (DateTime),<br>                                                   2000, 1, 1);<br>
CreateInstance  lets  you  specify  many  other  options,  such  as  the  assembly  from<br>which to load the type, the target application domain, and whether to bind to a<br>nonpublic constructor. A MissingMethodException is thrown if the runtime can't find<br>a suitable constructor.<br>
Calling  Invoke  on  a  ConstructorInfo  is  necessary  when  your  argument  values<br>can't disambiguate between overloaded constructors. For example, suppose class<br>X has two constructors: one accepting a parameter of type string, and another ac-<br>cepting a parameter of type StringBuilder. The target is ambiguous should you pass<br>a null argument into Activator.CreateInstance. This is when you need to use a<br>ConstructorInfo instead:<br>
// Fetch the constructor that accepts a single parameter of type <b>string</b>:<br>
ConstructorInfo ci = typeof (X).GetConstructor (new[] { typeof (string) };<br>
// Construct the object using that overload, passing in <b>null</b>:<br>
object foo = ci.Invoke (new object[] { null });<br>
To obtain a nonpublic constructor, you need to specify BindingFlags--see "Access-<br>ing  Nonpublic  Members"  on  page  696  in  the  section  "Reflecting  and  Invoking<br>Members" on page 688.<br>
Dynamic  instantiation  adds  a  few  microseconds  onto  the<br>time taken to construct the object. This is quite a lot in relative<br>terms because the CLR is ordinarily very fast in instantiating<br>objects (a simple new on a small class takes in the region of tens<br>of nanosecondsk).<br>
To dynamically instantiate arrays based on just element type, call MakeArrayType<br>first. You can also instantiate generic types: we describe this in the following section.<br>
To dynamically instantiate a delegate, call Delegate.CreateDelegate. The following<br>example demonstrates instantiating both an instance delegate and a static delegate:<br>
class Program<br>{<br>  delegate int IntFunc (int x);<br>
  static int Square (int x) { return x * x; }       // Static method<br>  int        Cube   (int x) { return x * x * x; }   // Instance method<br>
  static void Main()<br>  {<br>    Delegate staticD = Delegate.CreateDelegate<br>      (typeof (IntFunc), <b>typeof (Program)</b>, &quot;Square&quot;);d<br>
    Delegate instanceD = Delegate.CreateDelegate<br>      (typeof (IntFunc), <b>new Program()</b>, &quot;Cube&quot;);<br>
<b>686 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=707></a>    Console.WriteLine (staticD.DynamicInvoke (3));      // 9<br>
    Console.WriteLine (instanceD.DynamicInvoke (3));    // 27<br>  }<br>}<br>
You can invoke the Delegate object that's returned by calling DynamicInvoke, as we<br>did in this example, or by casting to the typed delegate:<br>
IntFunc f = (IntFunc) staticD;<br>Console.WriteLine (f(3));         // 9 <i>(but much faster!)</i><br>
You  can  pass  a  MethodInfo  into  CreateDelegate  instead  of  a  method  name.  We<br>describe  MethodInfo  shortly,  in  the  section  "Reflecting  and  Invoking  Mem-<br>bers" on page 688, along with the rationale for casting a dynamically created del-<br>egate back to the static delegate type.<br>
<b>Generic Types<br></b>A Type can  represent a closed or unbound generic type. Just as at compile time, a<br>closed generic type can be instantiated whereas an unbound type cannot:<br>
Type closed = typeof (List&lt;int&gt;);<br>
List&lt;int&gt; list = (List&lt;int&gt;) Activator.CreateInstance (closed);  // OK<br>
Type unbound   = typeof (List&lt;&gt;);<br>
object anError = Activator.CreateInstance (unbound);    // Runtime error<br>
The MakeGenericType method converts an unbound into a closed generic type. Sim-<br>ply pass in the desired type arguments:<br>
Type unbound = typeof (List&lt;&gt;);<br>
Type closed = unbound.MakeGenericType (typeof (int));<br>
The GetGenericTypeDefinition method does the opposite:<br>
Type unbound2 = closed.GetGenericTypeDefinition();  // unbound == unbound2<br>
The IsGenericType property returns true if a Type is generic, and the IsGenericType<br>Definition property returns true if the generic type is unbound. The following tests<br>whether a type is a nullable value type:<br>
Type nullable = typeof (bool?);<br>Console.WriteLine (<br>  nullable.IsGenericType &amp;&amp;<br>  nullable.GetGenericTypeDefinition() == typeof (Nullable&lt;&gt;));   // True<br>
GetGenericArguments returns the type arguments for closed generic types:<br>
Console.WriteLine (closed.GetGenericArguments()[0]);     // System.Int32<br>Console.WriteLine (nullable.GetGenericArguments()[0]);   // System.Boolean<br>
For unbound generic types, GetGenericArguments returns pseudotypes that represent<br>the placeholder types specified in the generic type definition:<br>
Console.WriteLine (unbound.GetGenericArguments()[0]);      // T<br>
<b>Reflection</b><br>
<b>Reflecting and Activating Types | 687</b><br>
<hr>
<A name=708></a>At  runtime,  all  generic  types  are  either  <i>unbound</i>  or  <i>closed</i>.<br>They're unbound in the (relatively unusual) case of an expres-<br>sion such as typeof(Foo&lt;&gt;); otherwise, they're closed. There's<br>no such things as an <i>open</i> generic type at runtime: all open types<br>are closed by the compiler. The method in the following class<br>always prints False:<br>
class Foo&lt;T&gt;<br>{<br>  public void Test()<br>  {<br>    Console.Write (GetType().IsGenericTypeDefinition);<br>
  }<br>}<br>
<b>Reflecting and Invoking Members<br></b>The GetMembers method returns the members of a type. Consider the following class:<br>
class Walnut<br>{<br>  private bool cracked;<br>
  public void Crack() { cracked = true; }<br>
}<br>
We can reflect on its public members as follows:<br>
MemberInfo[] members = <b>typeof (Walnut).GetMembers()</b>;<br>foreach (MemberInfo m in members)<br>  Console.WriteLine (m);<br>
This is the result:<br>
Void Crack()<br>System.Type GetType()<br>System.String ToString()<br>Boolean Equals(System.Object)<br>Int32 GetHashCode()<br>Void .ctor()<br>
When called with no arguments, GetMembers returns all the public members for a<br>type (and its base types). GetMember retrieves a specific member by name--though<br>it still returns an array because members can be overloaded:<br>
MemberInfo[] m = typeof (Walnut).GetMember (&quot;Crack&quot;);<br>Console.WriteLine (m[0]);                              // Void Crack()<br>
MemberInfo also has a property called MemberType of type MemberTypes. This is a flags<br>enum with these values:<br>
All           Custom        Field        NestedType     TypeInfo<br>Constructor   Event         Method       Property<br>
<b>688 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=709></a>When calling GetMembers, you can pass in a MemberTypes instance to restrict the kinds<br>of members that it returns. Alternatively, you can restrict the result set by calling<br>GetMethods,  GetFields,  GetProperties,  GetEvents,  GetConstructors,  or  GetNested<br>Types.  There  are  also  singular  versions  of  each  of  these  to  hone  in  on  a  specific<br>member.<br>
It pays to be as specific as possible when retrieving a type mem-<br>ber, so your code doesn't break if additional members are added<br>later. If you're retrieving a method by name, specifying all pa-<br>rameter types ensures your code will still work if the method is<br>later overloaded (we provide examples shortly, in the section<br>"Method Parameters" on page 693).<br>
A MemberInfo object has a Name property and two Type properties:<br>
DeclaringType<br>
Returns the Type that defines the member<br>
ReflectedType<br>
Returns the Type upon which GetMembers was called<br>
The two differ when called on a member that's defined in a base type: Declaring<br>Type returns the base type, whereas ReflectedType returns the subtype. The follow-<br>ing example highlights this:<br>
class Program<br>{<br>  static void Main()<br>
  {<br>    // MethodInfo is a subclass of MemberInfo; see Figure 18-1.<br>
    MethodInfo test = typeof (Program).GetMethod (&quot;ToString&quot;);<br>    MethodInfo obj  = typeof (object) .GetMethod (&quot;ToString&quot;);<br>
    Console.WriteLine (test.DeclaringType);      // System.Object<br>    Console.WriteLine (obj.DeclaringType);       // System.Object<br>
    Console.WriteLine (test.ReflectedType);      // <b>Program<br></b>    Console.WriteLine (obj.ReflectedType);       // System.Object<br>
    Console.WriteLine (test == obj);             // <b>False<br></b>  }<br>}<br>
Because they have different ReflectedTypes, the test and obj objects are not equal.<br>Their difference, however, is purely a fabrication of the reflection API; our Program<br>type has no distinct ToString method in the underlying type system. We can verify<br>that the two MethodInfo objects refer to the same method in either of two ways:<br>
Console.WriteLine (test.MethodHandle == obj.MethodHandle);    // True<br>
Console.WriteLine (test.MetadataToken == obj.MetadataToken    // True<br>
<b>Reflection</b><br>
                   &amp;&amp; test.Module == obj.Module);<br>
<b>Reflecting and Invoking Members | 689</b><br>
<hr>
<A name=710></a>A MethodHandle is unique to each (genuinely distinct) method within an application<br>domain; a MetadataToken is unique across all types and members within an assembly<br>module.<br>
MemberInfo also defines methods to return custom attributes (see the section "Re-<br>trieving Attributes at Runtime" on page 705 later in this chapter).<br>
You  can  obtain  the  MethodBase  of  the  currently  executing<br>method by calling MethodBase.GetCurrentMethod.<br>
<b>Member Types<br></b>MemberInfo itself is light on members because it's an abstract base for the types shown<br>in Figure 18-1.<br>
<i>Figure 18-1. Member types</i><br>
You can cast a MemberInfo to its subtype--based on its MemberType property. If you<br>obtained  a  member  via  GetMethod,  GetField,  GetProperty,  GetEvent,<br>GetConstructor, or GetNestedType (or their plural versions), a cast isn't necessary.<br>Table 18-1 summarizes what methods to use for each kind of C# construct.<br>
<i>Table 18-1. Retrieving member metadata</i><br>
<b>C# construct</b><br>
<b>Method to use</b><br>
<b>Name to use</b><br>
<b>Result</b><br>
Method<br>
GetMethod<br>
Method name<br>
MethodInfo<br>
Property<br>
GetProperty<br>
Property name<br>
PropertyInfo<br>
Indexer<br>
GetDefaultMembers<br>
 <br>
MemberInfo[] (containing<br>PropertyInfo objects if compiled in C#)<br>
Field<br>
GetField<br>
Field name<br>
FieldInfo<br>
Enum member<br>
GetField<br>
Member name<br>
FieldInfo<br>
<b>690 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=711></a><b>C# construct</b><br>
<b>Method to use</b><br>
<b>Name to use</b><br>
<b>Result</b><br>
Event<br>
GetEvent<br>
Event name<br>
EventInfo<br>
Constructor<br>
GetConstructor<br>
 <br>
ConstructorInfo<br>
Finalizer<br>
GetMethod<br>
&quot;Finalize&quot;<br>
MethodInfo<br>
Operator<br>
GetMethod<br>
&quot;op_&quot; + operator name<br>
MethodInfo<br>
Nested type<br>
GetNestedType<br>
Type name<br>
Type<br>
Each MemberInfo subclass has a wealth of properties and methods, exposing all as-<br>pects of the member's metadata. This includes such things as visibility, modifiers,<br>generic type arguments, parameters, return type, and custom attributes.<br>
Here is an example of using GetMethod:<br>
MethodInfo m = typeof (Walnut).GetMethod (&quot;Crack&quot;);<br>
Console.WriteLine (m);                             // Void Crack()<br>
Console.WriteLine (m.ReturnType);                  // System.Void<br>
All *Info instances are cached by the reflection API on first use:<br>
MethodInfo method = typeof (Walnut).<b>GetMethod</b> (&quot;Crack&quot;);<br>
MemberInfo member = typeof (Walnut).<b>GetMember</b> (&quot;Crack&quot;) [0];<br>
Console.Write (method == member);       // True<br>
As well as preserving object identity, caching improves the performance of what is<br>otherwise a fairly slow API.<br>
<b>C# Members Versus CLR Members<br></b>The preceding table illustrates that some of C#'s functional constructs don't have<br>a 1:1 mapping with CLR constructs. This makes sense because the CLR and reflec-<br>tion API were designed with all .NET languages in mind--you can use reflection<br>even from Visual Basic.<br>
Some C# constructs--namely indexers, enums, operators, and finalizers--are con-<br>trivances as far as the CLR is concerned. Specifically:<br>
· A C# indexer translates to a property accepting one or more arguments, marked<br>
as the type's [DefaultMember].<br>
· A C# enum translates to a subtype of System.Enum with a static field for each<br>
member.<br>
· A C# operator translates to a specially named static method, starting in "op_";<br>
for example, &quot;op_Addition&quot;.<br>
· A C# finalizer translates to a method that overrides Finalize.<br>
Another complication is that properties and events actually comprise two things:<br>
· Metadata describing the property or event (encapsulated by PropertyInfo or<br>
EventInfo)<br>
· One or two backing methods<br>
<b>Reflection</b><br>
<b>Reflecting and Invoking Members | 691</b><br>
<hr>
<A name=712></a>In a C# program, the backing methods are encapsulated within the property or event<br>definition. But when compiled to IL, the backing methods present as ordinary meth-<br>ods that you can call like any other. This means GetMethods returns property and<br>event backing methods alongside ordinary methods. To illustrate:<br>
class Test { public int X { get { return 0; } set {} } }<br>
void Demo()<br>{<br>  foreach (MethodInfo mi in typeof (Test).GetMethods())<br>
    Console.Write (mi.Name + &quot;  &quot;);<br>
}<br>
// OUTPUT:<br>
<b>get_X  set_X</b>  GetType  ToString  Equals  GetHashCode<br>
You can identify these methods through the IsSpecialName property in MethodInfo.<br>IsSpecialName returns true for property, indexer, and event accessors--as well as<br>operators. It returns false only for conventional C# methods--and the Finalize<br>method if a finalizer is defined.<br>
Here are the backing methods that C# generates:<br>
<b>C# construct</b><br>
<b>Member type</b><br>
<b>Methods in IL</b><br>
Property<br>
Property<br>
get_<i>XXX</i> and set_<i>XXX</i><br>
Indexer<br>
Property<br>
get_Item and set_Item<br>
Event<br>
Event<br>
add_<i>XXX</i> and remove_<i>XXX</i><br>
Each backing method has its own associated MethodInfo object. You can access these<br>as follows:<br>
PropertyInfo pi = typeof (Console).GetProperty (&quot;Title&quot;);<br>MethodInfo getter = pi.<b>GetGetMethod</b>();                   // get_Title<br>MethodInfo setter = pi.<b>GetSetMethod</b>();                   // set_Title<br>MethodInfo[] both = pi.<b>GetAccessors</b>();                   // Length==2<br>
GetAddMethod and GetRemoveMethod perform a similar job for EventInfo.<br>
To go in the reverse direction--from a MethodInfo to its associated PropertyInfo or<br>EventInfo--you need to perform a query. LINQ is ideal for this job:<br>
PropertyInfo p = mi.DeclaringType.GetProperties()<br>                   .First (x =&gt; x.GetAccessors (true).Contains (mi));<br>
<b>Generic Type Members<br></b>You can obtain member metadata for both unbound and closed generic types:<br>
PropertyInfo unbound = typeof (<b>IEnumerator&lt;&gt;</b>)  .GetProperty (&quot;Current&quot;);<br>PropertyInfo closed = typeof (<b>IEnumerator&lt;int&gt;</b>).GetProperty (&quot;Current&quot;);<br>
Console.WriteLine (unbound);   // T Current<br>Console.WriteLine (closed);    // Int32 Current<br>
<b>692 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=713></a>Console.WriteLine (unbound.PropertyType.IsGenericParameter);  // True<br>
Console.WriteLine (closed.PropertyType.IsGenericParameter);   // False<br>
The MemberInfo objects returned from unbound and closed generic types are always<br>distinct--even for members whose signatures don't feature generic type parameters:<br>
PropertyInfo unbound = typeof (<b>List&lt;&gt;</b>)  .GetProperty (&quot;Count&quot;);<br>
PropertyInfo closed = typeof (<b>List&lt;int&gt;</b>).GetProperty (&quot;Count&quot;);<br>
Console.WriteLine (unbound);   // Int32 Count<br>Console.WriteLine (closed);    // Int32 Count<br>
Console.WriteLine (unbound == closed);   // False<br>
Console.WriteLine (unbound.DeclaringType.IsGenericTypeDefinition); // True<br>Console.WriteLine (closed.DeclaringType.IsGenericTypeDefinition); // False<br>
Members of unbound generic types cannot be <i>dynamically invoked</i>.<br>
<b>Dynamically Invoking a Member<br></b>Once you have a MemberInfo object, you can dynamically call it or get/set its value.<br>This is called <i>dynamic binding</i> or <i>late binding</i>, because you choose which member<br>to invoke at runtime rather than compile time.<br>
To illustrate, the following uses ordinary <i>static binding</i>:<br>
string s = &quot;Hello&quot;;<br>int length = s.Length;<br>
Here's the same thing performed dynamically with reflection:<br>
object s = &quot;Hello&quot;;<br>PropertyInfo prop = s.GetType().GetProperty (&quot;Length&quot;);<br>int length = (int) <b>prop.GetValue (s, null);</b>               // 5<br>
GetValue and SetValue get and set the value of a PropertyInfo or FieldInfo. The first<br>argument is the instance, which can be null for a static member. Accessing an in-<br>dexer is just like accessing a property called "Item," except that you provide indexer<br>values as the second argument when calling GetValue or SetValue.<br>To dynamically call a method, call Invoke on a MethodInfo, providing an array of<br>arguments to pass to that method. If you get any of the argument types wrong, an<br>exception is thrown at runtime. With dynamic invocation, you lose compile-time<br>type safety, but still have runtime type safety (just as with the dynamic keyword).<br>
<b>Method Parameters<br></b>Suppose  we  want  to  dynamically  call  string's Substring method. Statically, this<br>would be done as follows:<br>
Console.WriteLine (&quot;stamp&quot;.Substring(2));                  // &quot;amp&quot;<br>
Here's the dynamic equivalent with reflection:<br>
<b>Reflection</b><br>
<b>Reflecting and Invoking Members | 693</b><br>
<hr>
<A name=714></a>Type type = typeof (string);<br>
Type[] parameterTypes = { typeof (int) };<br>MethodInfo method = type.GetMethod (&quot;Substring&quot;, parameterTypes);<br>
object[] arguments = { 2 };<br>
object returnValue = method.Invoke (&quot;stamp&quot;, arguments);<br>Console.WriteLine (returnValue);                           // &quot;amp&quot;<br>
Because the Substring method is overloaded, we had to pass an array of parameter<br>types to GetMethod to indicate which version we wanted. Without the parameter<br>types, GetMethod would throw an AmbiguousMatchException.<br>The GetParameters method, defined on MethodBase (the base class for MethodInfo and<br>ConstructorInfo), returns parameter metadata. We can continue our previous ex-<br>ample as follows:<br>
ParameterInfo[] paramList = method.GetParameters();<br>foreach (ParameterInfo x in paramList)<br>
{<br>  Console.WriteLine (x.Name);                 // startIndex<br>
  Console.WriteLine (x.ParameterType);        // System.Int32<br>
}<br>
<b>Dealing with ref and out parameters<br></b>To pass ref or out parameters, call MakeByRefType on the type before obtaining the<br>method. For instance, this code:<br>
int x;<br>bool successfulParse = int.TryParse (&quot;23&quot;, out x);<br>
can be dynamically executed as follows:<br>
object[] args = { &quot;23&quot;, 0 };<br>Type[] argTypes = { typeof (string), typeof (int)<b>.MakeByRefType()</b> };<br>MethodInfo tryParse = typeof (int).GetMethod (&quot;TryParse&quot;, argTypes);<br>bool successfulParse = (bool) tryParse.Invoke (null, args);<br>
Console.WriteLine (successfulParse + &quot; &quot; + args[1]);       // True 23<br>
This same approach works for both ref and out parameter types.<br>
<b>Retrieving and invoking generic methods<br></b>Explicitly specifying parameter types when calling GetMethod can be essential in dis-<br>ambiguating  overloaded  methods.  However,  it's  impossible  to  specify  generic<br>parameter types. For instance, consider the System.Linq.Enumerable class, which<br>overloads the Where method as follows:<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br> (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, bool&gt; predicate);<br>
public static IEnumerable&lt;TSource&gt; Where&lt;TSource&gt;<br> (this IEnumerable&lt;TSource&gt; source, Func&lt;TSource, int, bool&gt; predicate);<br>
To retrieve a specific overload, we must retrieve all methods and then manually find<br>the desired overload. The following query retrieves the former overload of Where:<br>
<b>694 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=715></a>from m in typeof (Enumerable).GetMethods()<br>
where m.Name == &quot;Where&quot; &amp;&amp; m.IsGenericMethod<br>let parameters = m.GetParameters()<br>where parameters.Length == 2<br>
let genArg = m.GetGenericArguments().First()<br>
let enumerableOfT = typeof (IEnumerable&lt;&gt;).MakeGenericType (genArg)<br>let funcOfTBool = typeof (Func&lt;,&gt;).MakeGenericType (genArg, typeof (bool))<br>where parameters[0].ParameterType == enumerableOfT<br>
   &amp;&amp; parameters[1].ParameterType == funcOfTBool<br>
select m<br>
Calling  .Single()  on  this  query  gives  the  correct  MethodInfo  object  with<br>unbound type parameters. The next step is to close the type parameters by calling<br>MakeGenericMethod:<br>
var closedMethod = unboundMethod.MakeGenericMethod (typeof (int));<br>
In this case, we've closed TSource with int, allowing us to call Enumerable.Where with<br>a source of type IEnumerable&lt;int&gt;, and a predicate of type Func&lt;int,bool&gt;:<br>
int[] source = { 3, 4, 5, 6, 7, 8 };<br>Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;   // Odd numbers only<br>
We can now invoke the closed generic method as follows:<br>
var query = (IEnumerable&lt;int&gt;) closedMethod.Invoke<br>
  (null, new object[] { source, predicate });<br>
foreach (int element in query) Console.Write (element + &quot;|&quot;);  // 3|5|7|<br>
If you're using the System.Linq.Expressions API to dynamically<br>build  expressions  (Chapter  8),  you  don't  need  to  go  to  this<br>trouble  to  specify  a  generic  method.  The  Expression.Call<br>method is overloaded to let you specify the closed type argu-<br>ments of the method you wish to call:<br>
int[] source = { 3, 4, 5, 6, 7, 8 };<br>Func&lt;int, bool&gt; predicate = n =&gt; n % 2 == 1;<br>
var sourceExpr = Expression.Constant (source);<br>var predicateExpr = Expression.Constant (predicate);<br>
var callExpression = Expression.Call (<br>
  typeof (Enumerable), &quot;Where&quot;,<br>  new[] { typeof (int) },  // Closed generic arg type.<br>  sourceExpr, predicateExpr);<br>
<b>Using Delegates for Performance<br></b>Dynamic invocations are relatively inefficient, with an overhead typically in the few-<br>microseconds region. If you're calling a method repeatedly in a loop, you can shift<br>the per-call overhead into the nanoseconds region by instead calling a dynamically<br>instantiated delegate that targets your dynamic method. In the following example,<br>we  dynamically  call  string's  Trim  method  a  million  times  without  significant<br>
<b>Reflection</b><br>
overhead:<br>
<b>Reflecting and Invoking Members | 695</b><br>
<hr>
<A name=716></a>delegate string StringToString (string s);<br>
static void Main()<br>{<br>  MethodInfo trimMethod = typeof (string).GetMethod (&quot;Trim&quot;, new Type[0]);<br>
  <b>var trim = (StringToString) Delegate.CreateDelegate<br></b>                                    <b>(typeof (StringToString), trimMethod);<br></b>  for (int i = 0; i &lt; 1000000; i++)<br>
    trim (&quot;test&quot;);<br>
}<br>
This is faster because the costly dynamic binding (shown in bold) happens just once.<br>
<b>Accessing Nonpublic Members<br></b>All of the methods on types used to probe metadata (e.g., GetProperty, GetField,<br>etc.) have overloads that take a BindingFlags enum. This enum serves as a metadata<br>filter and allows you to change the default selection criteria. The most common use<br>for this is to retrieve nonpublic members.<br>
For instance, consider the following class:<br>
class Walnut<br>
{<br>  private bool cracked;<br>  public void Crack() { cracked = true; }<br>
  public override string ToString() { return cracked.ToString(); }<br>}<br>
We can <i>uncrack</i> the walnut as follows:<br>
Type t = typeof (Walnut);<br>Walnut w = new Walnut();<br>w.Crack();<br>FieldInfo f = t.GetField (&quot;cracked&quot;, BindingFlags.NonPublic |<br>                                     BindingFlags.Instance);<br>f.SetValue (w, false);<br>Console.WriteLine (w);         // False<br>
Using reflection to access nonpublic members is powerful, but it is also dangerous,<br>since you can bypass encapsulation, creating an unmanageable dependency on the<br>internal implementation of a type.<br>
<b>The BindingFlags enum<br></b>BindingFlags is intended to be bitwise-combined. In order to get any matches at all,<br>you need to start with one of the following four combinations:<br>
BindingFlags.Public    | BindingFlags.Instance<br>BindingFlags.Public    | BindingFlags.Static<br>BindingFlags.NonPublic | BindingFlags.Instance<br>BindingFlags.NonPublic | BindingFlags.Static<br>
NonPublic includes internal, protected, protected internal, and private.<br>
<b>696 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=717></a>The following example retrieves all the public static members of type object:<br>
BindingFlags publicStatic = BindingFlags.Public | BindingFlags.Static;<br>
MemberInfo[] members = typeof (object).GetMembers (publicStatic);<br>
The following example retrieves all the nonpublic members of type object, both<br>static and instance:<br>
BindingFlags nonPublicBinding =<br>
  BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance;<br>
MemberInfo[] members = typeof (object).GetMembers (nonPublicBinding);<br>
The DeclaredOnly flag excludes functions inherited from base types, unless they are<br>overridden.<br>
The  DeclaredOnly  flag  is  somewhat  confusing  in  that  it  <i>re-<br>stricts</i>  the  result  set  (whereas  all  the  other  binding  flags  <i>ex-<br>pand</i> the result set).<br>
<b>Generic Methods<br></b>Generic methods cannot be invoked directly; the following throws an exception:<br>
class Program<br>
{<br>  public static T Echo&lt;T&gt; (T x) { return x; }<br>
  static void Main()<br>  {<br>    MethodInfo echo = typeof (Program).GetMethod (&quot;Echo&quot;);<br>    Console.WriteLine (echo.IsGenericMethodDefinition);    // <b>True<br></b>    echo.Invoke (null, new object[] { 123 } );             // <i>Exception<br></i>  }<br>}<br>
An  extra  step  is  required,  which  is  to  call  MakeGenericMethod  on  the  MethodInfo,<br>specifying concrete generic type arguments. This returns another MethodInfo, which<br>you can then invoke as follows:<br>
MethodInfo echo = typeof (Program).GetMethod (&quot;Echo&quot;);<br><b>MethodInfo intEcho = echo.MakeGenericMethod (typeof (int));<br></b>Console.WriteLine (intEcho.IsGenericMethodDefinition);            // <b>False<br></b>Console.WriteLine (intEcho.Invoke (null, new object[] { 3 } ));   // 3<br>
<b>Anonymously Calling Members of a Generic Interface<br></b>Reflection is useful when you need to invoke a member of a generic interface and<br>you don't know the type parameters until runtime. In theory, the need for this arises<br>rarely  if  types  are  perfectly  designed;  of  course,  types  are  not  always  perfectly<br>designed.<br>
<b>Reflection</b><br>
<b>Reflecting and Invoking Members | 697</b><br>
<hr>
<A name=718></a>For instance, suppose we want to write a more powerful version of ToString that<br>could expand the result of LINQ queries. We could start out as follows:<br>
public static string ToStringEx &lt;T&gt; (IEnumerable&lt;T&gt; sequence)<br>{<br>  ...<br>
}<br>
This is already quite limiting. What if sequence contained <i>nested</i> collections that we<br>also want to enumerate? We'd have to overload the method to cope:<br>
public static string ToStringEx &lt;T&gt; (IEnumerable&lt;IEnumerable&lt;T&gt;&gt; sequence)<br>
And then what if sequence contained groupings, or <i>projections</i> of nested sequences?<br>The static solution of method overloading becomes impractical--we need an ap-<br>proach that can scale to handle an arbitrary object graph, such as the following:<br>
public static string ToStringEx (object value)<br>
{<br>  if (value == null) return &quot;&lt;null&gt;&quot;;<br>
  StringBuilder sb = new StringBuilder();<br>
  if (value is <b>List&lt;&gt;</b>)                                            // Error<br>    sb.Append (&quot;List of &quot; + (<b>(List&lt;&gt;</b>) value).Count + &quot; items&quot;);   // Error<br>
  if (value is <b>IGrouping&lt;,&gt;</b>)                                      // Error<br>
    sb.Append (&quot;Group with key=&quot; + (<b>(IGrouping&lt;,&gt;</b>) value).Key);   // Error<br>
  // Enumerate collection elements if this is a collection,<br>  // recursively calling ToStringEx()<br>  // ...<br>
  return sb.ToString();<br>}<br>
Unfortunately, this won't compile: you cannot invoke members of an <i>unbound</i> ge-<br>neric type such as List&lt;&gt; or IGrouping&lt;&gt;. In the case of List&lt;&gt;, we can solve the<br>problem by using the nongeneric IList interface instead:<br>
  if (value is <b>IList</b>)<br>    sb.AppendLine (&quot;A list with &quot; + (<b>(IList)</b> value).Count + &quot; items&quot;);<br>
We can do this because the designers of List&lt;&gt; had the foresight<br>to implement IList classic (as well as IList <i>generic</i>). The same<br>principle is worthy of consideration when writing your own ge-<br>neric types: having a nongeneric interface or base class upon<br>which consumers can fall back can be extremely valuable.<br>
The solution is not as simple for IGrouping&lt;,&gt;. Here's how the interface is defined:<br>
public interface IGrouping &lt;TKey,TElement&gt; : IEnumerable &lt;TElement&gt;,<br>
                                             IEnumerable<br>{<br>  TKey Key { get; }<br>}<br>
<b>698 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=719></a>There's no nongeneric type we can use to access the Key property, so here we must<br>use reflection. The solution is not to invoke members of an unbound generic type<br>(which is impossible), but to invoke members of a <i>closed</i> generic type, whose type<br>arguments we establish at runtime.<br>
In the following chapter, we solve this more simply with C#'s<br>dynamic  keyword.  A  good  indication  for  dynamic  binding  is<br>when you would otherwise have to perform <i>type gymnastics</i>--<br>as we are doing right now.<br>
The first step is to determine whether value implements IGrouping&lt;,&gt;, and if so,<br>obtain its closed generic interface. We can do this most easily with a LINQ query.<br>Then we retrieve and invoke the Key property:<br>
public static string ToStringEx (object value)<br>
{<br>  if (value == null) return &quot;&lt;null&gt;&quot;;<br>
  if (value.GetType().IsPrimitive) return value.ToString();<br>
  StringBuilder sb = new StringBuilder();<br>
  if (value is IList)<br>
    sb.Append (&quot;List of &quot; + ((IList)value).Count + &quot; items: &quot;);<br>
  <b>Type closedIGrouping = value.GetType().GetInterfaces()<br></b>    <b>.Where (t =&gt; t.IsGenericType &amp;&amp;<br></b>                 <b>t.GetGenericTypeDefinition() == typeof (IGrouping&lt;,&gt;))</b><br>
    <b>.FirstOrDefault();</b><br>
  if (closedIGrouping != null)   // Call the Key property on IGrouping&lt;,&gt;<br>  {<br>    <b>PropertyInfo pi = closedIGrouping.GetProperty (&quot;Key&quot;);<br></b>    <b>object key = pi.GetValue (value, null);<br></b>    sb.Append (&quot;Group with key=&quot; + key + &quot;: &quot;);<br>  }<br>
  if (value is IEnumerable)<br>    foreach (object element in ((IEnumerable)value))<br>      sb.Append (ToStringEx (element) + &quot; &quot;);<br>
  if (sb.Length == 0) sb.Append (value.ToString());<br>
  return &quot;\r\n&quot; + sb.ToString();<br>}<br>
This approach is robust: it works whether IGrouping&lt;,&gt; is implemented implicitly<br>or explicitly. The following demonstrates this method:<br>
Console.WriteLine (ToStringEx (new List&lt;int&gt; { 5, 6, 7 } ));<br>Console.WriteLine (ToStringEx (&quot;xyyzzz&quot;.GroupBy (c =&gt; c) ));<br>
<i>List of 3 items: 5 6 7</i><br>
<b>Reflection</b><br>
<b>Reflecting and Invoking Members | 699</b><br>
<hr>
<A name=720></a><i>Group with key=x: x</i><br>
<i>Group with key=y: y y<br>Group with key=z: z z z</i><br>
<b>Reflecting Assemblies<br></b>You  can  dynamically  reflect  an  assembly  by  calling  GetType  or  GetTypes  on  an<br>Assembly object. The following retrieves from the current assembly, the type called<br>TestProgram in the Demos namespace:<br>
Type t = Assembly.GetExecutingAssembly().GetType (&quot;Demos.TestProgram&quot;);<br>
The next example lists all the types in the assembly <i>mylib.dll</i> in <i>e:\demo</i>:<br>
Assembly a = Assembly.LoadFrom (@&quot;e:\demo\mylib.dll&quot;);<br>
foreach (Type t in a.GetTypes())<br>
  Console.WriteLine (t);<br>
GetTypes returns only top-level and not nested types.<br>
<b>Loading an Assembly into a Reflection-Only Context<br></b>In the preceding example, we loaded an assembly into the current application do-<br>main in order to list its types. This can have undesirable side effects, such as exe-<br>cuting static constructors or upsetting subsequent type resolution. The solution, if<br>you just need to inspect type information (and not instantiate or invoke types), is to<br>load the assembly into a <i>reflection-only</i> context:<br>
Assembly a = Assembly.ReflectionOnlyLoadFrom (@&quot;e:\demo\mylib.dll&quot;);<br>
Console.WriteLine (a.ReflectionOnly);   // True<br>
foreach (Type t in a.GetTypes())<br>  Console.WriteLine (t);<br>
This is the starting point for writing a class browser.<br>
There are three methods for loading an assembly into the reflection-only context:<br>
· ReflectionOnlyLoad (byte[])<br>· ReflectionOnlyLoad (string)<br>· ReflectionOnlyLoadFrom (string)<br>
Even in a reflection-only context, it is not possible to load mul-<br>tiple  versions  of  <i>mscorlib.dll</i>.  For  this  reason,  class  browsers<br>such as Lutz Roeder's .NET Reflector are written with custom<br>classes  and  structs  that  map  to  the  unmanaged  metadata<br>interfaces.<br>
<b>700 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=721></a><b>Modules<br></b>Calling GetTypes on a multimodule assembly returns all types in all modules. As a<br>result, you can ignore the existence of modules and treat an assembly as a type's<br>container. There is one case, though, where modules are relevant--and that's when<br>dealing with metadata tokens.<br>
A metadata token is an integer that uniquely refers to a type, member, string, or<br>resource within the scope of a module. IL uses metadata tokens, so if you're parsing<br>IL, you'll need to be able to resolve them. The methods for doing this are defined in<br>the  Module  type  and  are  called  ResolveType,  ResolveMember,  ResolveString,  and<br>ResolveSignature. We revisit this in the final section of this chapter, on writing a<br>disassembler.<br>
You  can  obtain  a  list  of  all  the  modules  in  an  assembly  by  calling  GetModules.<br>You can also access an assembly's main module directly--via its ManifestModule<br>property.<br>
<b>Working with Attributes<br></b>The CLR allows additional metadata to be attached to types, members, and assem-<br>blies through attributes. This is the mechanism by which many CLR functions such<br>as serialization and security are directed, making attributes an indivisible part of an<br>application.<br>
A key characteristic of attributes is that you can write your own, and then use them<br>just as you would any other attribute to "decorate" a code element with additional<br>information. This additional information is compiled into the underlying assembly<br>and can be retrieved at runtime using reflection to build services that work declar-<br>atively, such as automated unit testing.<br>
<b>Attribute Basics<br></b>There are three kinds of attributes:<br>
· Bit-mapped attributes<br>· Custom attributes<br>· Pseudocustom attributes<br>
Of these, only <i>custom attributes</i> are extensible.<br>
The term "attribute" by itself can refer to any of the three, al-<br>though in the C# world, it most often refers to custom attributes<br>or pseudocustom attributes.<br>
Bit-mapped attributes (our terminology) map to dedicated bits in a type's metadata.<br>Most of C#'s modifier keywords, such as public, abstract, and sealed, compile to<br>
<b>Reflection</b><br>
bit-mapped  attributes.  These  attributes  are  very  efficient  because  they  consume<br>
<b>Working with Attributes | 701</b><br>
<hr>
<A name=722></a>minimal space in the metadata (usually just one bit), and the CLR can locate them<br>with little or no indirection. The reflection API exposes them via dedicated proper-<br>ties on Type (and other MemberInfo subclasses), such as IsPublic, IsAbstract, and<br>IsSealed. The Attributes property returns a flags enum that describes most of them<br>in one hit:<br>
static void Main()<br>
{<br>  TypeAttributes ta = typeof (Console).<b>Attributes</b>;<br>
  MethodAttributes ma = MethodInfo.GetCurrentMethod().<b>Attributes</b>;<br>  Console.WriteLine (ta + &quot;\r\n&quot; + ma);<br>
}<br>
Here's the result:<br>
AutoLayout, AnsiClass, Class, Public, Abstract, Sealed, BeforeFieldInit<br>
PrivateScope, Private, Static, HideBySig<br>
In  contrast,  <i>custom  attributes</i>  compile  to  a  blob  that  hangs  off  the  type's  main<br>metadata table. All custom attributes are represented by a subclass of System.Attrib<br>ute  and,  unlike  bit-mapped  attributes,  are  extensible.  The  blob  in  the  metadata<br>identifies the attribute class, and also stores the values of any positional or named<br>argument that was specified when the attribute was applied. Custom attributes that<br>you  define  yourself  are  architecturally  identical  to  those  defined  in  the  .NET<br>Framework.<br>
Chapter 4 describes how to attach custom attributes to a type or member in C#.<br>Here, we attach the predefined Obsolete attribute to the Foo class:<br>
[Obsolete] public class Foo {...}<br>
This instructs the compiler to incorporate an instance of ObsoleteAttribute into the<br>metadata for Foo, which can then be reflected at runtime by calling GetCustomAttri<br>butes on a Type or MemberInfo object.<br>
<i>Pseudocustom attributes</i> look and feel just like standard custom attributes. They are<br>represented  by  a  subclass  of  System.Attribute  and  are  attached  in  the  standard<br>manner:<br>
[Serializable] public class Foo {...}<br>
The  difference  is  that  the  compiler  or  CLR  internally  optimizes  pseudocustom<br>attributes  by  converting  them  to  bit-mapped  attributes.  Examples  include<br>[Serializable] (Chapter 16), StructLayout, In, and Out (Chapter 25). Reflection<br>exposes  psuedocustom  attributes  through  dedicated  properties  such  as<br>IsSerializable,  and  in  many  cases  they  are  also  returned  as  System.Attribute<br>objects when you call GetCustomAttributes (SerializableAttribute included). This<br>means you can (almost) ignore the difference between pseudo- and non-pseudo-<br>custom attributes (a notable exception is when using Reflection.Emit to generate<br>types dynamically at runtime; see "Emitting Assemblies and Types" on page 714<br>later in this chapter).<br>
<b>702 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=723></a><b>The AttributeUsage Attribute<br></b>AttributeUsage is an attribute applied to attribute classes. It tells the compiler how<br>the target attribute should be used:<br>
public sealed class AttributeUsageAttribute : Attribute<br>{<br>  public AttributeUsageAttribute (AttributeTargets validOn);<br>
  public bool AllowMultiple        { get; set; }<br>  public bool Inherited            { get; set; }<br>
  public AttributeTargets ValidOn  { get; }<br>}<br>
AllowMultiple controls whether the attribute being defined can be applied more than<br>once to the same target; Inherited controls whether the attribute can be subtyped.<br>ValidOn determines the set of targets (classes, interfaces, properties, methods, pa-<br>rameters, etc.) to which the attribute can be attached. It accepts any combination<br>of values from the AttributeTargets enum, which has the following members:<br>
All<br>
Delegate<br>
GenericParameter<br>
Parameter<br>
Assembly<br>
Enum<br>
Interface<br>
Property<br>
Class<br>
Event<br>
Method<br>
ReturnValue<br>
Constructor<br>
Field<br>
Module<br>
Struct<br>
To  illustrate,  here's  how  the  authors  of  the  .NET  Framework  have  applied<br>AttributeUsage to the Serializable attribute:<br>
[AttributeUsage (AttributeTargets.Delegate |<br>                 AttributeTargets.Enum     |<br>                 AttributeTargets.Struct   |<br>                 AttributeTargets.Class,     Inherited = false)<br>]<br>public sealed class SerializableAttribute : Attribute<br>{<br>}<br>
This is, in fact, almost the complete definition of the Serializable attribute. Writing<br>an attribute class that has no properties or special constructors is this simple.<br>
<b>Defining Your Own Attribute<br></b>Here's how you write your own attribute:<br>
1. Derive a class from System.Attribute or a descendent of System.Attribute. By<br>
convention, the class name should end with the word "Attribute," although this<br>isn't required.<br>
2. Apply the AttributeUsage attribute, described in the preceding section.<br>
If the attribute requires no properties or arguments in its constructor, the job<br>is done.<br>
<b>Reflection</b><br>
<b>Working with Attributes | 703</b><br>
<hr>
<A name=724></a>3. Write one or more public constructors. The parameters to the constructor de-<br>
fine the positional parameters of the attribute and will become mandatory when<br>using the attribute.<br>
4. Declare a public field or property for each named parameter you wish to sup-<br>
port. Named parameters are optional when using the attribute.<br>
Attribute properties and constructor parameters must be of the<br>following types:<br>
· A sealed primitive type: in other words, bool, byte, char,<br>
double, float, int, long, short, or string<br>
· The Type type<br>· An enum type<br>· A one-dimensional array of any of these<br>
When an attribute is applied, it must also be possible for the<br>compiler  to  statically  evaluate  each  of  the  properties  or  con-<br>structor arguments.<br>
The following class defines an attribute for assisting an automated unit-testing sys-<br>tem. It indicates that a method should be tested, the number of test repetitions, and<br>a message in case of failure:<br>
[AttributeUsage (AttributeTargets.Method)]<br>public sealed class TestAttribute : Attribute<br>
{<br>  public int     Repetitions;<br>  public string  FailureMessage;<br>
  public TestAttribute () : this (1)     { }<br>  public TestAttribute (int repetitions) { Repetitions = repetitions; }<br>}<br>
Here's a Foo class with methods decorated in various ways with the Test attribute:<br>
class Foo<br>{<br>  [Test]<br>  public void Method1() { ... }<br>
  [Test(20)]<br>  public void Method2() { ... }<br>
  [Test(20, FailureMessage=&quot;Debugging Time!&quot;)]<br>  public void Method3() { ... }<br>}<br>
<b>704 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=725></a><b>Retrieving Attributes at Runtime<br></b>There are two standard ways to retrieve attributes at runtime:<br>
· Call GetCustomAttributes on any Type or MemberInfo object.<br>· Call Attribute.GetCustomAttribute or Attribute.GetCustomAttributes.<br>
These latter two methods are overloaded to accept any reflection object that corre-<br>sponds  to  a  valid  attribute  target  (Type,  Assembly,  Module,  MemberInfo,  or<br>ParameterInfo).<br>
From  Framework  4.0,  you  can  also  call  GetCustomAttri<br>butes<b>Data</b>() on a type or member to obtain attribute informa-<br>tion. The difference between this and GetCustomAttributes() is<br>that the former tells you <i>how</i> the attribute was instantiated: it<br>reports the constructor overload that was used, and the value<br>of  each  constructor  argument  and  named  parameter.  This  is<br>useful when you want to emit code or IL to reconstruct the at-<br>tribute to the same state (see the section "Emitting Type Mem-<br>bers" on page 717 later in this chapter).<br>
Here's how we can enumerate each method in the preceding Foo class that has a<br>TestAttribute:<br>
foreach (MethodInfo mi in typeof (Foo).GetMethods())<br>
{<br>  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute<br>    (mi, typeof (TestAttribute));<br>
  if (att != null)<br>    Console.WriteLine (&quot;Method {0} will be tested; reps={1}; msg={2}&quot;,<br>                        mi.Name, att.Repetitions, att.FailureMessage);<br>}<br>
Here's the output:<br>
Method Method1 will be tested; reps=1; msg=<br>Method Method2 will be tested; reps=20; msg=<br>Method Method3 will be tested; reps=20; msg=Debugging Time!<br>
To complete the illustration on how we could use this to write a unit-testing system,<br>here's the same example expanded so that it actually calls the methods decorated<br>with the Test attribute:<br>
foreach (MethodInfo mi in typeof (Foo).GetMethods())<br>{<br>  TestAttribute att = (TestAttribute) Attribute.GetCustomAttribute<br>    (mi, typeof (TestAttribute));<br>
 <br>  if (att != null)<br>    for (int i = 0; i &lt; att.Repetitions; i++)<br>
<b>Reflection</b><br>
      try<br>
<b>Working with Attributes | 705</b><br>
<hr>
<A name=726></a>      {<br>
        mi.Invoke (new Foo(), null);    // Call method with no arguments<br>      }<br>      catch (Exception ex)       // Wrap exception in att.FailureMessage<br>
      {<br>
        throw new Exception (&quot;Error: &quot; + att.FailureMessage, ex);<br>      }<br>}<br>
Returning to attribute reflection, here's an example that lists the attributes present<br>on a specific type:<br>
[Serializable, Obsolete]<br>
class Test<br>{<br>  static void Main()<br>
  {<br>
    object[] atts = Attribute.GetCustomAttributes (typeof (Test));<br>
    foreach (object att in atts) Console.WriteLine (att);<br>
  }<br>}<br>
Output:<br>
System.ObsoleteAttribute<br>
System.SerializableAttribute<br>
<b>Retrieving Attributes in the Reflection-Only Context<br></b>Calling GetCustomAttributes on a member loaded in the reflection-only context is<br>prohibited  because  it  would  require  instantiating  arbitrarily  typed  attributes  (re-<br>member that object instantiation isn't allowed in the reflection-only context). To<br>work around this, there's a special type called CustomAttributeData for reflecting<br>over such attributes. Here's an example of how it's used:<br>
IList&lt;CustomAttributeData&gt; atts = CustomAttributeData.GetCustomAttributes<br>                                  (<i>myReflectionOnlyType</i>);<br>foreach (CustomAttributeData att in atts)<br>{<br>  Console.Write (att.GetType());               // Attribute type<br>
  Console.WriteLine (&quot; &quot; + att.Constructor);   // ConstructorInfo object<br>
  foreach (CustomAttributeTypedArgument arg in att.ConstructorArguments)<br>    Console.WriteLine (&quot;  &quot; +arg.ArgumentType + &quot;=&quot; + arg.Value);<br>
  foreach (CustomAttributeNamedArgument arg in att.NamedArguments)<br>    Console.WriteLine (&quot;  &quot; + arg.MemberInfo.Name + &quot;=&quot; + arg.TypedValue);<br>}<br>
In many cases, the attribute types will be in a different assembly from the one you're<br>reflecting. One way to cope with this is to handle the  ReflectionOnlyAssemblyRe<br>solve event on the current application domain:<br>
ResolveEventHandler handler = (object sender, ResolveEventArgs args)<br>                            =&gt; Assembly.ReflectionOnlyLoad (args.Name);<br>
<b>706 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=727></a>AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve += handler;<br>
// Reflect over attributes...<br>
AppDomain.CurrentDomain.ReflectionOnlyAssemblyResolve -= handler;<br>
<b>Dynamic Code Generation<br></b>The System.Reflection.Emit namespace contains classes for creating metadata and<br>IL at runtime. Generating code dynamically is useful for certain kinds of program-<br>ming tasks. An example is the regular expressions API, which emits performant types<br>tuned to specific regular expressions. Other uses of Reflection.Emit in the Frame-<br>work include dynamically generating transparent proxies for Remoting and gener-<br>ating types that perform specific XSLT transforms with minimum runtime overhead.<br>LINQPad uses Reflection.Emit to dynamically generate typed DataContext classes.<br>
<b>Generating IL with DynamicMethod<br></b>The DynamicMethod class is a lightweight tool in the System.Reflection.Emit name-<br>space for generating methods on the fly. Unlike TypeBuilder, it doesn't require that<br>you  first  set  up  a  dynamic  assembly,  module,  and  type  in  which  to  contain  the<br>method. This makes it suitable for simple tasks--as well as serving as a good intro-<br>duction to Reflection.Emit.<br>
A  DynamicMethod  and  the  associated  IL  are  garbage-collected<br>when no longer referenced. This means you can repeatedly gen-<br>erate dynamic methods without filling up memory. In contrast,<br>dynamic <i>assemblies</i> cannot be unloaded from memory unless<br>the containing application domain is torn down.<br>
Here is a simple use of DynamicMethod to create a method that writes Hello world to<br>the console:<br>
public class Test<br>{<br>  static void Main()<br>  {<br>    var dynMeth = new DynamicMethod (&quot;Foo&quot;, null, null, typeof (Test));<br>    ILGenerator gen = dynMeth.GetILGenerator();<br>    gen.EmitWriteLine (&quot;Hello world&quot;);<br>
    gen.Emit (OpCodes.Ret);<br>    dynMeth.Invoke (null, null);                    // Hello world<br>  }<br>}<br>
OpCodes has a static read-only field for every IL opcode. Most of the functionality is<br>exposed through various opcodes, although ILGenerator also has specialized meth-<br>ods for generating labels and local variables and for exception handling. A method<br>always ends in Opcodes.Ret, which means "return." The EmitWriteLine method on<br>
<b>Reflection</b><br>
ILGenerator is a shortcut for Emitting a number of lower-level opcodes. We could<br>
<b>Dynamic Code Generation | 707</b><br>
<hr>
<A name=728></a>have replaced the call to EmitWriteLine with this, and we would have gotten the<br>same result:<br>
MethodInfo writeLineStr = typeof (Console).GetMethod (&quot;WriteLine&quot;,<br>                           new Type[] { typeof (string) });<br>
gen.Emit (OpCodes.<b>Ldstr</b>, &quot;Hello world&quot;);     // Load a string<br>
gen.Emit (OpCodes.<b>Call</b>, writeLineStr);       // Call a method<br>
Note that we passed typeof(Test) into DynamicMethod's constructor. This gives the<br>dynamic method access to the nonpublic methods of that type, allowing us to do<br>this:<br>
public class Test<br>
{<br>  static void Main()<br>
  {<br>
    var dynMeth = new DynamicMethod (&quot;Foo&quot;, null, null, <b>typeof (Test)</b>);<br>    ILGenerator gen = dynMeth.GetILGenerator();<br>
    <b>MethodInfo privateMethod = typeof(Test).GetMethod (&quot;HelloWorld&quot;,</b><br>
      <b>BindingFlags.Static | BindingFlags.NonPublic);</b><br>
    gen.Emit (OpCodes.Call, privateMethod);     // Call HelloWorld<br>
    gen.Emit (OpCodes.Ret);<br>
    dynMeth.Invoke (null, null);                // Hello world<br>  }<br>
  static void HelloWorld()       // private method, yet we can call it<br>  {<br>
    Console.WriteLine (&quot;Hello world&quot;);<br>  }<br>}<br>
Understanding IL requires a considerable investment of time. Rather than under-<br>stand all the opcodes, it's much easier to compile a C# program then to examine,<br>copy, and tweak the IL. An assembly viewing tool such as <i>ildasm</i> or Lutz Roeder's<br>Reflector is perfect for the job.<br>
<b>The Evaluation Stack<br></b>Central to IL is the concept of the <i>evaluation stack</i>. The evaluation stack is distinct<br>from the stack used to store local variables and method parameters.<br>
To call a method with arguments, you first push ("load") the arguments onto the<br>evaluation stack, and then call the method. The method then pops the arguments<br>it  needs  from  the  evaluation  stack.  We  demonstrated  this  previously,  in  calling<br>Console.WriteLine. Here's a similar example with an integer:<br>
var dynMeth = new DynamicMethod (&quot;Foo&quot;, null, null, typeof(void));<br>ILGenerator gen = dynMeth.GetILGenerator();<br>MethodInfo writeLineInt = typeof (Console).GetMethod (&quot;WriteLine&quot;,<br>                                        new Type[] { typeof (int) });<br>
// The Ldc* op-codes load numeric literals of various types and sizes.<br>
<b>708 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=729></a>gen.Emit (<b>OpCodes.Ldc_I4</b>, 123);        // Push a 4-byte integer onto stack<br>
gen.Emit (OpCodes.Call, writeLineInt);<br>
gen.Emit (OpCodes.Ret);<br>
dynMeth.Invoke (null, null);           // 123<br>
To add two numbers together, you first load each number onto the evaluation stack,<br>and then call Add. The Add opcode pops two values from the evaluation stack and<br>pushes the result back on. The following adds 2 and 2, and then writes the result<br>using the writeLine method obtained previously:<br>
gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2<br>gen.Emit (OpCodes.Ldc_I4, 2);           // Push a 4-byte integer, value=2<br>
gen.Emit (OpCodes.Add);                 // Add the result together<br>
gen.Emit (OpCodes.Call, writeLineInt);<br>
To calculate 10 / 2 + 1, you can do either this:<br>
gen.Emit (OpCodes.Ldc_I4, 10);<br>
gen.Emit (OpCodes.Ldc_I4, 2);<br>
gen.Emit (OpCodes.Div);<br>
gen.Emit (OpCodes.Ldc_I4, 1);<br>gen.Emit (OpCodes.Add);<br>gen.Emit (OpCodes.Call, writeLineInt);<br>
or this:<br>
gen.Emit (OpCodes.Ldc_I4, 1);<br>
gen.Emit (OpCodes.Ldc_I4, 10);<br>gen.Emit (OpCodes.Ldc_I4, 2);<br>gen.Emit (OpCodes.Div);<br>gen.Emit (OpCodes.Add);<br>gen.Emit (OpCodes.Call, writeLineInt);<br>
<b>Passing Arguments to a Dynamic Method<br></b>You can load an argument passed into a dynamic method onto the stack with the<br>Ldarg and Ldarg_<i>XXX</i> opcodes. To return a value, leave exactly one value on the stack<br>upon finishing. For this to work, you must specify the return type and argument<br>types when calling DynamicMethod's constructor. The following creates a dynamic<br>method that returns the sum of two integers:<br>
DynamicMethod dynMeth = new DynamicMethod (&quot;Foo&quot;,<br>  <b>typeof (int),                              // Return type = int<br></b>  <b>new[] { typeof (int), typeof (int) },      // Parameter types = int, int<br></b>  typeof (void));<br>
ILGenerator gen = dynMeth.GetILGenerator();<br>
gen.Emit (OpCodes.Ldarg_0);      // Push first arg onto eval stack<br>gen.Emit (OpCodes.Ldarg_1);      // Push second arg onto eval stack<br>gen.Emit (OpCodes.Add);          // Add them together (result on stack)<br>gen.Emit (OpCodes.Ret);          // Return with stack having 1 value<br>
int result = (int) dynMeth.Invoke (null, new object[] { 3, 4 } );   // 7<br>
<b>Reflection</b><br>
<b>Dynamic Code Generation | 709</b><br>
<hr>
<A name=730></a>When you exit, the evaluation stack must have exactly 0 or 1<br>items (depending on whether your method returns a value). If<br>you violate this, the CLR will refuse to execute your method.<br>You can remove an item from the stack without processing it<br>with OpCodes.Pop.<br>
Rather  than  calling  Invoke,  it  can  be  more  convenient  to  work  with  a  dynamic<br>method as a typed delegate. The CreateDelegate method achieves just this. To il-<br>lustrate, suppose we define a delegate called BinaryFunction:<br>
delegate int BinaryFunction (int n1, int n2);<br>
We could then replace the last line of our preceding example with this:<br>
BinaryFunction f = (BinaryFunction) dynMeth.CreateDelegate<br>                                           (typeof (BinaryFunction));<br>
int result = f (3, 4);      // 7<br>
A delegate also eliminates the overhead of dynamic method in-<br>vocation--saving a few microseconds per call.<br>
We demonstrate how to pass by reference later in the section "Emitting Type Mem-<br>bers" on page 717.<br>
<b>Generating Local Variables<br></b>You can declare a local variable by calling DeclareLocal on an ILGenerator. This<br>returns a LocalBuilder object, which can be used in conjunction with opcodes such<br>as Ldloc (load a local variable) or Stloc (store a local variable). Ldloc pushes the<br>evaluation stack; Stloc pops it. For example, consider the following C# code:<br>
int x = 6;<br>int y = 7;<br>x *= y;<br>Console.WriteLine (x);<br>
The following generates the preceding code dynamically:<br>
var dynMeth = new DynamicMethod (&quot;Test&quot;, null, null, typeof (void));<br>ILGenerator gen = dynMeth.GetILGenerator();<br>
LocalBuilder localX = gen.DeclareLocal (typeof (int));    // Declare x<br>LocalBuilder localY = gen.DeclareLocal (typeof (int));    // Declare y<br>
gen.Emit (OpCodes.Ldc_I4, 6);        // Push literal 6 onto eval stack<br>gen.Emit (OpCodes.Stloc, localX);    // Store in localX<br>gen.Emit (OpCodes.Ldc_I4, 7);        // Push literal 7 onto eval stack<br>gen.Emit (OpCodes.Stloc, localY);    // Store in localY<br>
gen.Emit (OpCodes.Ldloc, localX);    // Push localX onto eval stack<br>gen.Emit (OpCodes.Ldloc, localY);    // Push localY onto eval stack<br>
<b>710 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=731></a>gen.Emit (OpCodes.Mul);              // Multiply values together<br>
gen.Emit (OpCodes.Stloc, localX);    // Store the result to localX<br>
gen.EmitWriteLine (localX);          // Write the value of localX<br>
gen.Emit (OpCodes.Ret);<br>
dynMeth.Invoke (null, null);         // 42<br>
Lutz  Roeder's  Reflector  is  also  great  for  examining  dynamic<br>methods for errors. If you decompile to C#, it's usually obvious<br>where you've gone wrong! We explain how to save dynamic<br>emissions  to  disk  in  the  section  "Emitting  Assemblies  and<br>Types" on page 714.<br>
<b>Branching<br></b>In IL, there are no while, do, and for loops; it's all done with labels and the equivalent<br>of goto and conditional goto statements. These are the branching opcodes, such as<br>Br (branch unconditionally), Brtrue (branch if the value on the evaluation stack is<br>true), and Blt (branch if the first value is less than the second value).<br>
To set a branch target, first call DefineLabel (this returns a Label object), and then<br>call MarkLabel at the place you want to anchor the label. e.g., consider this C# code:<br>
int x = 5;<br>
while (x &lt;= 10) Console.WriteLine (x++);<br>
We can emit this as follows:<br>
ILGenerator gen = <i>...</i><br>
Label startLoop = gen.DefineLabel();                  // Declare labels<br>Label endLoop = gen.DefineLabel();<br>
LocalBuilder x = gen.DeclareLocal (typeof (int));     // int x<br>gen.Emit (OpCodes.Ldc_I4, 5);                         //<br>gen.Emit (OpCodes.Stloc, x);                          // x = 5<br><b>gen.MarkLabel (startLoop);<br></b>  gen.Emit (OpCodes.Ldc_I4, 10);              // Load 10 onto eval stack<br>  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack<br>
  <b>gen.Emit (OpCodes.Blt, endLoop);            // if (x &gt; 10) goto endLoop</b><br>
  gen.EmitWriteLine (x);                      // Console.WriteLine (x)<br>
  gen.Emit (OpCodes.Ldloc, x);                // Load x onto eval stack<br>  gen.Emit (OpCodes.Ldc_I4, 1);               // Load 1 onto the stack<br>  gen.Emit (OpCodes.Add);                     // Add them together<br>  gen.Emit (OpCodes.Stloc, x);                // Save result back to x<br>
  <b>gen.Emit (OpCodes.Br, startLoop);           // return to start of loop<br>gen.MarkLabel (endLoop);</b><br>
<b>Reflection</b><br>
gen.Emit (OpCodes.Ret);<br>
<b>Dynamic Code Generation | 711</b><br>
<hr>
<A name=732></a><b>Instantiating Objects and Calling Instance Methods<br></b>The IL equivalent of new is the Newobj opcode. This takes a constructor and loads<br>the constructed object onto the evaluation stack. For instance, the code shown next<br>constructs a StringBuilder:<br>
var dynMeth = new DynamicMethod (&quot;Test&quot;, null, null, typeof (void));<br>ILGenerator gen = dynMeth.GetILGenerator();<br>
ConstructorInfo ci = typeof (StringBuilder).GetConstructor (new Type[0]);<br>
gen.Emit (OpCodes.Newobj, ci);<br>
Once an object is on the evaluation stack, you can call its instance methods using the<br>Call or Callvirt opcode. Extending this example, we'll query the StringBuilder's<br>MaxCapacity property by calling the property's get accessor, and then write out the<br>result:<br>
gen.Emit (<b>OpCodes.Callvirt</b>, typeof (StringBuilder)<br>
                            .GetProperty (&quot;MaxCapacity&quot;).GetGetMethod());<br>
gen.Emit (OpCodes.Call, typeof (Console).GetMethod (&quot;WriteLine&quot;,<br>
                                         new[] { typeof (int) } ));<br>
gen.Emit (OpCodes.Ret);<br>dynMeth.Invoke (null, null);              // 2147483647<br>
To emulate C# calling semantics:<br>
· Use Call to invoke static methods and value type instance methods.<br>· Use Callvirt to invoke reference type instance methods (whether or not they're<br>
declared virtual).<br>
In  our  example,  we  used  Callvirt  on  the  StringBuilder  instance--even  though<br>MaxProperty is not virtual. This doesn't cause an error: it simply performs a nonvir-<br>tual call instead. Always invoking reference type instance methods with Callvirt<br>avoids risking the opposite condition: invoking a virtual method with Call. (The<br>risk is real. The author of the target method may later <i>change</i> its declaration.)<br>
Invoking a virtual method with Call bypasses virtual calling se-<br>mantics, and calls that method directly. This is rarely desirable<br>and, in effect, violates type safety.<br>
In the following example, we construct a StringBuilder passing in two arguments,<br>append &quot;, world!&quot; to the StringBuilder, and then call ToString on it:<br>
// We will call:   new StringBuilder (&quot;Hello&quot;, 1000)<br>
ConstructorInfo ci = typeof (StringBuilder).GetConstructor (<br>                     new[] { typeof (string), typeof (int) } );<br>
gen.Emit (OpCodes.Ldstr, &quot;Hello&quot;);   // Load a string onto the eval stack<br>gen.Emit (OpCodes.Ldc_I4, 1000);     // Load an int onto the eval stack<br>gen.Emit (OpCodes.Newobj, ci);       // Construct the StringBuilder<br>
<b>712 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=733></a>Type[] strT = { typeof (string) };<br>
gen.Emit (OpCodes.Ldstr, &quot;, world!&quot;);<br>gen.Emit (OpCodes.Call, typeof (StringBuilder).GetMethod (&quot;Append&quot;, strT));<br>gen.Emit (OpCodes.Callvirt, typeof (object).GetMethod (&quot;ToString&quot;));<br>
gen.Emit (OpCodes.Call, typeof (Console).GetMethod (&quot;WriteLine&quot;, strT));<br>
gen.Emit (OpCodes.Ret);<br>dynMeth.Invoke (null, null);        // Hello, world!<br>
For fun we called GetMethod on typeof(object), and then used Callvirt to perform<br>a virtual method call on ToString. We could have gotten the same result by calling<br>ToString on the StringBuilder type itself:<br>
gen.Emit (OpCodes.Callvirt, typeof (StringBuilder).GetMethod (&quot;ToString&quot;,<br>
                                                          new Type[0] ));<br>
(The empty type array is required in calling GetMethod because StringBuilder over-<br>loads ToString with another signature.)<br>
Had we called object's ToString method nonvirtually:<br>
gen.Emit (OpCodes.Call,<br>          typeof (object).GetMethod (&quot;ToString&quot;));<br>
the  result  would  have  been  "System.Text.StringBuilder".  In<br>other  words,  we  would  have  circumvented  StringBuilder's<br>ToString override and called object's version directly.<br>
<b>Exception Handling<br></b>ILGenerator provides dedicated methods for exception handling. The translation for<br>the following C# code:<br>
try                               { throw new NotSupportedException(); }<br>catch (NotSupportedException ex)  { Console.WriteLine (ex.Message);    }<br>finally                           { Console.WriteLine (&quot;Finally&quot;);     }<br>
is this:<br>
MethodInfo getMessageProp = typeof (NotSupportedException)<br>                            .GetProperty (&quot;Message&quot;).GetGetMethod();<br>
MethodInfo writeLineString = typeof (Console).GetMethod (&quot;WriteLine&quot;,<br>                                             new[] { typeof (object) } );<br><b>gen.BeginExceptionBlock();<br></b>  ConstructorInfo ci = typeof (NotSupportedException).GetConstructor (<br>                                                        new Type[0] );<br>  gen.Emit (OpCodes.Newobj, ci);<br>  gen.Emit (OpCodes.Throw);<br><b>gen.BeginCatchBlock (typeof (NotSupportedException));<br></b>  gen.Emit (OpCodes.Callvirt, getMessageProp);<br>  gen.Emit (OpCodes.Call, writeLineString);<br><b>gen.BeginFinallyBlock();<br></b>  gen.EmitWriteLine (&quot;Finally&quot;);<br><b>gen.EndExceptionBlock();</b><br>
<b>Reflection</b><br>
<b>Dynamic Code Generation | 713</b><br>
<hr>
<A name=734></a>Just as in C#, you can include multiple catch blocks. To rethrow the same exception,<br>emit the Rethrow opcode.<br>
ILGenerator provides a helper method called ThrowException.<br>This contains a bug, however, preventing it from being used<br>with a DynamicMethod. It works only with a MethodBuilder (see<br>the next section).<br>
<b>Emitting Assemblies and Types<br></b>Although is convenient, it can generate only methods. If you need to emit any other<br>construct--or a complete type--you need to use the full "heavyweight" API. This<br>means dynamically building an assembly and module. The assembly need not have<br>a disk presence, however; it can live entirely in memory.<br>
Let's assume we want to dynamically build a type. Since a type must live in a module<br>within an assembly, we must first create the assembly and module before we can<br>create the type. This is the job of the AssemblyBuilder and ModuleBuilder types:<br>
AppDomain appDomain = AppDomain.CurrentDomain;<br>
AssemblyName aname = new AssemblyName (&quot;MyDynamicAssembly&quot;);<br>
AssemblyBuilder assemBuilder =<br>
  appDomain.DefineDynamicAssembly (aname, AssemblyBuilderAccess.Run);<br>
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (&quot;DynModule&quot;);<br>
You can't add a type to an existing assembly, because an as-<br>sembly is immutable once created.<br>
Once we have a module where the type can live, we can use TypeBuilder to create<br>the type. The following defines a class called Widget:<br>
TypeBuilder tb = modBuilder.DefineType (&quot;Widget&quot;, TypeAttributes.Public);<br>
The TypeAttributes flags enum supports the CLR type modifiers you see when dis-<br>assembling a type with <i>ildasm</i>. As well as member visibility flags, this includes type<br>modifiers such as Abstract and Sealed--and Interface for defining a .NET interface.<br>It also includes Serializable, which is equivalent to applying the [Serializable]<br>attribute in C#, and Explicit, which is equivalent to applying [StructLayout(Layout<br>Kind.Explicit)]. We describe how to apply other kinds of attributes later in this<br>chapter, in the section "Attaching Attributes" on page 722.<br>
<b>714 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=735></a>The DefineType method also accepts an optional base type:<br>
· To define a struct, specify a base type of System.ValueType.<br>· To define a delegate, specify a base type of System.Multi<br>
castDelegate.<br>
· To  implement  an  interface,  use  the  constructor  that  ac-<br>
cepts an array of interface types.<br>
· To define an interface, specify TypeAttributes.Interface<br>
| TypeAttributes.Abstract.<br>
Defining a delegate type requires a number of extra steps. In his<br>weblog  at  <i>http://blogs.msdn.com/joelpob/</i>,  Joel  Pobar  demon-<br>strates how this is done in his article titled "Creating delegate<br>types via Reflection.Emit."<br>
We can now create members within the type:<br>
MethodBuilder methBuilder = tb.DefineMethod (&quot;SayHello&quot;,<br>
                                             MethodAttributes.Public,<br>
                                             null, null);<br>
ILGenerator gen = methBuilder.GetILGenerator();<br>
gen.EmitWriteLine (&quot;Hello world&quot;);<br>
gen.Emit (OpCodes.Ret);<br>
We're now ready to create the type, which finalizes its definition:<br>
Type t = tb.CreateType();<br>
Once the type is created, we use ordinary reflection to inspect and perform dynamic<br>binding:<br>
object o = Activator.CreateInstance (t);<br>t.GetMethod (&quot;SayHello&quot;).Invoke (o, null);        // Hello world<br>
<b>Saving Emitted Assemblies<br></b>The Save method on writes a dynamically generated assembly to a specified filename.<br>For this to work, though, you must do two things:<br>
· Specify an AssemblyBuilderAccess of Save or RunAndSave when constructing the<br>
AssemblyBuilder.<br>
· Specify a filename when constructing the ModuleBuilder (this should match the<br>
assembly filename unless you want to create a multimodule assembly).<br>
You can also optionally set properties of the AssemblyName object, such as Version<br>or KeyPair (for signing).<br>For example:<br>
AppDomain domain = AppDomain.CurrentDomain;<br>
AssemblyName aname = new AssemblyName (&quot;MyEmissions&quot;);<br>aname.Version = new Version (2, 13, 0, 1);<br>
<b>Reflection</b><br>
<b>Emitting Assemblies and Types | 715</b><br>
<hr>
<A name=736></a><IMG src="c#-4-nutshell-736_1.jpg"><br>
AssemblyBuilder assemBuilder = domain.DefineDynamicAssembly (<br>
  aname, <b>AssemblyBuilderAccess.RunAndSave</b>);<br>
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (<br>
  &quot;MainModule&quot;, <b>&quot;MyEmissions.dll&quot;</b>);<br>
// Create types as we did previously...<br>// ...<br>
<b>assemBuilder.Save (&quot;MyEmissions.dll&quot;);</b><br>
This writes the assembly to the application's base directory. To save to a different<br>location,  you  must  provide  the  alternative  directory  when  constructing<br>AssemblyBuilder:<br>
AssemblyBuilder assemBuilder = domain.DefineDynamicAssembly (<br>
  aname, AssemblyBuilderAccess.RunAndSave, <b>@&quot;d:\assemblies&quot;</b> );<br>
A dynamic assembly, once written to a file, becomes an ordinary assembly just like<br>any other. A program could statically reference the assembly we just built and do<br>this:<br>
Widget w = new Widget();<br>
w.SayHello();<br>
<b>The Reflection.Emit Object Model<br></b>Figure 18-2 illustrates the essential types in . Each type describes a CLR construct<br>and is based on a counterpart in the System.Reflection namespace. This allows you<br>to use emitted constructs in place of normal constructs when building a type. For<br>example, we previously called Console.WriteLine as follows:<br>
MethodInfo writeLine = typeof(Console).GetMethod (&quot;WriteLine&quot;,<br>                                       new Type[] { typeof (string) });<br>gen.Emit (OpCodes.Call, writeLine);<br>
<i>Figure 18-2. System.Reflection.Emit</i><br>
<b>716 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=737></a>We could just as easily call a dynamically generated method by calling gen.Emit with<br>a MethodBuilder instead of a MethodInfo. This is essential--otherwise, you couldn't<br>write one dynamic method that called another in the same type.<br>
Recall  that  you  must  call  CreateType  on  a  TypeBuilder  when  you've  finished<br>populating  it.  Calling  CreateType  seals  the  TypeBuilder  and  all  its  members--so<br>nothing more can be added or changed--and gives you back a real Type that you<br>can instantiate.<br>
Before you call CreateType, the TypeBuilder and its members are in an "uncreated"<br>state. There are significant restrictions on what you can do with uncreated con-<br>structs. In particular, you cannot call any of the members that return MemberInfo<br>objects, such as GetMembers, GetMethod, or GetProperty--these all throw an excep-<br>tion. If you want to refer to members of an uncreated type, you must use the original<br>emissions:<br>
TypeBuilder tb = ...<br>
MethodBuilder method1 = tb.DefineMethod (&quot;Method1&quot;, ...);<br>
MethodBuilder method2 = tb.DefineMethod (&quot;Method2&quot;, ...);<br>
ILGenerator gen1 = method1.GetILGenerator();<br>
// Suppose we want method1 to call method2:<br>
gen1.Emit (OpCodes.Call, method2);                    // Right<br>
gen1.Emit (OpCodes.Call, tb.GetMethod (&quot;Method2&quot;));   // Wrong<br>
After calling CreateType, you can reflect on and activate not only the Type returned,<br>but also the original TypeBuilder object. The TypeBuilder, in fact, morphs into a<br>proxy for the real Type. We'll see why this feature is important later in this chapter<br>in the section "Awkward Emission Targets" on page 725.<br>
<b>Emitting Type Members<br></b>All the examples in this section assume a TypeBuilder, tb, has been instantiated as<br>follows:<br>
AppDomain domain = AppDomain.CurrentDomain;<br>AssemblyName aname = new AssemblyName (&quot;MyEmissions&quot;);<br>
AssemblyBuilder assemBuilder = domain.DefineDynamicAssembly (<br>  aname, AssemblyBuilderAccess.RunAndSave);<br>
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (<br>  &quot;MainModule&quot;, &quot;MyEmissions.dll&quot;);<br>
TypeBuilder tb = modBuilder.DefineType (&quot;Widget&quot;, TypeAttributes.Public);<br>
<b>Reflection</b><br>
<b>Emitting Type Members | 717</b><br>
<hr>
<A name=738></a><b>Emitting Methods<br></b>You can specify a return type and parameter types when calling DefineMethod, in the<br>same manner as when instantiating a DynamicMethod; e.g., the following method:<br>
public static double SquareRoot (double value)<br>
{<br>  return Math.Sqrt (value);<br>
}<br>
can be generated like this:<br>
MethodBuilder mb = tb.DefineMethod (&quot;SquareRoot&quot;,<br>  MethodAttributes.Static | MethodAttributes.Public,<br>
  CallingConventions.Standard,<br>
  <b>typeof (double),                     // Return type</b><br>
  <b>new[]  { typeof (double) } );        // Parameter types</b><br>
mb.DefineParameter (1, ParameterAttributes.None, &quot;value&quot;);  // Assign name<br>
ILGenerator gen = mb.GetILGenerator();<br>
gen.Emit (OpCodes.Ldarg_0);                                // Load 1st arg<br>
gen.Emit (OpCodes.Call, typeof(Math).GetMethod (&quot;Sqrt&quot;));<br>
gen.Emit (OpCodes.Ret);<br>
Type realType = tb.CreateType();<br>
double x = (double) tb.GetMethod (&quot;SquareRoot&quot;).Invoke (null,<br>
                                                new object[] { 10.0 });<br>Console.WriteLine (x);   // 3.16227766016838<br>
Calling DefineParameter is optional and is typically done to assign the parameter a<br>name. The number 1 refers to the first parameter (0 refers to the return value). If you<br>call DefineParameter, the parameter is implicitly named __p1, __p2, and so on. As-<br>signing names makes sense if you will write the assembly to disk; it makes your<br>methods friendly to consumers.<br>
DefineParameter returns a ParameterBuilder object upon which<br>you can call SetCustomAttribute to attach attributes (see "At-<br>taching Attributes" on page 722, later in this chapter).<br>
To emit pass-by-reference parameters, such as in the following C# method:<br>
public static void SquareRoot (<b>ref</b> double value)<br>{<br>  value = Math.Sqrt (value);<br>}<br>
call MakeByRefType on the parameter type(s):<br>
MethodBuilder mb = tb.DefineMethod (&quot;SquareRoot&quot;,<br>  MethodAttributes.Static | MethodAttributes.Public,<br>  CallingConventions.Standard,<br>  null,<br>  new Type[] { <b>typeof (double).MakeByRefType()</b> } );<br>
<b>718 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=739></a>mb.DefineParameter (1, ParameterAttributes.None, &quot;value&quot;);<br>
ILGenerator gen = mb.GetILGenerator();<br>gen.Emit (OpCodes.Ldarg_0);<br>
gen.Emit (OpCodes.Ldarg_0);<br>
gen.Emit (OpCodes.Ldind_R8);<br>gen.Emit (OpCodes.Call, typeof (Math).GetMethod (&quot;Sqrt&quot;));<br>gen.Emit (OpCodes.Stind_R8);<br>
gen.Emit (OpCodes.Ret);<br>
Type realType = tb.CreateType();<br>object[] args = { 10.0 };<br>
tb.GetMethod (&quot;SquareRoot&quot;).Invoke (null, args);<br>Console.WriteLine (args[0]);                     // 3.16227766016838<br>
The opcodes here were copied from a disassembled C# method. Notice the differ-<br>ence in semantics for accessing parameters passed by reference: Ldind and Stind<br>mean "load indirectly" and "store indirectly," respectively. The R8 suffix means an<br>8-byte floating-point number.<br>
The process for emitting out parameters is identical, except that you call DefinePara<br>meter as follows:<br>
mb.DefineParameter (1, <b>ParameterAttributes.Out</b>, &quot;value&quot;);<br>
<b>Generating instance methods<br></b>To generate an instance method, specify MethodAttributes.Instance when calling<br>DefineMethod:<br>
MethodBuilder mb = tb.DefineMethod (&quot;SquareRoot&quot;,<br>  MethodAttributes.<b>Instance</b> | MethodAttributes.Public<br>  ...<br>
With instance methods, argument zero is implicitly this; the remaining arguments<br>start at 1. So, Ldarg_0 loads this onto the evaluation stack; Ldarg_1 loads the first<br>real method argument.<br>
<b>HideBySig<br></b>If you're subclassing another type, it's nearly always worth specifying MethodAttri<br>butes.HideBySig when defining methods. HideBySig ensures that C#-style method<br>hiding semantics are applied, which is that a base method is hidden only if a subtype<br>defines a method with an identical <i>signature</i>. Without HideBySig, method hiding<br>considers only the <i>name</i>, so Foo(string) in the subtype will hide Foo() in the base<br>type, which is generally undesirable.<br>
<b>Emitting Fields and Properties<br></b>To create a field, you call DefineField on a TypeBuilder, telling it the desired field<br>name,  type,  and  visibility.  The  following  creates  a  private  integer  field  called<br>"length":<br>
<b>Reflection</b><br>
<b>Emitting Type Members | 719</b><br>
<hr>
<A name=740></a>FieldBuilder field = tb.DefineField (&quot;length&quot;, typeof (int),<br>
                                      FieldAttributes.Private);<br>
Creating  a  property  or  indexer  requires  a  few  more  steps.  First,  call  DefineProp<br>erty on a TypeBuilder, telling it the name and type of the property:<br>
PropertyBuilder prop = tb.DefineProperty (<br>
                         &quot;Text&quot;,                      // Name of property<br>                         PropertyAttributes.None,<br>
                         typeof (string),             // Property type<br>                         new Type[0]                  // Indexer types<br>
                       );<br>
(If you're writing an indexer, the final argument is an array of indexer types.) Note<br>that  we  haven't  specified  the  property  visibility:  this  is  done  individually  on  the<br>accessor methods.<br>
The  next  step  is  to  write  the  get  and  set  methods.  By  convention,  their  names<br>are csn3ed with "get_" or "set_". You then attach them to the property by calling<br>SetGetMethod and SetSetMethod on the PropertyBuilder.<br>
To give a complete example, we'll take the following field and property declaration:<br>
string _text;<br>
public string Text<br>
{<br>  get          { return _text; }<br>
  internal set { _text = value; }<br>
}<br>
and generate it dynamically:<br>
FieldBuilder field = tb.DefineField (&quot;_text&quot;, typeof (string),<br>                                      FieldAttributes.Private);<br>PropertyBuilder prop = tb.DefineProperty (<br>                         &quot;Text&quot;,                      // Name of property<br>                         PropertyAttributes.None,<br>                         typeof (string),             // Property type<br>                         new Type[0]);                // Indexer types<br>
MethodBuilder getter = tb.DefineMethod (<br>  &quot;get_Text&quot;,                                         // Method name<br>  MethodAttributes.Public | MethodAttributes.SpecialName,<br>  typeof (string),                                    // Return type<br>  new Type[0]);                                       // Parameter types<br>
ILGenerator getGen = getter.GetILGenerator();<br>getGen.Emit (OpCodes.Ldarg_0);        // Load &quot;this&quot; onto eval stack<br>getGen.Emit (OpCodes.Ldfld, field);   // Load field value onto eval stack<br>getGen.Emit (OpCodes.Ret);            // Return<br>
MethodBuilder setter = tb.DefineMethod (<br>  &quot;set_Text&quot;,<br>  MethodAttributes.Assembly | MethodAttributes.SpecialName,<br>  null,                                                 // Return type<br>  new Type[] { typeof (string) } );                     // Parameter types<br>
<b>720 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=741></a>ILGenerator setGen = setter.GetILGenerator();<br>
setGen.Emit (OpCodes.Ldarg_0);        // Load &quot;this&quot; onto eval stack<br>setGen.Emit (OpCodes.Ldarg_1);        // Load 2nd arg, i.e., value<br>setGen.Emit (OpCodes.Stfld, field);   // Store value into field<br>
setGen.Emit (OpCodes.Ret);            // return<br>
prop.SetGetMethod (getter);           // Link the get method and property<br>prop.SetSetMethod (setter);           // Link the set method and property<br>
We can test the property as follows:<br>
Type t = tb.CreateType();<br>
object o = Activator.CreateInstance (t);<br>
t.GetProperty (&quot;Text&quot;).SetValue (o, &quot;Good emissions!&quot;, new object[0]);<br>string text = (string) t.GetProperty (&quot;Text&quot;).GetValue (o, null);<br>
Console.WriteLine (text);             // Good emissions!<br>
Notice that in defining the accessor  MethodAttributes, we included SpecialName.<br>This instructs compilers to disallow direct binding to these methods when statically<br>referencing the assembly. It also ensures that the accessors are handled appropriately<br>by reflection tools and Visual Studio's IntelliSense.<br>
You  can  emit  events  in  a  similar  manner,  by  calling<br>DefineEvent on a TypeBuilder. You then write explicit event ac-<br>cessor methods, and attach them to the EventBuilder by calling<br>SetAddOnMethod and SetRemoveOnMethod.<br>
<b>Emitting Constructors<br></b>You  can  define  your  own  constructors  by  calling  DefineConstructor  on  a  type<br>builder. You're not obliged to do so--a default parameterless constructor is provi-<br>ded automatically if you don't. The default constructor calls the base class con-<br>structor if subtyping, just like in C#. Defining one or more constructors displaces<br>this default constructor.<br>
If you need to initialize fields, the constructor's a good spot. In fact, it's the only<br>spot: C#'s field initializers don't have special CLR support--they are simply a syn-<br>tactic shortcut for assigning values to fields in the constructor. So, to reproduce this:<br>
class Widget<br>{<br>  <b>int _capacity = 4000;<br></b>}<br>
you would define a constructor as follows:<br>
FieldBuilder field = tb.DefineField (&quot;_capacity&quot;, typeof (int),<br>                                      FieldAttributes.Private);<br>ConstructorBuilder c = tb.DefineConstructor (<br>  MethodAttributes.Public,<br>  CallingConventions.Standard,<br>  new Type[0]);                  // Constructor parameters<br>
<b>Reflection</b><br>
<b>Emitting Type Members | 721</b><br>
<hr>
<A name=742></a>ILGenerator gen = c.GetILGenerator();<br>
gen.Emit (OpCodes.Ldarg_0);             // Load &quot;this&quot; onto eval stack<br>gen.Emit (OpCodes.Ldc_I4, 4000);        // Load 4000 onto eval stack<br>
gen.Emit (OpCodes.Stfld, field);        // Store it to our field<br>
gen.Emit (OpCodes.Ret);<br>
<b>Calling base constructors<br></b>If subclassing another type, the constructor we just wrote would <i>circumvent the base<br>class constructor</i>. This is unlike C#, where the base class constructor is always called,<br>whether directly or indirectly. For instance, given the following code:<br>
class A     { public A() { Console.Write (&quot;A&quot;); } }<br>class B : A { public B() {} }<br>
the compiler, in effect, will translate the second line into this:<br>
class B : A { public B() <b>: base()</b> {} }<br>
This is not the case when generating IL: you must explicitly call the base constructor<br>if you want it to execute (which nearly always, you do). Assuming the base class is<br>called B, here's how to do it:<br>
gen.Emit (OpCodes.Ldarg_0);<br>ConstructorInfo baseConstr = typeof (B).GetConstructor (new Type[0]);<br>
gen.Emit (OpCodes.Call, baseConstr);<br>
Calling constructors with arguments is just the same as with methods.<br>
<b>Attaching Attributes<br></b>You can attach custom attributes to a dynamic construct by calling SetCustomAttri<br>bute with a CustomAttributeBuilder. For example, suppose we want to attach the<br>following attribute declaration to a field or property:<br>
[XmlElement (&quot;FirstName&quot;, Namespace=&quot;http://test/&quot;, Order=3)]<br>
This relies on the XmlElementAttribute constructor that accepts a single string. To<br>use CustomAttributeBuilder, we must retrieve this constructor, as well as the two<br>additional properties we wish to set (Namespace and Order):<br>
Type attType = typeof (XmlElementAttribute);<br>
ConstructorInfo attConstructor = attType.GetConstructor (<br>  new Type[] { typeof (string) } );<br>
var att = new CustomAttributeBuilder (<br>  attConstructor,                        // Constructor<br>  new object[] { &quot;FirstName&quot; },          // Constructor arguments<br>  new PropertyInfo[]<br>  {<br>    attType.GetProperty (&quot;Namespace&quot;),   // Properties<br>    attType.GetProperty (&quot;Order&quot;)<br>  },<br>  new object[] { &quot;http://test/&quot;, 3 }     // Property values<br>);<br>
<b>722 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=743></a>myFieldBuilder.SetCustomAttribute (att);<br>
// or propBuilder.SetCustomAttribute (att);<br>// or typeBuilder.SetCustomAttribute (att);  etc<br>
<b>Emitting Generic Methods and Types<br></b>All the examples in this section assume that modBuilder has been instantiated as<br>follows:<br>
AppDomain domain = AppDomain.CurrentDomain;<br>
AssemblyName aname = new AssemblyName (&quot;MyEmissions&quot;);<br>
AssemblyBuilder assemBuilder = domain.DefineDynamicAssembly (<br>
  aname, AssemblyBuilderAccess.RunAndSave);<br>
ModuleBuilder modBuilder = assemBuilder.DefineDynamicModule (<br>
  &quot;MainModule&quot;, &quot;MyEmissions.dll&quot;);<br>
<b>Defining Generic Methods<br></b>To emit a generic method:<br>
1. Call  DefineGenericParameters  on  a  MethodBuilder  to  obtain  an  array  of<br>
GenericTypeParameterBuilder objects.<br>
2. Call SetSignature on a MethodBuilder using these generic type parameters.<br>3. Optionally, name the parameters as you would otherwise.<br>
For example, the following generic method:<br>
public static T Echo&lt;T&gt; (T value)<br>{<br>  return value;<br>}<br>
can be emitted like this:<br>
TypeBuilder tb = modBuilder.DefineType (&quot;Widget&quot;, TypeAttributes.Public);<br>
MethodBuilder mb = tb.DefineMethod (&quot;Echo&quot;, MethodAttributes.Public |<br>                                            MethodAttributes.Static);<br><b>GenericTypeParameterBuilder[] genericParams<br></b>  <b>= mb.DefineGenericParameters (&quot;T&quot;);</b><br>
mb.SetSignature (<b>genericParams[0],     // Return type<br></b>                 null, null,<br>                 <b>genericParams,        // Parameter types<br></b>                 null, null);<br>
mb.DefineParameter (1, ParameterAttributes.None, &quot;value&quot;);   // Optional<br>
ILGenerator gen = mb.GetILGenerator();<br>gen.Emit (OpCodes.Ldarg_0);<br>gen.Emit (OpCodes.Ret);<br>
<b>Reflection</b><br>
<b>Emitting Generic Methods and Types | 723</b><br>
<hr>
<A name=744></a>The DefineGenericParameters method accepts any number of string arguments--<br>these correspond to the desired generic type names. In this example, we needed just<br>one generic type called T. GenericTypeParameterBuilder is based on System.Type, so<br>it can be used in place of a TypeBuilder when emitting opcodes.<br>
GenericTypeParameterBuilder also lets you specify a base type constraint:<br>
genericParams[0].<b>SetBaseTypeConstraint</b> (typeof (Foo));<br>
and interface constraints:<br>
genericParams[0].<b>SetInterfaceConstraints</b> (typeof (IComparable));<br>
To replicate this:<br>
public static T Echo&lt;T&gt; (T value) <b>where T : IComparable&lt;T&gt;</b><br>
you would write:<br>
genericParams[0].SetInterfaceConstraints (<br>
  typeof (IComparable&lt;&gt;).MakeGenericType (genericParams[0]) );<br>
For other kinds of constraints, call SetGenericParameterAttributes. This accepts a<br>member of the GenericParameterAttributes enum, which includes these values:<br>
DefaultConstructorConstraint<br>
NotNullableValueTypeConstraint<br>
ReferenceTypeConstraint<br>
Covariant<br>Contravariant<br>
The  last  two  are  equivalent  to  applying  the  out  and  in  modifiers  to  the  type<br>parameters.<br>
<b>Defining Generic Types<br></b>You can define generic types in a similar fashion. The difference is that you call<br>DefineGenericParameters on the TypeBuilder rather than the MethodBuilder. So, to<br>reproduce this:<br>
public class Widget&lt;T&gt;<br>{<br>  public T Value;<br>}<br>
you would do the following:<br>
TypeBuilder tb = modBuilder.DefineType (&quot;Widget&quot;, TypeAttributes.Public);<br>
GenericTypeParameterBuilder[] genericParams<br>  = tb.<b>DefineGenericParameters</b> (&quot;T&quot;);<br>
tb.DefineField (&quot;Value&quot;, genericParams[0], FieldAttributes.Public);<br>
Generic constraints can be added just as with a method.<br>
<b>724 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=745></a><b>Awkward Emission Targets<br></b>All the examples in this section assume that a modBuilder has been instantiated as<br>in previous sections.<br>
<b>Uncreated Closed Generics<br></b>Suppose you want to emit a method that uses a closed generic type:<br>
public class Widget<br>
{<br>  public static void Test() { var list = new List&lt;int&gt;(); }<br>
}<br>
The process is fairly straightforward:<br>
TypeBuilder tb = modBuilder.DefineType (&quot;Widget&quot;, TypeAttributes.Public);<br>
MethodBuilder mb = tb.DefineMethod (&quot;Test&quot;, MethodAttributes.Public |<br>
                                            MethodAttributes.Static);<br>
ILGenerator gen = mb.GetILGenerator();<br>
<b>Type variableType = typeof (List&lt;int&gt;);</b><br>
ConstructorInfo ci = variableType.GetConstructor (new Type[0]);<br>
LocalBuilder listVar = gen.DeclareLocal (variableType);<br>gen.Emit (OpCodes.Newobj, ci);<br>
gen.Emit (OpCodes.Stloc, listVar);<br>gen.Emit (OpCodes.Ret);<br>
Now suppose that instead of a list of integers, we want a list of widgets:<br>
public class Widget<br>{<br>  public static void Test() { var list = new List&lt;<b>Widget</b>&gt;(); }<br>}<br>
In theory, this is a simple modification; all we do is replace this line:<br>
Type variableType = typeof (List&lt;int&gt;);<br>
with this:<br>
Type variableType = typeof (List&lt;&gt;)<b>.MakeGenericType (tb)</b>;<br>
Unfortunately,  this  causes  a  NotSupportedException  to  be  thrown  when  we  then<br>call  GetConstructor.  The  problem  is  that  you  cannot  call  GetConstructor  on  a<br>generic type closed with an uncreated type builder. The same goes for GetField and<br>GetMethod.<br>
The solution is unintuitive. TypeBuilder provides three static methods as follows:<br>
public static ConstructorInfo GetConstructor (Type, ConstructorInfo);<br>public static FieldInfo       GetField       (Type, FieldInfo);<br>public static MethodInfo      GetMethod      (Type, MethodInfo);<br>
<b>Reflection</b><br>
<b>Awkward Emission Targets | 725</b><br>
<hr>
<A name=746></a>Although it doesn't appear so, these methods exist specifically to obtain members<br>of generic types closed with uncreated type builders! The first parameter is the closed<br>generic type; the second parameter is the member you want on the <i>unbound</i> generic<br>type. Here's the corrected version of our example:<br>
MethodBuilder mb = tb.DefineMethod (&quot;Test&quot;, MethodAttributes.Public |<br>                                            MethodAttributes.Static);<br>
ILGenerator gen = mb.GetILGenerator();<br>
Type variableType = typeof (List&lt;&gt;).MakeGenericType (tb);<br>
<b>ConstructorInfo unbound = typeof (List&lt;&gt;).GetConstructor (new Type[0]);<br>ConstructorInfo ci = TypeBuilder.GetConstructor (variableType, unbound);</b><br>
LocalBuilder listVar = gen.DeclareLocal (variableType);<br>
gen.Emit (OpCodes.Newobj, ci);<br>
gen.Emit (OpCodes.Stloc, listVar);<br>
gen.Emit (OpCodes.Ret);<br>
<b>Circular Dependencies<br></b>Suppose you want to build two types that reference each other. For instance:<br>
class A { public B Bee; }<br>class B { public A Aye; }<br>
You can generate this dynamically as follows:<br>
var publicAtt = FieldAttributes.Public;<br>
TypeBuilder aBuilder = modBuilder.DefineType (&quot;A&quot;);<br>
TypeBuilder bBuilder = modBuilder.DefineType (&quot;B&quot;);<br>
FieldBuilder bee = aBuilder.DefineField (&quot;Bee&quot;, bBuilder, publicAtt);<br>FieldBuilder aye = bBuilder.DefineField (&quot;Aye&quot;, aBuilder, publicAtt);<br>
Type realA = aBuilder.CreateType();<br>Type realB = bBuilder.CreateType();<br>
Notice that we didn't call CreateType on aBuilder or bBuilder until we populated<br>both objects. The principle is: first hook everything up, and then call CreateType on<br>each type builder.<br>
Interestingly, the realA type is valid but <i>dysfunctional</i> until you call CreateType on<br>bBuilder. (If you started using aBuilder prior to this, an exception would be thrown<br>when you tried to access field Bee.)<br>You might wonder how bBuilder knows to "fix up" realA after creating realB. The<br>answer is that it doesn't: realA can fix <i>itself</i> the next time it's used. This is possible<br>because after calling  CreateType, a TypeBuilder morphs into a proxy for the real<br>runtime type. So, realA, with its references to bBuilder, can easily obtain the meta-<br>data it needs for the upgrade.<br>
This system works when the type builder demands simple information of the un-<br>constructed type--information that can be <i>predetermined</i>--such as type, member,<br>
<b>726 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=747></a>and object references. In creating realA, the type builder doesn't need to know, for<br>instance, how many bytes realB will eventually occupy in memory. This is just as<br>well, because realB has not yet been created! But now imagine that realB was a<br>struct. The final size of realB is now critical information in creating realA.<br>If the relationship is noncyclical--for instance:<br>
struct A { public B Bee; }<br>
struct B {               }<br>
you can solve this by first creating struct B, and then struct A. But consider this:<br>
struct A { public B Bee; }<br>
struct B { public A Aye; }<br>
We won't try to emit this because it's nonsensical to have two structs contain each<br>other (C# generates a compile-time error if you try). But the following variation is<br>both legal and useful:<br>
public struct S&lt;T&gt; { ... }    // S can be empty and this demo will work.<br>
class A { S&lt;B&gt; Bee; }<br>
class B { S&lt;A&gt; Aye; }<br>
In creating A, a TypeBuilder now needs to know the memory footprint of B, and vice<br>versa. To illustrate, we'll assume that struct S is defined statically. Here's the code<br>to emit classes A and B:<br>
var pub = FieldAttributes.Public;<br>
TypeBuilder aBuilder = modBuilder.DefineType (&quot;A&quot;);<br>TypeBuilder bBuilder = modBuilder.DefineType (&quot;B&quot;);<br>
aBuilder.DefineField (&quot;Bee&quot;, typeof(S&lt;&gt;).MakeGenericType (bBuilder), pub);<br>bBuilder.DefineField (&quot;Aye&quot;, typeof(S&lt;&gt;).MakeGenericType (aBuilder), pub);<br>
Type realA = aBuilder.CreateType();    // Error: cannot load type B<br>Type realB = bBuilder.CreateType();<br>
CreateType now throws a TypeLoadException no matter in which order you go:<br>
· Call aBuilder.CreateType first and it says "cannot load type B".<br>· Call bBuilder.CreateType first and it says "cannot load type A"!<br>
You'll run into this problem if you emit typed LINQ to SQL<br>DataContexts  dynamically.  The  generic  EntityRef  type  is  a<br>struct, equivalent to S in our examples. The circular reference<br>happens  when  two  tables  in  the  database  link  to  each  other<br>through reciprocal parent/child relationships.<br>
To solve this, you must allow the type builder to create realB partway through cre-<br>ating realA. This is done by handling the TypeResolve event on the current applica-<br>tion domain just before calling CreateType. So, in our example, we replace the last<br>two lines with this:<br>
<b>Reflection</b><br>
<b>Awkward Emission Targets | 727</b><br>
<hr>
<A name=748></a>TypeBuilder[] uncreatedTypes = { aBuilder, bBuilder };<br>
ResolveEventHandler handler = delegate (object o, ResolveEventArgs args)<br>{<br>  var type = uncreatedTypes.FirstOrDefault (t =&gt; t.FullName == args.Name);<br>
  return type == null ? null : type.CreateType().Assembly;<br>};<br>
AppDomain.CurrentDomain.TypeResolve += handler;<br>
Type realA = aBuilder.CreateType();<br>Type realB = bBuilder.CreateType();<br>
AppDomain.CurrentDomain.TypeResolve -= handler;<br>
The TypeResolve event fires during the call to aBuilder.CreateType, at the point when<br>it needs you to call CreateType on bBuilder.<br>
Handling the TypeResolve event as in this example is also nec-<br>essary when defining a nested type, when the nested and parent<br>types refer to each other.<br>
<b>Parsing IL<br></b>You  can  obtain  information  about  the  content  of  an  existing  method  by  calling<br>GetMethodBody  on  a  MethodBase  object.  This  returns  a  MethodBody  object  that  has<br>properties  for  inspecting  a  method's  local  variables,  exception  handling  clauses,<br>stack size--as well as the raw IL. Rather like the reverse of Reflection.Emit!<br>Inspecting a method's raw IL can be useful in profiling code. A simple use would be<br>to determine which methods in an assembly have changed, when an assembly is<br>updated.<br>
To illustrate parsing IL, we'll write an application that disassembles IL in the style<br>of <i>ildasm</i>. This could be used as the starting point for a code analysis tool or a higher-<br>level language disassembler.<br>
Remember that in the reflection API, all of C#'s functional con-<br>structs are either represented by a MethodBase subtype, or (in the<br>case of properties, events, and indexers) have MethodBase objects<br>attached to them.<br>
<b>Writing a Disassembler</b><br>
You can download the source code for this at <i>http://www.alba<br>hari.com/nutshell/</i>.<br>
<b>728 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=749></a>Here is a sample of the output our disassembler will produce:<br>
IL_00EB:  ldfld        Disassembler._pos<br>
IL_00F0:  ldloc.2<br>
IL_00F1:  add<br>IL_00F2:  ldelema      System.Byte<br>IL_00F7:  ldstr        &quot;Hello world&quot;<br>
IL_00FC:  call         System.Byte.ToString<br>
IL_0101:  ldstr        &quot; &quot;<br>IL_0106:  call         System.String.Concat<br>
To obtain this output, we must parse the binary tokens that make up the IL. The<br>first step is to call the GetILAsByteArray method on MethodBody to obtain the IL as a<br>byte array. In order to make the rest of the job easier, we will write this into a class<br>as follows:<br>
public class Disassembler<br>
{<br>  public static string Disassemble (MethodBase method)<br>
  {<br>
    return new Disassembler (method).Dis();<br>
  }<br>
  StringBuilder _output;    // The result to which we'll keep appending<br>
  Module _module;           // This will come in handy later<br>
  byte[] _il;               // The raw byte code<br>  int _pos;                 // The position we're up to in the byte code<br>
  Disassembler (MethodBase method)<br>  {<br>
    _module = method.DeclaringType.Module;<br>    <b>_il = method.GetMethodBody().GetILAsByteArray();<br></b>  }<br>
  string Dis()<br>  {<br>    _output = new StringBuilder();<br>    while (_pos &lt; _il.Length) <b>DisassembleNextInstruction</b>();<br>    return _output.ToString();<br>  }<br>}<br>
The static Disassemble method will be the only public member of this class. All other<br>members will be private to the disassembly process. The Dis method contains the<br>"main" loop where we process each instruction.<br>
With  this  skeleton  in  place,  all  that  remains  is  to  write  DisassembleNextInstruc<br>tion. But before doing so, it will help to load all the opcodes into a static dictionary,<br>so we can access them by their 8- or 16-bit value. The easiest way to accomplish this<br>is  to  use  reflection  to  retrieve  all  the  static  fields  whose  type  is  OpCode  in  the<br>OpCodes class:<br>
<b>Reflection</b><br>
<b>Parsing IL | 729</b><br>
<hr>
<A name=750></a>static Dictionary&lt;short,OpCode&gt; _opcodes = new Dictionary&lt;short,OpCode&gt;();<br>
static Disassembler()<br>{<br>  Dictionary&lt;short, OpCode&gt; opcodes = new Dictionary&lt;short, OpCode&gt;();<br>
    foreach (FieldInfo fi in typeof (OpCodes).GetFields<br>                             (BindingFlags.Public | BindingFlags.Static))<br>      if (typeof (OpCode).IsAssignableFrom (fi.FieldType))<br>
      {<br>
        OpCode code = (OpCode) fi.GetValue (null);   // Get field's value<br>        if (code.OpCodeType != OpCodeType.Nternal)<br>          _opcodes.Add (code.Value, code);<br>
      }<br>
}<br>
We've written it in a static constructor so that it executes just once.<br>
Now we can write DisassembleNextInstruction. Each IL instruction consists of a 1-<br>or 2-byte opcode, followed by an operand of zero, one, two, four, or eight bytes. (An<br>exception is inline switch opcodes, which are followed by a variable number of op-<br>erands). So, we read the opcode, then the operand, and then write out the result:<br>
void DisassembleNextInstruction()<br>
{<br>  int opStart = _pos;<br>
  OpCode code = <b>ReadOpCode</b>();<br>
  string operand = <b>ReadOperand</b> (code);<br>
  _output.AppendFormat (&quot;IL_{0:X4}:  {1,-12} {2}&quot;,<br>                        opStart, code.Name, operand);<br>  _output.AppendLine();<br>}<br>
To read an opcode, we advance one byte and see whether we have a valid instruction.<br>If not, we advance another byte and look for a 2-byte instruction:<br>
OpCode ReadOpCode()<br>{<br>  byte byteCode = _il [_pos++];<br>  if (_opcodes.ContainsKey (byteCode)) return _opcodes [byteCode];<br>
  if (_pos == _il.Length)  throw new Exception (&quot;Unexpected end of IL&quot;);<br>
  short shortCode = (short) (byteCode * 256 + _il [_pos++]);<br>
  if (!_opcodes.ContainsKey (shortCode))<br>    throw new Exception (&quot;Cannot find opcode &quot; + shortCode);<br>
  return _opcodes [shortCode];<br>}<br>
To read an operand, we first must establish its length. We can do this based on the<br>operand type. Because most are four bytes long, we can filter out the exceptions<br>fairly easily in a conditional clause.<br>
<b>730 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=751></a>The next step is to call FormatOperand, which will attempt to format the operand:<br>
string ReadOperand (OpCode c)<br>
{<br>  int operandLength =<br>    c.OperandType == OperandType.InlineNone<br>      ? 0 :<br>
    c.OperandType == OperandType.ShortInlineBrTarget ||<br>
    c.OperandType == OperandType.ShortInlineI ||<br>    c.OperandType == OperandType.ShortInlineVar<br>      ? 1 :<br>
    c.OperandType == OperandType.InlineVar<br>
      ? 2 :<br>    c.OperandType == OperandType.InlineI8 ||<br>    c.OperandType == OperandType.InlineR<br>
      ? 8 :<br>
    c.OperandType == OperandType.InlineSwitch<br>      ? 4 * (BitConverter.ToInt32 (_il, _pos) + 1) :<br>      4;  // All others are 4 bytes<br>
  if (_pos + operandLength &gt; _il.Length)<br>
    throw new Exception (&quot;Unexpected end of IL&quot;);<br>
  string result = <b>FormatOperand</b> (c, operandLength);<br>
  if (result == null)<br>
  {                        // Write out operand bytes in hex<br>    result = &quot;&quot;;<br>    for (int i = 0; i &lt; operandLength; i++)<br>
      result += _il [_pos + i].ToString (&quot;X2&quot;) + &quot; &quot;;<br>  }<br>  _pos += operandLength;<br>  return result;<br>}<br>
If the result of calling FormatOperand is null, it means the operand needs no special<br>formatting, so we simply write it out in hexadecimal. We could test the disassembler<br>at this point by writing a FormatOperand method that always returns null. Here's<br>what the output would look like:<br>
IL_00A8:  ldfld        98 00 00 04<br>IL_00AD:  ldloc.2<br>IL_00AE:  add<br>IL_00AF:  ldelema      64 00 00 01<br>IL_00B4:  ldstr        26 04 00 70<br>IL_00B9:  call         B6 00 00 0A<br>IL_00BE:  ldstr        11 01 00 70<br>IL_00C3:  call         91 00 00 0A<br>...<br>
Although the opcodes are correct, the operands are not much use. Instead of hexa-<br>decimal numbers, we want member names and strings. The FormatOperand method,<br>once written, will address this--identifying the special cases that benefit from such<br>formatting. These comprise most 4-byte operands and the short branch instructions:<br>
<b>Reflection</b><br>
<b>Parsing IL | 731</b><br>
<hr>
<A name=752></a>string FormatOperand (OpCode c, int operandLength)<br>
{<br>  if (operandLength == 0) return &quot;&quot;;<br>
  if (operandLength == 4)<br>
    return <b>Get4ByteOperand</b> (c);<br>  else if (c.OperandType == OperandType.ShortInlineBrTarget)<br>    return <b>GetShortRelativeTarget</b>();<br>
  else if (c.OperandType == OperandType.InlineSwitch)<br>
    return <b>GetSwitchTarget</b> (operandLength);<br>  else<br>    return null;<br>
}<br>
There  are  three  kinds  of  4-byte  operands  that  we  treat  specially.  The  first  is<br>references to members or types--with these, we extract the member or type name<br>by calling the defining module's ResolveMember method. The second case is strings--<br>these are stored in the assembly module's metadata and can be retrieved by calling<br>ResolveString. The final case is branch targets, where the operand refers to a byte<br>offset  in  the  IL.  We  format  these  by  working  out  the  absolute  address  <i>after</i>  the<br>current instruction (+ 4 bytes):<br>
string Get4ByteOperand (OpCode c)<br>{<br>  int intOp = BitConverter.ToInt32 (_il, _pos);<br>
  switch (c.OperandType)<br>  {<br>    case OperandType.InlineTok:<br>    case OperandType.InlineMethod:<br>    case OperandType.InlineField:<br>    case OperandType.InlineType:<br>      MemberInfo mi;<br>      try   { mi = _module.ResolveMember (intOp); }<br>      catch { return null; }<br>      if (mi == null) return null;<br>
      if (mi.ReflectedType != null)<br>        return mi.ReflectedType.FullName + &quot;.&quot; + mi.Name;<br>      else if (mi is Type)<br>        return ((Type)mi).FullName;<br>      else<br>        return mi.Name;<br>
    case OperandType.InlineString:<br>      string s = _module.ResolveString (intOp);<br>      if (s != null) s = &quot;'&quot; + s + &quot;'&quot;;<br>      return s;<br>
    case OperandType.InlineBrTarget:<br>      return &quot;IL_&quot; + (_pos + intOp + 4).ToString (&quot;X4&quot;);<br>
    default:<br>      return null;<br>  }<br>
<b>732 | Chapter 18:</b><b>Reflection and Metadata</b><br>
<hr>
<A name=753></a>The point where we call ResolveMember is a good window for a<br>code analysis tool that reports on method dependencies.<br>
For any other 4-byte opcode, we return null (this will cause ReadOperand to format<br>the operand as hex digits).<br>
The final kinds of operand that need special attention are short branch targets and<br>inline switches. A short branch target describes the destination offset as a single<br>signed byte, as at the end of the current instruction (i.e., + 1 byte). A switch target<br>is followed by a variable number of 4-byte branch destinations:<br>
string GetShortRelativeTarget()<br>
{<br>  int absoluteTarget = _pos + (sbyte) _il [_pos] + 1;<br>  return &quot;IL_&quot; + absoluteTarget.ToString (&quot;X4&quot;);<br>
}<br>
string GetSwitchTarget (int operandLength)<br>{<br>  int targetCount = BitConverter.ToInt32 (_il, _pos);<br>
  string [] targets = new string [targetCount];<br>
  for (int i = 0; i &lt; targetCount; i++)<br>
  {<br>
    int ilTarget = BitConverter.ToInt32 (_il, _pos + (i + 1) * 4);<br>
    targets [i] = &quot;IL_&quot; + (_pos + ilTarget + operandLength).ToString (&quot;X4&quot;);<br>  }<br>  return &quot;(&quot; + string.Join (&quot;, &quot;, targets) + &quot;)&quot;;<br>
}<br>
This completes the disassembler. We can test it by disassembling one of its own<br>methods:<br>
MethodInfo mi = typeof (Disassembler).GetMethod (<br>  &quot;ReadOperand&quot;, BindingFlags.Instance | BindingFlags.NonPublic);<br>
Console.WriteLine (Disassembler.Disassemble (mi));<br>
<b>Reflection</b><br>
<b>Parsing IL | 733</b><br>
<hr>
<A name=754></a><hr>
<A name=755></a><b>19</b><br>
<b>Dynamic Programming</b><br>
In Chapter 4, we explained how dynamic binding works in the C# language. In this<br>chapter, we look briefly at the DLR, and then explore the following dynamic pro-<br>gramming patterns:<br>
· Numeric type unification<br>· Dynamic member overload resolution<br>· Implementing dynamic objects<br>· Interoperating with dynamic languages<br>
In Chapter 25, we'll describe how dynamic can improve COM<br>interoperability.<br>
The  types  in  this  chapter  live  in  the  System.Dynamic  namespace,  except  for<br>CallSite&lt;&gt;, which lives in System.Runtime.CompilerServices.<br>
<b>The Dynamic Language Runtime<br></b>C# relies on the <i>Dynamic Language Runtime</i> (DLR) to perform dynamic binding.<br>
Contrary to its name, the DLR is not a dynamic version of the CLR. Rather, it's a<br>library that sits atop the CLR--just like any other library such as <i>System.Xml.dll</i>. Its<br>primary role is to provide runtime services to <i>unify</i> dynamic programming--in both<br>statically and dynamically typed languages. This means that languages such as C#,<br>VB, IronPython, and IronRuby all use a common protocol for calling functions dy-<br>namically, allowing them to share libraries and call code written in other languages.<br>
The DLR also makes it relatively easy to write new dynamic languages in .NET.<br>Instead of having to emit IL, dynamic language authors work at the level of <i>expression</i><br>
<b>735</b><br>
<hr>
<A name=756></a><i>trees</i> (the same expression trees in System.Linq.Expressions that we talked about in<br>Chapter 8).<br>
The DLR further ensures that all consumers get the benefit of <i>call-site caching</i>, an<br>optimization whereby the DLR avoids unnecessarily repeating the potentially ex-<br>pensive member resolution decisions made during dynamic binding.<br>
Framework 4.0 is the first Framework version to ship with the<br>DLR. Prior to that, the DLR existed as a separate download on<br>Codeplex.  That  site  still  contains  some  additional  useful  re-<br>sources for language developers.<br>
<b>What Are Call Sites?</b><br>
When  the  compiler  encounters  a  dynamic  expression,  it  has  no  idea  who  will<br>evaluate that expression at runtime. For instance, consider the following method:<br>
public dynamic Foo (dynamic x, dynamic y)<br>{<br>  return x / y;   // Dynamic expression<br>
}<br>
The x and y variables could be any CLR object, a COM object, or even an object<br>hosted in a dynamic language. The compiler cannot, therefore, take its usual static<br>approach of emitting a call to a known method of a known type. Instead, the<br>compiler emits code that eventually results in an expression tree that describes the<br>operation, managed by a <i>call site</i> that the DLR will bind at runtime. The call site<br>essentially acts as an intermediary between caller and callee.<br>
A call site is represented by the CallSite&lt;&gt; class in <i>System.Core.dll</i>. We can see<br>this by disassembling the preceding method--the result is something like this:<br>
static CallSite&lt;Func&lt;CallSite,object,object,object&gt;&gt; divideSite;<br>
[return: Dynamic]<br>public object Foo ([Dynamic] object x, [Dynamic] object y)<br>{<br>  if (divideSite == null)<br>    divideSite =<br>      CallSite&lt;Func&lt;CallSite,object,object,object&gt;&gt;.Create (<br>        Microsoft.CSharp.RuntimeBinder.<b>Binder.BinaryOperation</b> (<br>          CSharpBinderFlags.None,<br>          <b>ExpressionType.Divide</b>,<br>          /* Remaining arguments omitted for brevity */ ));<br>
  return divideSite.Target (divideSite, x, y);<br>}<br>
As you can see, the call site is cached in a static field to avoid the cost of re-creating<br>it on each call. The DLR further caches the result of the binding phase and the<br>actual method targets. (There may be multiple targets depending on the types of<br>x and y.)<br>
<b>736 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=757></a>The actual dynamic call then happens by calling the site's Target (a delegate),<br>
<b>Programming</b><br>
passing in the x and y operands.<br>
<b>Dynamic</b><br>
Notice that the Binder class is specific to C#. Every language with support for<br>dynamic binding provides a language-specific binder to help the DLR interpret<br>expressions in a manner specific to that language, so as not to surprise the pro-<br>grammer. For instance, if we called Foo with integer values of 5 and 2, the C#<br>binder would ensure that we got back 2. In contrast, a VB.NET binder would give<br>us 2.5.<br>
<b>Numeric Type Unification<br></b>We saw in Chapter 4 how dynamic lets us write a single method that works across<br>all numeric types:<br>
static dynamic Mean (dynamic x, dynamic y)<br>{<br>  return (x + y) / 2;<br>
}<br>
static void Main()<br>
{<br>  int x = 3, y = 5;<br>  Console.WriteLine (Mean (x, y));<br>}<br>
It's a humorous reflection on C# that the keywords static and<br>dynamic  can  appear  adjacently!  The  same  applies  to  the  key-<br>words internal and extern.<br>
However, this (unnecessarily) sacrifices static type safety. The following compiles<br>without error, but then fails at runtime:<br>
string s = Mean (3, 5);   // Runtime error!<br>
We  can  fix  this  by  introducing  a  generic  type  parameter,  and  then  casting  to<br>dynamic within the calculation itself:<br>
static T Mean&lt;T&gt; (T x, T y)<br>{<br>  dynamic result = ((dynamic) x + y) / 2;<br>  return (T) result;<br>}<br>
Notice that we <i>explicitly</i> cast the result back to T. If we omitted this cast, we'd be<br>relying on an implicit cast, which might at first appear to work correctly. The implicit<br>cast would fail at runtime, though, upon calling the method with an 8- or 16-bit<br>integral type. To understand why, consider what happens with ordinary static typing<br>when you sum two 8-bit numbers together:<br>
<b>Numeric Type Unification | 737</b><br>
<hr>
<A name=758></a>byte b = 3;<br>
Console.WriteLine ((b + b).GetType().Name);  // Int32<br>
We get an Int32--because the compiler "promotes" 8- or 16-bit numbers to Int32<br>prior to performing arithmetic operations. For consistency, the C# binder tells the<br>DLR to do exactly the same thing, and we end up with an Int32 that requires an<br>explicit cast to the smaller numeric type. Of course, this could create the possibility<br>of overflow if we were, say, summing rather than averaging the values.<br>
Dynamic binding incurs a small performance hit--even with call-site caching. You<br>can mitigate this by adding statically typed overloads that cover just the most com-<br>monly used types. For example, if subsequent performance profiling showed that<br>calling Mean with doubles was a bottleneck, you could add the following overload:<br>
static double Mean (double x, double y)<br>
{<br>  return (x + y) / 2;<br>
}<br>
The compiler will favor that overload when Mean is called with arguments that are<br>known at compile time to be of type double.<br>
<b>Dynamic Member Overload Resolution<br></b>Calling a statically known method with dynamically typed arguments defers mem-<br>ber overload resolution from compile time to runtime. This is useful in simplifying<br>certain programming tasks--such as simplifying the <i>Visitor</i> design pattern. It's also<br>useful in working around limitations imposed by C#'s static typing.<br>
<b>Simplifying the Visitor Pattern<br></b>In essence, the Visitor pattern allows you to "add" a method to a class hierarchy<br>without altering existing classes. Although useful, this pattern in its static incarna-<br>tion is subtle and unintuitive compared to most other design patterns. It also requires<br>that visited classes be made "Visitor-friendly" by exposing an Accept method, which<br>can be impossible if the classes are not under your control.<br>
With dynamic binding, you can achieve the same goal more easily--and without<br>needing  to  modify  existing  classes.  To  illustrate,  consider  the  following  class<br>hierarchy:<br>
class Person<br>{<br>  public string FirstName { get; set; }<br>  public string LastName  { get; set; }<br>
  // The Friends collection may contain Customers &amp; Employees:<br>  public readonly IList&lt;Person&gt; Friends = new Collection&lt;Person&gt; ();<br>}<br>
class Customer : Person { public decimal CreditLimit { get; set; } }<br>class Employee : Person { public decimal Salary      { get; set; } }<br>
<b>738 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=759></a>Suppose we want to write a method that programmatically exports a Person's details<br>
<b>Programming</b><br>
to an XML XElement. The most obvious solution is to write a virtual method called<br>
<b>Dynamic</b><br>
ToXElement() in the Person class that returns an XElement populated with a Person's<br>properties. We would then override it in Customer and Employee classes such that the<br>XElement  was  also  populated  with  CreditLimit  and  Salary.  This  pattern  can  be<br>problematic, however, for two reasons:<br>
· You might not own the Person, Customer, and Employee classes, making it im-<br>
possible  to  add  methods  to  them.  (And  extension  methods  wouldn't  give<br>polymorphic behavior.)<br>
· The Person, Customer, and Employee classes might already be quite big. A fre-<br>
quent antipattern is the "God Object," where a class such as Person attracts so<br>much functionality that it becomes a nightmare to maintain. A good antidote<br>is to avoid adding functions to Person that don't need to access Person's private<br>state. A ToXElement method might be an excellent candidate.<br>
With dynamic member overload resolution, we can write the ToXElement function-<br>ality in a separate class, without resorting to ugly switches based on type:<br>
class ToXElementPersonVisitor<br>
{<br>  public XElement DynamicVisit (Person p)<br>  {<br>
    return Visit (<b>(dynamic)p</b>);<br>
  }<br>
  XElement Visit (Person p)<br>  {<br>    return new XElement (&quot;Person&quot;,<br>      new XAttribute (&quot;Type&quot;, p.GetType().Name),<br>      new XElement (&quot;FirstName&quot;, p.FirstName),<br>      new XElement (&quot;LastName&quot;, p.LastName),<br>      <b>p.Friends.Select (f =&gt; DynamicVisit (f))<br></b>    );<br>  }<br>
  XElement Visit (Customer c)   // Specialized logic for customers<br>  {<br>    XElement xe = Visit ((Person)c);   // Call &quot;base&quot; method<br>    xe.Add (new XElement (&quot;CreditLimit&quot;, c.CreditLimit));<br>    return xe;<br>  }<br>
  XElement Visit (Employee e)   // Specialized logic for employees<br>  {<br>    XElement xe = Visit ((Person)e);   // Call &quot;base&quot; method<br>    xe.Add (new XElement (&quot;Salary&quot;, e.Salary));<br>    return xe;<br>  }<br>}<br>
The DynamicVisit method performs a dynamic dispatch--calling the most specific<br>version of Visit as determined at runtime. Notice the line in boldface, where we call<br>
<b>Dynamic Member Overload Resolution | 739</b><br>
<hr>
<A name=760></a>DynamicVisit on each person in the Friends collection. This ensures that if a friend<br>is a Customer or Employee, the correct overload is called.<br>We can demonstrate this class as follows:<br>
var cust = new Customer<br>{<br>  FirstName = &quot;Joe&quot;, LastName = &quot;Bloggs&quot;, CreditLimit = 123<br>
};<br>
cust.Friends.Add (<br>  new Employee { FirstName = &quot;Sue&quot;, LastName = &quot;Brown&quot;, Salary = 50000 }<br>);<br>
Console.WriteLine (<b>new ToXElementPersonVisitor().DynamicVisit (cust)</b>);<br>
Here's the result:<br>
&lt;Person Type=&quot;Customer&quot;&gt;<br>
  &lt;FirstName&gt;Joe&lt;/FirstName&gt;<br>  &lt;LastName&gt;Bloggs&lt;/LastName&gt;<br>
  &lt;Person Type=&quot;Employee&quot;&gt;<br>    &lt;FirstName&gt;Sue&lt;/FirstName&gt;<br>
    &lt;LastName&gt;Brown&lt;/LastName&gt;<br>    &lt;Salary&gt;50000&lt;/Salary&gt;<br>
  &lt;/Person&gt;<br>  &lt;CreditLimit&gt;123&lt;/CreditLimit&gt;<br>
&lt;/Person&gt;<br>
<b>Variations<br></b>If you plan more than one visitor class, a useful variation is to define an abstract base<br>class for visitors:<br>
abstract class PersonVisitor&lt;T&gt;<br>{<br>  public T DynamicVisit (Person p) { return Visit ((dynamic)p); }<br>
  protected abstract T Visit (Person p);<br>  protected virtual T Visit (Customer c) { return Visit ((Person) c); }<br>  protected virtual T Visit (Employee e) { return Visit ((Person) e); }<br>}<br>
Subclasses then don't need to define their own DynamicVisit method: all they do is<br>override the versions of Visit whose behavior they want to specialize. This also has<br>the advantages of centralizing the methods that encompass the Person hierarchy,<br>and allowing implementers to call base methods more naturally:<br>
class ToXElementPersonVisitor : <b>PersonVisitor&lt;XElement&gt;<br></b>{<br>  protected override XElement Visit (Person p)<br>  {<br>    return new XElement (&quot;Person&quot;,<br>     new XAttribute (&quot;Type&quot;, p.GetType().Name),<br>     new XElement (&quot;FirstName&quot;, p.FirstName),<br>     new XElement (&quot;LastName&quot;, p.LastName),<br>     p.Friends.Select (f =&gt; DynamicVisit (f))<br>   );<br>
<b>740 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=761></a> }<br>
<b>Programming</b><br>
<b>Dynamic</b><br>
  protected override XElement Visit (Customer c)<br>  {<br>
    <b>XElement xe = base.Visit (c);</b><br>
    xe.Add (new XElement (&quot;CreditLimit&quot;, c.CreditLimit));<br>    return xe;<br>  }<br>
  protected override XElement Visit (Employee e)<br>  {<br>    <b>XElement xe = base.Visit (e);</b><br>
    xe.Add (new XElement (&quot;Salary&quot;, e.Salary));<br>
    return xe;<br>  }<br>}<br>
You can even then subclass ToXElementPersonVisitor itself.<br>
<b>Multiple Dispatch</b><br>
C# and the CLR have always supported a limited form of dynamism in the form<br>of virtual method calls. This differs from true dynamic programming in that for<br>virtual method calls, the compiler must commit to a particular virtual member at<br>compile time--based on the name and signature of a member in the base class.<br>This means that:<br>
· The calling expression must be fully understood by the compiler (e.g., it must<br>
decide at compile time whether a target member is a field or property).<br>
· Overload resolution must be completed entirely by the compiler, based on<br>
the compile-time argument types.<br>
A consequence of that last point is that the ability to perform virtual method calls<br>is known as <i>single dispatch</i>. To see why, consider the following method call (where<br>Walk is a virtual method):<br>
animal.Walk (owner);<br>
The runtime decision of whether to invoke a dog's Walk method or a cat's Walk<br>method depends only on the type of the <i>receiver</i>, animal (hence "single"). If many<br>overloads of Walk accept different kinds of owner, an overload will be selected at<br>compile time without regard to the actual runtime type of the owner object. In<br>other words, only the runtime type of the receiver can vary which method gets<br>called.<br>
In contrast, a dynamic call defers overload resolution until runtime:<br>
animal.Walk ((dynamic) owner);<br>
The final choice of which Walk method to call now depends on the types of both<br>animal and owner--this is called <i>multiple dispatch</i> since the runtime types of ar-<br>guments, in addition to the receiver type, contribute to the determination of which<br>Walk method to call.<br>
<b>Dynamic Member Overload Resolution | 741</b><br>
<hr>
<A name=762></a><b>Anonymously Calling Members of a Generic Type<br></b>The strictness of C#'s static typing is a two-edged sword. On one hand, it provides<br>guarantees of program correctness at compile time. On the other hand, it occasion-<br>ally makes certain kinds of code difficult or impossible to express, at which point<br>you have to resort to reflection. In these situations, dynamic binding is a cleaner and<br>faster alternative to reflection.<br>
An example is when you need to work with an object of type G&lt;T&gt; where T is un-<br>known. We can illustrate this by defining the following class:<br>
public class Foo&lt;T&gt; { public T Value; }<br>
Suppose we then write a method as follows:<br>
static void Write (object obj)<br>
{<br>  if (obj is <b>Foo&lt;&gt;</b>)                           // Illegal<br>
    Console.WriteLine (<b>(Foo&lt;&gt;</b>) obj).Value);   // Illegal<br>
}<br>
This method won't compile: you can't invoke members of <i>unbound</i> generic types.<br>
Dynamic binding offers two means by which we can work around this. The first is<br>to access the Value member dynamically as follows:<br>
static void Write (<b>dynamic</b> obj)<br>
{<br>  try { Console.WriteLine (obj.<b>Value</b>); }<br>  catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException) {...}<br>
}<br>
This has the (potential) advantage of working with any object that defines a Value<br>field or property. However, there are a couple of problems. First, catching an ex-<br>ception in this manner is somewhat messy and inefficient (and there's no way to ask<br>the  DLR  in  advance,  "Will  this  operation  succeed?").  Second,  this  approach<br>wouldn't work if Foo was an interface (say, IFoo&lt;T&gt;), and either of the following<br>conditions was true:<br>
· Value was implemented explicitly.<br>· The type that implemented IFoo&lt;T&gt; was inaccessible (more on this soon).<br>
A better solution is to write an overloaded helper method called GetFooValue and to<br>call it using <i>dynamic member overload resolution</i>:<br>
static void Write (dynamic obj)<br>{<br>  object result = GetFooValue (obj);<br>  if (result != null) Console.WriteLine (result);<br>}<br>
static T GetFooValue&lt;T&gt; (Foo&lt;T&gt; foo) { return foo.Value; }<br>static object GetFooValue (object foo) { return null; }<br>
Notice that we overloaded GetFooValue to accept an object parameter, which acts<br>as a fallback for any type. At runtime, the C# dynamic binder will pick the best<br>
<b>742 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=763></a>overload when calling GetFooValue with a dynamic argument. If the object in ques-<br>
<b>Programming</b><br>
tion is not based on Foo&lt;T&gt;, it will choose the object-parameter overload instead of<br>
<b>Dynamic</b><br>
throwing an exception.<br>
An alternative is to write just the first GetFooValue overload, and<br>then catch the RuntimeBinderException. The advantage is that it<br>distinguishes the case of foo.Value being null. The disadvantage<br>is  that  it  incurs  the  performance  overhead  of  throwing  and<br>catching an exception.<br>
In Chapter 18, we solved the same problem with an interface using reflection--with<br>a  lot  more  effort  (see  "Anonymously  Calling  Members  of  a  Generic  Inter-<br>face" on page 697). The example we used was to design a more powerful version of<br>ToString() that could understand objects such as IEnumerable and IGrouping&lt;,&gt;.<br>Here's the same example solved more elegantly with dynamic binding:<br>
static string GetGroupKey&lt;TKey,TElement&gt; (IGrouping&lt;TKey,TElement&gt; group)<br>
{<br>  return &quot;Group with key=&quot; + group.Key + &quot;: &quot;;<br>
}<br>
static string GetGroupKey (object source) { return null; }<br>
public static string ToStringEx (object value)<br>{<br>  if (value == null) return &quot;&lt;null&gt;&quot;;<br>
  if (value is string) return (string) value;<br>
  if (value.GetType().IsPrimitive) return value.ToString();<br>
  StringBuilder sb = new StringBuilder();<br>
  string groupKey = GetGroupKey (<b>(dynamic)value</b>);   // Dynamic dispatch<br>  if (groupKey != null) sb.Append (groupKey);<br>
  if (value is IEnumerable)<br>    foreach (object element in ((IEnumerable)value))<br>      sb.Append (ToStringEx (element) + &quot; &quot;);<br>
  if (sb.Length == 0) sb.Append (value.ToString());<br>
  return &quot;\r\n&quot; + sb.ToString();<br>}<br>
In action:<br>
Console.WriteLine (ToStringEx (&quot;xyyzzz&quot;.GroupBy (c =&gt; c) ));<br>
<i>Group with key=x: x<br>Group with key=y: y y<br>Group with key=z: z z z</i><br>
<b>Dynamic Member Overload Resolution | 743</b><br>
<hr>
<A name=764></a>Notice that we used dynamic <i>member overload resolution</i> to solve this problem. If<br>we did the following instead:<br>
<b>dynamic</b> d = value;<br>try { groupKey = d.<b>Value</b>); }<br>
catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException) {...}<br>
it would fail, because LINQ's GroupBy operator returns a type implementing IGroup<br>ing&lt;,&gt; which itself is internal, and therefore inaccessible:<br>
<b>internal</b> class Grouping : IGrouping&lt;TKey,TElement&gt;, ...<br>
{<br>  public TKey Key;<br>
  ...<br>
}<br>
Even  though  the  Key  property  is  declared  public,  its  containing  class  caps  it  at<br>internal, making it accessible only via the IGrouping&lt;,&gt; interface. And as we ex-<br>plained in Chapter 4, there's no way to tell the DLR to bind to that interface when<br>invoking the Value member dynamically.<br>
<b>Implementing Dynamic Objects<br></b>An object can provide its binding semantics by implementing IDynamicMetaObject<br>Provider--or more easily by subclassing DynamicObject, which provides a default<br>implementation of this interface. We demonstrated this briefly in Chapter 4, with<br>the following example:<br>
static void Main()<br>{<br>  dynamic d = new Duck();<br>  d.Quack();                  // Quack method was called<br>  d.Waddle();                 // Waddle method was called<br>}<br>
public class Duck : DynamicObject<br>{<br>  public override bool <b>TryInvokeMember</b> (<br>    InvokeMemberBinder binder, object[] args, out object result)<br>  {<br>    Console.WriteLine (binder.Name + &quot; method was called&quot;);<br>    result = null;<br>    return true;<br>  }<br>}<br>
<b>DynamicObject<br></b>In the preceding example, we overrode TryInvokeMember, which allows the consumer<br>to invoke a method on the dynamic object--such as a Quack or Waddle. DynamicOb<br>ject exposes other virtual methods that enable consumers to use other programming<br>constructs as well. The following correspond to constructs that have representations<br>in C#:<br>
<b>744 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=765></a><b>Method</b><br>
<b>Programming construct</b><br>
<b>Programming</b><br>
<b>Dynamic</b><br>
TryInvokeMember<br>
Method<br>
TryGetMember, TrySetMember<br>
Property or field<br>
TryGetIndex, TrySetIndex<br>
Indexer<br>
TryUnaryOperation<br>
Unary operator such as !<br>
TryBinaryOperation<br>
Binary operator such as ==<br>
TryConvert<br>
Conversion (cast) to another type<br>
TryInvoke<br>
Invocation on the object itself--e.g., d(&quot;foo&quot;)<br>
These  methods  should  return  true  if  successful.  If  they  return  false,  then  the<br>DLR will fall back to the language binder, looking for a matching member on the<br>DynamicObject (subclass) itself. If this fails, then a RuntimeBinderException is thrown.<br>
We can illustrate TryGetMember and TrySetMember with a class that lets us dynamically<br>access an attribute in an XElement (System.Xml.Linq):<br>
static class XExtensions<br>
{<br>  public static dynamic DynamicAttributes (this XElement e)<br>  {<br>
    return new XWrapper (e);<br>
  }<br>
  class XWrapper : DynamicObject<br>
  {<br>
    XElement _element;<br>    public XWrapper (XElement e) { _element = e; }<br>
    public override bool TryGetMember (GetMemberBinder binder,<br>                                       out object result)<br>    {<br>      result = _element.Attribute (binder.Name).Value;<br>      return true;<br>    }<br>
    public override bool TrySetMember (SetMemberBinder binder,<br>                                       object value)<br>    {<br>      _element.SetAttributeValue (binder.Name, value);<br>      return true;<br>    }<br>  }<br>}<br>
Here's how to use it:<br>
XElement x = XElement.Parse (@&quot;&lt;Label Text=&quot;&quot;Hello&quot;&quot; Id=&quot;&quot;5&quot;&quot;/&gt;&quot;);<br>dynamic da = x.DynamicAttributes();<br>Console.WriteLine (da.Id);           // 5<br>da.Text = &quot;Foo&quot;;<br>Console.WriteLine (x.ToString());    // &lt;Label Text=&quot;Foo&quot; Id=&quot;5&quot; /&gt;<br>
<b>Implementing Dynamic Objects | 745</b><br>
<hr>
<A name=766></a>The following does a similar thing for System.Data.IDataRecord, making it easier to<br>use data readers:<br>
public class DynamicReader : DynamicObject<br>{<br>  readonly IDataRecord _dataRecord;<br>
  public DynamicReader (IDataRecord dr) { _dataRecord = dr; }<br>
  public override bool TryGetMember (GetMemberBinder binder,<br>                                     out object result)<br>
  {<br>
    result = _dataRecord [binder.Name];<br>
    return true;<br>
  }<br>}<br>...<br>
using (IDataReader reader = <i>someDbCommand</i>.ExecuteReader())<br>
{<br>  dynamic dr = new DynamicReader (reader);<br>  while (reader.Read())<br>
  {<br>
    int id = dr.ID;<br>
    string firstName = dr.FirstName;<br>    DateTime dob = dr.DateOfBirth;<br>
    ...<br>
  }<br>
}<br>
The following demonstrates TryBinaryOperation and TryInvoke:<br>
static void Main()<br>{<br>  dynamic d = new Duck();<br>  Console.WriteLine (d + d);          // foo<br>  Console.WriteLine (d (78, 'x'));    // 123<br>}<br>
public class Duck : DynamicObject<br>{<br>  public override bool TryBinaryOperation (BinaryOperationBinder binder,<br>                                           object arg, out object result)<br>  {<br>    Console.WriteLine (binder.Operation);   // Add<br>    result = &quot;foo&quot;;<br>    return true;<br>  }<br>
  public override bool TryInvoke (InvokeBinder binder,<br>                                  object[] args, out object result)<br>  {<br>    Console.WriteLine (args[0]);    // 78<br>    result = 123;<br>    return true;<br>  }<br>}<br>
<b>746 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=767></a>DynamicObject also exposes some virtual methods for the benefit of dynamic lan-<br>
<b>Programming</b><br>
guages. In particular, overriding GetDynamicMemberNames allows you to return a list<br>
<b>Dynamic</b><br>
of all member names that your dynamic object provides.<br>
Another  reason  to  implement  GetDynamicMemberNames  is  that<br>Visual Studio's debugger makes use of this method to display a<br>view of a dynamic object.<br>
<b>ExpandoObject<br></b>Another simple application of DynamicObject would be to write a dynamic class that<br>stored and retrieved objects in a dictionary, keyed by string. However, this func-<br>tionality is already provided via the ExpandoObject class:<br>
dynamic x = new ExpandoObject();<br>
x.FavoriteColor = ConsoleColor.Green;<br>
x.FavoriteNumber = 7;<br>
Console.WriteLine (x.FavoriteColor);    // Green<br>Console.WriteLine (x.FavoriteNumber);   // 7<br>
ExpandoObject implements IDictionary&lt;string,object&gt;--so we can continue our<br>example and do this:<br>
var dict = (IDictionary&lt;string,object&gt;) x;<br>
Console.WriteLine (dict [&quot;FavoriteColor&quot;]);    // Green<br>Console.WriteLine (dict [&quot;FavoriteNumber&quot;]);   // 7<br>Console.WriteLine (dict.Count);                // 2<br>
<b>Interoperating with Dynamic Languages<br></b>Although C# 4.0 supports dynamic binding via the dynamic keyword, it doesn't go<br>as far as allowing you to execute an expression described in a string at runtime:<br>
string expr = &quot;2 * 3&quot;;<br>// We can't &quot;execute&quot; expr<br>
This is because the code to translate a string into an expression<br>tree requires a lexical and semantic parser. These features are<br>built into the C# compiler and are not available as a runtime<br>service. At runtime, C# merely provides a <i>binder</i>--which tells<br>the DLR how to interpret an already-built expression tree.<br>
True dynamic languages such as IronPython and IronRuby do allow you to execute<br>an arbitrary string, and this is useful in tasks such as scripting, dynamic configura-<br>tion, and implementing dynamic rules engines. So although you may write most of<br>your application in C#, it can be useful to call out to a dynamic language for such<br>tasks. In addition, you might want to leverage an API that is written in a dynamic<br>language where no equivalent functionality is available in a .NET library.<br>
<b>Interoperating with Dynamic Languages | 747</b><br>
<hr>
<A name=768></a>In the following example, we use IronPython to evaluate an expression created at<br>runtime from within C#. This script could be used to write a calculator.<br>
To  run  this  code,  download  IronPython  (search  the  Internet<br>for  <i>IronPython</i>),  and  then  reference  the  <i>IronPython</i>,<br><i>Microsoft.Scripting</i>,  and  <i>Microsoft.Scripting.Core</i>  assemblies<br>from your C# application.<br>
using System;<br>
using IronPython.Hosting;<br>
using Microsoft.Scripting;<br>
using Microsoft.Scripting.Hosting;<br>
class Calculator<br>
{<br>  static void Main()<br>
  {<br>
    int result = (int) Calculate (&quot;2 * 3&quot;);<br>
    Console.WriteLine (result);              // 6<br>
  }<br>
  static object Calculate (string expression)<br>
  {<br>
    <b>ScriptEngine engine = Python.CreateEngine();<br></b>    <b>return engine.Execute (expression);<br></b>  }<br>
}<br>
Because we're passing a string into Python, the expression will be evaluated accord-<br>ing to Python's rules and not C#'s. It also means we can use Python's language<br>features, such as lists:<br>
var list = (IEnumerable) Calculate (&quot;<b>[1, 2, 3] + [4, 5]</b>&quot;);<br>foreach (int n in list) Console.Write (n);  // 12345<br>
<b>Passing State Between C# and a Script<br></b>To pass variables from C# to Python, a few more steps are required. The following<br>example illustrates those steps, and could be the basis of a rules engine:<br>
// The following string could come from a file or database:<br>string auditRule = &quot;<b>taxPaidLastYear / taxPaidThisYear &gt; 2</b>&quot;;<br>
ScriptEngine engine = Python.CreateEngine ();<br>
ScriptScope scope = engine.CreateScope ();<br><b>scope.SetVariable (&quot;taxPaidLastYear&quot;, 20000m);<br>scope.SetVariable (&quot;taxPaidThisYear&quot;, 8000m);</b><br>
ScriptSource source = engine.CreateScriptSourceFromString (<br>                      auditRule, SourceCodeKind.Expression);<br>
bool auditRequired = (bool) source.Execute (scope);<br>Console.WriteLine (auditRequired);   // True<br>
<b>748 | Chapter 19:</b><b>Dynamic Programming</b><br>
<hr>
<A name=769></a>You can also get variables back by calling GetVariable:<br>
<b>Programming</b><br>
<b>Dynamic</b><br>
string code = &quot;result = input * 3&quot;;<br>
ScriptEngine engine = Python.CreateEngine();<br>
ScriptScope scope = engine.CreateScope();<br>
scope.SetVariable (&quot;input&quot;, 2);<br>
ScriptSource source = engine.CreateScriptSourceFromString (code,<br>                                  SourceCodeKind.<b>SingleStatement</b>);<br>
source.Execute (scope);<br>
<b>Console.WriteLine (engine.GetVariable (scope, &quot;result&quot;));   // 6</b><br>
Notice that we specified SourceCodeKind.SingleStatement in the second example<br>(rather than Expression) to tell the engine that we want to execute a statement.<br>Types are automatically marshaled between the .NET and Python worlds. You can<br>even access members of .NET objects from the scripting side:<br>
string code = @&quot;<b>sb.Append (&quot;&quot;World&quot;&quot;)</b>&quot;;<br>
ScriptEngine engine = Python.CreateEngine ();<br>
ScriptScope scope = engine.CreateScope ();<br>
<b>var sb = new StringBuilder (&quot;Hello&quot;);</b><br>
scope.SetVariable (&quot;sb&quot;, sb);<br>
ScriptSource source = engine.CreateScriptSourceFromString (<br>                      code, SourceCodeKind.SingleStatement);<br>source.Execute (scope);<br>Console.WriteLine (sb.ToString());   // HelloWorld<br>
<b>Interoperating with Dynamic Languages | 749</b><br>
<hr>
<A name=770></a><hr>
<A name=771></a><b>20</b><br>
<b>Security</b><br>
In this chapter, we discuss the two main components of .NET security:<br>
· Permissions<br>· Cryptography<br>
Permissions, in .NET, provide a layer of security independent of that imposed by<br>the operating system. Their job is twofold:<br>
<i>Sandboxing</i><br>
Limiting  the  kinds  of  operations  that  partially  trusted  .NET  assemblies  can<br>perform<br>
<i>Authorization</i><br>
Limiting <i>who</i> can do what<br>
The cryptography support in .NET allows you to store or exchange high-value se-<br>crets, prevent eavesdropping, detect message tampering, generate one-way hashes<br>for storing passwords, and create digital signatures.<br>
The types covered in this chapter are defined in the following namespaces:<br>
System.Security;<br>System.Security.Permissions;<br>System.Security.Principal;<br>System.Security.Cryptography;<br>
In Chapter 14, we covered <i>isolated storage</i>, which serves another useful role in a<br>secure environment.<br>
<b>Permissions<br></b>The Framework uses permissions for both sandboxing and authorization. A <i>per-<br>mission</i> acts as a gate that conditionally prevents code from executing. Sandboxing<br>uses <i>code access</i> permissions; authorization uses <i>identity</i> and <i>role</i> permissions.<br>
<b>751</b><br>
<hr>
<A name=772></a>Although both follow a similar model, they feel quite different to use. Part of the<br>reason for this is that they typically put you on a different side of the fence: with<br>code access security, you're usually the <i>untrusted</i> party; with identity and role se-<br>curity, you're usually the <i>untrusting</i> party. Code access security is most often forced<br>upon you by the CLR or a hosting environment such as ASP.NET or Internet Ex-<br>plorer, whereas authorization is usually something you implement to prevent un-<br>privileged callers from accessing your program.<br>
As an application developer, you'll need to understand code access security (CAS)<br>in order to write assemblies that will run in a limited permissions environment. If<br>you're writing and selling a component library, it's easy to overlook the possibility<br>that your customers will call your library from a <i>sandboxed</i> environment such as a<br>SQL Server CLR host.<br>
Another reason to understand CAS is if you want to create your own hosting envi-<br>ronment that sandboxes other assemblies. For example, you might write an appli-<br>cation that allows third parties to write plug-in components. Running those plug-<br>ins in an application domain with limited permissions reduces the chance of a plug-<br>in destabilizing your application or compromising its security.<br>
The main scenario for identity and role security is when writing middle tier or web<br>application servers. You typically decide on a set of roles, and then for each method<br>that you expose, you demand that callers are members of a particular role.<br>
<b>CodeAccessPermission and PrincipalPermission<br></b>There are essentially two kinds of permissions:<br>
CodeAccessPermission<br>
The abstract base class for all code access security (CAS) permissions, such as<br>FileIOPermission, ReflectionPermission, or PrintingPermission<br>
PrincipalPermission<br>
Describes an identity and/or role (e.g., "Mary" or "Human Resources")<br>
The term <i>permission</i> is somewhat misleading in the case of CodeAccessPermission,<br>because it suggests something has been granted. This is not necessarily the case. A<br>CodeAccessPermission object describes a <i>privileged operation</i>.<br>
For instance, a FileIOPermission object describes the privilege of being able to Read,<br>Write, or Append to a particular set of files or directories. Such an object can be used<br>in a variety of ways:<br>
· To verify that you and all your callers have the rights to perform these actions<br>
(Demand)<br>
· To verify that your immediate caller has the rights to perform these actions<br>
(LinkDemand)<br>
· To temporarily escape a sandbox and Assert your assembly-given rights to per-<br>
form these actions, regardless of callers' privileges<br>
<b>752 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=773></a>Framework  4.0  deprecates  support  for  Deny,  RequestMinimum,<br>RequestOptional, and RequestRefuse, and strongly discourages<br>the use of PermitOnly. Its new transparency model also makes<br>link demands effectively redundant.<br>
PrincipalPermission  is  much  simpler.  Its  only  security  method  is  Demand,  which<br>checks that the specified user or role is valid given the current execution thread.<br>
<b>Security</b><br>
<b>IPermission<br></b>Both  CodeAccessPermission  and  PrincipalPermission  implement  the  IPermission<br>interface:<br>
public interface IPermission<br>
{<br>  <b>void Demand();</b><br>
  IPermission Intersect (IPermission target);<br>  IPermission Union (IPermission target);<br>  bool IsSubsetOf (IPermission target);<br>
  IPermission Copy();<br>
}<br>
The  crucial  method  here  is  Demand.  It  performs  a  spot-check  to  see  whether  the<br>permission  or  privileged  operation  is  currently  permitted,  and  it  throws  a<br>SecurityException  if  not.  If  you're  the  <i>untrusting</i>  party,  <i>you</i>  will  be<br>Demanding. If you're the <i>untrusted</i> party, code that you <i>call</i> will be Demanding.<br>
For example, to ensure that only Mary can run management reports, you could write<br>this:<br>
new PrincipalPermission (&quot;Mary&quot;, null).<b>Demand</b>();<br>// ... run management reports<br>
In contrast, suppose your assembly was sandboxed such that file I/O was prohibited,<br>so the following line threw a SecurityException:<br>
using (FileStream fs = new FileStream (&quot;test.txt&quot;, FileMode.Create))<br>  ...<br>
The  Demand,  in  this  case,  is  made  by  code  that  you  call--in  other  words,  File<br>Stream's constructor:<br>
...<br>new FileIOPermission (...).<b>Demand</b>();<br>
<b>Permissions | 753</b><br>
<hr>
<A name=774></a>A code access security Demand checks right up the call stack, in<br>order to ensure that the requested operation is allowed for every<br>party in the calling chain (within the current application do-<br>main).  Effectively,  it's  asking,  "Is  this  application  domain<br>entitled to this permission?"<br>
With code access security, an interesting case arises with as-<br>semblies that run in the GAC, which are considered <i>fully trus-<br>ted</i>. If a such an assembly runs in a sandbox, any Demands that it<br>makes are still subject to the sandbox's permission set. Fully<br>trusted assemblies can, however, temporarily <i>escape</i> the sand-<br>box by calling Assert on a CodeAccessPermission object. After<br>doing so, Demands for the permissions that were asserted always<br>succeed. An Assert ends either when the current method fin-<br>ishes or when you call CodeAccessPermission.RevertAssert.<br>
The Intersect and Union methods combine two same-typed permission objects into<br>one. The result of Intersect is <i>less</i> restrictive when Demanded, requiring <i>intersected<br></i>permissions to be met. The result of Union is <i>more</i> restrictive when Demanded, re-<br>quiring both permission sets to be met.<br>
IsSubsetOf returns true if the given target contains at least its permissions:<br>
PrincipalPermission jay = new PrincipalPermission (&quot;Jay&quot;, null);<br>PrincipalPermission sue = new PrincipalPermission (&quot;Sue&quot;, null);<br>
PrincipalPermission jayOrSue = (PrincipalPermission) jay.Union (sue);<br>Console.WriteLine (jay.IsSubsetOf (jayOrSue));  // True<br>
In this example, calling Intersect on jay and sue would generate an empty permis-<br>sion, because they don't overlap.<br>
<b>PermissionSet<br></b>A PermissionSet represents a collection of differently typed IPermission objects. The<br>following  creates  a  permission  set  with  three  code  access  permissions,  and  then<br>Demands all of them in one hit:<br>
PermissionSet ps = new PermissionSet (PermissionState.None);<br>
ps.AddPermission (new UIPermission (PermissionState.Unrestricted));<br>ps.AddPermission (new SecurityPermission (<br>                      SecurityPermissionFlag.UnmanagedCode));<br>ps.AddPermission (new FileIOPermission (<br>                      FileIOPermissionAccess.Read, @&quot;c:\docs&quot;));<br>ps.Demand();<br>
PermissionSet's  constructor  accepts  a  PermissionState  enum,  which  indicates<br>whether the set should be considered "unrestricted." An unrestricted permission set<br>is treated as though it contained every possible permission (even though its collec-<br>tion is empty). Assemblies that execute with unrestricted code access security are<br>said to be <i>fully trusted</i>.<br>
<b>754 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=775></a>When you call AddPermission, the permission set looks to see whether a same-typed<br>permission  is  already  present.  If  so,  it  Unions  the  new  and  existing  permissions;<br>otherwise, it adds the new permission to its collection. Calling AddPermission on an<br>unrestricted permission set has no effect (as it already has, logically, all possible<br>permissions).<br>
You  can  Union  and  Intersect  permission  sets  just  as  you  can  with  IPermission<br>objects.<br>
<b>Security</b><br>
<b>Declarative Versus Imperative Security<br></b>So  far,  we  manually  instantiated  permission  objects  and  called  Demand  on  them.<br>This is <i>imperative security</i>. You can achieve the same result by adding attributes to<br>a  method,  constructor,  class,  struct,  or  assembly--this  is  <i>declarative  security</i>.<br>Although  imperative  security  is  more  flexible,  declarative  security  has  three<br>advantages:<br>
· It can mean less coding.<br>· It allows the CLR to determine in advance what permissions your assembly<br>
requires.<br>
· It can improve performance.<br>
For example:<br>
<b>[PrincipalPermission (SecurityAction.Demand, Name=&quot;Mary&quot;)]</b><br>
public ReportData GetReports()<br>{<br>  ...<br>}<br>
<b>[UIPermission(SecurityAction.Demand, Window=UIPermissionWindow.AllWindows)]<br></b>public Form FindForm()<br>{<br>  ...<br>}<br>
This works because every permission type has a sister attribute type in the .NET<br>Framework. PrincipalPermission has a PrincipalPermissionAttribute sister. The<br>first argument of the attribute's constructor is always a SecurityAction, which in-<br>dicates  what  security  method  to  call  once  the  permission  object  is  constructed<br>(usually  Demand).  The  remaining  named  parameters  mirror  the  properties  on  the<br>corresponding permission object.<br>
<b>Code Access Security (CAS)<br></b>The CodeAccessPermission types that are enforced throughout the .NET Framework<br>are listed by category in Tables 20-1 through 20-6. Collectively, these are intended<br>to cover all the means by which a program can do mischief!<br>
<b>Code Access Security (CAS) | 755</b><br>
<hr>
<A name=776></a><i>Table 20-1. Core permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
SecurityPermission<br>
Advanced operations, such as calling unmanaged code<br>
ReflectionPermission<br>
Use of reflection<br>
EnvironmentPermission<br>
Reading/writing command-line environment settings<br>
RegistryPermission<br>
Reading or writing to the Windows Registry<br>
SecurityPermission accepts a SecurityPermissionFlag argument. This is an enum<br>that allows any combination of the following:<br>
AllFlags                     ControlThread<br>
Assertion                    Execution<br>
BindingRedirects             Infrastructure<br>
ControlAppDomain             NoFlags<br>
ControlDomainPolicy          RemotingConfiguration<br>ControlEvidence              SerializationFormatter<br>
ControlPolicy                SkipVerification<br>
ControlPrincipal             UnmanagedCode<br>
The most significant member of this enum is Execution, without which code will<br>not run. The other members should be granted only in full-trust scenarios, because<br>they enable a grantee to compromise or escape a sandbox. ControlAppDomain allows<br>the creation of new application domains (see Chapter 24); UnmanagedCode allows you<br>to call native methods (see Chapter 25).<br>
ReflectionPermission  accepts  a  ReflectionPermissionFlag  enum,  which  includes<br>the members MemberAccess and RestrictedMemberAccess. If you're sandboxing as-<br>semblies, the latter is safer to grant while permitting reflection scenarios required by<br>APIs such as LINQ to SQL.<br>
<i>Table 20-2. I/O and data permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
FileIOPermission<br>
Reading/writing files and directories<br>
FileDialogPermission<br>
Reading/writing to a file chosen through an Open or Save<br>dialog<br>
IsolatedStorageFilePermission<br>
Reading/writing to own isolated storage<br>
ConfigurationPermission<br>
Reading of application configuration files<br>
SqlClientPermission, OleDbPermission,<br>
Communicating with a database server using the<br>
OdbcPermission<br>
SqlClient, OleDb, or Odbc class<br>
DistributedTransactionPermission<br>
Participation in distributed transactions<br>
FileDialogPermission  controls  access  to  the  OpenFileDialog  and  SaveFileDialog<br>classes. These classes are defined in Microsoft.Win32 (for use in WPF applications)<br>and in System.Windows.Forms (for use in Windows Forms applications). For this to<br>work, UIPermission is also required. FileIOPermission is not also required, however,<br>
<b>756 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=777></a>if  you  access  the  chosen  file  by  calling  OpenFile  on  the  OpenFileDialog  or<br>SaveFileDialog objects.<br>
<i>Table 20-3. Networking permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
DnsPermission<br>
DNS lookup<br>
<b>Security</b><br>
WebPermission<br>
WebRequest-based network access<br>
SocketPermission<br>
Socket-based network access<br>
SmtpPermission<br>
Sending mail through the SMTP libraries<br>
NetworkInformationPermission<br>
Use of classes such as Ping and NetworkInterface<br>
<i>Table 20-4. Encryption permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
DataProtectionPermission Use of the Windows data protection methods<br>
KeyContainerPermission<br>
Public key encryption and signing<br>
StorePermission<br>
Access to X.509 certificate stores<br>
<i>Table 20-5. UI permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
UIPermission<br>
Creating windows and interacting with the clipboard<br>
WebBrowserPermission<br>
Use of the WebBrowser control<br>
MediaPermission<br>
Image, audio, and video support in WPF<br>
PrintingPermission<br>
Accessing a printer<br>
<i>Table 20-6. Diagnostics permissions</i><br>
<b>Type</b><br>
<b>Enables</b><br>
EventLogPermission<br>
Reading or writing to the Windows event log<br>
PerformanceCounterPermission<br>
Use of Windows performance counters<br>
Demands for these permission types are enforced within the .NET Framework. There<br>are also some permission classes for which the intention is that Demands are enforced<br>in your own code. The most important of these are concerned with establishing<br>identity of the calling assembly, and are listed in Table 20-7. The caveat is that (as<br>with all CAS permissions) a Demand always succeeds if the application domain is<br>running in full trust (see the following section).<br>
<i>Table 20-7. Identity permissions</i><br>
<b>Type</b><br>
<b>Enforces</b><br>
GacIdentityPermission<br>
The assembly is loaded into the GAC<br>
StrongNameIdentityPermission<br>
The calling assembly has a particular strong name<br>
<b>Code Access Security (CAS) | 757</b><br>
<hr>
<A name=778></a><b>Type</b><br>
<b>Enforces</b><br>
PublisherIdentityPermission<br>
The calling assembly is Authenticode-signed with a particular certificate<br>
<b>How Code Access Security Is Applied<br></b>When you run a .NET executable from the Windows shell or command prompt, it<br>runs with unrestricted permissions. This is called <i>full trust</i>.<br>
If you execute an assembly via another hosting environment--such as a SQL Server<br>CLR integration host, ASP.NET, ClickOnce, or a custom host--the host decides<br>what permissions to give your assembly. If it restricts permissions in any way, this<br>is called <i>partial trust</i> or <i>sandboxing</i>.<br>
More accurately, a host does not restrict permissions to your <i>assembly</i>. Rather, it<br>creates an application domain with restricted permissions, and then loads your as-<br>sembly into that sandboxed domain. This means that any other assemblies that load<br>into that domain (such as assemblies that you reference) run in that same sandbox<br>with the same permission set. There are two exceptions, however:<br>
· Assemblies registered in the GAC (including the .NET Framework)<br>· Assemblies that a host has nominated to fully trust<br>
Assemblies in those two categories are considered <i>fully trusted</i> and can escape the<br>sandbox by Asserting any permission they want. They can also call methods marked<br>as [SecurityCritical] in other fully trusted assemblies, run unverifiable (unsafe)<br>code, and call methods that enforce link demands, and those link demands will<br>always succeed.<br>
So when we say that a <i>partially trusted</i> assembly calls a <i>fully trusted</i> assembly, we<br>mean that an assembly running in a sandboxed application domain calls a GAC<br>assembly--or an assembly nominated by the host for full trust.<br>
<b>Testing for Full Trust<br></b>You can test whether you have unrestricted permissions as follows:<br>
new PermissionSet (PermissionState.Unrestricted).Demand();<br>
This  throws  an  exception  if  your  application  domain  is  sandboxed.  However,  it<br>might be that your assembly is, in fact, fully trusted and so can Assert its way out<br>of the sandbox. You can test for this by querying the IsFullyTrusted property on<br>the Assembly in question.<br>
<b>Allowing Partially Trusted Callers<br></b>Allowing an assembly to accept partially trusted callers creates the possibility of an<br>elevation of privilege attack, and is therefore disallowed by the CLR unless you re-<br>quest otherwise. To see why this is so, let's look first at an elevation of privilege<br>attack.<br>
<b>758 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=779></a><b>Elevation of Privilege<br></b>Let's suppose the CLR didn't enforce the rule just described, and you wrote a library<br>intended to be used in full-trust scenarios. One of your properties was as follows:<br>
public string ConnectionString<br>
{<br>  get { return File.ReadAllText (_basePath + &quot;cxString.txt&quot;); }<br>
}<br>
<b>Security</b><br>
Now, assume that the user who deploys your library decides (rightly or wrongly) to<br>load your assembly into the GAC. That user then runs a totally unrelated application<br>hosted in ClickOnce or ASP.NET, inside a restrictive sandbox. The sandboxed ap-<br>plication now loads your fully trusted assembly--and tries to call the Connection<br>String property. Fortunately, it throws a SecurityException because File.ReadAll<br>Text will demand a FileIOPermission, which the caller won't have (remember that<br>a Demand checks right up the calling stack). But now consider the following method:<br>
public unsafe void Poke (int offset, int data)<br>
{<br>  int* target = (int*) _origin + offset;<br>  *target = data;<br>
  ...<br>
}<br>
Without an implicit Demand, the sandboxed assembly can call this method--and use<br>it to inflict damage. This is an <i>elevation of privilege</i> attack.<br>
The problem in this case is that you never intended for your library to be called by<br>partially trusted assemblies. Fortunately, the CLR helps you by preventing this sit-<br>uation by default.<br>
<b>APTCA and [SecurityTransparent]<br></b>To help avoid elevation of privilege attacks, the CLR does not allow partially trusted<br>assemblies to call fully trusted assemblies by default.*<br>
To allow such calls, you must do one of two things to X:<br>
· Apply the [AllowPartiallyTrustedCallers] attribute (called APTCA for short).<br>· Apply the [SecurityTransparent] attribute.<br>
Applying these attributes means that you must think about the possibility of being<br>the <i>untrusting</i> party (rather than the <i>untrusted</i> party).<br>
Prior to CLR 4.0, only the APTCA attribute was supported. And all that it did was<br>to enable partially trusted callers. From CLR 4.0, the APTCA also has the effect of<br>implicitly  marking  all  the  methods  (and  functions)  in  your  assembly  as  <i>security<br>transparent</i>.  We'll  explain  this  in  detail  in  the  next  section;  for  now,  we  can<br>
* Before CLR 4.0, partially trusted assemblies could not even call other partially trusted assemblies<br>
if the target was strongly named (unless you applied the APTCA). This restriction didn't really aid<br>security, and so was dropped in CLR 4.0.<br>
<b>Allowing Partially Trusted Callers | 759</b><br>
<hr>
<A name=780></a>summarize it by saying that security transparent methods can't do any of the fol-<br>lowing (whether running in full or partial trust):<br>
· Run unverifiable (unsafe) code.<br>· Run native code via P/Invoke or COM.<br>· Assert permissions to elevate their security level.<br>· Satisfy a link demand.<br>· Call methods in the .NET Framework marked as [SecurityCritical]. Essen-<br>
tially, these comprise methods that do one of the preceding four things without<br>appropriate safeguards or security checks.<br>
The rationale is that an assembly that doesn't do any of these<br>things cannot, in general, be susceptible to an elevation of priv-<br>ilege attack.<br>
The [SecurityTransparent] attribute applies a stronger version of the same rules.<br>The difference is that with APTCA, you can nominate selected methods in your<br>assembly as nontransparent, whereas with [SecurityTransparent], all methods must<br>be transparent.<br>
If your assembly can work with [SecurityTransparent], your<br>job is done as a library author. You can ignore the nuances of<br>the transparency model and skip ahead to "Operating System<br>Security" on page 772!<br>
Before we look at how to nominate selected methods as nontransparent, let's first<br>look at when you'd apply these attributes.<br>
The first (and more obvious) scenario is if you plan to write a fully trusted assembly<br>that will run in a partially trusted domain. We walk through an example in "Sand-<br>boxing Another Assembly" on page 769.<br>
The second (and less obvious) scenario is writing a library without knowledge of<br>how it will be deployed. For instance, suppose you write an object relational mapper<br>and sell it over the Internet. Customers have three options in how they call your<br>library:<br>
1. From a fully trusted environment<br>2. From a sandboxed domain<br>3. From a sandboxed domain, but with your assembly fully trusted (e.g., by load-<br>
ing it into the GAC)<br>
It's easy to overlook the third option--and this is where the transparency model<br>helps.<br>
<b>760 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=781></a><b>The Transparency Model in CLR 4.0</b><br>
To follow this, you'll need to have read the previous section and<br>understand the scenarios for applying APTCA and [Security<br>Transparent].<br>
<b>Security</b><br>
The security transparency model makes it easier to secure assemblies that might be<br>fully trusted and then called from partially trusted code.<br>
By way of analogy, let's imagine that being a partially trusted assembly is like being<br>convicted of a crime and being sent to prison. In prison, you discover that there are<br>a set of privileges (permissions) that you can earn for good behavior. These permis-<br>sions entitle you to perform activities such as watching TV or playing basketball.<br>There are some activities, however, that you can never perform--such as getting the<br>keys to the TV room (or the prison gates)--because such activities (methods) would<br>undermine the whole security system. These methods are called <i>security-critical</i>.<br>
If writing a fully trusted library, you would want to protect those security-critical<br>methods. One way to do so is to Demand that callers be fully trusted. This was the<br>approach prior to CLR 4.0:<br>
<b>[PermissionSet (SecurityAction.Demand, Unrestricted = true)]</b><br>
public Key GetTVRoomKey() { ... }<br>
This creates two problems. First, Demands are slow because they must check right up<br>the  call  stack;  this  matters  because  <i>security-critical</i>  methods  are  sometimes<br><i>performance-critical</i>. A Demand can become particularly wasteful if a security-critical<br>method is called in a loop--perhaps from another trusted assembly in the Frame-<br>work. The CLR 2.0 workaround with such methods was to instead enforce  <i>link<br>demands</i>, which check only the immediate caller. But this also comes at a price. To<br>maintain security, methods that call link-demanded methods must themselves per-<br>form demands or link demands--or be audited to ensure that they don't allow any-<br>thing potentially harmful if called from a less-trusted party. Such an audit becomes<br>burdensome when call graphs are complicated.<br>
The second problem is that it's easy to forget to perform a demand or link demand<br>on security-critical methods (again, complex call graphs exacerbate this). It would<br>be nice if the CLR could somehow help out and enforce that security-critical func-<br>tions are not unintentionally exposed to inmates.<br>
The transparency model does exactly that.<br>
The introduction of the transparency model is totally unrelated<br>to  the  removal  of  CAS  <i>policy</i>  (see  "Security  Policy  in  CLR<br>2.0" on page 768).<br>
<b>The Transparency Model in CLR 4.0 | 761</b><br>
<hr>
<A name=782></a><b>How the Transparency Model Works<br></b>In  the  transparency  model,  security-critical  methods  are  marked  with  the<br>[SecurityCritical] attribute:<br>
<b>[SecurityCritical]</b><br>
public Key GetTVRoomKey() { ... }<br>
All "dangerous" methods (containing code that the CLR considers could breach<br>security and allow an inmate to escape) must be marked with [SecurityCritical]<br>or [SecuritySafeCritical]. This comprises:<br>
· Unverifiable (unsafe) methods<br>· Methods that call unmanaged code via P/Invoke or COM interop<br>· Methods that Assert permissions or call link-demanding methods<br>· Methods that <i>call</i> [SecurityCritical] methods<br>· Methods that <i>override</i> virtual [SecurityCritical] methods<br>
[SecurityCritical]  means  "this  method  could  allow  a  partially  trusted  caller  to<br>escape a sandbox."<br>
[SecuritySafeCritical] means "this method does security-critical things--but with<br>appropriate safeguards and so is safe for partially trusted callers."<br>
Partially trusted assemblies can never call security critical methods in fully trusted<br>assemblies. [SecurityCritical] methods can be called only by:<br>
· Other [SecurityCritical] methods<br>· Methods marked as [SecuritySafeCritical]<br>
<i>Security-safe critical</i> methods act as gatekeepers for security-critical methods (see<br>Figure 20-1), and can be called by any method in any assembly (fully or partially<br>trusted, subject to permission-based CAS demands). To illustrate, suppose that as<br>an inmate you want to watch television. The WatchTV method that you'll call will<br>need to call GetTVRoomKey, which means that WatchTV must be <i>security-safe-critical</i>:<br>
<b>[SecuritySafeCritical]<br></b>public void WatchTV()<br>{<br>  new TVPermission().Demand();<br>  using (Key key = GetTVRoomKey())<br>    PrisonGuard.OpenDoor (key);<br>}<br>
Notice  that  we  Demand  a  TVPermission  to  ensure  that  the  caller  actually  has  TV-<br>watching  rights,  and  carefully  dispose  of  the  key  we  create.  We  are  wrapping  a<br><i>security-critical</i> method, making it <i>safe</i> to be called by anyone.<br>
<b>762 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=783></a><b>Security</b><br>
<i>Figure 20-1. Transparency model; only the area in gray needs security auditing</i><br>
Some methods partake in the activities considered "dangerous"<br>by the CLR, but are not actually dangerous. You can mark these<br>methods  directly  with  [SecuritySafeCritical]  instead  of<br>[SecurityCritical]. An example is the Array.Copy method: it<br>has an unmanaged implementation for efficiency, and yet can-<br>not be abused by partially trusted callers.<br>
<b>The UnsafeXXX Pattern</b><br>
There's a potential inefficiency in our TV-watching example in that if a prison<br>guard wants to watch TV via the WatchTV method, he must (unnecessarily) satisfy<br>a  TVPermission  demand.  As  a  remedy,  the  CLR  team  recommends  a  pattern<br>whereby you define two versions of the method. The first is security-critical and<br>is prefixed by the word <i>Unsafe</i>:<br>
[SecurityCritical]<br>public void <b>Unsafe</b>WatchTV()<br>{<br>  using (Key key = GetTVRoomKey())<br>    PrisonGuard.OpenDoor(key);<br>}<br>
The second is security-safe-critical, and calls the first after satisfying a full stack-<br>walking demand:<br>
[SecuritySafeCritical]<br>public void WatchTV()<br>{<br>  new TVPermission().Demand();<br>  UnsafeWatchTV();<br>}<br>
<b>Transparent code<br></b>Under the transparency model, all methods fall into one of three categories:<br>
<b>The Transparency Model in CLR 4.0 | 763</b><br>
<hr>
<A name=784></a>· <i>Security-critical<br></i>· <i>Security-safe-critical<br></i>· Neither (in which case, they're called <i>transparent</i>)<br>
<i>Transparent</i> methods are so called because you can ignore them when it comes to<br>auditing code for elevation of privilege attacks. All you need to focus on are the<br>[SecuritySafeCritical] methods (the gatekeepers), which typically comprise just a<br>small fraction of an assembly's methods. If an assembly comprises entirely trans-<br>parent  methods,  the  entire  assembly  can  be  marked  with  the  [SecurityTranspar<br>ent] attribute:<br>
[assembly: SecurityTransparent]<br>
We then say that the <i>assembly itself</i> is transparent. Transparent assemblies don't<br>need auditing for elevation of privilege attacks and implicitly allow partially trusted<br>callers--you don't need to apply APTCA.<br>
<b>Settings the transparency default for an assembly<br></b>To summarize what we said previously, there are two ways to specify transparency<br>at the assembly level:<br>
· Apply the APTCA. All methods are then implicitly transparent except those you<br>
mark otherwise.<br>
· Apply the [SecurityTransparent] assembly attribute. All methods are then im-<br>
plicitly transparent, without exception.<br>
The third option is to do nothing. This still opts you <i>into</i> the transparency rules, but<br>with every method implicitly [SecurityCritical] (apart from any virtual [Security<br>SafeCritical] methods that you override, which will remain safe-critical). The effect<br>is that you can call any method you like (assuming you're fully trusted), but trans-<br>parent methods in other assemblies won't be able to call you.<br>
<b>How to Write APTCA Libraries with Transparency<br></b>To follow the transparency model, first identify the potentially "dangerous" meth-<br>ods in your assembly (as described in the previous section). Unit tests will pick these<br>up, because the CLR will refuse to run such methods--even in a fully trusted envi-<br>ronment. (Framework 4.0 also ships with a tool called <i>SecAnnotate.exe</i> to help with<br>this.) Then mark each such method with:<br>
· [SecurityCritical], if the method might be harmful if called from a less trusted<br>
assembly<br>
· [SecuritySafeCritical],  if  the  method  performs  appropriate  checks/safe-<br>
guards and can be safely called from a less trusted assembly<br>
To illustrate, consider the following method, which calls a security-critical method<br>in the .NET Framework:<br>
public static void LoadLibraries()<br>{<br>
<b>764 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=785></a>  GC.AddMemoryPressure (1000000);   // <b>Security critical</b><br>
  ...<br>}<br>
This method could be abused by being called repeatedly from less trusted callers.<br>We could apply the [SecurityCritical] attribute, but then the method would be<br>callable only from other trusted parties via critical or safe-critical methods. A better<br>solution is to fix the method so that it's secure and then apply the [SecuritySafe<br>
<b>Security</b><br>
Critical] attribute:<br>
static bool _loaded;<br>
<b>[SecuritySafeCritical]</b><br>
public static void LoadLibraries()<br>{<br>  <b>if (_loaded) return;</b><br>
  <b>_loaded = true;</b><br>
  GC.AddMemoryPressure (1000000);<br>
  ...<br>
}<br>
(This has the benefit of making it safer for trusted callers, too.)<br>
<b>Securing unsafe methods<br></b>Next, suppose we have an unsafe method that is potentially harmful if called by a<br>less trusted assembly. We simply decorate it with [SecurityCritical]:<br>
<b>[SecurityCritical]<br></b>public unsafe void Poke (int offset, int data)<br>
{<br>  int* target = (int*) _origin + offset;<br>  *target = data;<br>  ...<br>}<br>
If you write unsafe code in a transparent method, the CLR will<br>throw a VerificationException ("Operation could destabilize<br>the runtime") before executing the method.<br>
We then secure the upstream methods, marking them with [SecurityCritical] or<br>[SecuritySafeCritical] as appropriate.<br>
Next, consider the following unsafe method, which filters a bitmap. This is intrins-<br>ically harmless, so we can mark it SecuritySafeCritical:<br>
[<b>SecuritySafeCritical</b>]<br>unsafe void BlueFilter (int[,] bitmap)<br>{<br>  int length = bitmap.Length;<br>  fixed (int* b = bitmap)<br>
  {<br>    int* p = b;<br>    for (int i = 0; i &lt; length; i++)<br>
<b>The Transparency Model in CLR 4.0 | 765</b><br>
<hr>
<A name=786></a>      *p++ &amp;= 0xFF;<br>
  }<br>}<br>
Conversely, you might write a function that doesn't perform anything "dangerous"<br>as far as the CLR is concerned, but poses a security risk nonetheless. You can dec-<br>orate these, too, with [SecurityCritical]:<br>
public string Password<br>
{<br>  <b>[SecurityCritical]</b> get { return _password; }<br>
}<br>
<b>P/Invokes and [SuppressUnmanagedSecurity]<br></b>Finally, consider the following unmanaged method, which returns a window handle<br>from a Point (System.Drawing):<br>
[DllImport (&quot;user32.dll&quot;)]<br>public static extern IntPtr WindowFromPoint (Point point);<br>
Remember that you can call unmanaged code only from [SecurityCritical] and<br>[SecuritySafeCritical] methods.<br>
You  could  say  that  all  extern  methods  are  implicitly<br>[SecurityCritical],  although  there  is  a  subtle  difference:<br>applying  [SecurityCritical]  explicitly  to  an  extern  method<br>has the subtle effect of advancing the security check from run-<br>time to JIT time. To illustrate, consider the following method:<br>
static void Foo (bool exec)<br>{<br>  if (exec) WindowFromPoint (...)<br>
}<br>
If called with false, this will be subject to a security check only<br>if  WindowFromPoint  is  marked  explicitly  with  [SecurityCriti<br>cal].<br>
Because  we've  made  the  method  public,  other  fully  trusted  assemblies  can  call<br>WindowFromPoint  directly  from  [SecurityCritical]  methods.  For  partially  trusted<br>callers, we expose the following secure version, which eliminates the danger, by<br>Demanding UI permission and returning a managed class instead of an IntPtr:<br>
<b>[UIPermission (SecurityAction.Demand, Unrestricted = true)]<br>[SecuritySafeCritical]<br></b>public static System.Windows.Forms.Control ControlFromPoint (Point point)<br>
{<br>  IntPtr winPtr = WindowFromPoint (point);<br>  if (winPtr == IntPtr.Zero) return null;<br>  return System.Windows.Forms.Form.FromChildHandle (winPtr);<br>}<br>
Just  one  problem  remains:  the  CLR  performs  an  implicit  Demand for unmanaged<br>permission whenever you P/Invoke. And because a Demand checks right up the call<br>
<b>766 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=787></a>stack, the WindowFromPoint method will fail if the caller's caller is partially trusted.<br>There are two ways around this. The first is to <i>assert</i> permission for unmanaged code<br>in the first line of the ControlFromPoint method:<br>
new SecurityPermission (SecurityPermissionFlag.UnmanagedCode).<b>Assert()</b>;<br>
Asserting our assembly-given unmanaged right here will ensure that the subsequent<br>implicit Demand in WindowFromPoint will succeed. Of course, this assertion would fail<br>if the assembly itself wasn't fully trusted (by virtue of being loaded into the GAC or<br>
<b>Security</b><br>
being nominated as fully trusted by the host). We'll cover assertions in more detail<br>in "Sandboxing Another Assembly" on page 769.<br>
The second (and more performant) solution is to apply the [SuppressUnmanagedCo<br>deSecurity] attribute to the unmanaged method:<br>
[DllImport (&quot;user32.dll&quot;), <b>SuppressUnmanagedCodeSecurity</b>]<br>public static extern IntPtr WindowFromPoint (Point point);<br>
This tells the CLR to skip the expensive stack-walking unmanaged Demand (an opti-<br>mization that could be particularly valuable if WindowFromPoint was called from other<br>trusted classes or assemblies). We can then dump the unmanaged permission as-<br>sertion in ControlFromPoint.<br>
Because you're following the transparency model, applying this<br>attribute to an extern method doesn't create the same security<br>risk as in CLR 2.0. This is because you're still protected by the<br>fact that P/Invokes are implicitly security-critical, and so can be<br>called only by other critical or safe-critical methods.<br>
<b>Transparency in Full-Trust Scenarios<br></b>In a fully trusted environment, you might want to write critical code and yet avoid<br>the burden of security attributes and method auditing. The easiest way to achieve<br>this is not to attach any assembly security attributes--in which case all your methods<br>are implicitly [SecurityCritical].<br>This works well as long as <i>all</i> partaking assemblies do the same thing--or if the<br>transparency-enabled assemblies are at the <i>bottom</i> of the call graph. In other words,<br>you  can  still  call  transparent  methods  in  third-party  libraries  (and  in  the  .NET<br>Framework).<br>
To go in the reverse direction is troublesome; however, this trouble typically guides<br>you to a better solution. Suppose you're writing assembly T, which is partly or wholly<br>transparent, and you want to call assembly X, which is unattributed (and therefore<br>fully critical). You have three options:<br>
· Go fully critical yourself. If your domain will always be fully trusted, you don't<br>
need to support partially trusted callers. Making that lack of support <i>explicit<br></i>makes sense.<br>
· Write [SecuritySafeCritical] wrappers around calls to X. This then highlights<br>
the security vulnerability points (although this can be burdensome).<br>
<b>The Transparency Model in CLR 4.0 | 767</b><br>
<hr>
<A name=788></a>· Ask the author of X to consider transparency. If X does nothing critical, this will<br>
be as simple as applying [SecurityTransparent] to X. If X does perform critical<br>functions, the process of following the transparency model will force the author<br>of X to at least identify (if not address) X's vulnerability points.<br>
<b>Security Policy in CLR 2.0</b><br>
Prior to CLR 4.0, the CLR granted a default set of permissions to .NET assemblies<br>based on a complex set of rules and mappings. This was called CAS <i>policy</i> and<br>was defined in the computer's .NET Framework configuration. Three standard<br>grant  sets  resulted  from  policy  evaluation,  customizable  at  the  enterprise,  ma-<br>chine, user, and application domain levels:<br>
· "Full trust," which was granted to assemblies that ran on the local hard drive<br>· "LocalIntranet," granted to assemblies that ran over a network share<br>· "Internet," granted to assemblies that ran within Internet Explorer<br>
Only "Full trust" was fully trusted by default. This meant that if you ran a .NET<br>executable over a network share, it would run with a limited permission set and<br>usually fail. This was supposed to offer some protection, but in reality it offered<br>none--because a malicious party could simply replace the .NET executable with<br>an unmanaged executable and be subject to no permission restrictions. All that<br>this restriction achieved was to frustrate people who wanted to run .NET assem-<br>blies in full trust over a network share.<br>
Therefore, the designers of CLR 4.0 decided to abolish these security policies. All<br>assemblies now run in a permission set defined entirely by the hosting environ-<br>ment. Executables that you double-click or run from the command prompt will<br>always run in full trust--whether on a network share or on a local hard drive.<br>
In other words, it's now <i>entirely up to the host</i> as to how permissions should be<br>restricted--a machine's CAS policy is irrelevant.<br>
If you still need to work with CLR 2.0's security policy (which will be the case if<br>your entry executable targets Framework Version 3.5 or earlier) you can view and<br>adjust  security  policy  with  either  the  <i>mscorcfg.msc</i>  MMC  plug-in  (Control<br>PanelAdministrative ToolsMicrosoft .NET Framework Configuration) or the<br><i>caspol.exe</i> command-line tool. The MMC plug-in no longer ships as standard with<br>the .NET Framework: you must install the .NET Framework 3.5 SDK.<br>
The  security  configuration  is  ultimately  stored  in  an  XML  file  called<br><i>security.config</i>, in the Framework's configuration folder. You can obtain this as <br>follows:<br>
<b>768 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=789></a>string dir = Path.Combine<br>
 (System.Runtime.InteropServices.RuntimeEnvironment<br>                .GetRuntimeDirectory(), &quot;config&quot;);<br>string configFile = Path.Combine (dir, &quot;security.config&quot;);<br>
<b>Sandboxing Another Assembly</b><br>
<b>Security</b><br>
Suppose you write an application that allows consumers to install third-party plug-<br>ins. Most likely you'd want to prevent plug-ins from leveraging your privileges as a<br>trusted  application,  so  as  not  to  destabilize  your  application--or  the  end  user's<br>computer. The best way to achieve this is to run each plug-in in its own sandboxed<br>application domain.<br>
For this example, we'll assume a plug-in is packaged as a .NET assembly called<br><i>plugin.exe</i> and that activating it is simply a matter of starting the executable. (In<br>Chapter 24, we describe how to load a library into an application domain and in-<br>teract with it in a more sophisticated way.)<br>
Here's the complete code, for the <i>host</i> program:<br>
using System;<br>
using System.IO;<br>
using System.Net;<br>
using System.Reflection;<br>using System.Security;<br>using System.Security.Policy;<br>
using System.Security.Permissions;<br>
class Program<br>{<br>  static void Main()<br>  {<br>    string pluginFolder = Path.Combine (<br>      AppDomain.CurrentDomain.BaseDirectory, &quot;plugins&quot;);<br>
    string plugInPath = Path.Combine (pluginFolder, &quot;plugin.exe&quot;);<br>
    PermissionSet ps = new PermissionSet (PermissionState.None);<br>
    ps.AddPermission<br>      (new SecurityPermission (SecurityPermissionFlag.Execution));<br>
    ps.AddPermission<br>      (new FileIOPermission (FileIOPermissionAccess.PathDiscovery |<br>                             FileIOPermissionAccess.Read, plugInPath));<br>
    ps.AddPermission (new UIPermission (PermissionState.Unrestricted));<br>
    AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;<br>    AppDomain sandbox = AppDomain.CreateDomain (&quot;sbox&quot;, null, setup, ps);<br>    sandbox.ExecuteAssembly (plugInPath);<br>    AppDomain.Unload (sandbox);<br>
<b>Sandboxing Another Assembly | 769</b><br>
<hr>
<A name=790></a>  }<br>
}<br>
You  can  also  pass  a  list  of  assemblies  to  fully  trust  into  the<br>CreateDomain method. We'll give an example in the following<br>section.<br>
First, we create a limited permission set to describe the privileges we want to give to<br>the sandbox. This must include at least execution rights and permission for the plug-<br>in  to  read  its  own  assembly;  otherwise,  it  won't  start.  In  this  case,  we  also  give<br>unrestricted UI permissions. Then we construct a new application domain, speci-<br>fying our custom permission set, which will be awarded to all assemblies loaded into<br>that domain. We then execute the plug-in assembly in the new domain, and unload<br>the domain when the plug-in finishes executing.<br>
In this example, we load the plug-in assemblies from a subdir-<br>ectory called <i>plugins</i>. Putting plug-ins in the same directory as<br>the fully trusted host creates the potential for an elevation of<br>privilege  attack,  whereby  the  fully  trusted  domain  implicitly<br>loads and runs code in a plug-in assembly in order to resolve a<br>type.  An  example  of  how  this  could  happen  is  if  the  plug-in<br>throws  a  custom  exception  whose  type  is  defined  in  its  own<br>assembly. When the exception bubbles up to the host, the host<br>will implicitly load the plug-in assembly if it can find it--in an<br>attempt to deserialize the exception. Putting the plug-ins in a<br>separate folder prevents such a load from succeeding.<br>
<b>Asserting Permissions<br></b>Permission assertions are useful when writing methods that can be called from a<br>partially trusted assembly. They allow fully trusted assemblies to temporarily escape<br>the  sandbox  in  order  to  perform  actions  that  would  otherwise  be  prohibited  by<br>downstream Demands.<br>
Assertions in the world of CAS have nothing to do with diag-<br>nostic  or  contract-based  assertions.  Calling  Debug.Assert,  in<br>fact, is more akin to Demanding a permission than Asserting a<br>permission.  In  particular,  asserting  a  permission  has  <i>side  ef-<br>fects</i> if the assertion succeeds, whereas Debug.Assert does not.<br>
Recall that we previously wrote an application that ran third-party plug-ins in a<br>restricted permission set. Suppose we want to extend this by providing a library of<br>safe  methods  for  plug-ins  to  call.  For  instance,  we  might  prohibit  plug-ins  from<br>accessing a database directly, and yet still allow them to perform certain queries<br>through methods in a library that we provide. Or we might want to expose a method<br>for writing to a log file--without giving them any file-based permission.<br>
<b>770 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=791></a>The first step in doing this is to create a separate assembly for this (e.g., <i>utilities</i>) and<br>add the AllowPartiallyTrustedCallers attribute. Then we can expose a method as<br>follows:<br>
public static void WriteLog (string msg)<br>
{<br>  // Write to log<br>
  ...<br>
}<br>
<b>Security</b><br>
The difficulty here is that writing to a file requires FileIOPermission. Even though<br>our <i>utilities</i> assembly will be fully trusted, the caller won't be, and so any file-based<br>Demands will fail. The solution is to first Assert the permission:<br>
public class Utils<br>
{<br>  string _logsFolder = ...;<br>
  [SecuritySafeCritical]<br>  public static void WriteLog (string msg)<br>
  {<br>
    FileIOPermission f = new FileIOPermission (PermissionState.None);<br>
    f.AddPathList (FileIOPermissionAccess.AllAccess, _logsFolder);<br>    <b>f.Assert();</b><br>
    // Write to log<br>
    ...<br>
  }<br>
}<br>
Because  we're  asserting  a  permission,  we  must  mark  the<br>method as [SecurityCritical] or [SecuritySafeCritical] (un-<br>less we're targeting an earlier version of the Framework). In this<br>case, the method is safe for partially trusted callers, so we choose<br>SecuritySafeCritical.  This,  of  course,  means  that  we  can't<br>mark the assembly as a whole with [SecurityTransparent]; we<br>must use APTCA instead.<br>
Remember that Demand performs a spot-check and throws an exception if the per-<br>mission is not satisfied. It then walks the stack, checking that all callers also have<br>that permission (within the current AppDomain). An assertion checks only that the<br><i>current assembly</i> has the necessary permissions, and if successful, makes a mark on<br>the stack, indicating that from now on, the caller's rights should be ignored and only<br>the current assembly's rights should be considered with respect to those permis-<br>sions. An Assert ends when the method finishes or when you call CodeAccessPermis<br>sion.RevertAssert.<br>
To complete our example, the remaining step is to create a sandboxed application<br>domain  that  fully  trusts  the  <i>utilities</i>  assembly.  Then  we  can  instantiate<br>a  StrongName  object  that  describes  the  assembly,  and  pass  it  into  AppDomain's<br>CreateDomain method:<br>
<b>Sandboxing Another Assembly | 771</b><br>
<hr>
<A name=792></a>static void Main()<br>
{<br>  string pluginFolder = Path.Combine (<br>    AppDomain.CurrentDomain.BaseDirectory, &quot;plugins&quot;);<br>
  string plugInPath = Path.Combine (pluginFolder, &quot;plugin.exe&quot;);<br>
  PermissionSet ps = new PermissionSet (PermissionState.None);<br>
  // Add desired permissions to <i>ps</i> as we did before<br>  // ...<br>
  <b>Assembly utilAssembly = typeof (Utils).Assembly;<br></b>  <b>StrongName utils = utilAssembly.Evidence.GetHostEvidence&lt;StrongName&gt;();</b><br>
  AppDomainSetup setup = AppDomain.CurrentDomain.SetupInformation;<br>  AppDomain sandbox = AppDomain.CreateDomain (&quot;sbox&quot;, null, setup, ps,<br>
                                              <b>utils</b>);<br>
  sandbox.ExecuteAssembly (plugInPath);<br>  AppDomain.Unload (sandbox);<br>}<br>
For this to work, the <i>utilities</i> assembly must be strong-name signed.<br>
Prior to Framework 4.0, you couldn't obtain a StrongName by<br>calling GetHostEvidence as we did. The solution was to instead<br>do this:<br>
AssemblyName name = utilAssembly.GetName();<br>
StrongName utils = new StrongName (<br>  new StrongNamePublicKeyBlob (name.GetPublicKey()),<br>  name.Name,<br>
  name.Version);<br>
The old-fashioned approach is still useful when you don't want<br>to load the assembly into the host's domain. This is because you<br>can obtain an AssemblyName without needing an Assembly or Type <br>object:<br>
AssemblyName name = AssemblyName.GetAssemblyName<br>                    (@&quot;d:\utils.dll&quot;);<br>
<b>Operating System Security<br></b>The operating system can further restrict what an application can do, based on the<br>user's login privileges. In Windows, there are two types of accounts:<br>
· An administrative account that imposes no restrictions in accessing the local<br>
computer<br>
· A limited permissions account that restricts administrative functions and visi-<br>
bility of other users' data<br>
<b>772 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=793></a>A feature called User Access Control (UAC) introduced in Windows Vista means<br>that administrators receive two tokens or "hats" when logging in: an administrative<br>hat and an ordinary user hat. By default, programs run wearing the ordinary user<br>hat--with restricted permissions--unless the program requests <i>administrative ele-<br>vation</i>. The user must then approve the request via a dialog that's presented.<br>
For application developers, UAC means that <i>by default</i>, your application will run<br>with restricted user privileges. This means you must either:<br>
<b>Security</b><br>
· Write your application such that it can run without administrative privileges.<br>· Demand administrative elevation in the application manifest.<br>
The first option is safer and more convenient to the user. Designing your program<br>to run without administrative privileges is easy in most cases: the restrictions are<br>much less draconian than those of a typical <i>code access security</i> sandbox.<br>
You can find out whether you're running under an administra-<br>tive account with the following method:<br>
[DllImport (&quot;shell32.dll&quot;, EntryPoint = &quot;#680&quot;)]<br>static extern bool IsUserAnAdmin();<br>
With UAC enabled, this returns true only if the current process<br>has administrative elevation.<br>
<b>Running in a Standard User Account<br></b>Here are the key things that you <i>cannot</i> do in a standard Windows user account:<br>
· Write to the following directories:<br>
-- The operating system folder (typically <i>\Windows</i>) and subdirectories<br>-- The program files folder (<i>\Program Files</i>) and subdirectories<br>-- The root of the operating system drive (e.g., <i>C:\</i>)<br>
· Write to the HKEY_LOCAL_MACHINE branch of the Registry<br>· Read performance monitoring (WMI) data<br>
Additionally, as an ordinary user (or even as an administrator), you may be refused<br>access to files or resources that belong to other users. Windows uses a system of <br>Access Control Lists (ACLs) to protect such resources--you can query and assert<br>your own rights in the ACLs via types in System.Security.AccessControl. ACLs can<br>also be applied to cross-process wait handles, described in Chapter 21.<br>
If  you're  refused  access  to  anything  as  a  result  of  operating  system  security,  an<br>UnauthorizedAccessException is thrown. This is different from the SecurityExcep<br>tion thrown when a .NET permission demand fails.<br>
<b>Operating System Security | 773</b><br>
<hr>
<A name=794></a>The .NET code access permission classes are mostly independ-<br>ent of ACLs. This means you can successfully Demand a FileIO<br>Permission--but still get an UnauthorizedAccessException due<br>to ACL restrictions when trying to access the file.<br>
In most cases, you can deal with standard user restrictions as follows:<br>
· Write files to their recommended locations.<br>· Avoid using the Registry for information that can be stored in files (aside of the<br>
HKEY_CURRENT_USER hive, which you will have read/write access to).<br>
· Register ActiveX or COM components during setup.<br>
The recommended location for user documents is SpecialFolder.MyDocuments:<br>
string docsFolder = Environment.GetFolderPath<br>
                    (Environment.SpecialFolder.MyDocuments);<br>
string path = Path.Combine (docsFolder, &quot;test.txt&quot;);<br>
The recommended location for configuration files that a user might need to modify<br>outside of your application is SpecialFolder.ApplicationData (current user only) or<br>SpecialFolder.CommonApplicationData (all users). You typically create subdirecto-<br>ries within these folders, based on your organization and product name.<br>
A good place to put data that need only be accessed within your application is iso-<br>lated storage.<br>
Perhaps the most inconvenient aspect of running in a standard user account is that<br>a program doesn't have write access to its files, making it difficult to implement an<br>automatic  update  system.  One  option  is  to  deploy  with  ClickOnce:  this  allows<br>updates to be applied without administrative elevation, but places significant re-<br>strictions  on  the  setup  procedure  (e.g.,  you  cannot  register  ActiveX  controls).<br>Applications deployed with ClickOnce may also be sandboxed with code access<br>security, depending on their mode of delivery. We described another, more sophis-<br>ticated solution in "Packing a Single-File Executable" on page 676.<br>
<b>Administrative Elevation and Virtualization<br></b>In Chapter 17, we described how to deploy an application manifest. With an appli-<br>cation manifest, you can request that Windows prompt the user for administrative<br>elevation whenever running your program:<br>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;assembly manifestVersion=&quot;1.0&quot; xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot;&gt;<br>  &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v2&quot;&gt;<br>    &lt;security&gt;<br>      &lt;requestedPrivileges&gt;<br>        <b>&lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; /&gt;<br></b>      &lt;/requestedPrivileges&gt;<br>    &lt;/security&gt;<br>  &lt;/trustInfo&gt;<br>&lt;/assembly&gt;<br>
<b>774 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=795></a>If  you  replace  requireAdministrator  with  asInvoker,  it  instructs  Windows  that<br>administrative elevation is <i>not</i> required. The effect is almost the same as not having<br>an application manifest at all--except that <i>virtualization</i> is disabled. Virtualization<br>is a temporary measure introduced with Windows Vista to help old applications run<br>correctly without administrative privileges. The absence of an application manifest<br>with  a  requestedExecutionLevel  element  activates  this  backward-compatibility<br>feature.<br>
<b>Security</b><br>
Virtualization comes into play when an application writes to the <i>Program Files</i> or<br><i>Windows</i> directory, or the HKEY_LOCAL_MACHINE area of the Registry. Instead<br>of throwing an exception, changes are redirected to a separate location on the hard<br>disk where they can't impact the original data. This prevents the application from<br>interfering with the operating system--or other well-behaved applications.<br>
<b>Identity and Role Security<br></b>Identity and role-based security is useful when writing a middle tier server or an<br>ASP.NET application, where you're potentially dealing with many users. It allows<br>you to restrict functionality according to the authenticated user's name or role. An<br><i>identity</i> describes a username; a <i>role</i> describes a group. A <i>principal</i> is an object that<br>describes  an  identity  and/or  a  role.  Hence,  a  PrincipalPermission  class  enforces<br>identity and/or role security.<br>
In a typical application server, you demand a PrincipalPermission on all methods<br>exposed to the client for which you want to enforce security. For example, the fol-<br>lowing requires that the caller be a member of the "finance" role:<br>
[PrincipalPermission (SecurityAction.Demand, Role = &quot;finance&quot;)]<br>public decimal GetGrossTurnover (int year)<br>{<br>  ...<br>}<br>
To enforce that only a particular user can call a method, you can specify a  Name<br>instead:<br>
[PrincipalPermission (SecurityAction.Demand, Name = &quot;sally&quot;)]<br>
(Of course, the necessity to hardcode names makes this hard to manage.) To allow<br>a combination of identities or roles, you have to use imperative security instead. This<br>means instantiating PrincipalPermission objects, calling Union to combine them,<br>and then calling Demand on the end result.<br>
<b>Assigning Users and Roles<br></b>Before  a  PrincipalPermission  demand  can  succeed,  you  must  attach  an<br>IPrincipal object to the current thread.<br>
You can instruct that the current Windows user be used as an identity in either of<br>two ways, depending on whether you want to impact the whole application domain<br>or just the current thread:<br>
<b>Identity and Role Security | 775</b><br>
<hr>
<A name=796></a>AppDomain.CurrentDomain.SetPrincipalPolicy (PrincipalPolicy.<br>
                                            WindowsPrincipal);<br>// or:<br>Thread.CurrentPrincipal = new WindowsPrincipal (WindowsIdentity.<br>
                                                GetCurrent());<br>
If you're using WCF or ASP.NET, their infrastructures can help with impersonating<br>the client's identity. You can also do this yourself with the GenericPrincipal and<br>GenericIdentity classes. The following creates a user called "Jack" and assigns him<br>three roles:<br>
GenericIdentity id = new GenericIdentity (&quot;Jack&quot;);<br>GenericPrincipal p = new GenericPrincipal<br>
  (id, new string[] { &quot;accounts&quot;, &quot;finance&quot;, &quot;management&quot; } );<br>
For this to take effect, you'd assign it to the current thread as follows:<br>
Thread.CurrentPrincipal = p;<br>
A principal is thread-based because an application server typically processes many<br>client requests concurrently--each on its own thread. As each request may come<br>from a different client, it needs a different principal.<br>
You  can  subclass  GenericIdentity  and  GenericPrincipal--or  implement  the<br>IIdentity  and  IPrincipal  interfaces  directly  in  your  own  types.  Here's  how  the<br>interfaces are defined:<br>
public interface IIdentity<br>
{<br>  string Name { get; }<br>  string AuthenticationType { get; }<br>  bool IsAuthenticated { get; }<br>}<br>
public interface IPrincipal<br>{<br>  IIdentity Identity { get; }<br>  bool IsInRole (string role);<br>}<br>
The key method is IsInRole. Notice that there's no method returning a list of roles,<br>so you're obliged only to rule on whether a particular role is valid for that principal.<br>This can be the basis for more elaborate authorization systems.<br>
<b>Cryptography Overview<br></b>Table 20-8 summarizes the cryptography options in .NET. In the remaining sections,<br>we explore each of these.<br>
<b>776 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=797></a><i>Table 20-8. Encryption and hashing options in .NET</i><br>
<b>Option</b><br>
<b>Keys to manage</b><br>
<b>Speed</b><br>
<b>Strength</b><br>
<b>Notes</b><br>
File.Encrypt<br>
0<br>
Fast<br>
Depends on<br>
Protects files transparently with file-<br>
user's password<br>
system support. A key is derived im-<br>plicitly from the logged-in user's<br>credentials.<br>
Windows Data<br>
0<br>
Fast<br>
Depends on user's<br>
Encrypts and decrypts byte arrays using<br>
<b>Security</b><br>
Protection<br>
password<br>
an implicitly derived key.<br>
Hashing<br>
0<br>
Fast<br>
High<br>
One-way (irreversible) transforma-<br>tion. Used for storing passwords, com-<br>paring files, and checking for data<br>corruption.<br>
Symmetric Encryption<br>
1<br>
Fast<br>
High<br>
For general-purpose encryption/de-<br>cryption. The same key encrypts and<br>decrypts. Can be used to secure<br>messages in transit.<br>
Public Key Encryption<br>
2<br>
Slow<br>
High<br>
Encryption and decryption use differ-<br>ent keys. Used for exchanging a sym-<br>metric key in message transmission<br>and for digitally signing files.<br>
The Framework also provides more specialized support for creating and validating<br>XML-based signatures in System.Security.Cryptography.Xml and types for working<br>with digital certificates in System.Security.Cryptography.X509Certificates.<br>
<b>Windows Data Protection<br></b>In the section "File and Directory Operations" on page 559 in Chapter 14, we de-<br>scribed how you could use File.Encrypt to request that the operating system trans-<br>parently encrypt a file:<br>
File.WriteAllText (&quot;myfile.txt&quot;, &quot;&quot;);<br>File.Encrypt (&quot;myfile.txt&quot;);<br>
File.AppendAllText (&quot;myfile.txt&quot;, &quot;sensitive data&quot;);<br>
The encryption in this case uses a key derived from the logged-in user's password.<br>You  can  use  this  same  implicitly  derived  key  to  encrypt  a  byte  array  with  the<br>Windows Data Protection API. The Data Protection API is exposed through the<br>ProtectedData class--a simple type with two static methods:<br>
public static byte[] Protect (byte[] userData, byte[] optionalEntropy,<br>
                              DataProtectionScope scope);<br>
public static byte[] Unprotect (byte[] encryptedData, byte[] optionalEntropy,<br>                                DataProtectionScope scope);<br>
<b>Windows Data Protection | 777</b><br>
<hr>
<A name=798></a>Most  types  in  System.Security.Cryptography  live  in<br><i>mscorlib.dll</i>  and  <i>System.dll</i>.  ProtectedData  is  an  exception:  it<br>lives in <i>System.Security.dll</i>.<br>
Whatever you include in optionalEntropy is added to the key, thereby increasing<br>its  security.  The  DataProtectionScope  enum  argument  allows  two  options:<br>CurrentUser or LocalMachine. With CurrentUser, a key is derived from the logged-in<br>user's credentials; with LocalMachine, a machine-wide key is used, common to all<br>users. A LocalMachine key provides less protection, but works under a Windows<br>Service or a program needing to operate under a variety of accounts.<br>
Here's a simple encryption and decryption demo:<br>
byte[] original = {1, 2, 3, 4, 5};<br>DataProtectionScope scope = DataProtectionScope.CurrentUser;<br>
byte[] encrypted = ProtectedData.Protect (original, null, scope);<br>
byte[] decrypted = ProtectedData.Unprotect (encrypted, null, scope);<br>// decrypted is now {1, 2, 3, 4, 5}<br>
Windows Data Protection provides moderate security against an attacker with full<br>access to the computer, depending on the strength of the user's password. With<br>LocalMachine  scope,  it's  effective  only  against  those  with  restricted  physical  and<br>electronic access.<br>
<b>Hashing<br></b>Hashing  provides  one-way  encryption.  This  is  ideal  for  storing  passwords  in  a<br>database, as you might never need (or want) to see a decrypted version. To authen-<br>ticate, simply hash what the user types in and compare it to what's stored in the<br>database.<br>
A hash code is always a small fixed size regardless of the source data length. This<br>makes it good for comparing files or detecting errors in a data stream (rather like a<br>checksum). A single-bit change anywhere in the source data results in a significantly<br>different hash code.<br>
To  hash,  you  call  ComputeHash  on  one  of  the  HashAlgorithm  subclasses  such  as<br>SHA256 or MD5:<br>
byte[] hash;<br>using (Stream fs = File.OpenRead (&quot;checkme.doc&quot;))<br>  hash = MD5.Create().ComputeHash (fs);           // hash is 16 bytes long<br>
The ComputeHash method also accepts a byte array, which is convenient for hashing<br>passwords:<br>
byte[] data = System.Text.Encoding.UTF8.GetBytes (&quot;stRhong%pword&quot;);<br>byte[] hash = SHA256.Create().ComputeHash (data);<br>
<b>778 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=799></a>The GetBytes method on an Encoding object converts a string<br>to  a  byte  array;  the  GetString  method  converts  it  back.<br>An Encoding object cannot, however, convert an encrypted or<br>hashed byte array to a string, because scrambled data usually<br>violates text encoding rules. Instead, use the following:<br>
· Convert.ToBase64String<br>
<b>Security</b><br>
· Convert.FromBase64String<br>
These convert between any byte array and a legal (and XML-<br>friendly) string.<br>
MD5 and SHA256 are two of the HashAlgorithm subtypes provided by the .NET Frame-<br>work. Here are all the major algorithms, in ascending order of security (and hash<br>length, in bytes):<br>
MD5(16)  SHA1(20)  SHA256(32)  SHA384(48)  SHA512(64)<br>
The shorter the algorithm, the faster it executes. MD5 is more than 20 times faster<br>than SHA512 and is well suited to calculating file checksums. You can hash hundreds<br>of megabytes per second with MD5, and then store its result in a Guid. (A Guid happens<br>to be exactly 16 bytes long, and as a value type it is more tractable than a byte array;<br>you can meaningfully compare Guids with the simple equality operator, for instance.)<br>However, shorter hashes increase the possibility of <i>collision</i> (two distinct files yield-<br>ing the same hash).<br>
Use <i>at least</i> SHA256 when hashing passwords or other security-<br>sensitive data. MD5 and SHA1 are considered insecure for this pur-<br>pose,  and  are  suitable  to  protect  only  against  accidental<br>corruption, not deliberate tampering.<br>
SHA384 is no faster than SHA512, so if you want more security than<br>SHA256, you may as well use SHA512.<br>
The longer SHA algorithms are suitable for password hashing, but they require that<br>you enforce a strong password policy to mitigate a <i>dictionary attack</i>--a strategy<br>whereby an attacker builds a password lookup table by hashing every word in a<br>dictionary. You can provide additional protection against this by "stretching" your<br>password hashes--repeatedly rehashing to obtain more computationally intensive<br>byte sequences. If you rehash 100 times, a dictionary attack that might otherwise<br>take  1  month  would  take  8  years.  The  Rfc2898DeriveBytes  and  PasswordDerive<br>Bytes classes perform exactly this kind of stretching.<br>
Another technique to avoid dictionary attacks is to incorporate "salt"--a long series<br>of bytes that you initially obtain via a random number generator, and then combine<br>
<b>Hashing | 779</b><br>
<hr>
<A name=800></a>with each password before hashing. This frustrates hackers in two ways: hashes take<br>longer to compute, and they made not have access to the salt bytes.<br>
The Framework also provides a 160-bit RIPEMD hashing algorithm, slightly above<br>SHA1 in security. It suffers an inefficient .NET implementation, though, making it<br>slower to execute than even SHA512.<br>
<b>Symmetric Encryption<br></b>Symmetric  encryption  uses  the  same  key  for  encryption  as  for  decryption.  The<br>Framework provides four symmetric algorithms, of which Rijndael is the premium<br>(pronounced "Rhine Dahl" or "Rain Doll"). Rijndael is both fast and secure and has<br>two implementations:<br>
· The Rijndael class, which was available since Framework 1.0<br>· The Aes class, which was introduced in Framework 3.5<br>
The two are almost identical, except that Aes does not let you weaken the cipher by<br>changing the block size. Aes is recommended by the CLR's security team.<br>
Rijndael and Aes allow symmetric keys of length 16, 24, or 32 bytes: all are currently<br>considered secure. Here's how to encrypt a series of bytes as they're written to a file,<br>using a 16-byte key:<br>
byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};<br>byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};<br>
byte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.<br>
using (SymmetricAlgorithm algorithm = Aes.Create())<br>using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))<br>using (Stream f = File.Create (&quot;encrypted.bin&quot;))<br>using (Stream c = new CryptoStream (f, encryptor, CryptoStreamMode.Write))<br>  c.Write (data, 0, data.Length);<br>
The following code decrypts the file:<br>
byte[] key = {145,12,32,245,98,132,98,214,6,77,131,44,221,3,9,50};<br>byte[] iv  = {15,122,132,5,93,198,44,31,9,39,241,49,250,188,80,7};<br>
byte[] decrypted = new byte[5];<br>
using (SymmetricAlgorithm algorithm = Aes.Create())<br>using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))<br>using (Stream f = File.OpenRead (&quot;encrypted.bin&quot;))<br>using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))<br>  for (int b; (b = c.ReadByte()) &gt; -1;)<br>    Console.Write (b + &quot; &quot;);                            // 1 2 3 4 5<br>
In this example, we made up a key of 16 randomly chosen bytes. If the wrong key<br>was  used  in  decryption,  CryptoStream  would  throw  a  CryptographicException.<br>Catching this exception is the only way to test whether a key is correct.<br>
<b>780 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=801></a>As well as a key, we made up an IV, or <i>Initialization Vector</i>. This 16-byte sequence<br>forms part of the cipher--much like the key--but is not considered <i>secret</i>. If trans-<br>mitting an encrypted message, you would send the IV in plain text (perhaps in a<br>message header) and then <i>change it with every message</i>. This would render each<br>encrypted message unrecognizable from any previous one--even if their unencryp-<br>ted versions were similar or identical.<br>
<b>Security</b><br>
If you don't need--or want--the protection of an IV, you can<br>defeat it by using the same 16-byte value for both the key and<br>the IV. Sending multiple messages with the same IV, though,<br>weakens the cipher and might even make it possible to crack.<br>
The cryptography work is divided among the classes. Aes is the mathematician; it<br>applies the cipher algorithm, along with its encryptor and decryptor transforms.<br>CryptoStream  is  the  plumber;  it  takes  care  of  stream  plumbing.  You  can  replace<br>Aes with a different symmetric algorithm, yet still use CryptoStream.<br>
CryptoStream is <i>bidirectional</i>, meaning you can read or write to the stream depending<br>on  whether  you  choose  CryptoStreamMode.Read  or  CryptoStreamMode.Write.  Both<br>encryptors and decryptors are read- <i>and</i> write-savvy, yielding four combinations--<br>the choice can have you staring at a blank screen for a while! It can be helpful to<br>model reading as "pulling" and writing as "pushing." If in doubt, start with Write<br>for encryption and Read for decryption; this is often the most natural.<br>Use RandomNumberGenerator in System.Cryptography to generate a random key or IV.<br>The numbers it produces are genuinely unpredictable, or <i>cryptographically strong<br></i>(the System.Random class does not offer the same guarantee). Here's an example:<br>
byte[] key = new byte [16];<br>byte[] iv  = new byte [16];<br>
RandomNumberGenerator rand = RandomNumberGenerator.Create();<br>rand.GetBytes (key);<br>rand.GetBytes (iv);<br>
If  you  don't  specify  a  key  and  IV,  cryptographically  strong  random  values  are<br>generated automatically. You can query these through the Aes object's Key and IV<br>properties.<br>
<b>Encrypting in Memory<br></b>With a MemoryStream, you can encrypt and decrypt entirely in memory. Here are<br>helper methods that do just this, with byte arrays:<br>
public static byte[] Encrypt (byte[] data, byte[] key, byte[] iv)<br>{<br>  using (Aes algorithm = Aes.Create())<br>  using (ICryptoTransform encryptor = algorithm.CreateEncryptor (key, iv))<br>    return Crypt (data, key, iv, encryptor);<br>}<br>
public static byte[] Decrypt (byte[] data, byte[] key, byte[] iv)<br>
<b>Symmetric Encryption | 781</b><br>
<hr>
<A name=802></a>{<br>  using (Aes algorithm = Aes.Create())<br>  using (ICryptoTransform decryptor = algorithm.CreateDecryptor (key, iv))<br>    return Crypt (data, key, iv, decryptor);<br>
}<br>
static byte[] Crypt (byte[] data, byte[] key, byte[] iv,<br>                     ICryptoTransform cryptor)<br>
{<br>  MemoryStream m = new MemoryStream();<br>  using (Stream c = new CryptoStream (m, cryptor, CryptoStreamMode.Write))<br>    c.Write (data, 0, data.Length);<br>
  return m.ToArray();<br>
}<br>
Here, CryptoStreamMode.Write works best for both encryption and decryption, since<br>in both cases we're "pushing" into a fresh memory stream.<br>
Here are overloads that accept and return strings:<br>
public static string Encrypt (string data, byte[] key, byte[] iv)<br>{<br>  return Convert.ToBase64String (<br>
    Encrypt (Encoding.UTF8.GetBytes (data), key, iv));<br>
}<br>
public static string Decrypt (string data, byte[] key, byte[] iv)<br>
{<br>  return Encoding.UTF8.GetString (<br>    Decrypt (Convert.FromBase64String (data), key, iv));<br>}<br>
The following demonstrates their use:<br>
byte[] kiv = new byte[16];<br>RandomNumberGenerator.Create().GetBytes (kiv);<br>
string encrypted = Encrypt (&quot;Yeah!&quot;, kiv, kiv);<br>Console.WriteLine (encrypted);                 // R1/5gYvcxyR2vzPjnT7yaQ==<br>
string decrypted = Decrypt (encrypted, kiv, kiv);<br>Console.WriteLine (decrypted);                 // Yeah!<br>
<b>Chaining Encryption Streams<br></b>CryptoStream is a decorator, meaning it can be chained with other streams. In the<br>following example, we write compressed encrypted text to a file, and then read it<br>back:<br>
// Use default key/iv for demo.<br>using (Aes algorithm = Aes.Create())<br>{<br>  using (ICryptoTransform encryptor = algorithm.CreateEncryptor())<br>  using (Stream f = File.Create (&quot;serious.bin&quot;))<br>  using (Stream c = new CryptoStream (f,encryptor,CryptoStreamMode.Write))<br>  using (Stream d = new DeflateStream (c, CompressionMode.Compress))<br>  using (StreamWriter w = new StreamWriter (d))<br>
<b>782 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=803></a>    w.WriteLine (&quot;Small and secure!&quot;);<br>
  using (ICryptoTransform decryptor = algorithm.CreateDecryptor())<br>  using (Stream f = File.OpenRead (&quot;serious.bin&quot;))<br>
  using (Stream c = new CryptoStream (f, decryptor, CryptoStreamMode.Read))<br>
  using (Stream d = new DeflateStream (c, CompressionMode.Decompress))<br>  using (StreamReader r = new StreamReader (d))<br>    Console.WriteLine (r.ReadLine());            // Small and secure!<br>
}<br>
<b>Security</b><br>
In this example, all one-letter variables form part of a chain. The mathematicians--<br>algorithm, encryptor, and decyptor--are there to assist CryptoStream in the cipher<br>work. Figure 20-2 shows this diagrammatically.<br>
<i>Figure 20-2. Chaining encryption and compression streams</i><br>
Chaining streams in this manner demands little memory, regardless of the ultimate<br>stream sizes.<br>
As an alternative to nesting multiple using statements, you can<br>construct a chain as follows:<br>
using (ICryptoTransform encryptor = algorithm.CreateEncryptor())<br>using<br>
  (StreamWriter w = new StreamWriter (<br>    new DeflateStream (<br>      new CryptoStream (<br>        File.Create (&quot;serious.bin&quot;),<br>
<b>Symmetric Encryption | 783</b><br>
<hr>
<A name=804></a>        encryptor,<br>
        CryptoStreamMode.Write<br>
      ),<br>
      CompressionMode.Compress)<br>
    )<br>
  )<br>
This is less robust than the previous approach, however, be-<br>cause should an exception be thrown in an object's constructor<br>(e.g.,  DeflateStream),  any  objects  already  instantiated  (e.g.,<br>FileStream) would not be disposed.<br>
<b>Disposing Encryption Objects<br></b>Disposing a CryptoStream ensures that its internal cache of data is flushed to the<br>underlying stream. Internal caching is necessary for encryption algorithms because<br>they process data in blocks, rather than one byte at a time.<br>
CryptoStream is unusual in that its Flush method does nothing. To flush a stream<br>(without  disposing  it),  you  must  call  FlushFinalBlock.  In  contrast  to  Flush,<br>FlushFinalBlock can be called only once, and then no further data can be written.<br>
In  our  examples,  we  also  disposed  the  mathematicians--the  Aes  algorithm  and<br>ICryptoTransform objects (encryptor and decryptor). Disposal is actually optional<br>with the Rijndael transforms, because their implementations are purely managed.<br>Disposal still serves a useful role, however: it wipes the symmetric key and related<br>data from memory, preventing subsequent discovery by other software running on<br>the computer (we're talking malware). You can't rely on the garbage collector for<br>this job because it merely flags sections of memory as available; it doesn't write zeros<br>over every byte.<br>
The  easiest  way  to  dispose  an  Aes  object  outside  of  a  using  statement  is  to  call<br>Clear. Its Dispose method is hidden via explicit implementation (to signal its unusual<br>disposal semantics).<br>
<b>Key Management<br></b>It is inadvisable to hardcode encryption keys because popular tools exist to decom-<br>pile assemblies with little expertise. A better option is to manufacture a random key<br>for each installation, storing it securely with Windows Data Protection (or encrypt<br>the entire message with Windows Data Protection). If you're encrypting a message<br>stream, public key encryption provides the best option still.<br>
<b>Public Key Encryption and Signing<br></b>Public key cryptography is <i>asymmetric</i>, meaning that encryption and decryption use<br>different keys.<br>
Unlike  symmetric  encryption,  where  any  arbitrary  series  of  bytes  of  appropriate<br>length can serve as a key, asymmetric cryptography requires specially crafted key<br>
<b>784 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=805></a>pairs. A key pair contains a <i>public key</i> and <i>private key</i> component that work together<br>as follows:<br>
· The public key encrypts messages.<br>· The private key decrypts messages.<br>
The party "crafting" a key pair keeps the private key secret while distributing the<br>public key freely. A special feature of this type of cryptography is that you cannot<br>
<b>Security</b><br>
calculate a private key from a public key. So, if the private key is lost, encrypted data<br>cannot be recovered; conversely, if a private key is leaked, the encryption system<br>becomes useless.<br>
A  public  key  handshake  allows  two  computers  to  communicate  securely  over  a<br>public network, with no prior contact and no existing shared secret. To see how this<br>works, suppose computer <i>Origin</i> wants to send a confidential message to computer<br><i>Target</i>:<br>
1. <i>Target</i>  generates  a  public/private  key  pair,  and  then  sends  its  public  key  to<br>
<i>Origin</i>.<br>
2. <i>Origin</i> encrypts the confidential message using <i>Target</i>'s public key, then sends<br>
it to <i>Target</i>.<br>
3. <i>Target</i> decrypts the confidential message using its private key.<br>
An eavesdropper will see the following:<br>
· <i>Target</i>'s public key<br>· The secret message, encrypted with <i>Target</i>'s public key<br>
But without <i>Target</i>'s private key, the message cannot be decrypted.<br>
This  doesn't  prevent  against  a  man-in-the-middle  attack:  in<br>other words, <i>Origin</i> cannot know that <i>Target</i> isn't some mali-<br>cious party. In order to authenticate the recipient, the originator<br>needs to already know the recipient's public key, or be able to<br>validate its key through a <i>digital site certificate</i>.<br>
The secret message sent from  <i>Origin</i> to <i>Target</i> typically contains a fresh key for<br>subsequent <i>symmetric</i> encryption. This allows public key encryption to be aban-<br>doned for the remainder of the session, in favor of a symmetric algorithm capable<br>of handling larger messages. This protocol is particularly secure if a fresh public/<br>private key pair is generated for each session, as no keys then need to be stored on<br>either computer.<br>
The public key encryption algorithms rely on the message being<br>smaller than the key. This makes them suitable for encrypting<br>only small amounts of data, such as a key for subsequent sym-<br>metric encryption. If you try to encrypt a message much larger<br>than half the key size, the provider will throw an exception.<br>
<b>Public Key Encryption and Signing | 785</b><br>
<hr>
<A name=806></a><b>The RSA Class<br></b>The .NET Framework provides a number of asymmetric algorithms, of which RSA<br>is the most popular. Here's how to encrypt and decrypt with RSA:<br>
byte[] data = { 1, 2, 3, 4, 5 };   // This is what we're encrypting.<br>
using (var rsa = new RSACryptoServiceProvider())<br>
{<br>  byte[] encrypted = rsa.Encrypt (data, true);<br>
  byte[] decrypted = rsa.Decrypt (encrypted, true);<br>
}<br>
Because we didn't specify a public or private key, the cryptographic provider auto-<br>matically generated a key pair, using the default length of 1,024 bits; you can request<br>longer  keys  in  increments  of  eight  bytes,  through  the  constructor.  For  security-<br>critical applications, it's prudent to request 2,048 bits:<br>
var rsa = new RSACryptoServiceProvider (2048);<br>
Generating a key pair is computationally intensive--taking perhaps 100 ms. For this<br>reason, the RSA implementation delays this until a key is actually needed, such as<br>when calling Encrypt. This gives you the chance to load in an existing key--or key<br>pair, should it exist.<br>
The  methods  ImportCspBlob and  ExportCspBlob load and save keys in byte array<br>format. FromXmlString and ToXmlString do the same job in a string format, the string<br>containing an XML fragment. A boolean flag lets you indicate whether to include<br>the private key when saving. Here's how to manufacture a key pair and save it to disk:<br>
using (var rsa = new RSACryptoServiceProvider())<br>{<br>  File.WriteAllText (&quot;PublicKeyOnly.xml&quot;, rsa.ToXmlString (false));<br>  File.WriteAllText (&quot;PublicPrivate.xml&quot;, rsa.ToXmlString (true));<br>}<br>
Since we didn't provide existing keys, ToXmlString forced the manufacture of a fresh<br>key pair (on the first call). In the next example, we read back these keys and use<br>them to encrypt and decrypt a message:<br>
byte[] data = Encoding.UTF8.GetBytes (&quot;Message to encrypt&quot;);<br>
string publicKeyOnly = File.ReadAllText (&quot;PublicKeyOnly.xml&quot;);<br>string publicPrivate = File.ReadAllText (&quot;PublicPrivate.xml&quot;);<br>
byte[] encrypted, decrypted;<br>
using (var rsaPublicOnly = new RSACryptoServiceProvider())<br>{<br>  rsaPublicOnly.FromXmlString (publicKeyOnly);<br>  encrypted = rsaPublicOnly.Encrypt (data, true);<br>
  // The next line would throw an exception because you need the private<br>  // key in order to decrypt:<br>  // decrypted = rsaPublicOnly.Decrypt (encrypted, true);<br>}<br>
<b>786 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=807></a>using (var rsaPublicPrivate = new RSACryptoServiceProvider())<br>
{<br>  // With the private key we can successfully decrypt:<br>  rsaPublicPrivate.FromXmlString (publicPrivate);<br>
  decrypted = rsaPublicPrivate.Decrypt (encrypted, true);<br>
}<br>
<b>Digital Signing</b><br>
<b>Security</b><br>
Public key algorithms can also be used to digitally sign messages or documents. A<br>signature is like a hash, except that its production requires a private key and so<br>cannot be forged. The public key is used to verify the signature. Here's an example:<br>
byte[] data = Encoding.UTF8.GetBytes (&quot;Message to sign&quot;);<br>
byte[] publicKey;<br>
byte[] signature;<br>
object hasher = SHA1.Create();         // Our chosen hashing algorithm.<br>
// Generate a new key pair, then sign the data with it:<br>using (var publicPrivate = new RSACryptoServiceProvider())<br>
{<br>  signature = publicPrivate.SignData (data, hasher);<br>
  publicKey = publicPrivate.ExportCspBlob (false);    // get public key<br>}<br>
// Create a fresh RSA using just the public key, then test the signature.<br>
using (var publicOnly = new RSACryptoServiceProvider())<br>{<br>  publicOnly.ImportCspBlob (publicKey);<br>  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // True<br>
  // Let's now tamper with the data, and recheck the signature:<br>  data[0] = 0;<br>  Console.Write (publicOnly.VerifyData (data, hasher, signature)); // False<br>
  // The following throws an exception as we're lacking a private key:<br>  signature = publicOnly.SignData (data, hasher);<br>}<br>
Signing works by first hashing the data, and then applying the asymmetric algorithm<br>to the resultant hash. Because hashes are of a small fixed size, large documents can<br>be signed relatively quickly (public key encryption is much more CPU-intensive than<br>hashing). If you want, you can do the hashing yourself, and then call SignHash instead<br>of SignData:<br>
using (var rsa = new RSACryptoServiceProvider())<br>{<br>  byte[] hash = SHA1.Create().ComputeHash (data);<br>  signature = rsa.SignHash (hash, CryptoConfig.MapNameToOID (&quot;SHA1&quot;));<br>  ...<br>}<br>
<b>Public Key Encryption and Signing | 787</b><br>
<hr>
<A name=808></a>SignHash still needs to know what hash algorithm you used; CryptoConfig.MapName<br>ToOID provides this information in the correct format from a friendly name such as<br>"SHA1".<br>
RSACryptoServiceProvider produces signatures whose size matches that of the key.<br>Currently, no mainstream algorithm produces secure signatures significantly smaller<br>than 128 bytes (suitable for product activation codes, for instance).<br>
For signing to be effective, the recipient must know, and trust,<br>the sender's public key. This can happen via prior communica-<br>tion, preconfiguration, or a site certificate. A site certificate is<br>an electronic record of the originator's public key and name--<br>itself signed by an independent trusted authority. The name-<br>space System.Security.Cryptography.X509Certificates defines<br>the types for working with certificates.<br>
<b>788 | Chapter 20:</b><b>Security</b><br>
<hr>
<A name=809></a><b>21</b><br>
<b>Threading</b><br>
C# allows you to execute code in parallel through multithreading.<br>
A thread is analogous to the operating system process in which your application<br>runs. Just as processes run in parallel on a computer, threads run in parallel <i>within<br>a single process</i>. Processes are fully isolated from each other; threads have just a<br>limited degree of isolation. In particular, threads share (heap) memory with other<br>threads running in the same application. This, in part, is why threading is useful:<br>one thread can fetch data in the background, for instance, while another thread can<br>display the data as it arrives.<br>
This chapter describes the language and Framework features for creating, configur-<br>ing, and communicating with threads, and how to coordinate their actions through<br>locking and signaling. It also covers the basic predefined types that assist threading,<br>such as BackgroundWorker and the Timer classes.<br>
<b>Threading's Uses and Misuses<br></b>Multithreading has many uses; here are the most common:<br>
<i>Maintaining a responsive user interface</i><br>
By running time-consuming tasks on a parallel "worker" thread, the main UI<br>thread is free to continue processing keyboard and mouse events.<br>
<i>Making efficient use of an otherwise blocked CPU</i><br>
Multithreading is useful when a thread is awaiting a response from another<br>computer or piece of hardware. While one thread is blocked while performing<br>the  task,  other  threads  can  take  advantage  of  the  otherwise  unburdened<br>computer.<br>
<i>Parallel programming</i><br>
Code that performs intensive calculations can execute faster on multicore or<br>multiprocessor computers if the workload is shared among multiple threads in<br>a "divide-and-conquer" strategy (the following chapter is dedicated to this).<br>
<b>789</b><br>
<hr>
<A name=810></a><i>Speculative execution</i><br>
On multicore machines, you can sometimes improve performance by predicting<br>something that might need to be done, and then doing it ahead of time. LINQ-<br>Pad uses this technique to speed up the creation of new queries. A variation is<br>to run a number of different algorithms in parallel that all solve the same task.<br>Whichever  one  finishes  first  "wins"--this  is  effective  when  you  can't  know<br>ahead of time which algorithm will execute fastest.<br>
<i>Allowing requests to be processed simultaneously</i><br>
On a server, client requests can arrive concurrently and so need to be handled<br>in parallel (the .NET Framework creates threads for this automatically if you<br>use ASP.NET, WCF, Web Services, or Remoting). This can also be useful on a<br>client (e.g., handling peer-to-peer networking--or even multiple requests from<br>the user).<br>
With technologies such as ASP.NET and WCF, you may be unaware that multi-<br>threading is even taking place--unless you access shared data (perhaps via static<br>fields) without appropriate locking, running afoul of thread safety.<br>
Threads also come with strings attached. The biggest is that multithreading can<br>increase complexity. Having lots of threads does not in and of itself create much<br>complexity; it's the interaction between threads (typically via shared data) that does.<br>This applies whether or not the interaction is intentional, and can cause long de-<br>velopment cycles and an ongoing susceptibility to intermittent and nonreproducible<br>bugs. For this reason, it pays to keep interaction to a minimum, and to stick to simple<br>and proven designs wherever possible. This chapter focuses largely on dealing with<br>just these complexities; remove the interaction and there's much less to say!<br>
A good strategy is to encapsulate multithreading logic into re-<br>usable classes that can be independently examined and tested.<br>The Framework itself offers many higher-level threading con-<br>structs, which we cover in this and the following chapter.<br>
Threading also incurs a resource and CPU cost in scheduling and switching threads<br>(when there are more active threads than CPU cores)--and there's also a creation/<br>tear-down cost. Multithreading will not always speed up your application--it can<br>even slow it down if used excessively or inappropriately. For example, when heavy<br>disk I/O is involved, it can be faster to have a couple of worker threads run tasks in<br>sequence than to have 10 threads executing at once. (In "Signaling with Wait and<br>Pulse" on page 840, we describe how to implement a producer/consumer queue,<br>which provides just this functionality.)<br>
<b>790 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=811></a><b>Getting Started<br></b>A <i>client</i> program (Console, WPF, or Windows Forms) starts in a single thread that's<br>created automatically by the CLR and operating system (the "main" thread). Here<br>it lives out its life as a single-threaded application, unless you do otherwise, by cre-<br>ating more threads (directly or indirectly).*<br>
You can create and start a new thread by instantiating a Thread object and calling<br>its Start method. The simplest constructor for Thread takes a ThreadStart delegate:<br>a parameterless method indicating where execution should begin. For example, see<br>the code listing following the note.<br>
<b>Threading</b><br>
All examples assume the following namespaces are imported:<br>
using System;<br>using System.Threading;<br>
class ThreadTest<br>{<br>  static void Main()<br>
  {<br>
    Thread t = new Thread (WriteY);          // Kick off a new thread<br>    t.Start();                               // running WriteY()<br>
    // Simultaneously, do something on the main thread.<br>    for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;x&quot;);<br>
  }<br>
  static void WriteY()<br>  {<br>    for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;y&quot;);<br>  }<br>}<br>
// Output:<br>xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy<br>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy<br>yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx<br>xxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy<br>yyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx<br>
...<br>
The main thread creates a new thread t on which it runs a method that repeatedly<br>prints the character "y". Simultaneously, the main thread repeatedly prints the char-<br>acter "x", as shown in Figure 21-1. On a single-core computer, the operating system<br>must allocate "slices" of time to each thread (typically 20 ms in Windows) to sim-<br>ulate concurrency, resulting in repeated blocks of "x" and "y". On a multicore or<br>multiprocessor machine, the two threads can genuinely execute in parallel (subject<br>to competition by other active processes on the computer), although you still get<br>
* The CLR creates other threads behind the scenes for garbage collection and finalization.<br>
<b>Getting Started | 791</b><br>
<hr>
<A name=812></a><i>Figure 21-1. Starting a new thread</i><br>
repeated blocks of "x" and "y" because of subtleties in the mechanism by which<br>Console handles concurrent requests.<br>
A thread is said to be <i>preempted</i> at the points where its execution<br>is interspersed with the execution of code on another thread.<br>The term often crops up in explaining why something has gone<br>wrong!<br>
Once started, a thread's IsAlive property returns true, until the point where the<br>thread ends. A thread ends when the delegate passed to the Thread's constructor<br>finishes executing. Once ended, a thread cannot restart.<br>
You can wait for another thread to end by calling its Join method. Here's an example:<br>
static void Main()<br>{<br>  Thread t = new Thread (Go);<br>  t.Start();<br>  t.Join();<br>  Console.WriteLine (&quot;Thread t has ended!&quot;);<br>}<br>
static void Go() { for (int i = 0; i &lt; 1000; i++) Console.Write (&quot;y&quot;); }<br>
This prints "y" 1,000 times, followed by "Thread t has ended!" immediately after-<br>ward. You can include a timeout when calling Join, either in milliseconds or as a<br>TimeSpan. It then returns true if the thread ended or false if it timed out.<br>
Thread.Sleep pauses the current thread for a specified period:<br>
Thread.Sleep (TimeSpan.FromHours (1));  // sleep for 1 hour<br>Thread.Sleep (500);                     // sleep for 500 milliseconds<br>
While  a  thread  waits  during  a  Sleep  or  Join,  it's  said  to  be <br><i>blocked</i>. We describe blocking in more detail in "Synchroniza-<br>tion" on page 805.<br>
<b>792 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=813></a>Thread.Sleep(0) relinquishes the thread's current time slice immediately, voluntar-<br>ily handing over the CPU to other threads. Framework 4.0's new Thread.Yield()<br>method does the same thing--except that it relinquishes only to threads running on<br>the <i>same</i> processor.<br>
Sleep(0) or Yield is occasionally useful in production code for<br>advanced performance tweaks. It's also an excellent diagnostic<br>tool  for  helping  to  uncover  thread  safety  issues:  if  inserting<br>Thread.Yield()  anywhere  in  your  code  makes  or  breaks  the<br>program, you almost certainly have a bug.<br>
Each thread has a Name property that you can set for the benefit of debugging. This<br>
<b>Threading</b><br>
is particularly useful in Visual Studio, since the thread's name is displayed in the<br>Threads Window and Debug Location toolbar. You can set a thread's name just<br>once; attempts to change it later will throw an exception.<br>
The static Thread.CurrentThread property gives you the currently executing thread:<br>
Console.WriteLine (Thread.CurrentThread.Name);<br>
<b>Passing Data to a Thread<br></b>The easiest way to pass arguments to a thread's target method is to execute a lambda<br>expression that calls the method with the desired arguments:<br>
static void Main()<br>
{<br>  Thread t = new Thread ( <b>() =&gt; Print (&quot;Hello from t!&quot;)</b> );<br>  t.Start();<br>}<br>
static void Print (string message) { Console.WriteLine (message); }<br>
With this approach, you can pass in any number of arguments to the method. You<br>can even wrap the entire implementation in a multistatement lambda:<br>
new Thread (() =&gt;<br>{<br>  Console.WriteLine (&quot;I'm running on another thread!&quot;);<br>  Console.WriteLine (&quot;This is so easy!&quot;);<br>}).Start();<br>
You can do the same thing almost as easily in C# 2.0 with anonymous methods:<br>
new Thread (<b>delegate()<br></b>{<br>  ...<br>}).Start();<br>
Another technique is to pass an argument into Thread's Start method:<br>
<b>Getting Started | 793</b><br>
<hr>
<A name=814></a>static void Main()<br>
{<br>  Thread t = new Thread (Print);<br>  t.Start <b>(&quot;Hello from t!&quot;)</b>;<br>
}<br>
static void Print (object messageObj)<br>{<br>  string message = (string) messageObj;   // We need to cast here<br>
  Console.WriteLine (message);<br>}<br>
This  works  because  Thread's  constructor  is  overloaded  to  accept  either  of  two<br>delegates:<br>
public delegate void ThreadStart();<br>
public delegate void ParameterizedThreadStart (object obj);<br>
The limitation of ParameterizedThreadStart is that it accepts only one argument.<br>And because it's of type object, it usually needs to be cast.<br>
<b>Lambda expressions and captured variables<br></b>As we saw, a lambda expression is the most powerful way to pass data to a thread.<br>However, you must be careful about accidentally modifying <i>captured variables</i> after<br>starting the thread. For instance, consider the following:<br>
for (int i = 0; i &lt; 10; i++)<br>
  new Thread (() =&gt; Console.Write (i)).Start();<br>
The output is nondeterministic! Here's a typical result:<br>
0223557799<br>
The problem is that the i variable refers to the <i>same</i> memory location throughout<br>the loop's lifetime. Therefore, each thread calls Console.Write on a variable whose<br>value may change as it is running! The solution is to use a temporary variable as<br>follows:<br>
for (int i = 0; i &lt; 10; i++)<br>{<br>  int temp = i;<br>  new Thread (() =&gt; Console.Write (temp)).Start();<br>}<br>
This is analogous to the problem we described in "Captured<br>Variables" on page 325 in Chapter 8. The problem is less about<br>multithreading and more about C#'s rules for capturing varia-<br>bles (which are somewhat undesirable in the case of for and<br>foreach loops).<br>
Variable temp is now local to each loop iteration. Therefore, each thread captures a<br>different memory location and there's no problem. We can illustrate the problem in<br>the earlier code more simply with the following example:<br>
<b>794 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=815></a>string text = &quot;t1&quot;;<br>
Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );<br>
text = &quot;t2&quot;;<br>
Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );<br>
t1.Start();<br>t2.Start();<br>
Here's the output:<br>
t2<br>
t2<br>
<b>Sharing Data Between Threads</b><br>
<b>Threading</b><br>
The preceding example demonstrated that captured variables are shared between<br>threads. Let's take a step back and examine what happens with local variables in the<br>simpler case where no lambda expressions or anonymous methods are involved.<br>Consider this program:<br>
static void Main()<br>
{<br>  new Thread (Go).Start();      // Call Go() on a new thread<br>
  Go();                         // Call Go() on the main thread<br>}<br>
static void Go()<br>
{<br>  // Declare and use a local variable - 'cycles'<br>
  for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write (cycles);<br>}<br>
// OUTPUT:  0123401234<br>
Each thread gets a separate copy of the cycles variable as it enters the Go method<br>and so is unable to interfere with another concurrent thread. The CLR and operating<br>system achieve this by assigning each thread its own private memory stack for local<br>variables.<br>
If threads do want to share data, they do so via a common reference. This can be a<br>captured variable as we saw previously--but much more often it's a <i>field</i>. Here's an<br>example:<br>
static void Main()<br>{<br>  Introducer intro = new Introducer();<br>  intro.Message = &quot;Hello&quot;;<br>
  var t = new Thread (intro.Run);<br>  t.Start(); t.Join();<br>
  Console.WriteLine (intro.Reply);<br>}<br> <br>
<b>Getting Started | 795</b><br>
<hr>
<A name=816></a>class Introducer<br>
{<br>  public string Message;<br>  public string Reply;<br>
  public void Run()<br>  {<br>    Console.WriteLine (Message);<br>
    Reply = &quot;Hi right back!&quot;;<br>
  }<br>}<br>
// Output:<br>Hello<br>
Hi right back!<br>
Shared fields allow both for passing data to a new thread and for receiving data back<br>from it later on. Moreover, they allow threads to communicate with each other as<br>they're running. Shared fields can be either instance or static.<br>
Shared data is the primary cause of complexity and obscure er-<br>rors in multithreading. Although often essential, it pays to keep<br>it as simple as possible. Sometimes it's possible to avoid shared<br>state  altogether--in  which  case,  you  entirely  avoid  the  com-<br>plexities and overhead of synchronization (which we'll describe<br>later).<br>
<b>Foreground and Background Threads<br></b>By default, threads you create explicitly are <i>foreground threads</i>. Foreground threads<br>keep the application alive for as long as any one of them is running, whereas <i>back-<br>ground threads</i> do not. Once all foreground threads finish, the application ends, and<br>any background threads still running abruptly terminate.<br>
A thread's foreground/background status has no relation to its<br>priority or allocation of execution time.<br>
You can query or change a thread's background status using its IsBackground prop-<br>erty. Here's an example:<br>
class PriorityTest<br>{<br>  static void Main (string[] args)<br>  {<br>    Thread worker = new Thread ( () =&gt; Console.ReadLine() );<br>    if (args.Length &gt; 0) worker.IsBackground = true;<br>    worker.Start();<br>  }<br>}<br>
<b>796 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=817></a>If this program is called with no arguments, the worker thread assumes foreground<br>status and will wait on the ReadLine statement for the user to press Enter. Meanwhile,<br>the main thread exits, but the application keeps running because a foreground thread<br>is still alive.<br>
On the other hand, if an argument is passed to Main(), the worker is assigned back-<br>ground status, and the program exits almost immediately as the main thread ends<br>(terminating the ReadLine).<br>When a process terminates in this manner, any finally blocks in the execution stack<br>of background threads are circumvented. This is a problem if your program employs<br>finally (or using) blocks to perform cleanup work such as releasing resources or<br>deleting temporary files. To avoid this, you can explicitly wait out such background<br>threads upon exiting an application. There are two ways to accomplish this:<br>
<b>Threading</b><br>
· If you've created the thread yourself, call Join on the thread.<br>· If you're on a pooled thread (see "Thread Pooling" on page 800) use an event<br>
wait handle (see "Signaling with Event Wait Handles" on page 832).<br>
In either case, you should specify a timeout, so you can abandon a renegade thread<br>should it refuse to finish for some reason. This is your backup exit strategy: in the<br>end, you want your application to close--without the user having to enlist help from<br>the Task Manager!<br>
If  a  user  uses  the  Task  Manager  to  forcibly  end  a  .NET<br>process,  all  threads  "drop  dead"  as  though  they  were  back-<br>ground threads. This is observed rather than documented be-<br>havior, and it could vary depending on the CLR and operating<br>system version.<br>
Foreground threads don't require this treatment, but you must take care to avoid<br>bugs that could cause the thread not to end. A common cause for applications failing<br>to exit properly is the presence of active foreground threads.<br>
<b>Thread Priority<br></b>A thread's Priority property determines how much execution time it gets relative<br>to other active threads in the operating system, on the following scale:<br>
enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest }<br>
This becomes relevant only when multiple threads are simultaneously active.<br>
Think carefully before elevating a thread's priority--it can lead<br>to problems such as resource starvation for other threads.<br>
Elevating  a  thread's  priority  doesn't  make  it  capable  of  performing  real-time<br>work, because it's still throttled by the application's process priority. To perform<br>
<b>Getting Started | 797</b><br>
<hr>
<A name=818></a>real-time work, you must also elevate the process priority using the Process class in<br>System.Diagnostics (we didn't tell you how to do this):<br>
using (Process p = Process.GetCurrentProcess())<br>  p.PriorityClass = ProcessPriorityClass.High;<br>
ProcessPriorityClass.High  is  actually  one  notch  short  of  the  highest  priority:<br>Realtime. Setting a process priority to Realtime instructs the OS that you never want<br>the process to yield CPU time to another process. If your program enters an acci-<br>dental  infinite  loop,  you  might  find  even  the  operating  system  locked  out,  with<br>nothing short of the power button left to rescue you! For this reason, High is usually<br>the best choice for real-time applications.<br>
If your real-time application has a user interface, elevating the<br>process priority gives screen updates excessive CPU time, slow-<br>ing down the entire computer (particularly if the UI is complex).<br>Lowering the main thread's priority in conjunction with raising<br>the process's priority ensures that the real-time thread doesn't<br>get preempted by screen redraws, but doesn't solve the problem<br>of starving other applications of CPU time, because the operat-<br>ing system will still allocate disproportionate resources to the<br>process as a whole. An ideal solution is to have the real-time<br>worker and user interface run as separate applications with dif-<br>ferent  process  priorities,  communicating  via  Remoting  or<br>memory-mapped files. Memory-mapped files are ideally suited<br>to this task; we explain how they work in Chapters 14 and 25.<br>
Even with an elevated process priority, there's a limit to the suitability of the man-<br>aged environment in handling hard real-time requirements. In Chapter 12, we de-<br>scribed the issues of garbage collection and the workarounds. Further, the operating<br>system may present additional challenges--even for unmanaged applications--that<br>are best solved with dedicated hardware or a specialized real-time platform.<br>
<b>Exception Handling<br></b>Any try/catch/finally blocks in scope when a thread is created are of no relevance<br>to the thread when it starts executing. Consider the following program:<br>
public static void Main()<br>{<br>  try<br>  {<br>    new Thread (Go).Start();<br>  }<br>  catch (Exception ex)<br>  {<br>    // We'll never get here!<br>    Console.WriteLine (&quot;Exception!&quot;);<br>  }<br>}<br>
static void Go() { throw null; }   // Throws a NullReferenceException<br>
<b>798 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=819></a>The try/catch statement in this example is ineffective, and the newly created thread<br>will  be  encumbered  with  an  unhandled  NullReferenceException.  This  behavior<br>makes sense when you consider that each thread has an independent execution path.<br>
The remedy is to move the exception handler into the Go method:<br>
public static void Main()<br>{<br>   new Thread (Go).Start();<br>}<br>
static void Go()<br>
{<br>  try<br>  {<br>
<b>Threading</b><br>
    ...<br>
    throw null;    // The NullReferenceException will get caught below<br>
    ...<br>  }<br>  catch (Exception ex)<br>
  {<br>
    Typically log the exception, and/or signal another thread<br>
    that we've come unstuck<br>    ...<br>
  }<br>
}<br>
You  need  an  exception  handler  on  all  thread  entry  methods  in  production<br>applications--just as you do (usually at a higher level, in the execution stack) on<br>your main thread. An unhandled exception causes the whole application to shut<br>down. With an ugly dialog!<br>
In writing such exception handling blocks, rarely would you<br><i>ignore</i> the error: typically, you'd log the details of the exception,<br>and then perhaps display a dialog allowing the user to auto-<br>matically  submit  those  details  to  your  web  server.  You  then<br>might shut down the application--because it's possible that the<br>error corrupted the program's state. However, the cost of doing<br>so is that the user will lose his recent work--open documents,<br>for instance.<br>
The "global" exception handling events for WPF and Windows<br>Forms  applications  (Application.DispatcherUnhandledExcep<br>tion and Application.ThreadException) fire only for exceptions<br>thrown on the main UI thread. You still must handle exceptions<br>on worker threads manually.<br>
AppDomain.CurrentDomain.UnhandledException fires on any un-<br>handled  exception,  but  provides  no  means  of  preventing  the<br>application from shutting down afterward.<br>
<b>Getting Started | 799</b><br>
<hr>
<A name=820></a>There are, however, some cases where you don't need to handle exceptions on a<br>worker thread, because the .NET Framework does it for you. These are covered in<br>upcoming sections, and are:<br>
· Asynchronous delegates<br>· BackgroundWorker<br>· The Task Parallel Library (conditions apply)<br>
<b>Thread Pooling<br></b>Whenever you start a thread, a few hundred microseconds are spent organizing such<br>things as a fresh private local variable stack. Each thread also consumes (by default)<br>around 1 MB of memory. The <i>thread pool</i> cuts these overheads by sharing and re-<br>cycling threads, allowing multithreading to be applied at a very granular level with-<br>out a performance penalty. This is useful when leveraging multicore processors to<br>execute computationally intensive code in parallel in "divide-and-conquer" style.<br>
The thread pool also keeps a lid on the total number of worker threads it will run<br>simultaneously. Too many active threads throttle the operating system with admin-<br>istrative burden and render CPU caches ineffective. Once a limit is reached, jobs<br>queue up and start only when another finishes. This makes arbitrarily concurrent<br>applications possible, such as a web server. (The <i>asynchronous method</i> pattern takes<br>this further by making highly efficient use of the pooled threads; see Chapter 23.)<br>
There are a number of ways to enter the thread pool:<br>
· Via the Task Parallel Library or PLINQ (from Framework 4.0)<br>· By calling ThreadPool.QueueUserWorkItem<br>· Via asynchronous delegates<br>· Via BackgroundWorker<br>
The following constructs use the thread pool <i>indirectly</i>:<br>
· WCF, Remoting, ASP.NET, and ASMX Web Services ap-<br>
plication servers<br>
· System.Timers.Timer and System.Threading.Timer<br>· Framework methods that end in <i>Async</i>, such as those on<br>
WebClient  (the  <i>event-based  asynchronous  pattern</i>),  and<br>most  Begin<i>XXX</i> methods (the  <i>asynchronous programming<br>model</i> pattern)<br>
The <i>Task Parallel Library</i> (TPL) and PLINQ are sufficiently powerful and high-level<br>that you'll want to use them to assist in multithreading even when thread pooling<br>is unimportant. We discuss this fully in the following chapter. Right now, we'll look<br>briefly at how you can use the Task class as a simple means of running a delegate on<br>a pooled thread.<br>
<b>800 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=821></a>There are a few things to be wary of when using pooled threads:<br>
· You cannot set the Name of a pooled thread, making de-<br>
bugging more difficult (although you can attach a descrip-<br>tion when debugging in Visual Studio's Threads window).<br>
· Pooled threads are always <i>background threads</i> (this is usu-<br>
ally not a problem).<br>
· Blocking a pooled thread may trigger additional latency in<br>
the  early  life  of  an  application  unless  you  call  Thread<br>Pool.SetMinThreads  (see  the  section  "Optimizing  the<br>Thread Pool" on page 805).<br>
You are free to change the priority of a pooled thread--it will<br>
<b>Threading</b><br>
be restored to normal when released back to the pool.<br>
You can query if you're currently executing on a pooled thread via the property<br>Thread.CurrentThread.IsThreadPoolThread.<br>
<b>Entering the Thread Pool via TPL<br></b>You can enter the thread pool easily using the Task classes in the Task Parallel Li-<br>brary. These were introduced in Framework 4.0: if you're familiar with the older<br>constructs, consider the nongeneric Task class a replacement for ThreadPool.QueueU<br>serWorkItem, and the generic Task&lt;TResult&gt; a replacement for asynchronous dele-<br>gates. The newer constructs are faster, more convenient, and more flexible than the<br>old.<br>
To use the nongeneric Task class, call Task.Factory.StartNew, passing in a delegate<br>of the target method:<br>
static void Main()    // The Task class is in <b>System.Threading.Tasks<br></b>{<br>  Task.Factory.StartNew (Go);<br>}<br>
static void Go()<br>{<br>  Console.WriteLine (&quot;Hello from the thread pool!&quot;);<br>}<br>
Task.Factory.StartNew returns a Task object, which you can then use to monitor the<br>task--for instance, you can wait for it to complete by calling its Wait method.<br>
Any unhandled exceptions are conveniently rethrown onto the<br>host thread when you call a task's Wait method. (If you don't<br>call Wait and abandon the task, an unhandled exception will<br>shut down the process, as with an ordinary thread.)<br>
<b>Thread Pooling | 801</b><br>
<hr>
<A name=822></a>The generic Task&lt;TResult&gt; class is a subclass of the nongeneric Task. It lets you get<br>a return value back from the task after it finishes executing. In the following example,<br>we download a web page using Task&lt;TResult&gt;:<br>
static void Main()<br>
{<br>  // Start the task executing:<br>
  Task&lt;string&gt; task = Task.Factory.StartNew<b>&lt;string&gt;</b><br>
    ( () =&gt; DownloadString (&quot;http://www.linqpad.net&quot;) );<br>
  // We can do other work here and it will execute in parallel:<br>  RunSomeOtherMethod();<br>
  // When we need the task's return value, we query its Result property:<br>
  // If it's still executing, the current thread will now block (wait)<br>
  // until the task finishes:<br>  string result = <b>task.Result</b>;<br>
}<br>
static string DownloadString (string uri)<br>{<br>  using (var wc = new System.Net.WebClient())<br>
    return wc.DownloadString (uri);<br>
}<br>
(The &lt;string&gt; type argument in boldface is for clarity: it would be <i>inferred</i> if we<br>omitted it.)<br>
Any unhandled exceptions are automatically rethrown when you query the task's<br>Result property, wrapped in an AggregateException. However, if you fail to query<br>its  Result property (and don't call Wait), any unhandled exception will take the<br>process down.<br>
The Task Parallel Library has many more features, and is particularly well suited to<br>leveraging multicore processors. We'll resume our discussion of TPL in the following<br>chapter.<br>
<b>Entering the Thread Pool Without TPL<br></b>You  can't  use  the  Task  Parallel  Library  if  you're  targeting  an  earlier  version  of<br>the .NET Framework (prior to 4.0). Instead, you must use one of the older constructs<br>for entering the thread pool: ThreadPool.QueueUserWorkItem and asynchronous del-<br>egates. The difference between the two is that asynchronous delegates let you return<br>data from the thread. Asynchronous delegates also marshal any exception back to<br>the caller.<br>
<b>QueueUserWorkItem<br></b>To use QueueUserWorkItem, simply call this method with a delegate that you want to<br>run on a pooled thread:<br>
<b>802 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=823></a>static void Main()<br>
{<br>  ThreadPool.QueueUserWorkItem (Go);<br>  ThreadPool.QueueUserWorkItem (Go, 123);<br>
  Console.ReadLine();<br>
}<br>
static void Go (object data)   // <i>data</i> will be <b>null</b> with the first call.<br>
{<br>  Console.WriteLine (&quot;Hello from the thread pool! &quot; + data);<br>}<br>
// Output:<br>Hello from the thread pool!<br>
Hello from the thread pool! 123<br>
<b>Threading</b><br>
Our  target  method,  Go,  must  accept  a  single  object  argument  (to  satisfy  the<br>WaitCallback  delegate).  This  provides  a  convenient  way  of  passing  data  to  the<br>method, just like with ParameterizedThreadStart. Unlike with Task, QueueUserWor<br>kItem doesn't return an object to help you subsequently manage execution. Also,<br>you must explicitly deal with exceptions in the target code--unhandled exceptions<br>will take down the program.<br>
<b>Asynchronous delegates<br></b>ThreadPool.QueueUserWorkItem doesn't provide an easy mechanism for getting return<br>values back from a thread after it has finished executing. Asynchronous delegate<br>invocations (asynchronous delegates for short) solve this, allowing any number of<br>typed arguments to be passed in both directions. Furthermore, unhandled excep-<br>tions on asynchronous delegates are conveniently rethrown on the original thread<br>(or more accurately, the thread that calls EndInvoke), and so they don't need explicit<br>handling.<br>
Don't  confuse  asynchronous  delegates  with  asynchronous<br>methods  (methods  starting  with  <i>Begin</i>  or  <i>End</i>,  such  as<br>File.BeginRead/File.EndRead). Asynchronous methods follow<br>a  similar  protocol  outwardly,  but  they  exist  to  solve  a  much<br>more difficult problem, which we describe in Chapter 23.<br>
Here's how you start a worker task via an asynchronous delegate:<br>
1. Instantiate a delegate targeting the method you want to run in parallel (typically<br>
one of the predefined Func delegates).<br>
2. Call BeginInvoke on the delegate, saving its IAsyncResult return value.<br>
BeginInvoke returns immediately to the caller. You can then perform other ac-<br>tivities while the pooled thread is working.<br>
3. When you need the results, call EndInvoke on the delegate, passing in the saved<br>
IAsyncResult object.<br>
<b>Thread Pooling | 803</b><br>
<hr>
<A name=824></a>In the following example, we use an asynchronous delegate invocation to execute<br>concurrently with the main thread, a simple method that returns a string's length:<br>
static void Main()<br>{<br>  Func&lt;string, int&gt; method = Work;<br>
  IAsyncResult cookie = method.BeginInvoke (&quot;test&quot;, null, null);<br>  //<br>  // ... here's where we can do other work in parallel...<br>
  //<br>
  int result = method.EndInvoke (cookie);<br>  Console.WriteLine (&quot;String length is: &quot; + result);<br>}<br>
static int Work (string s) { return s.Length; }<br>
EndInvoke does three things. First, it waits for the asynchronous delegate to finish<br>executing, if it hasn't already. Second, it receives the return value (as well as any<br>ref or out parameters). Third, it throws any unhandled worker exception back to<br>the calling thread.<br>
If the method you're calling with an asynchronous delegate has<br>no return value, you are still (technically) obliged to call EndIn<br>voke. In practice, this is open to debate; there are no EndInvoke<br>police to administer punishment to noncompliers! If you choose<br>not to call EndInvoke, however, you'll need to consider excep-<br>tion handling on the worker method to avoid silent failures.<br>
You can also specify a callback delegate when calling BeginInvoke--a method ac-<br>cepting an IAsyncResult object that's automatically called upon completion. This<br>allows the instigating thread to "forget" about the asynchronous delegate, but it<br>requires a bit of extra work at the callback end:<br>
static void Main()<br>
{<br>  Func&lt;string, int&gt; method = Work;<br>  method.BeginInvoke (&quot;test&quot;, Done, method);<br>  // ...<br>  //<br>}<br>
static int Work (string s) { return s.Length; }<br>
static void Done (IAsyncResult cookie)<br>{<br>  var target = (Func&lt;string, int&gt;) cookie.AsyncState;<br>  int result = target.EndInvoke (cookie);<br>  Console.WriteLine (&quot;String length is: &quot; + result);<br>}<br>
The  final  argument  to  BeginInvoke  is  a  user  state  object  that  populates  the<br>AsyncState property of IAsyncResult. It can contain anything you like; in this case,<br>
<b>804 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=825></a>we're using it to pass the method delegate to the completion callback, so we can call<br>EndInvoke on it.<br>
<b>Optimizing the Thread Pool<br></b>The thread pool starts out with one thread in its pool. As tasks are assigned, the pool<br>manager "injects" new threads to cope with the extra concurrent workload, up to a<br>maximum limit. After a sufficient period of inactivity, the pool manager may "retire"<br>threads if it suspects that doing so will lead to better throughput.<br>
You can set the upper limit of threads that the pool will create by calling Thread<br>Pool.SetMaxThreads; the defaults are:<br>
· 1023 in Framework 4.0 in a 32-bit environment<br>
<b>Threading</b><br>
· 32768 in Framework 4.0 in a 64-bit environment<br>· 250 per core in Framework 3.5<br>· 25 per core in Framework 2.0<br>
(These figures may vary according to the hardware and operating system.) The rea-<br>son for there being that many is to ensure progress should some threads be blocked<br>(idling while awaiting some condition, such as a response from a remote computer).<br>
You can also set a lower limit by calling ThreadPool.SetMinThreads. The role of the<br>lower limit is subtler: it's an advanced optimization technique that instructs the pool<br>manager  not  to  <i>delay</i>  in  the  allocation  of  threads  until  reaching  the  lower  limit.<br>Raising the minimum thread count improves concurrency when there are blocked<br>threads (see sidebar).<br>
The default lower limit is one thread per processor core--the<br>minimum that allows full CPU utilization. On server environ-<br>ments,  though  (such  ASP.NET  under  IIS),  the  lower  limit  is<br>typically much higher--as much as 50 or more.<br>
<b>Synchronization<br></b>So far, we've described how to start a task on a thread, configure a thread, and pass<br>data in both directions. We've also described how local variables are private to a<br>thread and how references can be shared among threads, allowing them to com-<br>municate via common fields.<br>
The next step is <i>synchronization</i>: coordinating the actions of threads for a predictable<br>outcome. Synchronization is particularly important when threads access the same<br>data; it's surprisingly easy to run aground in this area.<br>
Synchronization constructs can be divided into four categories:<br>
<i>Simple blocking methods</i><br>
These wait for another thread to finish or for a period of time to elapse. Sleep,<br>Join, and Task.Wait are simple blocking methods.<br>
<b>Synchronization | 805</b><br>
<hr>
<A name=826></a><i>Locking constructs</i><br>
These limit the number of threads that can perform some activity or execute a<br>section of code at a time. <i>Exclusive</i> locking constructs are most common--these<br>allow just one thread in at a time, and allow competing threads to access com-<br>mon data without interfering with each other. The standard exclusive locking<br>constructs  are  lock  (Monitor.Enter/Monitor.Exit),  Mutex,  and  SpinLock.  The<br>nonexclusive locking constructs are Semaphore, SemaphoreSlim, and ReaderWri<br>terLockSlim (we cover reader/writer locks later in this chapter).<br>
<i>Signaling constructs</i><br>
These allow a thread to pause until receiving a notification from another, avoid-<br>ing the need for inefficient polling. There are two commonly used signaling<br>devices: event wait handles and Monitor's Wait/Pulse methods. Framework 4.0<br>introduces the CountdownEvent and Barrier classes.<br>
<i>Nonblocking synchronization constructs</i><br>
These protect access to a common field by calling upon processor primitives.<br>The CLR and C# provide the following nonblocking constructs: Thread.Memo<br>ryBarrier, Thread.VolatileRead, Thread.VolatileWrite, the volatile keyword,<br>and the Interlocked class.<br>
Blocking is essential to all but the last category. Let's briefly examine this concept.<br>
<b>How Does the Minimum Thread Count Work?</b><br>
Increasing the thread pool's minimum thread count to <i>x</i> doesn't actually force <i>x<br></i>threads to be created right away--threads are created only on demand. Rather, it<br>instructs the pool manager to create up to <i>x</i> threads the <i>instant</i> they are required.<br>The question, then, is why would the thread pool otherwise delay in creating a<br>thread when it's needed?<br>
The answer is to prevent a brief burst of short-lived activity from causing a full<br>allocation of threads, suddenly swelling an application's memory footprint. To<br>illustrate, consider a quad-core computer running a client application that en-<br>queues 40 tasks at once. If each task performs a 10 ms calculation, the whole thing<br>will be over in 100 ms, assuming the work is divided among the four cores. Ideally,<br>we'd want the 40 tasks to run on <i>exactly four threads</i>:<br>
· Any less and we'd not be making maximum use of all four cores.<br>· Any more and we'd be wasting memory and CPU time creating unnecessary<br>
threads.<br>
And this is exactly how the thread pool works. Matching the thread count to the<br>core count allows a program to retain a small memory footprint without hurting<br>performance--as long as the threads are efficiently used (which in this case they<br>are).<br>
But now suppose that instead of working for 10 ms, each task queries the Internet,<br>waiting half a second for a response while the local CPU is idle. The pool manager's<br>thread-economy strategy breaks down; it would now do better to create more<br>threads, so all the Internet queries could happen simultaneously.<br>
<b>806 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=827></a>Fortunately, the pool manager has a backup plan. If its queue remains stationary<br>for more than half a second, it responds by creating more threads--one every half-<br>second--up to the capacity of the thread pool.<br>
The half-second delay is a two-edged sword. On the one hand, it means that a<br>one-off burst of brief activity doesn't make a program suddenly consume an extra<br>unnecessary 40 MB (or more) of memory. On the other hand, it can needlessly<br>delay things when a pooled thread blocks, such as when querying a database or<br>calling WebClient.DownloadFile. For this reason, you can tell the pool manager not<br>to  delay  in  the  allocation  of  the  first  <i>x</i>  threads,  by  calling  SetMinThreads,  for<br>instance:<br>
ThreadPool.SetMinThreads (50, 50);<br>
(The second value indicates how many threads to assign to I/O completion ports,<br>
<b>Threading</b><br>
which are used by the APM, described in Chapter 23.)<br>
The default value is one thread per core.<br>
<b>Blocking<br></b>A thread is deemed <i>blocked</i> when its execution is paused for some reason, such as<br>when Sleeping or waiting for another to end via Join or EndInvoke. A blocked thread<br>immediately <i>yields</i> its processor time slice, and from then on consumes no processor<br>time until its blocking condition is satisfied. You can test for a thread being blocked<br>via its ThreadState property:<br>
bool blocked = (someThread.ThreadState &amp; ThreadState.WaitSleepJoin) != 0;<br>
ThreadState is a flags enum, combining three "layers" of data in<br>a  bitwise  fashion.  Most  values,  however,  are  redundant,  un-<br>used, or deprecated. The following code strips a ThreadState to<br>one  of  four  useful  values:  Unstarted, Running, WaitSleepJoin,<br>and Stopped:<br>
public static ThreadState SimpleThreadState (ThreadState ts)<br>{<br>  return ts &amp; (ThreadState.Unstarted |<br>               ThreadState.WaitSleepJoin |<br>               ThreadState.Stopped);<br>}<br>
The ThreadState property is useful for diagnostic purposes, but<br>unsuitable  for  synchronization,  because  a  thread's  state  may<br>change  in  between  testing  ThreadState  and  acting  on  that<br>information.<br>
When  a  thread  blocks  or  unblocks,  the  operating  system  performs  a  <i>context<br>switch</i>. This incurs an overhead of a few microseconds.<br>
<b>Synchronization | 807</b><br>
<hr>
<A name=828></a><b>Blocking Versus Spinning<br></b>Sometimes a thread must pause until a certain condition is met. Signaling and lock-<br>ing constructs achieve this efficiently by <i>blocking</i> until a condition is satisfied. How-<br>ever, there is a simpler alternative: a thread can await a condition by <i>spinning</i> in a<br>polling loop. For example:<br>
while (!proceed);<br>
or:<br>
while (DateTime.Now &lt; nextStartTime);<br>
In general, this is very wasteful on processor time: as far as the CLR and operating<br>system are concerned, the thread is performing an important calculation, and so gets<br>allocated resources accordingly!<br>
Sometimes a hybrid between blocking and spinning is used:<br>
while (!proceed) Thread.Sleep (10);<br>
Although inelegant, this is (in general) far more efficient than outright spinning.<br>Problems can arise, though, due to concurrency issues on the proceed flag. Proper<br>use of locking and signaling avoids this.<br>
Spinning <i>very briefly</i> can be effective when you expect a condi-<br>tion to be satisfied soon (perhaps within a few microseconds)<br>because it avoids the overhead and latency of a context switch.<br>The .NET Framework provides special methods and classes to<br>assist--these are covered in the following chapter (see "Spin-<br>Lock and SpinWait" on page 920).<br>
<b>Locking<br></b>Exclusive locking is used to ensure that only one thread can enter particular sections<br>of code at a time. The two main exclusive locking constructs are lock and Mutex. Of<br>the two, the lock construct is faster and more convenient. Mutex, though, has a niche<br>in that its lock can span applications in different processes on the computer.<br>
In this section, we'll start with the lock construct and then move on to Mutex and<br>semaphores (for nonexclusive locking). Later in the chapter we'll cover reader/writer<br>locks.<br>
From Framework 4.0, there is also the SpinLock struct for high-<br>concurrency scenarios, which we cover in the following chapter.<br>
Let's start with the following class:<br>
<b>808 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=829></a>class ThreadUnsafe<br>
{<br>  static int _val1 = 1, _val2 = 1;<br>
  static void Go()<br>
  {<br>    if (_val2 != 0) Console.WriteLine (_val1 / _val2);<br>    _val2 = 0;<br>
  }<br>
}<br>
This class is not thread-safe: if Go was called by two threads simultaneously, it would<br>be possible to get a division-by-zero error, because _val2 could be set to zero in one<br>thread  right  as  the  other  thread  was  in  between  executing  the  if  statement  and<br>Console.WriteLine.<br>
<b>Threading</b><br>
Here's how lock can fix the problem:<br>
class ThreadSafe<br>
{<br>  static readonly object _locker = new object();<br>
  static int _val1, _val2;<br>
  static void Go()<br>
  {<br>
    <b>lock (_locker)<br></b>    {<br>      if (_val2 != 0) Console.WriteLine (_val1 / _val2);<br>
      _val2 = 0;<br>    }<br>
  }<br>}<br>
Only one thread can lock the synchronizing object (in this case, _locker) at a time,<br>and any contending threads are blocked until the lock is released. If more than one<br>thread contends the lock, they are queued on a "ready queue" and granted the lock<br>on a first-come, first-served basis. Exclusive locks are sometimes said to enforce<br><i>serialized</i> access to whatever's protected by the lock, because one thread's access<br>cannot overlap with that of another. In this case, we're protecting the logic inside<br>the Go method, as well as the fields _val1 and _val2.<br>A thread blocked while awaiting a contended lock has a ThreadState of WaitSleep<br>Join. In "Interrupt and Abort" on page 855, we describe how a blocked thread can<br>be forcibly released via another thread. This is a fairly heavy-duty technique that<br>might be used in ending a thread.<br>
 Nuances  in  the  behavior  of  Windows  and  the  CLR  mean  that  the  fairness  of  the  queue  can<br>
sometimes be violated.<br>
<b>Locking | 809</b><br>
<hr>
<A name=830></a><b>Monitor.Enter and Monitor.Exit<br></b>C#'s  lock  statement  is  in  fact  a  syntactic  shortcut  for  a  call  to  the  methods<br>Monitor.Enter and Monitor.Exit, with a try/finally block. Here's (a simplified ver-<br>sion of) what's actually happening within the Go method of the preceding example:<br>
<b>Monitor.Enter (_locker);<br></b>try<br>
{<br>  if (_val2 != 0) Console.WriteLine (_val1 / _val2);<br>
  _val2 = 0;<br>
}<br>finally { <b>Monitor.Exit (_locker);</b> }<br>
Calling Monitor.Exit without first calling Monitor.Enter on the same object throws<br>an exception.<br>
<b>The lockTaken overloads<br></b>The code that we just demonstrated is exactly what the C# 1.0, 2.0, and 3.0 com-<br>pilers produce in translating a lock statement.<br>There's a subtle vulnerability in this code, however. Consider the (unlikely) event<br>of an exception being thrown within the implementation of Monitor.Enter, or be-<br>tween the call to Monitor.Enter and the try block (due, perhaps, to Abort being called<br>on that thread--or an OutOfMemoryException being thrown). In such a scenario, the<br>lock may or may not be taken. If the lock <i>is</i> taken, it won't be released--because<br>we'll never enter the try/finally block. This will result in a leaked lock.<br>To  avoid  this  danger,  CLR  4.0's  designers  added  the  following  overload  to<br>Monitor.Enter:<br>
public static void Enter (object obj, <b>ref bool lockTaken</b>);<br>
lockTaken  is  false  after  this  method  if  (and  only  if)  the  Enter  method  throws  an<br>exception and the lock was not taken.<br>
Here's the correct pattern of use (which is exactly how C# 4.0 translates a lock<br>statement):<br>
<b>bool lockTaken = false;<br></b>try<br>{<br>  Monitor.Enter (_locker, <b>ref lockTaken</b>);<br>  // Do your stuff...<br>}<br>finally { <b>if (lockTaken)</b> Monitor.Exit (_locker); }<br>
<b>TryEnter<br></b>Monitor also provides a TryEnter method that allows a timeout to be specified, either<br>in milliseconds or as a TimeSpan. The method then returns true if a lock was obtained,<br>or false if no lock was obtained because the method timed out. TryEnter can also<br>be called with no argument, which "tests" the lock, timing out immediately if the<br>lock can't be obtained right away.<br>
<b>810 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=831></a>As  with  the  Enter  method,  it's  overloaded  in  CLR  4.0  to  accept  a  lockTaken<br>argument.<br>
<b>Choosing the Synchronization Object<br></b>Any object visible to each of the partaking threads can be used as a synchronizing<br>object, subject to one hard rule: it must be a reference type. The synchronizing object<br>is typically private (because this helps to encapsulate the locking logic) and is typi-<br>cally an instance or static field. The synchronizing object can double as the object<br>it's protecting, as the _list field does in the following example:<br>
class ThreadSafe<br>
{<br>  List &lt;string&gt; _list = new List &lt;string&gt;();<br>
<b>Threading</b><br>
  void Test()<br>
  {<br>    lock (_list)<br>
    {<br>
      _list.Add (&quot;Item 1&quot;);<br>
      ...<br>
A field dedicated for the purpose of locking (such as _locker, in the example prior)<br>allows precise control over the scope and granularity of the lock. The containing<br>object (this)--or even its type--can also be used as a synchronization object:<br>
lock (this) { ... }<br>
or:<br>
lock (typeof (Widget)) { ... }    // For protecting access to statics<br>
The disadvantage of locking in this way is that you're not encapsulating the locking<br>logic, so it becomes harder to prevent deadlocking and excessive blocking. A lock<br>on a type may also seep through application domain boundaries (within the same<br>process--see Chapter 24).<br>
You can also lock on local variables captured by lambda expressions or anonymous<br>methods.<br>
Locking doesn't restrict access to the synchronizing object itself<br>in any way. In other words, x.ToString() will not block because<br>another  thread  has  called  lock(x);  both  threads  must  call<br>lock(x) in order for blocking to occur.<br>
<b>When to Lock<br></b>As a basic rule, you need to lock around accessing <i>any writable shared field</i>. Even in<br>the simplest case--an assignment operation on a single field--you must consider<br>synchronization. In the following class, neither the Increment nor the Assign method<br>is thread-safe:<br>
<b>Locking | 811</b><br>
<hr>
<A name=832></a>class ThreadUnsafe<br>
{<br>  static int _x;<br>  static void Increment() { _x++; }<br>
  static void Assign()    { _x = 123; }<br>
}<br>
Here are thread-safe versions of Increment and Assign:<br>
class ThreadSafe<br>{<br>  static readonly object _locker = new object();<br>
  static int _x;<br>
  static void Increment() { lock (_locker) _x++; }<br>  static void Assign()    { lock (_locker) _x = 123; }<br>
}<br>
In "Nonblocking Synchronization" on page 825, we explain how this need arises,<br>and how the memory barriers and the Interlocked class can provide alternatives to<br>locking in these situations.<br>
<b>Locking and Atomicity<br></b>If a group of variables are always read and written within the same lock, you can say<br>the variables are read and written <i>atomically</i>. Let's suppose fields x and y are always<br>read and assigned within a lock on object locker:<br>
lock (locker) { if (x != 0) y /= x; }<br>
One can say  x and y are accessed atomically, because the code block cannot be<br>divided or preempted by the actions of another thread in such a way that it will<br>change x or y and <i>invalidate its outcome</i>. You'll never get a division-by-zero error,<br>providing x and y are always accessed within this same exclusive lock.<br>
The atomicity provided by a lock is violated if an exception is<br>thrown  within  a  lock  block.  For  example,  consider  the<br>following:<br>
decimal _savingsBalance, _checkBalance;<br>
void Transfer (decimal amount)<br>{<br>  lock (_locker)<br>  {<br>    _savingsBalance += amount;<br>    _checkBalance -= amount + GetBankFee();<br>  }<br>}<br>
If an exception was thrown by GetBankFee(), the bank would<br>lose money. In this case, we could avoid the problem by calling<br>GetBankFee earlier. A solution for more complex cases is to im-<br>plement "rollback" logic within a catch or finally block.<br>
<b>812 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=833></a><i>Instruction</i> atomicity is a different, although analogous concept: an instruction is<br>atomic if it executes indivisibly on the underlying processor (see "Nonblocking Syn-<br>chronization" on page 825).<br>
<b>Nested Locking<br></b>A thread can repeatedly lock the same object in a nested (<i>reentrant</i>) fashion:<br>
lock (locker)<br>
  lock (locker)<br>
    lock (locker)<br>    {<br>
       // Do something...<br>
    }<br>
<b>Threading</b><br>
or:<br>
Monitor.Enter (locker); Monitor.Enter (locker);  Monitor.Enter (locker);<br>
// Do something...<br>Monitor.Exit (locker);  Monitor.Exit (locker);   Monitor.Exit (locker);<br>
In these scenarios, the object is unlocked only when the outermost lock statement<br>has exited--or a matching number of Monitor.Exit statements have executed.<br>Nested locking is useful when one method calls another within a lock:<br>
static readonly object _locker = new object();<br>
static void Main()<br>{<br>  <b>lock (_locker)<br></b>  {<br>     AnotherMethod();<br>     // We still have the lock - because locks are reentrant.<br>  }<br>}<br>
static void AnotherMethod()<br>{<br>  <b>lock (_locker)</b> { Console.WriteLine (&quot;Another method&quot;); }<br>}<br>
A thread can block on only the first (outermost) lock.<br>
<b>Deadlocks<br></b>A deadlock happens when two threads each wait for a resource held by the other,<br>so neither can proceed. The easiest way to illustrate this is with two locks:<br>
object locker1 = new object();<br>object locker2 = new object();<br> <br>
new Thread (() =&gt; {<br>                    lock (locker1)<br>
                    {<br>                      Thread.Sleep (1000);<br>
<b>Locking | 813</b><br>
<hr>
<A name=834></a>                      <b>lock (locker2);      // Deadlock</b><br>
                    }<br>                  }).Start();<br>lock (locker2)<br>
{<br>  Thread.Sleep (1000);<br>  <b>lock (locker1);                          // Deadlock<br></b>}<br>
More elaborate deadlocking chains can be created with three or more threads.<br>
The CLR, in a standard hosting environment, is not like SQL<br>Server and does not automatically detect and resolve deadlocks<br>by terminating one of the offenders. A threading deadlock cau-<br>ses  participating  threads  to  block  indefinitely,  unless  you've<br>specified a locking timeout. (Under the SQL CLR integration<br>host,  however,  deadlocks  <i>are</i>  automatically  detected  and  a<br>[catchable] exception is thrown on one of the threads.)<br>
Deadlocking  is  one  of  the  hardest  problems  in  multithreading--especially  when<br>there are many interrelated objects. Fundamentally, the difficulty is that you can't<br>be sure what locks your <i>caller</i> has taken out.<br>
So, you might innocently lock private field a within your class x, unaware that your<br>caller (or caller's caller) has already locked field b within class y. Meanwhile, another<br>thread is doing the reverse--creating a deadlock. Ironically, the problem is exacer-<br>bated by (good) object-oriented design patterns, because such patterns create call<br>chains that are not determined until runtime.<br>
The popular advice, "lock objects in a consistent order to avoid deadlocks," although<br>helpful in our initial example, is hard to apply to the scenario just described. A better<br>strategy is to be wary of locking around calling methods in objects that may have<br>references back to your own object. Also, consider whether you really need to lock<br>around  calling  methods  in  other  classes  (often  you  do--as  we'll  see  in  "Thread<br>Safety" on page 543--but sometimes there are other options). Relying more on de-<br>clarative and data parallelism (Chapter 22), immutable types, and nonblocking syn-<br>chronization constructs (later in this chapter) can lessen the need for locking.<br>
Here is an alternative way to perceive the problem: when you<br>call out to other code while holding a lock, the encapsulation<br>of that lock subtly <i>leaks</i>. This is not a fault in the CLR or .NET<br>Framework, but a fundamental limitation of locking in general.<br>The problems of locking are being addressed in various research<br>projects, including <i>Software Transactional Memory</i>.<br>
Another deadlocking scenario arises when calling Dispatcher.Invoke (in a WPF ap-<br>plication) or Control.Invoke (in a Windows Forms application) while in possession<br>of a lock. If the UI happens to be running another method that's waiting on the same<br>lock, a deadlock will happen right there. This can often be fixed simply by calling<br>
<b>814 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=835></a>BeginInvoke instead of Invoke. Alternatively, you can release your lock before calling<br>Invoke,  although  this  won't  work  if  your  <i>caller</i>  took  out  the  lock.  We  explain <br>Invoke and BeginInvoke in the section "Rich Client Applications and Thread Affin-<br>ity" on page 822.<br>
<b>Performance<br></b>Locking is fast: you can expect to acquire and release a lock in less than 100 nano-<br>seconds on a 2010-era computer if the lock is uncontended. If it is contended, the<br>consequential context switch moves the overhead closer to the microsecond region,<br>although it may be longer before the thread is actually rescheduled. You can avoid<br>the  cost  of  a  context  switch  with  the  SpinLock  class  described  in  the  following<br>chapter--if you're locking very briefly.<br>
<b>Threading</b><br>
If used excessively, locking can degrade concurrency by causing other threads to<br>wait unnecessarily. This can also increase the chance of deadlock.<br>
<b>Mutex<br></b>A Mutex is like a C# lock, but it can work across multiple processes. In other words,<br>Mutex can be <i>computer-wide</i> as well as <i>application-wide</i>.<br>
Acquiring and releasing an uncontended Mutex takes a few mi-<br>croseconds--about 50 times slower than a lock.<br>
With a Mutex class, you call the WaitOne method to lock and ReleaseMutex to unlock.<br>Closing or disposing a Mutex automatically releases it. Just as with the lock statement,<br>a Mutex can be released only from the same thread that obtained it.<br>A common use for a cross-process Mutex is to ensure that only one instance of a<br>program can run at a time. Here's how it's done:<br>
class OneAtATimePlease<br>{<br>  static void Main()<br>  {<br>    // Naming a Mutex makes it available computer-wide. Use a name that's<br>    // unique to your company and application (e.g., include your URL).<br>
    using (var mutex = new Mutex (false, &quot;oreilly.com OneAtATimeDemo&quot;))<br>    {<br>
      // Wait a few seconds if contended, in case another instance<br>      // of the program is still in the process of shutting down.<br>
      if (!mutex.WaitOne (TimeSpan.FromSeconds (3), false))<br>      {<br>        Console.WriteLine (&quot;Another instance of the app is running. Bye!&quot;);<br>        return;<br>      }<br>      RunProgram();<br>
<b>Locking | 815</b><br>
<hr>
<A name=836></a>    }<br>
  }<br>
  static void RunProgram()<br>
  {<br>
    Console.WriteLine (&quot;Running. Press Enter to exit&quot;);<br>    Console.ReadLine();<br>  }<br>
}<br>
If running under Terminal Services, a computer-wide Mutex is<br>ordinarily  visible  only  to  applications  in  the  same  terminal<br>server session. To make it visible to all terminal server sessions,<br>prefix its name with <i>Global\</i>.<br>
<b>Semaphore<br></b>A semaphore is like a nightclub: it has a certain capacity, enforced by a bouncer.<br>Once it's full, no more people can enter, and a queue builds up outside. Then, for<br>each person that leaves, one person enters from the head of the queue. The con-<br>structor  requires  a  minimum  of  two  arguments:  the  number  of  places  currently<br>available in the nightclub and the club's total capacity.<br>
A semaphore with a capacity of one is similar to a Mutex or lock, except that the<br>semaphore has no "owner"--it's <i>thread-agnostic</i>. Any thread can call Release on a<br>Semaphore, whereas with Mutex and lock, only the thread that obtained the lock can<br>release it.<br>
There  are  two  functionally  similar  versions  of  this  class:<br>Semaphore  and  SemaphoreSlim.  The  latter  was  introduced  in<br>Framework 4.0 and has been optimized to meet the low-latency<br>demands of parallel programming. It's also useful in traditional<br>multithreading because it lets you specify a cancellation token<br>when  waiting  (see  "Safe  Cancellation"  on  page  857).  It  can-<br>not, however, be used for interprocess signaling.<br>
Semaphore  incurs  about  1  microsecond  in  calling  WaitOne  or<br>Release; SemaphoreSlim incurs about a quarter of that.<br>
Semaphores can be useful in limiting concurrency--preventing too many threads<br>from executing a particular piece of code at once. In the following example, five<br>threads try to enter a nightclub that allows only three threads in at once:<br>
class TheClub      // No door lists!<br>
{<br>  static SemaphoreSlim _sem = new SemaphoreSlim (3);    // Capacity of 3<br>
 <br> <br>
<b>816 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=837></a>  static void Main()<br>
  {<br>    for (int i = 1; i &lt;= 5; i++) new Thread (Enter).Start (i);<br>  }<br>
  static void Enter (object id)<br>  {<br>    Console.WriteLine (id + &quot; wants to enter&quot;);<br>
    <b>_sem.Wait();</b><br>
    Console.WriteLine (id + &quot; is in!&quot;);           // Only three threads<br>    Thread.Sleep (1000 * (int) id);               // can be here at<br>    Console.WriteLine (id + &quot; is leaving&quot;);       // a time.<br>
    <b>_sem.Release();</b><br>
  }<br>}<br>
<b>Threading</b><br>
1 wants to enter<br>1 is in!<br>
2 wants to enter<br>2 is in!<br>
3 wants to enter<br>3 is in!<br>
4 wants to enter<br>5 wants to enter<br>
1 is leaving<br>4 is in!<br>
2 is leaving<br>5 is in!<br>
If  the  Sleep  statement  was  instead  performing  intensive  disk  I/O,  the  Semaphore<br>would  improve  overall  performance  by  limiting  excessive  concurrent  hard-drive<br>activity.<br>
A Semaphore, if named, can span processes in the same way as a Mutex.<br>
<b>Thread Safety<br></b>A program or method is thread-safe if it has no indeterminacy in the face of any<br>multithreading scenario. Thread safety is achieved primarily with locking and by<br>reducing the possibilities for thread interaction.<br>
General-purpose  types  are  rarely  thread-safe  in  their  entirety,  for  the  following<br>reasons:<br>
· The development burden in full thread safety can be significant, particularly if<br>
a type has many fields (each field is a potential for interaction in an arbitrarily<br>multithreaded context).<br>
· Thread safety can entail a performance cost (payable, in part, whether or not<br>
the type is actually used by multiple threads).<br>
· A thread-safe type does not necessarily make the program using it thread-safe,<br>
and often the work involved in the latter makes the former redundant.<br>
<b>Thread Safety | 817</b><br>
<hr>
<A name=838></a>Thread safety is hence usually implemented just where it needs to be, in order to<br>handle a specific multithreading scenario.<br>
There are, however, a few ways to "cheat" and have large and complex classes run<br>safely in a multithreaded environment. One is to sacrifice granularity by wrapping<br>large sections of code--even access to an entire object--within a single exclusive<br>lock, enforcing serialized access at a high level. This tactic is, in fact, essential if you<br>want to use thread-unsafe third-party code (or most Framework types, for that mat-<br>ter) in a multithreaded context. The trick is simply to use the same exclusive lock to<br>protect access to all properties, methods, and fields on the thread-unsafe object. The<br>solution works well if the object's methods all execute quickly (otherwise, there will<br>be a lot of blocking).<br>
Primitive  types  aside,  few  .NET  Framework  types,  when  in-<br>stantiated, are thread-safe for anything more than concurrent<br>read-only access. The onus is on the developer to superimpose<br>thread safety, typically with exclusive locks. (The collections in<br>System.Collections.Concurrent  are  an  exception;  we'll  cover<br>them in the next chapter.)<br>
Another way to cheat is to minimize thread interaction by minimizing shared data.<br>This is an excellent approach and is used implicitly in "stateless" middle-tier appli-<br>cation and web page servers. Since multiple client requests can arrive simultane-<br>ously, the server methods they call must be thread-safe. A stateless design (popular<br>for  reasons  of  scalability)  intrinsically  limits  the  possibility  of  interaction,  since<br>classes do not persist data between requests. Thread interaction is then limited just<br>to the static fields one may choose to create, for such purposes as caching commonly<br>used data in memory and in providing infrastructure services such as authentication<br>and auditing.<br>
The final approach in implementing thread safety is to use an automatic locking<br>regime.  The  .NET  Framework  does  exactly  this,  if  you  subclass  ContextBoundOb<br>ject and apply the Synchronization attribute to the class. Whenever a method or<br>property on such an object is then called, an object-wide lock is automatically taken<br>for the whole execution of the method or property. Although this reduces the thread-<br>safety burden, it creates problems of its own: deadlocks that would not otherwise<br>occur, impoverished concurrency, and unintended reentrancy. For these reasons,<br>manual locking is generally a better option--at least until a less simplistic automatic<br>locking regime becomes available.<br>
<b>Thread Safety and .NET Framework Types<br></b>Locking can be used to convert thread-unsafe code into thread-safe code. A good<br>application of this is the .NET Framework: nearly all of its nonprimitive types are<br>not thread-safe (for anything more than read-only access) when instantiated, and<br>yet they can be used in multithreaded code if all access to any given object is pro-<br>tected via a lock. Here's an example, where two threads simultaneously add an item<br>to the same List collection, then enumerate the list:<br>
<b>818 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=839></a>class ThreadSafe<br>
{<br>  static List &lt;string&gt; _list = new List &lt;string&gt;();<br>
  static void Main()<br>
  {<br>    new Thread (AddItem).Start();<br>    new Thread (AddItem).Start();<br>
  }<br>
  static void AddItem()<br>  {<br>
    lock (_list) _list.Add (&quot;Item &quot; + _list.Count);<br>
    string[] items;<br>
<b>Threading</b><br>
    lock (_list) items = _list.ToArray();<br>    foreach (string s in items) Console.WriteLine (s);<br>
  }<br>
}<br>
In this case, we're locking on the _list object itself. If we had two interrelated lists,<br>we would have to choose a common object upon which to lock (we could nominate<br>one of the lists, or better: use an independent field).<br>
Enumerating .NET collections is also thread-unsafe in the sense that an exception<br>is thrown if the list is modified during enumeration. Rather than locking for the<br>duration of enumeration, in this example we first copy the items to an array. This<br>avoids holding the lock excessively if what we're doing during enumeration is po-<br>tentially  time-consuming.  (Another  solution  is  to  use  a  reader/writer  lock;  see<br>"Reader/Writer Locks" on page 865.)<br>
<b>Locking around thread-safe objects<br></b>Sometimes you also need to lock around accessing thread-safe objects. To illustrate,<br>imagine that the Framework's List class was, indeed, thread-safe, and we want to<br>add an item to a list:<br>
if (!_list.Contains (newItem)) _list.Add (newItem);<br>
Whether or not the list was thread-safe, this statement is certainly not! The whole<br>if statement would have to be wrapped in a lock in order to prevent preemption in<br>between testing for containership and adding the new item. This same lock would<br>then need to be used everywhere we modified that list. For instance, the following<br>statement would also need to be wrapped in the identical lock:<br>
_list.Clear();<br>
to ensure that it did not preempt the former statement. In other words, we would<br>have to lock exactly as with our thread-unsafe collection classes (making the List<br>class's hypothetical thread safety redundant).<br>
<b>Thread Safety | 819</b><br>
<hr>
<A name=840></a>Locking  around  accessing  a  collection  can  cause  excessive<br>blocking  in  highly  concurrent  environments.  To  this  end,<br>Framework 4.0 provides a thread-safe queue, stack, and dic-<br>tionary, which we describe in the following chapter.<br>
<b>Static methods<br></b>Wrapping access to an object around a custom lock works only if all concurrent<br>threads are aware of--and use--the lock. This may not be the case if the object is<br>widely scoped. The worst case is with static members in a public type. For instance,<br>imagine if the static property on the DateTime struct, DateTime.Now, was not thread-<br>safe, and that two concurrent calls could result in garbled output or an exception.<br>The only way to remedy this with external locking might be to lock the type itself--<br>lock(typeof(DateTime))--before calling DateTime.Now. This would work only if all<br>programmers agreed to do this (which is unlikely). Furthermore, locking a type cre-<br>ates problems of its own.<br>
For this reason, static members on the DateTime struct have been carefully program-<br>med to be thread-safe. This is a common pattern throughout the .NET Framework: <br><i>static members are thread-safe; instance members are not</i>. Following this pattern also<br>makes sense when writing types for public consumption, so as not to create impos-<br>sible thread-safety conundrums. In other words, by making static methods thread-<br>safe, you're programming so as not to <i>preclude</i> thread safety for consumers of that<br>type.<br>
Thread safety in static methods is something that you must ex-<br>plicitly code: it doesn't happen automatically by virtue of the<br>method being static!<br>
<b>Read-only thread safety<br></b>Making types thread-safe for concurrent read-only access (where possible) is ad-<br>vantageous because it means that consumers can avoid excessive locking. Many of<br>the .NET Framework types follow this principle: collections, for instance, are thread-<br>safe for concurrent readers.<br>
Following this principle yourself is simple: if you document a type as being thread-<br>safe for concurrent read-only access, don't write to fields within methods that a<br>consumer would expect to be read-only (or lock around doing so). For instance, in<br>implementing a ToArray() method in a collection, you might start by compacting<br>the collection's internal structure. However, this would make it thread-unsafe for<br>consumers that expected this to be read-only.<br>
Read-only thread safety is one of the reasons that enumerators are separate from<br>"enumerables": two threads can simultaneously enumerate over a collection because<br>each gets a separate enumerator object.<br>
<b>820 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=841></a>In  the  absence  of  documentation,  it  pays  to  be  cautious  in<br>assuming whether a method is read-only in nature. A good ex-<br>ample  is  the  Random  class:  when  you  call  Random.Next(),  its<br>internal  implementation  requires  that  it  update  private  seed<br>values. Therefore, you must either lock around using the Ran<br>dom class, or maintain a separate instance per thread.<br>
<b>Thread Safety in Application Servers<br></b>Application servers need to be multithreaded to handle simultaneous client requests.<br>WCF, ASP.NET, and Web Services applications are implicitly multithreaded; the<br>same holds true for Remoting server applications that use a network channel such<br>
<b>Threading</b><br>
as TCP or HTTP. This means that when writing code on the server side, you must<br>consider thread safety if there's any possibility of interaction among the threads<br>processing client requests. Fortunately, such a possibility is rare; a typical server class<br>either is stateless (no fields) or has an activation model that creates a separate object<br>instance for each client or each request. Interaction usually arises only through static<br>fields,  sometimes  used  for  caching  in  memory  parts  of  a  database  to  improve<br>performance.<br>
For example, suppose you have a RetrieveUser method that queries a database:<br>
// User is a custom class with fields for user data<br>
internal User RetrieveUser (int id) { ... }<br>
If this method was called frequently, you could improve performance by caching the<br>results in a static Dictionary. Here's a solution that takes thread safety into account:<br>
static class UserCache<br>{<br>  static Dictionary &lt;int, User&gt; _users = new Dictionary &lt;int, User&gt;();<br>
  internal static User GetUser (int id)<br>  {<br>    User u = null;<br>
    lock (_users)<br>      if (_users.TryGetValue (id, out u))<br>        return u;<br>
    u = RetrieveUser (id);           // Method to retrieve from database;<br>    lock (_users) _users [id] = u;<br>    return u;<br>  }<br>}<br>
We must, at a minimum, lock around reading and updating the dictionary to ensure<br>thread safety. In this example, we choose a practical compromise between simplicity<br>and performance in locking. Our design actually creates a very small potential for<br>inefficiency: if two threads simultaneously called this method with the same previ-<br>ously unretrieved id, the RetrieveUser method would be called twice--and the dic-<br>tionary would be updated unnecessarily. Locking once across the whole method<br>
<b>Thread Safety | 821</b><br>
<hr>
<A name=842></a>would prevent this, but would create a worse inefficiency: the entire cache would<br>be  locked  up  for  the  duration  of  calling  RetrieveUser,  during  which  time  other<br>threads would be blocked in retrieving <i>any</i> user.<br>
<b>Rich Client Applications and Thread Affinity<br></b>Both the Windows Presentation Foundation (WPF) and Windows Forms libraries<br>follow models based on thread affinity. Although each has a separate implementa-<br>tion, they are both very similar in how they function.<br>
The objects that make up a rich client are based primarily on DependencyObject in<br>the case of WPF, or Control in the case of Windows Forms. These objects have<br><i>thread affinity</i>, which means that only the thread that instantiates them can subse-<br>quently access their members. Violating this causes either unpredictable behavior,<br>or an exception to be thrown.<br>
On the positive side, this means you don't need to lock around accessing a UI object.<br>On the negative side, if you want to call a member on object X created on another<br>thread Y, you must marshal the request to thread Y. You can do this explicitly as<br>follows:<br>
· In WPF, call Invoke or BeginInvoke on the element's Dispatcher object.<br>· In Windows Forms, call Invoke or BeginInvoke on the control.<br>
Invoke and BeginInvoke both accept a delegate, which references the method on the<br>target control that you want to run. Invoke works <i>synchronously</i>: the caller blocks<br>until the marshal is complete. BeginInvoke works <i>asynchronously</i>: the caller returns<br>immediately and the marshaled request is queued up (using the same message queue<br>that handles keyboard, mouse, and timer events).<br>
Assuming we have a window that contains a text box called txtMessage, whose con-<br>tent we wish a worker thread to update, here's an example for WPF:<br>
public partial class MyWindow : Window<br>{<br>  public MyWindow()<br>  {<br>    InitializeComponent();<br>    new Thread (Work).Start();<br>  }<br>
  void Work()<br>  {<br>    Thread.Sleep (5000);           // Simulate time-consuming task<br>    UpdateMessage (&quot;The answer&quot;);<br>  }<br>
  void UpdateMessage (string message)<br>  {<br>    Action action = () =&gt; txtMessage.Text = message;<br>    <b>Dispatcher.Invoke (action);<br></b>  }<br>}<br>
<b>822 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=843></a>The  code  is  similar  for  Windows  Forms,  except  that  we  call  the  (Form's)  Invoke<br>method instead:<br>
  void UpdateMessage (string message)<br>  {<br>
    Action action = () =&gt; txtMessage.Text = message;<br>
    <b>this.Invoke (action);<br></b>  }<br>
The  Framework  provides  two  constructs  to  simplify  this<br>process:<br>
· BackgroundWorker  (see  the  section  "Background-<br>
Worker" on page 852)<br>
<b>Threading</b><br>
· Task continuations (see "Continuations" on page 904)<br>
<b>Worker threads versus UI threads<br></b>It's helpful to think of a rich client application as having two distinct categories of<br>threads: UI threads and worker threads. UI threads instantiate (and subsequently<br>"own") UI elements; worker threads do not. Worker threads typically execute long-<br>running tasks such as fetching data.<br>
Most  rich  client  applications  have  a  single  UI  thread  (which  is  also  the  main<br>application thread) and periodically spawn worker threads--either directly or using<br>BackgroundWorker. These workers then marshal back to the main UI thread in order<br>to update controls or report on progress.<br>
So, when would an application have multiple UI threads? The main scenario is when<br>you  have  an  application  with  multiple  top-level  windows,  often  called  a  <i>Single<br>Document Interface</i> (SDI) application, such as Microsoft Word. Each SDI window<br>typically shows itself as a separate "application" on the taskbar and is mostly isola-<br>ted, functionally, from other SDI windows. By giving each such window its own UI<br>thread, the application can be made more responsive.<br>
<b>Immutable Objects<br></b>An immutable object is one whose state cannot be altered--externally or internally.<br>The fields in an immutable object are typically declared read-only and are fully ini-<br>tialized during construction.<br>
Immutability is a hallmark of functional programming--where instead of <i>mutat-<br>ing</i> an object, you create a new object with different properties. LINQ follows this<br>paradigm. Immutability is also valuable in multithreading in that it avoids the prob-<br>lem of shared writable state--by eliminating (or minimizing) the writable.<br>
One pattern is to use immutable objects to encapsulate a group of related fields, to<br>minimize lock durations. To take a very simple example, suppose we had two fields<br>as follows:<br>
int _percentComplete;<br>string _statusMessage;<br>
<b>Thread Safety | 823</b><br>
<hr>
<A name=844></a>and we wanted to read/write them atomically. Rather than locking around these<br>fields, we could define the following immutable class:<br>
class ProgressStatus    // Represents progress of some activity<br>{<br>  public <b>readonly</b> int PercentComplete;<br>
  public <b>readonly</b> string StatusMessage;<br>
  // This class might have many more fields...<br>
  public ProgressStatus (int percentComplete, string statusMessage)<br>
  {<br>    PercentComplete = percentComplete;<br>
    StatusMessage = statusMessage;<br>  }<br>
}<br>
Then we could define a single field of that type, along with a locking object:<br>
readonly object _statusLocker = new object();<br>ProgressStatus _status;<br>
We can now read/write values of that type without holding a lock for more than a<br>single assignment:<br>
var status = new ProgressStatus (50, &quot;Working on it&quot;);<br>
// Imagine we were assigning many more fields...<br>
// ...<br>
<b>lock (_statusLocker) _status = status;    // Very brief lock</b><br>
To read the object, we first obtain a copy of the object (within a lock). Then we can<br>read its values without needing to hold on to the lock:<br>
ProgressStatus status;<br><b>lock (_locker ProgressStatus) status = _status;   // Again, a brief lock<br></b>int pc = statusCopy.PercentComplete;<br>string msg = statusCopy.StatusMessage;<br>...<br>
Technically, the last two lines of code are thread-safe by virtue<br>of the preceding lock performing an implicit <i>memory barrier</i>.<br>We'll discuss this in the next section.<br>
Note that this lock-free approach prevents inconsistency within a group of related<br>fields. But it doesn't prevent data from changing while you subsequently act on it--<br>for this, you usually need a lock. In Chapter 22, we'll see more examples of using<br>immutability to simplify multithreading--including PLINQ.<br>
<b>824 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=845></a>It's also possible to safely assign a new ProgressStatus object<br>based on its preceding value (e.g., it's possible to "increment"<br>the PercentComplete value)--without locking over more than<br>one line of code. In fact, we can do this without using a single<br>lock,  through  the  use  of  explicit  memory  barriers,<br>Interlocked.CompareExchange,  and  spin-waits.  This  is  an  ad-<br>vanced technique, which we demonstrate in the final section of<br>Chapter 22.<br>
<b>Nonblocking Synchronization<br></b>Earlier, we said that the need for synchronization arises even in the simple case of<br>
<b>Threading</b><br>
assigning or incrementing a field. Although locking can always satisfy this need, a<br>contended lock means that a thread must block, suffering the overhead of a context<br>switch and the latency of being descheduled, which can be undesirable in highly<br>concurrent and performance-critical scenarios. The .NET Framework's <i>nonblock-<br>ing</i> synchronization constructs can perform simple operations without ever block-<br>ing, pausing, or waiting.<br>
Writing nonblocking or lock-free multithreaded code properly<br>is tricky! Memory barriers, in particular, are easy to get wrong<br>(the volatile keyword is even easier to get wrong). Think care-<br>fully whether you really need the performance benefits before<br>dismissing ordinary locks.<br>
The nonblocking approaches also work across multiple processes. An example of<br>where this might be useful is in reading and writing process-shared memory.<br>
<b>Memory Barriers and Volatility<br></b>Consider the following example:<br>
class Foo<br>{<br>  int _answer;<br>  bool _complete;<br>
  void A()<br>  {<br>    _answer = 123;<br>    _complete = true;<br>
  }<br>
  void B()<br>  {<br>    if (_complete) Console.WriteLine (_answer);<br>  }<br>}<br>
<b>Nonblocking Synchronization | 825</b><br>
<hr>
<A name=846></a>If methods A and B ran concurrently on different threads, might it be possible for B<br>to write "0"? The answer is yes--for the following reasons:<br>
· The compiler, CLR, or CPU may <i>reorder</i> your program's instructions to im-<br>
prove efficiency.<br>
· The compiler, CLR, or CPU may introduce caching optimizations such that<br>
assignments to variables won't be visible to other threads right away.<br>
C# and the runtime are very careful to ensure that such optimizations don't break<br>ordinary single-threaded code--or multithreaded code that makes proper use of<br>locks. Outside of these scenarios, you must explicitly defeat these optimizations by<br>creating <i>memory barriers</i> (also called <i>memory fences</i>) to limit the effects of instruc-<br>tion reordering and read/write caching.<br>
<b>Full fences<br></b>The simplest kind of memory barrier is a <i>full memory barrier</i> (<i>full fence</i>), which<br>prevents any kind of instruction reordering or caching around that fence. Calling<br>Thread.MemoryBarrier generates a full fence; we can fix our example by applying four<br>full fences as follows:<br>
class Foo<br>
{<br>  int _answer;<br>
  bool _complete;<br>
  void A()<br>  {<br>    _answer = 123;<br>    <b>Thread.MemoryBarrier();    // Barrier 1<br></b>    _complete = true;<br>    <b>Thread.MemoryBarrier();    // Barrier 2<br></b>  }<br>
  void B()<br>  {<br>    <b>Thread.MemoryBarrier();    // Barrier 3<br></b>    if (_complete)<br>    {<br>      <b>Thread.MemoryBarrier();       // Barrier 4<br></b>      Console.WriteLine (_answer);<br>    }<br>  }<br>}<br>
Barriers 1 and 4 prevent this example from writing "0". Barriers 2 and 3 provide a<br><i>freshness</i> guarantee: they ensure that if B ran after A, reading _complete would eval-<br>uate to true.<br>A full fence takes a few tens of nanoseconds.<br>
<b>826 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=847></a>The following implicitly generate full fences:<br>
· C#'s lock statement (Monitor.Enter/Monitor.Exit)<br>· All  methods  on  the  Interlocked  class  (we'll  cover  these<br>
soon)<br>
· Asynchronous callbacks that use the thread pool--these<br>
include  asynchronous  delegates,  APM  callbacks  (Chap-<br>ter 23), and Task continuations (Chapter 22)<br>
· Setting and waiting on a signaling construct<br>· Anything that relies on signaling, such as starting or wait-<br>
ing on a Task<br>
By virtue of that last point, the following is thread-safe:<br>
<b>Threading</b><br>
int x = 0;<br>Task t = Task.Factory.StartNew (() =&gt; x++);<br>t.Wait();<br>
Console.WriteLine (x);    // 1<br>
You don't necessarily need a full fence with every individual read or write. If we had<br>three <i>answer</i> fields, our example would still need only four fences:<br>
class Foo<br>
{<br>  int _answer1, _answer2, _answer3;<br>  bool _complete;<br>
  void A()<br>  {<br>    _answer1 = 1; _answer2 = 2; _answer3 = 3;<br>    <b>Thread.MemoryBarrier();<br></b>    _complete = true;<br>    <b>Thread.MemoryBarrier();<br></b>  }<br>
  void B()<br>  {<br>    <b>Thread.MemoryBarrier();<br></b>    if (_complete)<br>    {<br>      <b>Thread.MemoryBarrier();<br></b>      Console.WriteLine (_answer1 + _answer2 + _answer3);<br>    }<br>  }<br>}<br>
A good approach is to start by putting memory barriers before<br>and after every instruction that reads or writes a shared field,<br>and then strip away the ones that you don't need. If you're un-<br>certain of any, leave them in. Or better: switch back to using<br>locks!<br>
<b>Nonblocking Synchronization | 827</b><br>
<hr>
<A name=848></a><b>Do We Really Need Locks and Barriers?</b><br>
Working with <i>shared writable fields</i> without locks or fences is asking for trouble.<br>There's a lot of misleading information on this topic--including the MSDN doc-<br>umentation, which states that MemoryBarrier is required only on multiprocessor<br>systems with weak memory ordering, such as a system employing multiple Itanium<br>processors. We can demonstrate that memory barriers are important on ordinary<br>Intel Core-2 and Pentium processors with the following short program. You'll<br>need to run it with optimizations enabled and without a debugger (in Visual Stu-<br>dio, select Release Mode in the solution's configuration manager, and then start<br>without debugging):<br>
static void Main()<br>
{<br>  bool complete = false;<br>
  var t = new Thread (() =&gt;<br>
  {<br>
    bool toggle = false;<br>
    while (!complete) toggle = !toggle;<br>  });<br>
  t.Start();<br>
  Thread.Sleep (1000);<br>
  complete = true;<br>  t.Join();        // Blocks indefinitely<br>}<br>
This program <i>never terminates</i> because the complete variable is cached in a CPU<br>register. Inserting a call to Thread.MemoryBarrier inside the while loop (or locking<br>around reading complete) fixes the error.<br>
<b>The volatile keyword<br></b>Another (more advanced) way to solve this problem is to apply the volatile keyword<br>to the _complete field:<br>
<b>volatile</b> bool _complete;<br>
The volatile keyword instructs the compiler to generate an <i>acquire-fence</i> on every<br>read from that field, and a <i>release-fence</i> on every write to that field. An acquire-fence<br>prevents other reads/writes from being moved <i>before</i> the fence; a release-fence pre-<br>vents other reads/writes from being moved <i>after</i> the fence. These "half-fences" are<br>faster than full fences because they give the runtime and hardware more scope for<br>optimization.<br>
<b>828 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=849></a>As  it  happens,  Intel's  X86  and  X64  processors  always  apply<br>acquire-fences to reads and release-fences to writes--whether<br>or not you use the volatile keyword--so this keyword has no<br>effect on the <i>hardware</i> if you're using these processors. How-<br>ever, volatile <i>does</i> have an effect on optimizations performed<br>by the compiler and the CLR--as well as on 64-bit AMD and<br>(to a greater extent) Itanium processors. This means that you<br>cannot be more relaxed by virtue of your clients running a par-<br>ticular type of CPU.<br>
(And even if you <i>do</i> use volatile, you should still maintain a<br>healthy sense of anxiety, as we'll see shortly!)<br>
The effect of applying volatile to fields can be summarized as follows:<br>
<b>Threading</b><br>
<b>First instruction</b><br>
<b>Second instruction</b><br>
<b>Can they be swapped?</b><br>
Read<br>
Read<br>
No<br>
Read<br>
Write<br>
No<br>
Write<br>
Write<br>
Noa<br>
Write<br>
Read<br>
<b>Yes!</b><br>
a The CLR ensures that write-write operations are never swapped, even without the volatile keyword.<br>
Notice that applying volatile doesn't prevent a write followed by a read from being<br>swapped, and this can create brainteasers. Joe Duffy illustrates the problem well<br>with  the  following  example:  if  Test1  and  Test2  run  simultaneously  on  different<br>threads, it's possible for a and b to both end up with a value of 0 (despite the use of<br>volatile on both x and y):<br>
class IfYouThinkYouUnderstandVolatile<br>{<br>  volatile int x, y;<br>
  void Test1()        // Executed on one thread<br>  {<br>    x = 1;            // Volatile write (release-fence)<br>    int a = y;        // Volatile read (acquire-fence)<br>    ...<br>  }<br>
  void Test2()         // Executed on another thread<br>  {<br>
    y = 1;            // Volatile write (release-fence)<br>    int b = x;        // Volatile read (acquire-fence)<br>    ...<br>  }<br>}<br>
<b>Nonblocking Synchronization | 829</b><br>
<hr>
<A name=850></a>The MSDN documentation states that use of the volatile key-<br>word ensures that the most up-to-date value is present in the<br>field at all times. This is incorrect, since as we've seen, a write<br>followed by a read <i>can</i> be reordered.<br>
This presents a strong case for avoiding volatile: even if you understand the subtlety<br>in this example, will other developers working on your code also understand it? A<br>full fence between each of the two assignments in Test1 and Test2 (or a lock) solves<br>the problem.<br>
The  volatile  keyword  is  not  supported  with  pass-by-reference  arguments  or<br>captured  local  variables:  in  these  cases,  you  must  use  the  VolatileRead  and<br>VolatileWrite methods.<br>
<b>VolatileRead and VolatileWrite<br></b>The static VolatileRead and VolatileWrite methods in the Thread class read/write a<br>variable  while  enforcing  (technically,  a  superset  of)  the  guarantees  made  by  the<br>volatile keyword. Their implementations are relatively inefficient, though, in that<br>they actually generate full fences. Here are their complete implementations for the<br>integer type:<br>
public static void VolatileWrite (ref int address, int value)<br>{<br>  MemoryBarrier(); address = value;<br>}<br>
public static int VolatileRead (ref int address)<br>{<br>  int num = address; MemoryBarrier(); return num;<br>}<br>
You can see from this that if you call VolatileWrite followed by VolatileRead, no<br>barrier is generated in the middle: this enables the same brainteaser scenario that<br>we saw earlier.<br>
<b>Memory barriers and locking<br></b>As we said earlier, Monitor.Enter and Monitor.Exit both generate full fences. So if<br>we ignore a lock's mutual exclusion guarantee, we could say that this:<br>
<b>lock</b> (<i>someField</i>) { ... }<br>
is equivalent to this:<br>
<b>Thread.MemoryBarrier()</b>; { ... } <b>Thread.MemoryBarrier()</b>;<br>
<b>Interlocked<br></b>Use of memory barriers is not always enough when reading or writing fields in lock-<br>free code. Operations on 64-bit fields, increments, and decrements require the heav-<br>ier approach of using the Interlocked helper class. Interlocked also provides the<br>
<b>830 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=851></a>Exchange and CompareExchange methods, the latter enabling lock-free read-modify-<br>write operations, with a little additional coding.<br>
A statement is intrinsically <i>atomic</i> if it executes as a single indivisible instruction on<br>the underlying processor. Strict atomicity precludes any possibility of preemption.<br>A simple read or write on a field of 32 bits or less is always atomic. Operations on<br>64-bit fields are guaranteed to be atomic only in a 64-bit runtime environment, and<br>statements that combine more than one read/write operation are never atomic:<br>
class Atomicity<br>{<br>  static int _x, _y;<br>
  static long _z;<br>
  static void Test()<br>
<b>Threading</b><br>
  {<br>
    long myLocal;<br>
    _x = 3;             // Atomic<br>
    _z = 3;             // Nonatomic on 32-bit environs (_z is 64 bits)<br>    myLocal = _z;       // Nonatomic on 32-bit environs (_z is 64 bits)<br>
    _y += _x;           // Nonatomic (read AND write operation)<br>
    _x++;               // Nonatomic (read AND write operation)<br>
  }<br>
}<br>
Reading and writing 64-bit fields is nonatomic on 32-bit environments because it<br>requires two separate instructions: one for each 32-bit memory location. So, if thread<br>X reads a 64-bit value while thread Y is updating it, thread X may end up with a<br>bitwise combination of the old and new values (a <i>torn read</i>).<br>
The compiler implements unary operators of the kind x++ by reading a variable,<br>processing it, and then writing it back. Consider the following class:<br>
class ThreadUnsafe<br>{<br>  static int _x = 1000;<br>  static void Go() { for (int i = 0; i &lt; 100; i++) _x--; }<br>}<br>
Putting aside the issue of memory barriers, you might expect that if 10 threads con-<br>currently run Go, _x would end up as 0. However, this is not guaranteed, because a<br><i>race condition</i> is possible whereby one thread preempts another in between retrieving<br>_x's current value, decrementing it, and writing it back (resulting in an out-of-date<br>value being written).<br>
Of course, you can address these issues by wrapping the nonatomic operations in a<br>lock  statement.  Locking  simulates  atomicity  if  consistently  applied,  but  the<br>Interlocked class provides an easier and faster solution for such simple operations:<br>
class Program<br>{<br>  static long _sum;<br>
 <br>
<b>Nonblocking Synchronization | 831</b><br>
<hr>
<A name=852></a>  static void Main()<br>
  {                                                             // _sum<br>    // Simple increment/decrement operations:<br>    Interlocked.Increment (ref _sum);                              // 1<br>
    Interlocked.Decrement (ref _sum);                              // 0<br>
    // Add/subtract a value:<br>    Interlocked.Add (ref _sum, 3);                                 // 3<br>
    // Read a 64-bit field:<br>    Console.WriteLine (Interlocked.Read (ref _sum));               // 3<br>
    // Write a 64-bit field while reading previous value:<br>    // (This prints &quot;3&quot; while updating _sum to 10)<br>
    Console.WriteLine (Interlocked.Exchange (ref _sum, 10));       // 10<br>
    // Update a field only if it matches a certain value (10):<br>
    Console.WriteLine (Interlocked.CompareExchange (ref _sum,<br>
                                                    123, 10);      // 123<br>  }<br>}<br>
All of Interlocked's methods generate a full fence. Therefore,<br>fields that you access via Interlocked don't need additional fen-<br>ces--unless they're accessed in other places in your program<br>without Interlocked or a lock.<br>
Interlocked's mathematical operations are restricted to Increment, Decrement, and<br>Add. If you want to multiply--or perform any other calculation--you can do so in<br>lock-free style by using the CompareExchange method (typically in conjunction with<br>spin-waiting). We give an example in the final section in the following chapter.<br>
Interlocked works by making its need for atomicity known to the operating system<br>and virtual machine.<br>
Interlocked's methods have a typical overhead of 50 ns--half<br>that of an uncontended lock. Further, they can never suffer the<br>additional cost of context switching due to blocking. The flip<br>side is that using Interlocked within a loop with many iterations<br>can be less efficient than obtaining a single lock <i>around</i> the loop <br>(although Interlocked enables greater <i>concurrency</i>).<br>
<b>Signaling with Event Wait Handles<br></b>Event wait handles are used for <i>signaling</i>. Signaling is when one thread waits until<br>it receives notification from another. Event wait handles are the simplest of the sig-<br>naling constructs, and they are unrelated to C# events. They come in three flavors:<br>AutoResetEvent, ManualResetEvent, and (from Framework 4.0) CountdownEvent. The<br>
<b>832 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=853></a>former two are based on the common EventWaitHandle class, where they derive all<br>their functionality.<br>
<b>AutoResetEvent<br></b>An AutoResetEvent is like a ticket turnstile: inserting a ticket lets exactly one person<br>through. The "auto" in the class's name refers to the fact that an open turnstile<br>automatically closes or "resets" after someone steps through. A thread waits, or<br>blocks, at the turnstile by calling WaitOne (wait at this "one" turnstile until it opens),<br>and  a  ticket  is  inserted  by  calling  the  Set  method.  If  a  number  of  threads  call<br>WaitOne, a queue builds up behind the turnstile. A ticket can come from any thread;<br>in other words, any (unblocked) thread with access to the AutoResetEvent object can<br>call Set on it to release one blocked thread.<br>
<b>Threading</b><br>
You can create an AutoResetEvent in two ways. The first is via its constructor:<br>
var auto = new AutoResetEvent (false);<br>
(Passing true into the constructor is equivalent to immediately calling Set upon it.)<br>The second way to create an AutoResetEvent is as follows:<br>
var auto = new EventWaitHandle (false, EventResetMode.AutoReset);<br>
In the following example, a thread is started whose job is simply to wait until signaled<br>by another thread (see Figure 21-2):<br>
class BasicWaitHandle<br>
{<br>  static EventWaitHandle _waitHandle = new AutoResetEvent (false);<br>
  static void Main()<br>  {<br>    new Thread (Waiter).Start();<br>    Thread.Sleep (1000);                  // Pause for a second...<br>    _waitHandle.Set();                    // Wake up the Waiter.<br>  }<br>
  static void Waiter()<br>  {<br>    Console.WriteLine (&quot;Waiting...&quot;);<br>    _waitHandle.WaitOne();                // Wait for notification<br>    Console.WriteLine (&quot;Notified&quot;);<br>  }<br>}<br>
// Output:<br>Waiting... <i>(pause)</i> Notified.<br>
 As with locks, the fairness of the queue can sometimes be violated due to nuances in the operating<br>
system.<br>
<b>Signaling with Event Wait Handles | 833</b><br>
<hr>
<A name=854></a><i>Figure 21-2. Signaling with an EventWaitHandle</i><br>
If Set is called when no thread is waiting, the handle stays open for as long as it takes<br>until some thread calls WaitOne. This behavior helps avoid a race between a thread<br>heading for the turnstile, and a thread inserting a ticket ("Oops, inserted the ticket<br>a microsecond too soon, bad luck, now you'll have to wait indefinitely!"). However,<br>calling Set repeatedly on a turnstile at which no one is waiting doesn't allow a whole<br>party through when they arrive: only the next single person is let through and the<br>extra tickets are "wasted."<br>
Calling Reset on an AutoResetEvent closes the turnstile (should it be open) without<br>waiting or blocking.<br>
WaitOne accepts an optional timeout parameter, returning false if the wait ended<br>because of a timeout rather than obtaining the signal.<br>
Calling WaitOne with a timeout of 0 tests whether a wait handle<br>is "open," without blocking the caller. Bear in mind, though,<br>that doing this resets the AutoResetEvent if it's open.<br>
<b>Disposing Wait Handles</b><br>
Once you've finished with a wait handle, you can call its Close method to release<br>the operating system resource. Alternatively, you can simply drop all references<br>to the wait handle and allow the garbage collector to do the job for you sometime<br>later  (wait  handles  implement  the  disposal  pattern  whereby  the  finalizer  calls<br>Close). This is one of the few scenarios where relying on this backup is (arguably)<br>acceptable, because wait handles have a light OS burden (asynchronous delegates<br>rely on exactly this mechanism to release their IAsyncResult's wait handle).<br>Wait handles are released automatically when an application domain unloads.<br>
<b>834 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=855></a><b>Two-way signaling<br></b>Let's say we want the main thread to signal a worker thread three times in a row. If<br>the main thread simply calls Set on a wait handle several times in rapid succession,<br>the second or third signal may get lost, since the worker may take time to process<br>each signal.<br>
The solution is for the main thread to wait until the worker's ready before signaling<br>it. This can be done with another AutoResetEvent, as follows:<br>
class TwoWaySignaling<br>
{<br>  static EventWaitHandle _ready = new AutoResetEvent (false);<br>
  static EventWaitHandle _go = new AutoResetEvent (false);<br>
  static readonly object _locker = new object();<br>
<b>Threading</b><br>
  static string _message;<br>
  static void Main()<br>
  {<br>
    new Thread (Work).Start();<br>
    <b>_ready.WaitOne();</b>                  // First wait until worker is ready<br>
    lock (_locker) _message = &quot;ooo&quot;;<br>
    <b>_go.Set();</b>                         // Tell worker to go<br>
    <b>_ready.WaitOne();</b><br>
    lock (_locker) _message = &quot;ahhh&quot;;  // Give the worker another message<br>
    <b>_go.Set();</b><br>
    <b>_ready.WaitOne();<br></b>    lock (_locker) _message = null;    // Signal the worker to exit<br>    <b>_go.Set();<br></b>  }<br>
  static void Work()<br>  {<br>    while (true)<br>    {<br>      <b>_ready.Set();</b>                          // Indicate that we're ready<br>      <b>_go.WaitOne();</b>                         // Wait to be kicked off...<br>      lock (_locker)<br>      {<br>        if (_message == null) return;          // Gracefully exit<br>        Console.WriteLine (_message);<br>      }<br>    }<br>  }<br>}<br>
// Output:<br>ooo<br>ahhh<br>
<b>Signaling with Event Wait Handles | 835</b><br>
<hr>
<A name=856></a>Figure 21-3 shows this process visually.<br>
<i>Figure 21-3. Two-way signaling</i><br>
Here,  we're  using  a  null  message  to  indicate  that  the  worker  should  end.  With<br>threads that run indefinitely, it's important to have an exit strategy!<br>
<b>ManualResetEvent<br></b>A ManualResetEvent functions like an ordinary gate. Calling Set opens the gate, al-<br>lowing <i>any</i> number of threads calling WaitOne to be let through. Calling Reset closes<br>the gate. Threads that call WaitOne on a closed gate will block; when the gate is next<br>opened, they will be released all at once. Apart from these differences, a ManualRese<br>tEvent functions like an AutoResetEvent.<br>
As with AutoResetEvent, you can construct a ManualResetEvent in two ways:<br>
var manual1 = new ManualResetEvent (false);<br>var manual2 = new EventWaitHandle (false, EventResetMode.ManualReset);<br>
From Framework 4.0, there's another version of ManualResetE<br>vent  called  ManualResetEventSlim.  The  latter  is  optimized  for<br>short waiting times--with the ability to opt into spinning for a<br>set number of iterations. It also has a more efficient managed<br>implementation and allows a Wait to be canceled via a Cancel<br>lationToken (see "Cancellation" on page 886). It cannot, how-<br>ever, be used for interprocess signaling. ManualResetEventSlim<br>doesn't subclass WaitHandle; however, it exposes a WaitHandle<br>property  that  returns  a  WaitHandle-based  object  when  called<br>(with the performance profile of a traditional wait handle).<br>
<b>836 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=857></a><b>Signaling Constructs and Performance</b><br>
Waiting or signaling an AutoResetEvent or ManualResetEvent takes about one mi-<br>crosecond (assuming no blocking).<br>
ManualResetEventSlim and CountdownEvent can be up to 50 times faster in short-<br>wait scenarios, because of their nonreliance on the operating system and judicious<br>use of spinning constructs.<br>
In  most  scenarios,  however,  the  overhead  of  the  signaling  classes  themselves<br>doesn't create a bottleneck, and so is rarely a consideration. An exception is with<br>highly concurrent code, which we'll discuss in the following chapter.<br>
<b>Threading</b><br>
A ManualResetEvent is useful in allowing one thread to unblock many other threads.<br>The reverse scenario is covered by CountdownEvent.<br>
<b>CountdownEvent<br></b>CountdownEvent lets you wait on more than one thread. The class is new to Frame-<br>work 4.0 and has an efficient, fully managed implementation. To use the class, in-<br>stantiate it with the number of threads or "counts" that you want to wait on:<br>
var countdown = new CountdownEvent (3);  // Initialize with &quot;count&quot; of 3.<br>
Calling  Signal  decrements  the  "count";  calling  Wait  blocks  until  the  count  goes<br>down to zero. For example:<br>
static CountdownEvent _countdown = <b>new CountdownEvent (3);</b><br>
static void Main()<br>{<br>  new Thread (SaySomething).Start (&quot;I am thread 1&quot;);<br>  new Thread (SaySomething).Start (&quot;I am thread 2&quot;);<br>  new Thread (SaySomething).Start (&quot;I am thread 3&quot;);<br>  <b>_countdown.Wait();   // Blocks until Signal has been called 3 times<br></b>  Console.WriteLine (&quot;All threads have finished speaking!&quot;);<br>}<br>
static void SaySomething (object thing)<br>{<br>  Thread.Sleep (1000);<br>  Console.WriteLine (thing);<br>  <b>_countdown.Signal();<br></b>}<br>
Problems for which CountdownEvent is effective can sometimes<br>be solved more easily using the <i>structured parallelism</i> constructs<br>that  we'll  cover  in  the  following  chapter  (PLINQ  and  the<br>Parallel class).<br>
<b>Signaling with Event Wait Handles | 837</b><br>
<hr>
<A name=858></a>You can reincrement a CountdownEvent's count by calling AddCount. However, if it<br>has already reached zero, this throws an exception: you can't "unsignal" a Countdow<br>nEvent by calling AddCount. To avoid the possibility of an exception being thrown,<br>you can instead call TryAddCount, which returns false if the countdown is zero.<br>To unsignal a countdown event, call Reset: this both unsignals the construct and<br>resets its count to the original value.<br>
Like ManualResetEventSlim, CountdownEvent exposes a WaitHandle property for sce-<br>narios where some other class or method expects an object based on WaitHandle.<br>
<b>Creating a Cross-Process EventWaitHandle<br></b>EventWaitHandle's constructor allows a "named" EventWaitHandle to be created, ca-<br>pable of operating across multiple processes. The name is simply a string, and it can<br>be any value that doesn't unintentionally conflict with someone else's! If the name<br>is  already  in  use  on  the  computer,  you  get  a  reference  to  the  same  underlying<br>EventWaitHandle;  otherwise,  the  operating  system  creates  a  new  one.  Here's  an<br>example:<br>
EventWaitHandle wh = new EventWaitHandle (false, EventResetMode.AutoReset,<br>                                          &quot;MyCompany.MyApp.SomeName&quot;);<br>
If two applications each ran this code, they would be able to signal each other: the<br>wait handle would work across all threads in both processes.<br>
<b>Wait Handles and the Thread Pool<br></b>If your application has lots of threads that spend most of their time blocked on a<br>wait handle, you can reduce the resource burden by calling ThreadPool.Register<br>WaitForSingleObject. This method accepts a delegate that is executed when a wait<br>handle is signaled. While it's waiting, it doesn't tie up a thread:<br>
static ManualResetEvent _starter = new ManualResetEvent (false);<br>
public static void Main()<br>{<br>  <b>RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject<br></b>   <b>(_starter, Go, &quot;Some Data&quot;, -1, true);<br></b>  Thread.Sleep (5000);<br>  Console.WriteLine (&quot;Signaling worker...&quot;);<br>  _starter.Set();<br>  Console.ReadLine();<br>  <b>reg.Unregister (_starter);</b>    // Clean up when we're done.<br>}<br>
public static void Go (object data, bool timedOut)<br>{<br>  Console.WriteLine (&quot;Started - &quot; + data);<br>  // Perform task...<br>}<br>
// Output:<br>(5 second delay)<br>
<b>838 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=859></a>Signaling worker...<br>
Started - Some Data<br>
When the wait handle is signaled (or a timeout elapses), the delegate runs on a pooled<br>thread.<br>
In addition to the wait handle and delegate, RegisterWaitForSingleObject accepts a<br>"black box" object that it passes to your delegate method (rather like Parameteri<br>zedThreadStart), as well as a timeout in milliseconds (-1 meaning no timeout), and<br>a boolean flag indicating whether the request is one-off rather than recurring.<br>
RegisterWaitForSingleObject  is  particularly  valuable  in  an  application  server<br>that  must  handle  many  concurrent  requests.  Suppose  you  need  to  block  on  a<br>ManualResetEvent and simply call WaitOne:<br>
<b>Threading</b><br>
void AppServerMethod()<br>
{<br>  _wh.WaitOne();<br>
  // ... continue execution<br>
}<br>
If 100 clients called this method, 100 server threads would be tied up for the duration<br>of the blockage. Replacing _wh.WaitOne with RegisterWaitForSingleObject allows<br>the method to return immediately, wasting no threads:<br>
void AppServerMethod<br>
{<br>  RegisteredWaitHandle reg = ThreadPool.RegisterWaitForSingleObject<br>   (_wh, Resume, null, -1, true);<br>
  ...<br>}<br>
static void Resume (object data, bool timedOut)<br>{<br>  // ... continue execution<br>}<br>
The data object passed to Resume allows continuance of any transient data.<br>
<b>WaitAny, WaitAll, and SignalAndWait<br></b>In addition to the Set, WaitOne, and Reset methods, there are static methods on the<br>WaitHandle  class  to  crack  more  complex  synchronization  nuts.  The  WaitAny,<br>WaitAll, and SignalAndWait methods perform atomic signaling and waiting opera-<br>tions on multiple handles. The wait handles can be of differing types (including<br>Mutex  and  Semaphore,  since  these  also  derive  from  the  abstract  WaitHandle  class).<br>ManualResetEventSlim  and  CountdownEvent  can  also  partake  in  these  methods  via<br>their WaitHandle properties.<br>
<b>Signaling with Event Wait Handles | 839</b><br>
<hr>
<A name=860></a>WaitAll and SignalAndWait have a weird connection to the leg-<br>acy COM architecture: these methods require that the caller be<br>in a multithreaded apartment, the model least suitable for in-<br>teroperability. The main thread of a WPF or Windows appli-<br>cation, for example, is unable to interact with the clipboard in<br>this mode. We'll discuss alternatives shortly.<br>
WaitHandle.WaitAny waits for any one of an array of wait handles; WaitHandle.Wai<br>tAll waits on all of the given handles, atomically. This means that if you wait on<br>two AutoResetEvents:<br>
· WaitAny will never end up "latching" both events.<br>· WaitAll will never end up "latching" only one event.<br>
SignalAndWait  calls  Set  on  one  WaitHandle,  and  then  calls  WaitOne  on  another<br>WaitHandle. The atomicity guarantee is that after signaling the first handle, it will<br>jump to the head of the queue in waiting on the second handle: you can think of it<br>as "swapping" one signal for another. You can use this method on a pair of Even<br>tWaitHandles to set up two threads to rendezvous or "meet" at the same point in<br>time. Either AutoResetEvent or ManualResetEvent will do the trick. The first thread<br>executes the following:<br>
WaitHandle.SignalAndWait (wh1, wh2);<br>
whereas the second thread does the opposite:<br>
WaitHandle.SignalAndWait (wh2, wh1);<br>
<b>Alternatives to WaitAll and SignalAndWait<br></b>WaitAll and SignalAndWait won't run in a single-threaded apartment. Fortunately,<br>there are alternatives. In the case of SignalAndWait, it's rare that you need its atom-<br>icity guarantee: in our rendezvous example, for instance, you could simply call Set<br>on  the  first  wait  handle,  and  then  WaitOne  on  the  other.  In  "The  Barrier<br>Class" on page 849, we'll explore yet another option for implementing a thread<br>rendezvous.<br>
In the case of WaitAll, an alternative in some situations is to use the Parallel class's<br>Invoke method, which we'll cover in the following chapter. (In that chapter we'll<br>also cover Tasks and continuations, and see how Task.ContinueWithAny provides an<br>alternative to WaitAny.)<br>In all other scenarios, the answer is to take the low-level approach that solves all<br>signaling problems: Wait and Pulse.<br>
<b>Signaling with Wait and Pulse<br></b>The Monitor class provides a low-level signaling construct via the static methods<br>Wait and Pulse (and PulseAll). The principle is that you write the signaling logic<br>yourself using custom flags and fields (enclosed in lock statements), and then in-<br>troduce Wait and Pulse commands to prevent spinning. With just these methods<br>
<b>840 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=861></a>and the lock statement, you can achieve the functionality of AutoResetEvent, Manual<br>ResetEvent, and Semaphore, as well as (with some caveats) WaitHandle's static meth-<br>ods WaitAll and WaitAny. Furthermore, Wait and Pulse can be amenable in situations<br>where all of the wait handles are parsimoniously challenged.<br>
Wait and Pulse signaling, however, has a number of disadvantages over event wait<br>handles:<br>
· Wait/Pulse cannot span application domains or processes on a computer.<br>· Wait/Pulse  cannot  be  used  in  the  asynchronous  method  pattern  (see  Chap-<br>
ter  23)  because  the  thread  pool  offers  Monitor.Wait  no  equivalent  of<br>RegisterWaitForSingleObject, so a blocked Wait cannot avoid monopolizing a<br>thread.<br>
<b>Threading</b><br>
· You must remember to protect all variables related to the signaling logic with<br>
locks.<br>
· Wait/Pulse  programs  may  confuse  developers  relying  on  Microsoft's<br>
documentation.<br>
The documentation problem arises because it's not obvious how Wait and Pulse are<br>supposed  to  be  used,  even  when  you've  read  up  on  how  they  work.  Wait  and<br>Pulse also have a peculiar aversion to dabblers: they will seek out any holes in your<br>understanding and then delight in tormenting you! Fortunately, there is a simple<br>pattern of use that tames Wait and Pulse.<br>In terms of performance, calling Pulse takes a few hundred nanoseconds--about<br>half the time it takes to call Set on a wait handle. Calling Wait will always block and<br>incur the overhead of a context switch--but you don't necessarily need to Wait if<br>you follow our suggested pattern of use.<br>
<b>How to Use Wait and Pulse<br></b>Here's how to use Wait and Pulse:<br>
1. Define a single field for use as the synchronization object, such as:<br>
readonly object _locker = new object();<br>
2. Define field(s) for use in your custom blocking condition(s). For example:<br>
bool _go;  <i>or:</i>  int _semaphoreCount;<br>
3. Whenever you want to block, include the following code:<br>
lock (_locker)<br>  while ( <i>&lt;blocking-condition&gt;</i> )<br>    Monitor.Wait (_locker);<br>
4. Whenever you change (or potentially change) a blocking condition, include this<br>
code:<br>
lock (_locker)<br>{<br>  <i>&lt; alter the field(s) or data that might<br></i>    <i>impact the blocking condition(s) &gt;</i><br>
<b>Signaling with Wait and Pulse | 841</b><br>
<hr>
<A name=862></a>  Monitor.Pulse (_locker);   // <i>or:</i> Monitor.PulseAll (_locker)<br>
}<br>
(If you change a blocking condition <i>and</i> want to block, you can incorporate<br>steps 3 and 4 in a single lock statement.)<br>
This pattern allows any thread to wait at any time for any condition. Here's a simple<br>example, where a worker thread waits until the _go field is set to true:<br>
class SimpleWaitPulse<br>{<br>  static readonly object _locker = new object();<br>
  static bool _go;<br>
  static void Main()<br>  {                                // The new thread will block<br>
    new Thread (Work).Start();     // because _go==false.<br>
    Console.ReadLine();            // Wait for user to hit Enter<br>
    lock (_locker)                 // Let's now wake up the thread by<br>
    {                              // setting _go=true and pulsing.<br>
      _go = true;<br>
      <b>Monitor.Pulse (_locker);<br></b>    }<br>
  }<br>
  static void Work()<br>  {<br>    lock (_locker)<br>      while (!_go)<br>        <b>Monitor.Wait (_locker)</b>;    // Lock is released while we're waiting<br>
    Console.WriteLine (&quot;Woken!!!&quot;);<br>  }<br>}<br>
// Output<br>Woken!!!   (after pressing Enter)<br>
For thread safety, we ensure that all shared fields are accessed within a lock. Hence,<br>we add lock statements around both reading and updating the _go flag. This is es-<br>sential (unless you're willing to follow the nonblocking synchronization principles).<br>
The Work method is where we block, waiting for the _go flag to become true. The<br>Monitor.Wait method does the following, in order:<br>
1. Releases the lock on _locker.<br>2. Blocks until _locker is "pulsed."<br>3. Reacquires the lock on _locker. If the lock is contended, then it blocks until the<br>
lock is available.<br>
<b>842 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=863></a>This  means  that  despite  appearances,  <i>no</i>  lock  is  held  on  the<br>synchronization object while Monitor.Wait awaits a pulse:<br>
lock (_locker)<br>{<br>  while (!_go)<br>    Monitor.Wait (_locker);  // _lock is released<br>
  // lock is regained<br>  ...<br>
}<br>
Execution then continues at the next statement. Monitor.Wait is designed for use<br>within a lock statement; it throws an exception if called otherwise. The same goes<br>for Monitor.Pulse.<br>
<b>Threading</b><br>
In the Main method, we signal the worker by setting the _go flag (within a lock) and<br>calling Pulse. As soon as we <i>release the lock</i>, the worker resumes execution, reiter-<br>ating its while loop.<br>The  Pulse  and  PulseAll  methods  release  threads  blocked  on  a  Wait  statement.<br>Pulse releases a maximum of one thread; PulseAll releases them all. In our example,<br>just one thread is blocked, so their effects are identical. If more than one thread is<br>waiting, calling PulseAll is <i>usually</i> safest with our suggested pattern of use.<br>
In order for Wait to communicate with Pulse or PulseAll, the<br>synchronizing object (_locker, in our case) must be the same.<br>
In our pattern, pulsing indicates that <i>something might have changed</i>, and that waiting<br>threads should recheck their blocking conditions. In the Work method, this check is<br>accomplished via the while loop. The <i>waiter</i> then decides whether to continue, <i>not<br>the notifier</i>. If pulsing by itself is taken as instruction to continue, the Wait construct<br>is stripped of any real value; you end up with an inferior version of an AutoResetEvent.<br>If  we  abandon  our  pattern,  removing  the  while  loop,  the  _go  flag,  and  the<br>ReadLine, we get a bare-bones Wait/Pulse example:<br>
static void Main()<br>{<br>  new Thread (Work).Start();<br>  lock (_locker) Monitor.Pulse (_locker);<br>
}<br>
static void Work()<br>{<br>  lock (_locker) Monitor.Wait (_locker);<br>  Console.WriteLine (&quot;Woken!!!&quot;);<br>}<br>
It's not possible to display the output, because it's nondeterministic! A race ensues<br>between the main thread and the worker. If Wait executes first, the signal works. If<br>
<b>Signaling with Wait and Pulse | 843</b><br>
<hr>
<A name=864></a>Pulse executes first, the <i>pulse is lost</i> and the worker remains forever stuck. This differs<br>from the behavior of an AutoResetEvent, where its Set method has a memory or<br>"latching" effect, so it is still effective if called before WaitOne.<br>
Pulse has no latching effect because you're expected to write the latch yourself, using<br>a "go" flag as we did before. This is what makes Wait and Pulse versatile: with a<br>boolean flag, we can make it function as an AutoResetEvent; with an integer field,<br>we can imitate a Semaphore. With more complex data structures, we can go further<br>and write such constructs as a producer/consumer queue.<br>
<b>Producer/Consumer Queue<br></b>A producer/consumer queue is a common requirement in threading. Here's how it<br>works:<br>
· A  queue  is  set  up  to  describe  work  items--or  data  upon  which  work  is<br>
performed.<br>
· When a task needs executing, it's enqueued, allowing the caller to get on with<br>
other things.<br>
· One or more worker threads plug away in the background, picking off and<br>
executing queued items.<br>
The advantage of this model is that you have precise control over how many worker<br>threads execute at once. This can allow you to limit consumption of not only CPU<br>time, but other resources as well. If the tasks perform intensive disk I/O, for instance,<br>you might have just one worker thread to avoid starving the operating system and<br>other applications. Another type of application may have 20. You can also dynam-<br>ically add and remove workers throughout the queue's life. The CLR's thread pool<br>itself is a kind of producer/consumer queue.<br>
A producer/consumer queue typically holds items of data upon which (the same)<br>task is performed. For example, the items of data may be filenames, and the task<br>might be to encrypt those files. By making the item a delegate, however, we can write<br>a very general-purpose producer/consumer queue where each item can do anything.<br>Here's an example that does exactly that:<br>
Framework  4.0  provides  a  new  class  called  BlockingCollec<br>tion&lt;T&gt; that implements the functionality of a producer/con-<br>sumer  queue.  We'll  cover  this  in  "Concurrent  Collec-<br>tions" on page 914 in the following chapter.<br>
Our manually written producer/consumer queue is still valua-<br>ble--not only to illustrate Wait/Pulse and thread safety, but also<br>as a basis for more sophisticated structures. For instance, if you<br>wanted a <i>bounded blocking queue</i> (limiting the number of en-<br>queued elements) that allowed cancellation (and removal) of<br>enqueued work items, the following code would provide an ex-<br>cellent starting point.<br>
<b>844 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=865></a>using System;<br>
using System.Threading;<br>using System.Collections.Generic;<br>
public class PCQueue : IDisposable<br>
{<br>  readonly object _locker = new object();<br>  Thread[] _workers;<br>
  Queue&lt;Action&gt; _itemQ = new Queue&lt;Action&gt;();<br>
  public PCQueue (int workerCount)<br>  {<br>
    _workers = new Thread [workerCount];<br>
    // Create and start a separate thread for each worker<br>
<b>Threading</b><br>
    for (int i = 0; i &lt; workerCount; i++)<br>      (_workers [i] = new Thread (Consume)).Start();<br>
  }<br>
  public void Dispose()<br>  {<br>
    // Enqueue one null item per worker to make each exit.<br>    foreach (Thread worker in _workers) EnqueueItem (null);<br>
  }<br>
  public void EnqueueItem (Action item)<br>
  {<br>    lock (_locker)<br>    {<br>      _itemQ.Enqueue (item);           // We must pulse because we're<br>      <b>Monitor.Pulse (_locker);</b>         // changing a blocking condition.<br>
    }<br>  }<br>
  void Consume()<br>  {<br>    while (true)                        // Keep consuming until<br>    {                                   // told otherwise.<br>      Action item;<br>      lock (_locker)<br>      {<br>
        while (_itemQ.Count == 0) <b>Monitor.Wait (_locker);<br></b>        item = _itemQ.Dequeue();<br>      }<br>      if (item == null) return;         // This signals our exit.<br>      item();                           // Execute item.<br>    }<br>  }<br>}<br>
Again we have an exit strategy: enqueuing a null item signals a consumer to finish<br>after completing any outstanding items (if we want it to quit sooner, we could use<br>an independent "cancel" flag). Because we're supporting multiple consumers, we<br>must enqueue one null item per consumer to completely shut down the queue.<br>
<b>Signaling with Wait and Pulse | 845</b><br>
<hr>
<A name=866></a>Here's a Main method that starts a producer/consumer queue, specifying two con-<br>current consumer threads, and then enqueues 10 delegates to be shared among the<br>two consumers:<br>
static void Main()<br>
{<br>  using (PCQueue q = new PCQueue (2))<br>
  {<br>
    for (int i = 0; i &lt; 10; i++)<br>
    {<br>
      int itemNumber = i;      // To avoid the captured variable trap<br>      q.EnqueueItem (() =&gt;<br>
      {<br>        Thread.Sleep (1000);          // Simulate time-consuming work<br>
        Console.Write (&quot; Task&quot; + itemNumber);<br>      });<br>    }<br>
    Console.WriteLine (&quot;Enqueued 10 items&quot;);<br>
    Console.WriteLine (&quot;Waiting for items to complete...&quot;);<br>  }<br>
  // Exiting the using statement runs PCQueue's Dispose method, which<br>
  // tells the consumers to end when outstanding items are complete.<br>
}<br>
// Output:<br>Enqueued 10 items<br>Waiting for items to complete...<br> Task1 Task0 <i>(pause...)</i> Task2 Task3 <i>(pause...)</i> Task4 Task5 <i>(pause...)<br></i> Task6 Task7 <i>(pause...)</i> Task8 Task9 <i>(pause...)</i><br>
Let's revisit PCQueue and examine the Consume method, where a worker picks off and<br>executes an item from the queue. We want the worker to block while there's nothing<br>to do; in other words, when there are no items on the queue. Hence, our blocking<br>condition is _itemQ.Count == 0:<br>
      Action item;<br>      lock (_locker)<br>      {<br>        while (_<b>itemQ.Count == 0</b>) Monitor.Wait (_locker);<br>        item = _itemQ.Dequeue();<br>      }<br>      if (item == null) return;         // This signals our exit<br>      item();                           // Perform task.<br>
The while loop exits when _itemQ.Count is nonzero, meaning that (at least) one item<br>is outstanding. We must dequeue the item <i>before</i> releasing the lock--otherwise, the<br>item may not be there for us to dequeue; the presence of other threads means things<br>can change while you blink. In particular, another consumer just finishing a previous<br>job could sneak in and dequeue our item if we weren't meticulous with locking.<br>
After the item is dequeued, we release the lock immediately. If we held on to it while<br>performing the task, we would unnecessarily block other consumers and producers.<br>
<b>846 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=867></a>We don't pulse after dequeuing, as no other consumer can ever unblock by there<br>being fewer items on the queue.<br>
Locking  briefly  is  advantageous  when  using  Wait  and  Pulse<br>(and  in  general),  as  it  avoids  unnecessarily  blocking  other<br>threads. Locking across many lines of code is fine--providing<br>they  all  execute  quickly.  Remember  that  you're  helped  by<br>Monitor.Wait's releasing the underlying lock while awaiting a<br>pulse!<br>
For the sake of efficiency, we call Pulse instead of PulseAll when enqueuing an item.<br>This is because (at most) one consumer needs to be woken per item. If you had just<br>one ice cream, you wouldn't wake a class of 30 sleeping children to queue for it;<br>
<b>Threading</b><br>
similarly, with 30 consumers, there's no benefit in waking them all--only to have<br>29  spin  a  useless  iteration  on  their  while  loop  before  going  back  to  sleep.  We<br>wouldn't break anything functionally, however, by replacing Pulse with PulseAll.<br>
<b>Wait Timeouts<br></b>You  can  specify  a  timeout  when  calling  Wait,  either  in  milliseconds  or  as  a<br>TimeSpan. The Wait method then returns false if it gave up because of a timeout.<br>The timeout applies only to the <i>waiting phase</i>. Hence, a Wait with a timeout does<br>the following:<br>
1. Releases the underlying lock<br>2. Blocks until pulsed, <i>or the timeout elapses<br></i>3. Reacquires the underlying lock<br>
Specifying a timeout is like asking the CLR to give you a "virtual pulse" after the<br>timeout interval. A timed-out Wait will still perform step 3 and reacquire the lock--<br>just as if pulsed.<br>
Should Wait block in step 3 (while reacquiring the lock), any<br>timeout is ignored. This is rarely an issue, though, because other<br>threads will lock only briefly in a well-designed Wait/Pulse ap-<br>plication.  So,  reacquiring  the  lock  should  be  a  near-instant<br>operation.<br>
Wait timeouts have a useful application. Sometimes it may be unreasonable or im-<br>possible to Pulse whenever an unblocking condition arises. An example might be if<br>a blocking condition involves calling a method that derives information from peri-<br>odically querying a database. If latency is not an issue, the solution is simple--you<br>can specify a timeout when calling Wait, as follows:<br>
lock (_locker)<br>  while ( <i>&lt;blocking-condition&gt;</i> )<br>    Monitor.Wait (_locker, <i>&lt;timeout&gt;</i> );<br>
<b>Signaling with Wait and Pulse | 847</b><br>
<hr>
<A name=868></a>This forces the blocking condition to be rechecked at the interval specified by the<br>timeout, as well as when pulsed. The simpler the blocking condition, the smaller<br>the timeout can be without creating inefficiency. In this case, we don't care whether<br>the Wait was pulsed or timed out, so we ignore its return value.<br>The same system works equally well if the pulse is absent due to a bug in the program.<br>It can be worth adding a timeout to all Wait commands in programs where synchro-<br>nization is particularly complex, as an ultimate backup for obscure pulsing errors.<br>It also provides a degree of bug immunity if the program is modified later by someone<br>not on the Pulse!<br>
Monitor.Wait returns a bool value indicating whether it got a<br>"real" pulse. If this returns false, it means that it timed out:<br>sometimes it can be useful to log this or throw an exception if<br>the timeout was unexpected.<br>
<b>Simulating Wait Handles<br></b>We can use Wait and Pulse to simulate a ManualResetEvent as follows:<br>
readonly object _locker = new object();<br>
bool _signal;<br>
void WaitOne()<br>
{<br>  lock (_locker)<br>
  {<br>
    while (!_signal) Monitor.Wait (_locker);<br>  }<br>}<br>
void Set()<br>{<br>  lock (_locker) { _signal = true; Monitor.PulseAll (_locker); }<br>}<br>
void Reset() { lock (_locker) _signal = false; }<br>
We used PulseAll because there could be any number of blocked waiters. Simulating<br>an AutoResetEvent is simply a matter of replacing the code in WaitOne with this:<br>
lock (_locker)<br>{<br>  while (!_signal) Monitor.Wait (_locker);<br>  <b>_signal = false;<br></b>}<br>
and replacing PulseAll with Pulse in the Set method:<br>
  lock (_locker) { _signal = true; Monitor.<b>Pulse</b> (_locker); }<br>
<b>848 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=869></a>Use of PulseAll would forgo fairness in the queuing of back-<br>logged waiters, because each call to PulseAll would result in the<br>queue breaking and then re-forming.<br>
Replacing _signal with an integer field would form the basis of a Semaphore.<br>Simulating the static methods that work across a set of wait handles is easy in simple<br>scenarios. The equivalent of calling WaitAll is nothing more than a blocking condi-<br>tion that incorporates all the flags used in place of the wait handles:<br>
lock (_locker)<br>
  while (!_flag1 &amp;&amp; !_flag2 &amp;&amp; !_flag3...)<br>    Monitor.Wait (_locker);<br>
<b>Threading</b><br>
This can be particularly useful given that WaitAll is often unusable due to COM<br>legacy issues. Simulating WaitAny is simply a matter of replacing the &amp;&amp; operator with<br>the || operator.<br>
If you have dozens of flags, this approach becomes less efficient<br>because they must all share a single synchronizing object in or-<br>der  for  the  signaling  to  work  atomically.  This  is  where  wait<br>handles have an advantage.<br>
<b>The Barrier Class<br></b>The Barrier class is a signaling construct new to Framework 4.0. It implements a <br><i>thread execution barrier</i>, which allows many threads to rendezvous at a point in time.<br>The class is very fast and efficient, and is built upon Wait, Pulse, and spinlocks.<br>To use this class:<br>
1. Instantiate it, specifying how many threads should partake in the rendezvous<br>
(you can change this later by calling AddParticipants/RemoveParticipants).<br>
2. Have each thread call SignalAndWait when it wants to rendezvous.<br>
Instantiating  Barrier  with  a  value  of  3  causes  SignalAndWait  to  block  until  that<br>method has been called three times. It then starts over: calling SignalAndWait again<br>blocks until called another three times. This keeps each thread "in step" with every<br>other thread.<br>
In the following example, each of three threads writes the numbers 0 through 4,<br>while keeping in step with the other threads:<br>
static Barrier _barrier = <b>new Barrier (3);</b><br>
static void Main()<br>{<br>  new Thread (Speak).Start();<br>  new Thread (Speak).Start();<br>  new Thread (Speak).Start();<br>
<b>The Barrier Class | 849</b><br>
<hr>
<A name=870></a>}<br>
static void Speak()<br>{<br>  for (int i = 0; i &lt; 5; i++)<br>
  {<br>    Console.Write (i + &quot; &quot;);<br><b>    _barrier.SignalAndWait();</b><br>
  }<br>
}<br>
OUTPUT:  0 0 0 1 1 1 2 2 2 3 3 3 4 4 4<br>
A really useful feature of Barrier is that you can also specify a <i>post-phase action</i> when<br>constructing it. This is a delegate that runs after SignalAndWait has been called <i>n<br></i>times, but <i>before</i> the threads are unblocked (as shown in the shaded area in Fig-<br>ure 21-4). In our example, if we instantiate our barrier as follows:<br>
static Barrier _barrier = new Barrier (3, <b>barrier =&gt; Console.WriteLine()</b>);<br>
then the output is:<br>
0 0 0<br>
1 1 1<br>
2 2 2<br>
3 3 3<br>
4 4 4<br>
<i>Figure 21-4. Barrier</i><br>
A  post-phase  action  can  be  useful  for  coalescing  data  from  each  of  the  worker<br>threads. It doesn't have to worry about preemption, because all workers are blocked<br>while it does its thing.<br>
<b>850 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=871></a><b>The Event-Based Asynchronous Pattern<br></b>The event-based asynchronous pattern (EAP) provides a simple means by which<br>classes can offer multithreading capability without consumers needing to explicitly<br>start or manage threads. It also provides the following features:<br>
· A cooperative cancellation model<br>· The ability to safely update WPF or Windows Forms controls when the worker<br>
completes<br>
· Forwarding of exceptions to the completion event<br>
The EAP is just a pattern, so these features must be written by the implementer. Just<br>a  few  classes  in  the  Framework  follow  this  pattern,  most  notably  Background<br>
<b>Threading</b><br>
Worker (which we'll cover next), and WebClient in System.Net. Essentially the pattern<br>is this: a class offers a family of members that internally manage multithreading,<br>similar to the following.<br>
// These members are from the WebClient class:<br>
public byte[] DownloadData (Uri address);    // Synchronous version<br>
public void DownloadData<b>Async</b> (Uri address);<br>
public void DownloadData<b>Async</b> (Uri address, <b>object userToken</b>);<br>
public event DownloadData<b>CompletedEventHandler</b> DownloadData<b>Completed</b>;<br>
<b>public void CancelAsync (object userState);  // Cancels an operation</b><br>
<b>public bool IsBusy { get; }                  // Indicates if still running</b><br>
The *Async methods execute asynchronously: in other words, they start an operation<br>on another thread and then return immediately to the caller. When the operation<br>completes, the <i>*</i>Completed event fires--automatically calling Invoke if required by a<br>WPF application. This event passes back an event arguments object that contains:<br>
· A flag indicating whether the operation was canceled (by the consumer calling<br>
CancelAsync)<br>
· An Error object indicating an exception that was thrown (if any)<br>· The userToken object if supplied when calling the Async method<br>
Here's how we can use WebClient's EAP members to download a web page:<br>
var wc = new WebClient();<br>wc.DownloadStringCompleted += (sender, args) =&gt;<br>{<br>  if (args.Cancelled)<br>    Console.WriteLine (&quot;Canceled&quot;);<br>  else if (args.Error != null)<br>    Console.WriteLine (&quot;Exception: &quot; + args.Error.Message);<br>  else<br>  {<br>    Console.WriteLine (args.Result.Length + &quot; chars were downloaded&quot;);<br>    // We could update the UI from here...<br>  }<br>};<br>wc.DownloadStringAsync (new Uri (&quot;http://www.linqpad.net&quot;));  // Start it<br>
<b>The Event-Based Asynchronous Pattern | 851</b><br>
<hr>
<A name=872></a>A class following the EAP may offer additional groups of asynchronous methods.<br>For instance:<br>
public string DownloadString (Uri address);<br>public void DownloadStringAsync (Uri address);<br>
public void DownloadStringAsync (Uri address, object userToken);<br>
public event DownloadStringCompletedEventHandler DownloadStringCompleted;<br>
However, these will share the same CancelAsync and IsBusy members. Therefore,<br>only one asynchronous operation can happen at once.<br>
The EAP offers the <i>possibility</i> of economizing on threads, if its<br>internal implementation follows the APM (see Chapter 23).<br>
We'll see in the next chapter how Tasks offer similar capabilities--including excep-<br>tion forwarding, continuations, cancellation tokens, and support for synchroniza-<br>tion contexts. This makes <i>implementing</i> the EAP less attractive--except in simple<br>cases where BackgroundWorker will do.<br>
<b>BackgroundWorker<br></b>BackgroundWorker is a helper class in the System.ComponentModel namespace for man-<br>aging a worker thread. It can be considered a general-purpose implementation of<br>the EAP, and provides the following features:<br>
· A cooperative cancellation model<br>· The ability to safely update WPF or Windows Forms controls when the worker<br>
completes<br>
· Forwarding of exceptions to the completion event<br>· A protocol for reporting progress<br>· An  implementation  of  IComponent  allowing  it  to  be  sited  in  Visual  Studio's<br>
designer<br>
BackgroundWorker uses the thread pool, which means you should never call Abort on<br>a BackgroundWorker thread.<br>
<b>Using BackgroundWorker<br></b>Here are the minimum steps in using BackgroundWorker:<br>
1. Instantiate BackgroundWorker and handle the DoWork event.<br>2. Call RunWorkerAsync, optionally with an object argument.<br>
This then sets it in motion. Any argument passed to RunWorkerAsync will be forwar-<br>ded to DoWork's event handler, via the event argument's Argument property. Here's<br>an example:<br>
<b>852 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=873></a>class Program<br>
{<br>  static BackgroundWorker _bw = new BackgroundWorker();<br>
  static void Main()<br>
  {<br>    _bw.DoWork += bw_DoWork;<br>    _bw.RunWorkerAsync (&quot;Message to worker&quot;);<br>
    Console.ReadLine();<br>
  }<br>
  static void bw_DoWork (object sender, DoWorkEventArgs e)<br>
  {<br>    // This is called on the worker thread<br>
    Console.WriteLine (e.Argument);        // writes &quot;Message to worker&quot;<br>
<b>Threading</b><br>
    // Perform time-consuming task...<br>
  }<br>}<br>
BackgroundWorker has a RunWorkerCompleted event that fires after the DoWork event<br>handler has done its job. Handling RunWorkerCompleted is not mandatory, but you<br>usually do so in order to query any exception that was thrown in DoWork. Further,<br>code  within  a  RunWorkerCompleted  event  handler  is  able  to  update  user  interface<br>controls without explicit marshaling; code within the DoWork event handler cannot.<br>To add support for progress reporting:<br>
1. Set the WorkerReportsProgress property to true.<br>2. Periodically call ReportProgress from within the DoWork event handler with a<br>
"percentage complete" value, and optionally, a user-state object.<br>
3. Handle the ProgressChanged event, querying its event argument's ProgressPer<br>
centage property.<br>
4. Code in the ProgressChanged event handler is free to interact with UI controls<br>
just as with RunWorkerCompleted. This is typically where you will update a pro-<br>gress bar.<br>
To add support for cancellation:<br>
1. Set the WorkerSupportsCancellation property to true.<br>2. Periodically check the CancellationPending property from within the DoWork<br>
event handler. If it's true, set the event argument's Cancel property to true, and<br>return. (The worker can also set Cancel and exit without CancellationPending<br>being true if it decides that the job is too difficult and it can't go on.)<br>
3. Call CancelAsync to request cancellation.<br>
Here's an example that implements all the preceding features:<br>
using System;<br>using System.Threading;<br>using System.ComponentModel;<br>
 <br>
<b>BackgroundWorker | 853</b><br>
<hr>
<A name=874></a>class Program<br>
{<br>  static BackgroundWorker _bw;<br>
  static void Main()<br>
  {<br>    _bw = new BackgroundWorker<br>    {<br>
      WorkerReportsProgress = true,<br>
      WorkerSupportsCancellation = true<br>    };<br>    _bw.DoWork += bw_DoWork;<br>
    _bw.ProgressChanged += bw_ProgressChanged;<br>
    _bw.RunWorkerCompleted += bw_RunWorkerCompleted;<br>
    _bw.RunWorkerAsync (&quot;Hello to worker&quot;);<br>
    Console.WriteLine (&quot;Press Enter in the next 5 seconds to cancel&quot;);<br>
    Console.ReadLine();<br>    if (_bw.IsBusy) _bw.CancelAsync();<br>    Console.ReadLine();<br>
  }<br>
  static void bw_DoWork (object sender, DoWorkEventArgs e)<br>  {<br>
    for (int i = 0; i &lt;= 100; i += 20)<br>    {<br>
      if (_bw.CancellationPending) { e.Cancel = true; return; }<br>      _bw.ReportProgress (i);<br>
      Thread.Sleep (1000);      // Just for the demo... don't go sleeping<br>    }                           // for real in pooled threads!<br>
    e.Result = 123;    // This gets passed to RunWorkerCompleted<br>  }<br>
  static void bw_RunWorkerCompleted (object sender,<br>                                     RunWorkerCompletedEventArgs e)<br>  {<br>    if (e.Cancelled)<br>      Console.WriteLine (&quot;You canceled!&quot;);<br>    else if (e.Error != null)<br>
      Console.WriteLine (&quot;Worker exception: &quot; + e.Error.ToString());<br>    else<br>      Console.WriteLine (&quot;Complete: &quot; + e.Result);      // from DoWork<br>  }<br>
  static void bw_ProgressChanged (object sender,<br>                                  ProgressChangedEventArgs e)<br>  {<br>    Console.WriteLine (&quot;Reached &quot; + e.ProgressPercentage + &quot;%&quot;);<br>
  }<br>}<br>
// Output:<br>Press Enter in the next 5 seconds to cancel<br>Reached 0%<br>
<b>854 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=875></a>Reached 20%<br>
Reached 40%<br>Reached 60%<br>Reached 80%<br>
Reached 100%<br>
Complete: 123<br>
Press Enter in the next 5 seconds to cancel<br>
Reached 0%<br>
Reached 20%<br>Reached 40%<br>
You canceled!<br>
<b>Interrupt and Abort</b><br>
<b>Threading</b><br>
All blocking methods (such as Sleep, Join, EndInvoke, and Wait) block forever if the<br>unblocking condition is never met and no timeout is specified. Occasionally, it can<br>be useful to release a blocked thread prematurely; for instance, when ending an<br>application. Two methods accomplish this:<br>
· Thread.Interrupt<br>· Thread.Abort<br>
The Abort method is also capable of ending a nonblocked thread--stuck, perhaps,<br>in an infinite loop. Abort is occasionally useful in <i>niche</i> scenarios; Interrupt is almost<br>never needed.<br>
Interrupt and  Abort can cause considerable trouble: it's pre-<br>cisely because they <i>seem</i> like obvious choices in solving a range<br>of problems that it's worth examining their pitfalls.<br>
<b>Interrupt<br></b>Calling Interrupt on a blocked thread forcibly releases it, throwing a ThreadInter<br>ruptedException, as follows:<br>
static void Main()<br>{<br>  Thread t = new Thread (delegate()<br>  {<br>    try { Thread.Sleep (Timeout.Infinite); }<br>    catch (ThreadInterruptedException) { Console.Write (&quot;Forcibly &quot;); }<br>    Console.WriteLine (&quot;Woken!&quot;);<br>
  });<br>  t.Start();<br>  t.Interrupt();<br>}<br>
// Output:<br>Forcibly Woken!<br>
<b>Interrupt and Abort | 855</b><br>
<hr>
<A name=876></a>Interrupting a thread does not cause the thread to end, unless the ThreadInterrup<br>tedException is unhandled.<br>
If Interrupt is called on a thread that's not blocked, the thread continues executing<br>until it next blocks, at which point a ThreadInterruptedException is thrown. This<br>avoids the need for the following test:<br>
if ((worker.ThreadState &amp; ThreadState.WaitSleepJoin) &gt; 0)<br>
  worker.Interrupt();<br>
which is not thread-safe because of the possibility of preemption between the if<br>statement and worker.Interrupt.<br>Interrupting a thread arbitrarily is dangerous, however, because any framework or<br>third-party methods in the calling stack could unexpectedly receive the interrupt<br>rather than your intended code. All it would take is for the thread to block briefly<br>on a simple lock or synchronization resource, and any pending interruption would<br>kick in. If the method isn't designed to be interrupted (with appropriate cleanup<br>code in finally blocks), objects could be left in an unusable state or resources in-<br>completely released.<br>
Moreover, Interrupt is unnecessary: if you are writing the code that blocks, you can<br>achieve the same result more safely with a signaling construct--or Framework 4.0's<br>cancellation  tokens  (see  "Safe  Cancellation"  on  page  857).  And  if  you  want  to<br>"unblock" someone else's code, Abort is nearly always more useful.<br>
<b>Abort<br></b>A blocked thread can also be forcibly released via its Abort method. This has an effect<br>similar to calling Interrupt, except that a ThreadAbortException is thrown instead<br>of a ThreadInterruptedException. Furthermore, the exception will be rethrown at<br>the end of the catch block (in an attempt to terminate the thread for good) unless<br>Thread.ResetAbort is called within the catch block. In the interim, the thread has a<br>ThreadState of AbortRequested.<br>
An unhandled ThreadAbortException is one of only two types of<br>exception that does not cause application shutdown (the other<br>is AppDomainUnloadException).<br>
The big difference between Interrupt and Abort is what happens when it's called on<br>a thread that is not blocked. Whereas Interrupt waits until the thread next blocks<br>before doing anything, Abort throws an exception on the thread right where it's<br>executing (unmanaged code excepted). This is a problem because .NET Framework<br>code might be aborted; code that is not abort-safe. For example, if an abort occurs<br>while a FileStream is being constructed, it's possible that an unmanaged file handle<br>will remain open until the application domain ends. This rules out using Abort in<br>almost any nontrivial context.<br>
<b>856 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=877></a>For a discussion as to why aborting .NET Framework code is<br>not safe, see the topic "Aborting Threads" at <i>http://www.alba<br>hari.com/threading/</i>.<br>
There are two cases, though, where you can safely use Abort. One is if you are willing<br>to tear down a thread's application domain after it is aborted. A good example of<br>when you might do this is in writing a unit-testing framework. (We discuss appli-<br>cation domains fully in Chapter 24.) Another case where you can call Abort safely<br>is on your own thread (because you know exactly where you are). Aborting your<br>own thread throws an "unswallowable" exception: one that gets rethrown after each<br>catch block. ASP.NET does exactly this when you call Redirect.<br>
<b>Threading</b><br>
LINQPad aborts threads when you cancel a runaway query. Af-<br>ter aborting, it dismantles and re-creates the query's application<br>domain  to  avoid  the  potentially  polluted  state  that  could<br>otherwise occur.<br>
<b>Safe Cancellation<br></b>As we saw in the preceding section, calling Abort on a thread is dangerous in most<br>scenarios. The alternative, then, is to implement a <i>cooperative</i> pattern whereby the<br>worker  periodically  checks  a  flag  that  indicates  whether  it  should  abort  (like  in<br>BackgroundWorker). To cancel, the instigator simply sets the flag, and then waits for<br>the worker to comply. This BackgroundWorker helper class implements such a flag-<br>based cancellation pattern, and you easily implement one yourself.<br>
The obvious disadvantage is that the worker method must be written explicitly to<br>support cancellation. Nonetheless, this is one of the few safe cancellation patterns.<br>To illustrate this pattern, we'll first write a class to encapsulate the cancellation flag:<br>
class RulyCanceler<br>{<br>  object _cancelLocker = new object();<br>
  bool _cancelRequest;<br>  public bool IsCancellationRequested<br>  {<br>    get { lock (_cancelLocker) return _cancelRequest; }<br>  }<br>
  public void Cancel() { lock (_cancelLocker) _cancelRequest = true; }<br>
  public void ThrowIfCancellationRequested()<br>  {<br>    if (IsCancellationRequested) throw new OperationCanceledException();<br>  }<br>}<br>
<b>Safe Cancellation | 857</b><br>
<hr>
<A name=878></a>OperationCanceledException is a Framework type intended for<br>just this purpose. Any exception class will work just as well,<br>though.<br>
We can use this as follows:<br>
class Test<br>
{<br>  static void Main()<br>  {<br>
    var canceler = new RulyCanceler();<br>
    new Thread (() =&gt; {<br>
                        try { Work (canceler); }<br>                        catch (OperationCanceledException)<br>
                        {<br>
                          Console.WriteLine (&quot;Canceled!&quot;);<br>
                        }<br>
                      }).Start();<br>
    Thread.Sleep (1000);<br>
    canceler.Cancel();               // Safely cancel worker.<br>  }<br>
  static void Work (RulyCanceler c)<br>
  {<br>    while (true)<br>    {<br>
      c.ThrowIfCancellationRequested();<br>      // ...<br>
      try      { OtherMethod (c); }<br>      finally  { /* any required cleanup */ }<br>    }<br>  }<br>
  static void OtherMethod (RulyCanceler c)<br>  {<br>    // Do stuff...<br>    c.ThrowIfCancellationRequested();<br>  }<br>}<br>
We could simplify our example by eliminating the RulyCanceler class and adding<br>the static boolean field _cancelRequest to the Test class. However, doing so would<br>mean that if several threads called Work at once, setting _cancelRequest to true would<br>cancel all workers. Our RulyCanceler class is therefore a useful abstraction. Its only<br>inelegance is that when we look at the Work method's signature, the intention is<br>unclear:<br>
static void Work (RulyCanceler c)<br>
Might the Work method itself intend to call Cancel on the RulyCanceler object? In<br>this instance, the answer is no, so it would be nice if this could be enforced in the<br>type system. Framework 4.0 provides <i>cancellation tokens</i> for this exact purpose.<br>
<b>858 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=879></a><b>Cancellation Tokens<br></b>Framework 4.0 provides two types that formalize the cooperative cancellation pat-<br>tern that we just demonstrated: CancellationTokenSource and CancellationToken.<br>The two types work in tandem:<br>
· A CancellationTokenSource defines a Cancel method.<br>· A  CancellationToken  defines  an  IsCancellationRequested  property  and<br>
ThrowIfCancellationRequested method.<br>
Together, these amount to a more sophisticated version of the RulyCanceler class in<br>our previous example. But because the types are separate, you can isolate the ability<br>to cancel from the ability to check the cancellation flag.<br>
<b>Threading</b><br>
To use these types, first instantiate a CancellationTokenSource object:<br>
var cancelSource = new CancellationTokenSource();<br>
Then,  pass  its  Token  property  into  a  method  for  which  you'd  like  to  support<br>cancellation:<br>
new Thread (() =&gt; Work (<b>cancelSource.Token</b>)).Start();<br>
Here's how Work would be defined:<br>
void Work (CancellationToken cancelToken)<br>
{<br>  cancelToken.ThrowIfCancellationRequested();<br>  ...<br>
}<br>
When you want to cancel, simply call Cancel on cancelSource.<br>
CancellationToken is actually a struct, although you can treat it<br>like a class. When implicitly copied, the copies behave identi-<br>cally and reference the original CancellationTokenSource.<br>
The CancellationToken struct provides two additional useful members. The first is<br>WaitHandle, which returns a wait handle that's signaled when the token is canceled.<br>The second is Register, which lets you register a callback delegate that will be fired<br>upon cancellation.<br>
Cancellation tokens are used within the .NET Framework itself, most notably in the<br>following classes:<br>
· ManualResetEventSlim and SemaphoreSlim<br>· CountdownEvent<br>· Barrier<br>· BlockingCollection (see Chapter 22)<br>· PLINQ and the Task Parallel Library (see Chapter 22)<br>
<b>Safe Cancellation | 859</b><br>
<hr>
<A name=880></a>Most of these classes' use of cancellation tokens is in their Wait methods. For ex-<br>ample, if you Wait on a ManualResetEventSlim and specify a cancellation token, an-<br>other  thread  can  Cancel  its  wait.  This  is  much  tidier  and  safer  than  calling<br>Interrupt on the blocked thread.<br>
<b>Lazy Initialization<br></b>A common problem in threading is how to lazily initialize a shared field in a thread-<br>safe fashion. The need arises when you have a field of a type that's expensive to<br>construct:<br>
class Foo<br>
{<br>  <b>public readonly Expensive Expensive = new Expensive();<br></b>  <b>...</b><br>
}<br>class Expensive {  /* Suppose this is expensive to construct */  }<br>
The problem with this code is that instantiating Foo incurs the performance cost of<br>instantiating Expensive--whether or not the Expensive field is ever accessed. The<br>obvious answer is to construct the instance <i>on demand</i>:<br>
class Foo<br>
{<br>  Expensive _expensive;<br>
  public Expensive                 // <i>Lazily</i> instantiate Expensive<br>  {<br>    get<br>    {<br>      if (_expensive == null) _expensive = new Expensive();<br>      return _expensive;<br>    }<br>  }<br>  ...<br>}<br>
The question then arises, is this thread-safe? Aside from the fact that we're accessing<br>_expensive outside a lock without a memory barrier, consider what would happen<br>if two threads accessed this property at once. They could both satisfy the if state-<br>ment's  predicate  and  each  thread  might  end  up  with  a  <i>different</i>  instance  of<br>Expensive. As this may lead to subtle errors, we would say, in general, that this code<br>is not thread-safe.<br>
The solution to the problem is to lock around checking and initializing the object:<br>
Expensive _expensive;<br>readonly object <b>_expenseLock</b> = new object();<br>
public Expensive<br>{<br>  get<br>  {<br>    <b>lock (_expenseLock)<br></b>    {<br>
<b>860 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=881></a>      if (_expensive == null) _expensive = new Foo();<br>
      return _expensive;<br>    }<br>  }<br>
}<br>
<b>Lazy&lt;T&gt;<br></b>Framework 4.0 provides a new class called Lazy&lt;T&gt; to help with lazy initialization.<br>If instantiated with an argument of true, it implements the thread-safe initialization<br>pattern just described.<br>
Lazy&lt;T&gt; actually implements a slightly more efficient version of<br>
<b>Threading</b><br>
this  pattern,  called  <i>double-checked  locking</i>.  Double-checked<br>locking performs an additional volatile read to avoid the cost of<br>obtaining a lock if the object is already initialized.<br>
To use Lazy&lt;T&gt;, instantiate the class with a value factory delegate that tells it how to<br>initialize a new value, and the argument true. Then access its value via the Value<br>property:<br>
Lazy&lt;Expensive&gt; _expensive = new Lazy&lt;Expensive&gt;<br>
  (() =&gt; new Expensive(), true);<br>
public static Expensive Expensive { get { return _expensive.<b>Value</b>; } }<br>
If you pass false into Lazy&lt;T&gt;'s constructor, it implements the thread-unsafe lazy<br>initialization pattern that we described at the start of this section--this makes sense<br>when you want to use Lazy&lt;T&gt; in a single-threaded context.<br>
<b>LazyInitializer<br></b>LazyInitializer is a static class that works exactly like Lazy&lt;T&gt; except:<br>
· Its functionality is exposed through a static method that operates directly on a<br>
field in your own type. This avoids a level of indirection, improving performance<br>in cases where you need extreme optimization.<br>
· It  offers  another  mode  of  initialization  that  has  multiple  threads  race  to<br>
initialize.<br>
To use LazyInitializer, call EnsureInitialized before accessing the field, passing<br>a reference to the field and the factory delegate:<br>
Expensive _expensive;<br>public Expensive Expensive<br>{<br>  get          // Implement double-checked locking<br>  {<br>    LazyInitializer.EnsureInitialized (ref _expensive,<br>                                      () =&gt; new Expensive());<br>    return _expensive;<br>
<b>Lazy Initialization | 861</b><br>
<hr>
<A name=882></a>  }<br>
}<br>
You can also pass in another argument to request that competing threads <i>race</i> to<br>initialize. This sounds similar to our original thread-unsafe example, except that the<br>first thread to finish always wins--and so you end up with only one instance. The<br>advantage  of  this  technique  is  that  it's  even  faster  (on  multicores)  than  double-<br>checked locking--because it can be implemented entirely without locks. This is an<br>extreme optimization that you rarely need, and one that comes at a cost:<br>
· It's slower when more threads race to initialize than you have cores.<br>· It potentially wastes CPU resources performing redundant initialization.<br>· The initialization logic must be thread-safe (in this case, it would be thread-<br>
unsafe if Expensive's constructor wrote to static fields, for instance).<br>
· If the initializer instantiates an object requiring disposal, the "wasted" object<br>
won't get disposed without additional logic.<br>
For reference, here's how double-checked locking is implemented:<br>
volatile Expensive _expensive;<br>
public Expensive Expensive<br>
{<br>  get<br>
  {<br>
    if (_expensive == null)<br>
    {<br>      var expensive = new Expensive();<br>      lock (_expenseLock) if (_expensive == null) _expensive = expensive;<br>    }<br>    return _expensive;<br>  }<br>}<br>
And here's how the race-to-initialize pattern is implemented:<br>
volatile Expensive _expensive;<br>public Expensive Expensive<br>{<br>  get<br>  {<br>    if (_expensive == null)<br>    {<br>      var instance = new Expensive();<br>      Interlocked.CompareExchange (ref _expensive, instance, null);<br>    }<br>    return _expensive;<br>  }<br>}<br>
<b>Thread-Local Storage<br></b>Much of this chapter has focused on synchronization constructs and the issues aris-<br>ing from having threads concurrently access the same data. Sometimes, however,<br>
<b>862 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=883></a>you want to keep data isolated, ensuring that each thread has a separate copy. Local<br>variables achieve exactly this, but they are useful only with transient data.<br>
The solution is <i>thread-local storage</i>. You might be hard-pressed to think of a re-<br>quirement: data you'd want to keep isolated to a thread tends to be transient by<br>nature. Its main application is for storing "out-of-band" data--that which supports<br>the  execution  path's  infrastructure,  such  as  messaging,  transaction,  and  security<br>tokens. Passing such data around in method parameters is extremely clumsy and<br>alienates all but your own methods; storing such information in ordinary static fields<br>means sharing it among all threads.<br>
Thread-local storage can also be useful in optimizing parallel<br>code. It allows each thread to exclusively access its own version<br>
<b>Threading</b><br>
of a thread-unsafe object without needing locks--and without<br>needing to reconstruct that object between method calls.<br>
There are three ways to implement thread-local storage.<br>
<b>[ThreadStatic]<br></b>The  easiest  approach  to  thread-local  storage  is  to  mark  a  static  field  with  the<br>ThreadStatic attribute:<br>
[ThreadStatic] static int _x;<br>
Each thread then sees a separate copy of _x.<br>Unfortunately,  [ThreadStatic]  doesn't  work  with  instance  fields  (it  simply  does<br>nothing), nor does it play well with field initializers--they execute only <i>once</i> on the<br>thread that's running when the static constructor executes. If you need to work with<br>instance fields--or start with a nondefault value--ThreadLocal&lt;T&gt; provides a better<br>option.<br>
<b>ThreadLocal&lt;T&gt;<br></b>ThreadLocal&lt;T&gt; is new to Framework 4.0. It provides thread-local storage for both<br>static and instance fields--and allows you to specify default values.<br>
Here's how to create a ThreadLocal&lt;int&gt; with a default value of 3 for each thread:<br>
static ThreadLocal&lt;int&gt; _x = new ThreadLocal&lt;int&gt; (() =&gt; 3);<br>
You then use _x's Value property to get or set its thread-local value. A bonus of using<br>ThreadLocal is that values are lazily evaluated: the factory function evaluates on the<br>first call (for each thread).<br>
<b>ThreadLocal&lt;T&gt; and instance fields<br></b>ThreadLocal&lt;T&gt; is also useful with instance fields and captured local variables. For<br>example, consider the problem of generating random numbers in a multithreaded<br>environment. The Random class is not thread-safe, so we have to either lock around<br>
<b>Thread-Local Storage | 863</b><br>
<hr>
<A name=884></a>using Random (limiting concurrency) or generate a separate Random object for each<br>thread. ThreadLocal&lt;T&gt; makes the latter easy:<br>
var localRandom = <b>new ThreadLocal&lt;Random&gt;(() =&gt; new Random())</b>;<br>Console.WriteLine (localRandom.Value.Next());<br>
Our factory function for creating the Random object is a bit simplistic, though, in that<br>Random's parameterless constructor relies on the system clock for a random number<br>seed. This may be the same for two Random objects created within ~10 ms of each<br>other. Here's one way to fix it:<br>
var localRandom = new ThreadLocal&lt;Random&gt;<br>
 ( () =&gt; new Random (Guid.NewGuid().GetHashCode()) );<br>
We  use  this  in  the  following  chapter  (see  the  parallel  spellchecking  example  in<br>"PLINQ" on page 877).<br>
<b>GetData and SetData<br></b>The third approach is to use two methods in the Thread class: GetData and SetData.<br>These store data in thread-specific "slots." Thread.GetData reads from a thread's<br>isolated data store; Thread.SetData writes to it. Both methods require a LocalDataS<br>toreSlot object to identify the slot. The same slot can be used across all threads and<br>they'll still get separate values. Here's an example:<br>
class Test<br>{<br>  // The same LocalDataStoreSlot object can be used across all threads.<br>
  LocalDataStoreSlot _secSlot = Thread.GetNamedDataSlot (&quot;securityLevel&quot;);<br>
  // This property has a separate value on each thread.<br>  int SecurityLevel<br>  {<br>    get<br>    {<br>      object data = Thread.GetData (_secSlot);<br>      return data == null ? 0 : (int) data;    // null == uninitialized<br>    }<br>    set { Thread.SetData (_secSlot, value); }<br>  }<br>  ...<br>
In this instance, we called Thread.GetNamedDataSlot, which creates a named slot--<br>this allows sharing of that slot across the application. Alternatively, you can control<br>a  slot's  scope  yourself  by  instantiating  a  LocalDataStoreSlot  explicitly--without<br>providing any name:<br>
class Test<br>{<br>  LocalDataStoreSlot _secSlot = new LocalDataStoreSlot();<br>  ...<br>
Thread.FreeNamedDataSlot will release a named data slot across all threads, but only<br>once all references to that LocalDataStoreSlot have dropped out of scope and have<br>been garbage-collected. This ensures that threads don't get data slots pulled out<br>
<b>864 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=885></a>from  under  their  feet,  as  long  as  they  keep  a  reference  to  the  appropriate<br>LocalDataStoreSlot object while the slot is needed.<br>
<b>Reader/Writer Locks<br></b>Quite often, instances of a type are thread-safe for concurrent read operations, but<br>not for concurrent updates (nor for a concurrent read and update). This can also be<br>true with resources such as a file. Although protecting instances of such types with<br>a simple exclusive lock for all modes of access usually does the trick, it can unrea-<br>sonably restrict concurrency if there are many readers and just occasional updates.<br>An example of where this could occur is in a business application server, where<br>commonly used data is cached for fast retrieval in static fields. The ReaderWriter<br>
<b>Threading</b><br>
LockSlim  class  is  designed  to  provide  maximum-availability  locking  in  just  this<br>scenario.<br>
ReaderWriterLockSlim was introduced in Framework 3.5 and is<br>a replacement for the older "fat" ReaderWriterLock class. The<br>latter is similar in functionality, but it is several times slower and<br>has an inherent design fault in its mechanism for handling lock<br>upgrades.<br>
When  compared  to  an  ordinary  lock  (Monitor.Enter/Exit),<br>ReaderWriterLockSlim is still twice as slow, though.<br>
With both classes, there are two basic kinds of lock--a read lock and a write lock:<br>
· A write lock is universally exclusive.<br>· A read lock is compatible with other read locks.<br>
So, a thread holding a write lock blocks all other threads trying to obtain a read <i>or<br></i>write lock (and vice versa). But if no thread holds a write lock, any number of threads<br>may concurrently obtain a read lock.<br>
ReaderWriterLockSlim  defines  the  following  methods  for  obtaining  and  releasing<br>read/write locks:<br>
public void EnterReadLock();<br>public void ExitReadLock();<br>public void EnterWriteLock();<br>public void ExitWriteLock();<br>
Additionally, there are "Try" versions of all Enter<i>XXX</i> methods that accept timeout<br>arguments in the style of Monitor.TryEnter (timeouts can occur quite easily if the<br>resource is heavily contended). ReaderWriterLock provides similar methods, named<br>Acquire<i>XXX</i> and Release<i>XXX</i>. These throw an ApplicationException if a timeout oc-<br>curs, rather than returning false.<br>
<b>Reader/Writer Locks | 865</b><br>
<hr>
<A name=886></a>The following program demonstrates ReaderWriterLockSlim. Three threads contin-<br>ually enumerate a list, while two further threads append a random number to the<br>list every second. A read lock protects the list readers, and a write lock protects the<br>list writers:<br>
class SlimDemo<br>{<br>  <b>static ReaderWriterLockSlim _rw = new ReaderWriterLockSlim();<br></b>  static List&lt;int&gt; _items = new List&lt;int&gt;();<br>
  static Random _rand = new Random();<br>
  static void Main()<br>
  {<br>    new Thread (Read).Start();<br>
    new Thread (Read).Start();<br>
    new Thread (Read).Start();<br>
    new Thread (Write).Start (&quot;A&quot;);<br>    new Thread (Write).Start (&quot;B&quot;);<br>
  }<br>
  static void Read()<br>  {<br>
    while (true)<br>
    {<br>
      <b>_rw.EnterReadLock();</b><br>
      foreach (int i in _items) Thread.Sleep (10);<br>
      <b>_rw.ExitReadLock();<br></b>    }<br>
  }<br>
  static void Write (object threadID)<br>  {<br>    while (true)<br>    {<br>      int newNumber = GetRandNum (100);<br>      <b>_rw.EnterWriteLock();<br></b>      _items.Add (newNumber);<br>      <b>_rw.ExitWriteLock();<br></b>      Console.WriteLine (&quot;Thread &quot; + threadID + &quot; added &quot; + newNumber);<br>      Thread.Sleep (100);<br>    }<br>  }<br>
  static int GetRandNum (int max) { lock (_rand) return _rand.Next(max); }<br>}<br>
In production code, you'd typically add try/finally blocks to<br>ensure that locks were released if an exception was thrown.<br>
<b>866 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=887></a>Here's the result:<br>
Thread B added 61<br>
Thread A added 83<br>
Thread B added 55<br>Thread A added 33<br>...<br>
ReaderWriterLockSlim  allows  more  concurrent  Read  activity  than  a  simple  lock<br>would. We can illustrate this by inserting the following line in the Write method, at<br>the start of the while loop:<br>
Console.WriteLine (_rw.CurrentReadCount + &quot; concurrent readers&quot;);<br>
This nearly always prints "3 concurrent readers" (the Read methods spend most of<br>their time inside the foreach loops). As well as CurrentReadCount, ReaderWriterLock<br>
<b>Threading</b><br>
Slim provides the following properties for monitoring locks:<br>
public bool IsReadLockHeld            { get; }<br>
public bool IsUpgradeableReadLockHeld { get; }<br>
public bool IsWriteLockHeld           { get; }<br>
public int  WaitingReadCount          { get; }<br>
public int  WaitingUpgradeCount       { get; }<br>
public int  WaitingWriteCount         { get; }<br>
public int  RecursiveReadCount        { get; }<br>
public int  RecursiveUpgradeCount     { get; }<br>public int  RecursiveWriteCount       { get; }<br>
<b>Upgradeable Locks and Recursion<br></b>Sometimes it's useful to swap a read lock for a write lock in a single atomic operation.<br>For instance, suppose you want to add an item to a list only if the item wasn't already<br>present. Ideally, you'd want to minimize the time spent holding the (exclusive) write<br>lock, so you might proceed as follows:<br>
1. Obtain a read lock.<br>2. Test if the item is already present in the list, and if so, release the lock and return.<br>3. Release the read lock.<br>4. Obtain a write lock.<br>5. Add the item.<br>
The problem is that another thread could sneak in and modify the list (e.g., adding<br>the same item) between steps 3 and 4. ReaderWriterLockSlim addresses this through<br>a third kind of lock called an <i>upgradeable lock</i>. An upgradeable lock is like a read<br>lock except that it can later be promoted to a write lock in an atomic operation.<br>Here's how you use it:<br>
1. Call EnterUpgradeableReadLock.<br>2. Perform read-based activities (e.g., test whether the item is already present in<br>
the list).<br>
<b>Reader/Writer Locks | 867</b><br>
<hr>
<A name=888></a>3. Call EnterWriteLock (this converts the upgradeable lock to a write lock).<br>4. Perform write-based activities (e.g., add the item to the list).<br>5. Call ExitWriteLock (this converts the write lock back to an upgradeable lock).<br>6. Perform any other read-based activities.<br>7. Call ExitUpgradeableReadLock.<br>
From the caller's perspective, it's rather like nested or recursive locking. Function-<br>ally, though, in step 3, ReaderWriterLockSlim releases your read lock and obtains a<br>fresh write lock, atomically.<br>
There's another important difference between upgradeable locks and read locks.<br>While an upgradeable lock can coexist with any number of <i>read</i> locks, only one<br>upgradeable lock can itself be taken out at a time. This prevents conversion dead-<br>locks by <i>serializing</i> competing conversions--just as update locks do in SQL Server:<br>
<b>SQL Server</b><br>
<b>ReaderWriterLockSlim</b><br>
Share lock<br>
Read lock<br>
Exclusive lock<br>
Write lock<br>
Update lock<br>
Upgradeable lock<br>
We can demonstrate an upgradeable lock by changing the Write method in the pre-<br>ceding example such that it adds a number to list only if not already present:<br>
while (true)<br>
{<br>  int newNumber = GetRandNum (100);<br>
  <b>_rw.EnterUpgradeableReadLock();<br></b>  if (!_items.Contains (newNumber))<br>  {<br>    <b>_rw.EnterWriteLock();<br></b>    _items.Add (newNumber);<br>    <b>_rw.ExitWriteLock();</b><br>
    Console.WriteLine (&quot;Thread &quot; + threadID + &quot; added &quot; + newNumber);<br>  }<br>  <b>_rw.ExitUpgradeableReadLock();<br></b>  Thread.Sleep (100);<br>}<br>
ReaderWriterLock can also do lock conversions--but unreliably<br>because it doesn't support the concept of upgradeable locks.<br>This is why the designers of ReaderWriterLockSlim had to start<br>afresh with a new class.<br>
<b>Lock recursion<br></b>Ordinarily,  nested  or  recursive  locking  is  prohibited  with  ReaderWriterLockSlim.<br>Hence, the following throws an exception:<br>
<b>868 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=889></a>var rw = new ReaderWriterLockSlim();<br>
rw.EnterReadLock();<br>rw.EnterReadLock();<br>rw.ExitReadLock();<br>
rw.ExitReadLock();<br>
It runs without error, however, if you construct ReaderWriterLockSlim as follows:<br>
var rw = new ReaderWriterLockSlim (<b>LockRecursionPolicy.SupportsRecursion</b>);<br>
This ensures that recursive locking can happen only if you plan for it. Recursive<br>locking can create undesired complexity because it's possible to acquire more than<br>one kind of lock:<br>
rw.EnterWriteLock();<br>rw.EnterReadLock();<br>
<b>Threading</b><br>
Console.WriteLine (rw.IsReadLockHeld);     // True<br>
Console.WriteLine (rw.IsWriteLockHeld);    // True<br>
rw.ExitReadLock();<br>
rw.ExitWriteLock();<br>
The basic rule is that once you've acquired a lock, subsequent recursive locks can<br>be less, but not greater, on the following scale:<br>
Read LockUpgradeable LockWrite Lock<br>
A request to promote an upgradeable lock to a write lock, however, is always legal.<br>
<b>Timers<br></b>If you need to execute some method repeatedly at regular intervals, the easiest way<br>is  with  a  <i>timer</i>.  Timers  are  convenient  and  efficient  in  their  use  of  memory  and<br>resources--compared with techniques such as the following:<br>
new Thread (delegate() {<br>                         while (<i>enabled</i>)<br>                         {<br>                           <i>DoSomeAction</i>();<br>                           Thread.Sleep (TimeSpan.FromHours (24));<br>                         }<br>                       }).Start();<br>
Not only does this permanently tie up a thread resource, but without additional<br>coding,  DoSomeAction  will  happen  at  a  later  time  each  day.  Timers  solve  these<br>problems.<br>
The  .NET  Framework  provides  four  timers.  Two  of  these  are  general-purpose<br>multithreaded timers:<br>
· System.Threading.Timer<br>· System.Timers.Timer<br>
The other two are special-purpose single-threaded timers:<br>
· System.Windows.Forms.Timer (Windows Forms timer)<br>· System.Windows.Threading.DispatcherTimer (WPF timer)<br>
<b>Timers | 869</b><br>
<hr>
<A name=890></a>The  multithreaded  timers  are  more  powerful,  accurate,  and  flexible;  the  single-<br>threaded timers are safer and more convenient for running simple tasks that update<br>Windows Forms controls or WPF elements.<br>
<b>Multithreaded Timers<br></b>System.Threading.Timer is the simplest multithreaded timer: it has just a constructor<br>and two methods (a delight for minimalists, as well as book authors!). In the fol-<br>lowing example, a timer calls the Tick method, which writes "tick..." after five sec-<br>onds have elapsed, and then every second after that, until the user presses Enter:<br>
using System;<br>
using System.Threading;<br>
class Program<br>
{<br>  static void Main()<br>  {<br>
    // First interval = 5000ms; subsequent intervals = 1000ms<br>
    <b>Timer tmr = new Timer (Tick, &quot;tick...&quot;, 5000, 1000);</b><br>
    Console.ReadLine();<br>    tmr.Dispose();         // This both stops the timer and cleans up.<br>  }<br>
  static void Tick (object data)<br>
  {<br>    // This runs on a pooled thread<br>    Console.WriteLine (data);          // Writes &quot;tick...&quot;<br>  }<br>}<br>
You can change a timer's interval later by calling its Change method. If you want a<br>timer to fire just once, specify Timeout.Infinite in the constructor's last argument.<br>The  .NET  Framework  provides  another  timer  class  of  the  same  name  in  the<br>System.Timers namespace. This simply wraps the System.Threading.Timer, provid-<br>ing additional convenience while using the identical underlying engine. Here's a<br>summary of its added features:<br>
· A Component implementation, allowing it to be sited in Visual Studio's designer<br>· An Interval property instead of a Change method<br>· An Elapsed <i>event</i> instead of a callback delegate<br>· An Enabled property to start and stop the timer (its default value being false)<br>· Start and Stop methods in case you're confused by Enabled<br>· An AutoReset flag for indicating a recurring event (default value is true)<br>· A  SynchronizingObject  property  with  Invoke  and  BeginInvoke  methods  for<br>
safely calling methods on WPF elements and Windows Forms controls<br>
Here's an example:<br>
using System;<br>using System.Timers;   // Timers namespace rather than Threading<br>
<b>870 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=891></a>class SystemTimer<br>
{<br>  static void Main()<br>  {<br>
    Timer tmr = new Timer();       // Doesn't require any args<br>
    tmr.Interval = 500;<br>    tmr.Elapsed += tmr_Elapsed;    // Uses an event instead of a delegate<br>    tmr.Start();                   // Start the timer<br>
    Console.ReadLine();<br>
    tmr.Stop();                    // Stop the timer<br>    Console.ReadLine();<br>    tmr.Start();                   // Restart the timer<br>
    Console.ReadLine();<br>
    tmr.Dispose();                 // Permanently stop the timer<br>
<b>Threading</b><br>
  }<br>
  static void tmr_Elapsed (object sender, EventArgs e)<br>  {<br>
    Console.WriteLine (&quot;Tick&quot;);<br>  }<br>
}<br>
Multithreaded timers use the thread pool to allow a few threads to serve many timers.<br>This means that the callback method or Tick event may fire on a different thread<br>each time it is called. Furthermore, a Tick always fires (approximately) on time--<br>regardless of whether the previous Tick has finished executing. Hence, callbacks or<br>event handlers must be thread-safe.<br>
The precision of multithreaded timers depends on the operating system, and is typ-<br>ically in the 10­20 ms region. If you need greater precision, you can use native interop<br>and call the Windows multimedia timer. This has precision down to 1 ms and it is<br>defined in <i>winmm.dll</i>. First call timeBeginPeriod to inform the operating system that<br>you need high timing precision, and then call timeSetEvent to start a multimedia<br>timer. When you're done, call timeKillEvent to stop the timer and timeEndPeriod to<br>inform the OS that you no longer need high timing precision. Chapter 25 demon-<br>strates calling external methods with P/Invoke. You can find complete examples on<br>the Internet that use the multimedia timer by searching for the keywords <i>dllimport<br>winmm.dll timesetevent</i>.<br>
<b>Single-Threaded Timers<br></b>The .NET Framework provides timers designed to eliminate thread-safety issues for<br>WPF and Windows Forms applications:<br>
· System.Windows.Threading.DispatcherTimer (WPF)<br>· System.Windows.Forms.Timer (Windows Forms)<br>
The  single-threaded  timers  are  not  designed  to  work  outside<br>their  respective  environments.  If  you  use  a  Windows  Forms<br>timer  in  a  Windows  Service  application,  for  instance,  the<br>Timer event won't fire!<br>
<b>Timers | 871</b><br>
<hr>
<A name=892></a>Both are like System.Timers.Timer in the members that they expose (Interval, Tick,<br>Start, and Stop) and are used in a similar manner. However, they differ in how they<br>work internally. Instead of using the thread pool to generate timer events, the WPF<br>and Windows Forms timers rely on the message pumping mechanism of their un-<br>derlying user interface model. This means that the Tick event always fires on the<br>same thread that originally created the timer--which, in a normal application, is the<br>same thread used to manage all user interface elements and controls. This has a<br>number of benefits:<br>
· You can forget about thread safety.<br>· A fresh Tick will never fire until the previous Tick has finished processing.<br>· You can update user interface elements and controls directly from Tick event<br>
handling code, without calling Control.Invoke or Dispatcher.Invoke.<br>
It sounds too good to be true, until you realize that a program employing these timers<br>is  not  really  multithreaded--<i>there  is  no  parallel  execution</i>.  One  thread  serves  all<br>timers--as well as the processing UI events. This brings us to the disadvantage of<br>single-threaded timers:<br>
· Unless  the  Tick  event  handler  executes  quickly,  the  user  interface  becomes<br>
unresponsive.<br>
This makes the WPF and Windows Forms timers suitable for only small jobs, typ-<br>ically those that involve updating some aspect of the user interface (e.g., a clock or<br>countdown display). Otherwise, you need a multithreaded timer.<br>
In terms of precision, the single-threaded timers are similar to the multithreaded<br>timers (tens of milliseconds), although they are typically less <i>accurate</i>, because they<br>can  be  delayed  while  other  user  interface  requests  (or  other  timer  events)  are<br>processed.<br>
<b>872 | Chapter 21:</b><b>Threading</b><br>
<hr>
<A name=893></a><b>22</b><br>
<b>Parallel Programming</b><br>
In this chapter, we cover the multithreading APIs and constructs aimed at leveraging<br>multicore processors:<br>
· Parallel LINQ or <i>PLINQ<br></i>· The Parallel class<br>· The <i>task parallelism</i> constructs<br>· The <i>concurrent collections<br></i>· SpinLock and SpinWait<br>
These are new to Framework 4.0 and are collectively known (loosely) as PFX (Par-<br>allel Framework). The Parallel class together with the task parallelism constructs<br>is called the <i>Task Parallel Library</i> or TPL.<br>
Framework  4.0  also  adds  a  number  of  lower-level  threading  constructs  that  are<br>aimed  equally  at  traditional  multithreading.  We  covered  these  in  the  previous<br>chapter:<br>
· The low-latency signaling constructs:<br>
-- SemaphoreSlim (see the section "Locking" on page 808)<br>-- ManualResetEventSlim  (see  the  section  "Signaling  with  Event  Wait  Han-<br>
dles" on page 832)<br>
-- CountdownEvent  (see  the  section  "Signaling  with  Event  Wait  Han-<br>
dles" on page 832)<br>
-- Barrier (see the section "The Barrier Class" on page 849)<br>
· Cancellation tokens for cooperative cancellation (see the section "Safe Cancel-<br>
lation" on page 857)<br>
· The  lazy  initialization  classes  (see  the  section  "Lazy  Initialization"<br>
on page 860)<br>
· ThreadLocal&lt;T&gt; (see the section "Thread-Local Storage" on page 862)<br>
<b>873</b><br>
<hr>
<A name=894></a>You'll need to be comfortable with the fundamentals in Chapter 21 before reading<br>this chapter--particularly locking and thread safety.<br>
<b>Why PFX?<br></b>In recent times, CPU clock speeds have stagnated and manufacturers have shifted<br>their focus to increasing core counts. This is problematic for us as programmers<br>because our standard single-threaded code will not automatically run faster as a<br>result of those extra cores.<br>
Leveraging multiple cores is easy for most server applications, where each thread<br>can independently handle a separate client request, but is harder on the desktop--<br>because it typically requires that you take your computationally intensive code and<br>do the following:<br>
1. <i>Partition</i> it into small chunks.<br>2. Execute those chunks in parallel via multithreading.<br>3. <i>Collate</i> the results as they become available, in a thread-safe and performant<br>
manner.<br>
Although  you  can  do  all  of  this  with  the  classic  multithreading  constructs,  it's<br>awkward--particularly the steps of partitioning and collating. A further problem is<br>that the usual strategy of locking for thread safety causes a lot of contention when<br>many threads work on the same data at once.<br>
The PFX libraries have been designed specifically to help in these scenarios.<br>
Programming to leverage multicores or multiple processors is<br>called  <i>parallel  programming</i>.  This  is  a  subset  of  the  broader<br>concept of multithreading.<br>
<b>PFX Concepts<br></b>There are two strategies for partitioning work among threads: <i>data parallelism</i> and<br><i>task parallelism</i>.<br>
When a set of tasks must be performed on many data values, we can parallelize by<br>having each thread perform the (same) set of tasks on a subset of values. This is<br>called  <i>data  parallelism</i>  because  we  are  partitioning  the  <i>data</i>  between  threads.  In<br>contrast, with <i>task parallelism</i> we partition the <i>tasks</i>; in other words, we have each<br>thread perform a different task.<br>
In general, data parallelism is easier and scales better to highly parallel hardware,<br>because  it  reduces  or  eliminates  shared  data  (thereby  reducing  contention  and<br>thread-safety issues). Also, data parallelism leverages the fact that there are often<br>more data values than discrete tasks, increasing the parallelism potential.<br>
<b>874 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=895></a>Data parallelism is also conducive to <i>structured parallelism</i>, which means that par-<br>allel work units start and finish in the same place in your program. In contrast, task<br>parallelism tends to be unstructured, meaning that parallel work units may start and<br>finish in places scattered across your program. Structured parallelism is simpler and<br>less error-prone and allows you to farm the difficult job of partitioning and thread<br>coordination (and even result collation) out to libraries.<br>
<b>PFX Components<br></b>PFX comprises two layers of functionality, as shown in Figure 22-1. The higher layer<br>consists of two <i>structured data parallelism</i> APIs: PLINQ and the Parallel class. The<br>lower layer contains the task parallelism classes--plus a set of additional constructs<br>to help with parallel programming activities.<br>
<b>Programming</b><br>
<b>Parallel</b><br>
<i>Figure 22-1. PFX components</i><br>
PLINQ offers the richest functionality: it automates all the steps of parallelization--<br>including partitioning the work into tasks, executing those tasks on threads, and<br>collating the results into a single output sequence. It's called <i>declarative</i>--because<br>you simply declare that you want to parallelize your work (which you structure as<br>a LINQ query), and let the Framework take care of the implementation details. In<br>contrast, the other approaches are <i>imperative</i>, in that you need to explicitly write<br>code to partition or collate. In the case of the Parallel class, you must collate results<br>yourself; with the task parallelism constructs, you must partition the work yourself,<br>too:<br>
<b>Why PFX? | 875</b><br>
<hr>
<A name=896></a><b> </b><br>
<b>Partitions work</b><br>
<b>Collates results</b><br>
PLINQ<br>
Yes<br>
Yes<br>
The Parallel class<br>
Yes<br>
No<br>
PFX's task parallelism<br>
No<br>
No<br>
The concurrent collections and spinning primitives help you with lower-level par-<br>allel programming activities. These are important because PFX has been designed<br>to work not only with today's hardware, but also with future generations of pro-<br>cessors with far more cores. If you want to move a pile of chopped wood and you<br>have 32 workers to do the job, the biggest challenge is moving the wood without<br>the workers getting in each other's way. It's the same with dividing an algorithm<br>among 32 cores: if ordinary locks are used to protect common resources, the resul-<br>tant blocking may mean that only a fraction of those cores are ever actually busy at<br>once. The concurrent collections are tuned specifically for highly concurrent access,<br>with the focus on minimizing or eliminating blocking. PLINQ and the Parallel class<br>themselves rely on the concurrent collections and on spinning primitives for efficient<br>management of work.<br>
<b>PFX and Traditional Multithreading</b><br>
A traditional multithreading scenario is one where multithreading can be of benefit<br>even on a single-core machine--with no true <i>parallelization</i> taking place. We cov-<br>ered these in the previous chapter: they include such tasks as maintaining a re-<br>sponsive user interface and downloading two web pages at once.<br>
Some of the constructs that we'll cover in this chapter are also sometimes useful<br>in traditional multithreading. In particular:<br>
· PLINQ and the Parallel class are useful whenever you want to execute op-<br>
erations in parallel and then wait for them to complete (<i>structured</i> parallel-<br>ism). This includes non-CPU-intensive tasks such as calling a web service.<br>
· The task parallelism constructs are useful when you want to run some oper-<br>
ation on a pooled thread (we introduced this in the previous chapter), and<br>also to manage a task's workflow through continuations and parent/child<br>tasks.<br>
· The  concurrent  collections  are  sometimes  appropriate  when  you  want  a<br>
thread-safe queue, stack, or dictionary.<br>
· BlockingCollection  provides  an  easy  means  to  implement  producer/<br>
consumer structures.<br>
<b>When to Use PFX<br></b>The primary use case for PFX is <i>parallel programming</i>: leveraging multicore pro-<br>cessors to speed up computationally intensive code.<br>
A challenge in leveraging multicores is Amdahl's law, which states that the maxi-<br>mum performance improvement from parallelization is governed by the portion of<br>
<b>876 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=897></a>the code that must execute sequentially. For instance, if only two-thirds of an algo-<br>rithm's execution time is parallelizable, you can never exceed a threefold perform-<br>ance gain--even with an infinite number of cores.<br>
So, before proceeding, it's worth verifying that the bottleneck is in parallelizable<br>code. It's also worth considering whether your code <i>needs</i> to be computationally<br>intensive--optimization is often the easiest and most effective approach. There's a<br>trade-off, though, in that some optimization techniques can make it harder to par-<br>allelize code.<br>
The easiest gains come with what's called <i>embarrassingly parallel</i> problems--where<br>a job can be divided easily into tasks that execute efficiently on their own (structured<br>parallelism is very well suited to such problems). Examples include many image<br>processing tasks, ray tracing, and brute force approaches in mathematics or cryp-<br>tography. An example of a nonembarrassingly parallel problem is implementing an<br>optimized version of the quicksort algorithm--a good result takes some thought<br>and may require unstructured parallelism.<br>
<b>PLINQ</b><br>
<b>Programming</b><br>
<b>Parallel</b><br>
PLINQ automatically parallelizes local LINQ queries. PLINQ has the advantage of<br>being easy to use in that it offloads the burden of both work partitioning and result<br>collation to the Framework.<br>
To use PLINQ, simply call AsParallel() on the input sequence and then continue<br>the LINQ query as usual. The following query calculates the prime numbers between<br>3 and 100,000--making full use of all cores on the target machine:<br>
// Calculate prime numbers using a simple (unoptimized) algorithm.<br>
IEnumerable&lt;int&gt; numbers = Enumerable.Range (3, 100000-3);<br>
var parallelQuery =<br>  from n in numbers<b>.AsParallel()<br></b>  where Enumerable.Range (2, (int) Math.Sqrt (n)).All (i =&gt; n % i &gt; 0)<br>  select n;<br>
int[] primes = parallelQuery.ToArray();<br>
AsParallel is an extension method in System.Linq.ParallelEnumerable. It wraps the<br>input in a sequence based on ParallelQuery&lt;TSource&gt;, which causes the LINQ query<br>operators that you subsequently call to bind to an alternate set of extension methods<br>defined in ParallelEnumerable. These provide parallel implementations of each of<br>the standard query operators. Essentially, they work by partitioning the input se-<br>quence into chunks that execute on different threads, collating the results back into<br>a single output sequence for consumption (see Figure 22-2).<br>
Calling AsSequential() unwraps a ParallelQuery sequence so that subsequent query<br>operators bind to the standard query operators and execute sequentially. This is<br>necessary before calling methods that have side effects or are not thread-safe.<br>
<b>PLINQ | 877</b><br>
<hr>
<A name=898></a><i>Figure 22-2. PLINQ execution model</i><br>
For query operators that accept two input sequences (Join, GroupJoin, Concat, Union,<br>Intersect, Except, and Zip), you must apply AsParallel() to both input sequences<br>(otherwise, an exception is thrown). You don't, however, need to keep applying<br>AsParallel to a query as it progresses, because PLINQ's query operators output<br>another ParallelQuery sequence. In fact, calling AsParallel again introduces ineffi-<br>ciency in that it forces merging and repartitioning of the query:<br>
mySequence.AsParallel()           // Wraps sequence in ParallelQuery&lt;int&gt;<br>          .Where (n =&gt; n &gt; 100)   // Outputs another ParallelQuery&lt;int&gt;<br>
          <b>.AsParallel()           // Unnecessary - and inefficient!<br></b>          .Select (n =&gt; n * n)<br>
Not all query operators can be effectively parallelized. For those that cannot (see<br>"PLINQ Limitations" on page 880), PLINQ implements the operator sequentially<br>instead. PLINQ may also operate sequentially if it suspects that the overhead of<br>parallelization will actually slow a particular query.<br>
PLINQ is only for local collections: it doesn't work with LINQ to SQL or Entity<br>Framework because in those cases the LINQ translates into SQL, which then exe-<br>cutes on a database server. However, you <i>can</i> use PLINQ to perform additional local<br>querying on the result sets obtained from database queries.<br>
If  a  PLINQ  query  throws  an  exception,  it's  rethrown  as  an<br>AggregateException whose InnerExceptions property contains<br>the real exception (or exceptions). See "Working with Aggre-<br>gateException" on page 912 for more details.<br>
<b>878 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=899></a><b>Why Isn't AsParallel the Default?</b><br>
Given that AsParallel transparently parallelizes LINQ queries, the question arises,<br>"Why didn't Microsoft simply parallelize the standard query operators and make<br>PLINQ the default?"<br>
There are a number of reasons for the <i>opt-in</i> approach. First, for PLINQ to be<br>useful, there has to be a reasonable amount of computationally intensive work for<br>it  to  farm  out  to  worker  threads.  Most  LINQ  to  Objects  queries  execute  very<br>quickly, and not only would parallelization be unnecessary, but the overhead of<br>partitioning, collating, and coordinating the extra threads may actually slow things<br>down.<br>
Additionally:<br>
· The output of a PLINQ query (by default) may differ from a LINQ query with<br>
respect to element ordering (see "PLINQ and Ordering" on page 880).<br>
· PLINQ wraps exceptions in an AggregateException (to handle the possibility<br>
of multiple exceptions being thrown).<br>
<b>Programming</b><br>
· PLINQ  will  give  unreliable  results  if  the  query  invokes  thread-unsafe<br>
<b>Parallel</b><br>
methods.<br>
Finally, PLINQ offers quite a few hooks for tuning and tweaking. Burdening the<br>standard LINQ to Objects API with such nuances would add distraction.<br>
<b>Parallel Execution Ballistics<br></b>Like ordinary LINQ queries, PLINQ queries are lazily evaluated. This means that<br>execution is triggered only when you begin consuming the results--typically via a<br>foreach loop (although it may also be via a conversion operator such as ToArray or<br>an operator that returns a single element or value).<br>
As  you  enumerate  the  results,  though,  execution  proceeds  somewhat  differently<br>from that of an ordinary sequential query. A sequential query is powered entirely by<br>the consumer in a "pull" fashion: each element from the input sequence is fetched<br>exactly when required by the consumer. A parallel query ordinarily uses independent<br>threads to fetch elements from the input sequence slightly <i>ahead</i> of when they're<br>needed by the consumer (rather like a teleprompter for newsreaders, or an antiskip<br>buffer in CD players). It then processes the elements in parallel through the query<br>chain, holding the results in a small buffer so that they're ready for the consumer on<br>demand. If the consumer pauses or breaks out of the enumeration early, the query<br>processor also pauses or stops so as not to waste CPU time or memory.<br>
<b>PLINQ | 879</b><br>
<hr>
<A name=900></a>You  can  tweak  PLINQ's  buffering  behavior  by  calling<br>WithMergeOptions  after  AsParallel.  The  default  value  of<br>AutoBuffered  generally  gives  the  best  overall  results.<br>NotBuffered  disables  the  buffer  and  is  useful  if  you  want  to<br>see results as soon as possible; FullyBuffered caches the entire<br>result  set  before  presenting  it  to  the  consumer  (the  OrderBy<br>and Reverse operators naturally work this way, as do the ele-<br>ment, aggregation, and conversion operators).<br>
<b>PLINQ and Ordering<br></b>A side effect of parallelizing the query operators is that when the results are collated,<br>it's not necessarily in the same order that they were submitted (see Figure 22-2). In<br>other words, LINQ's normal order-preservation guarantee for sequences no longer<br>holds.<br>
If you need order preservation, force it by calling AsOrdered() after AsParallel():<br>
myCollection.AsParallel().AsOrdered()...<br>
Calling AsOrdered incurs a performance hit with large numbers of elements because<br>PLINQ must keep track of each element's original position.<br>
You can negate the effect of AsOrdered later in a query by calling AsUnordered: this<br>introduces a "random shuffle point," which allows the query to execute more effi-<br>ciently from that point on. So if you wanted to preserve input-sequence ordering for<br>just the first two query operators, you'd do this:<br>
inputSequence.AsParallel()<b>.AsOrdered()<br></b>  <i>.QueryOperator1</i>()<br>  <i>.QueryOperator2</i>()<br>  <b>.AsUnordered()</b>       // From here on, ordering doesn't matter<br>  .<i>QueryOperator3</i>()<br>  ...<br>
AsOrdered is not the default because for most queries, the original input ordering<br>doesn't matter. In other words, if AsOrdered was the default, you'd have to apply<br>AsUnordered to the majority of your parallel queries to get the best performance,<br>which would be burdensome.<br>
<b>PLINQ Limitations<br></b>There are currently some practical limitations on what PLINQ can parallelize. These<br>limitations may loosen with subsequent service packs and Framework versions.<br>
The following query operators prevent a query from being parallelized, unless the<br>source elements are in their original indexing position:<br>
· Take, TakeWhile, Skip, and SkipWhile<br>· The indexed versions of Select, SelectMany, and ElementAt<br>
<b>880 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=901></a>Most query operators change the indexing position of elements (including those that<br>remove elements, such as Where). This means that if you want to use the preceding<br>operators, they'll usually need to be at the start of the query.<br>
The following query operators are parallelizable, but use an expensive partitioning<br>strategy that can sometimes be slower than sequential processing:<br>
· Join, GroupBy, GroupJoin, Distinct, Union, Intersect, and Except<br>
The Aggregate operator's <i>seeded</i> overloads in their standard incarnations are not<br>parallelizable--PLINQ provides special overloads to deal with this (see "Optimizing<br>PLINQ" on page 886).<br>
All other operators are parallelizable, although use of these operators doesn't guar-<br>antee that your query will be parallelized. PLINQ may run your query sequentially<br>if it suspects that the overhead of parallelization will slow down that particular query.<br>You can override this behavior and force parallelism by calling the following after<br>AsParallel():<br>
.WithExecutionMode (ParallelExecutionMode.ForceParallelism)<br>
<b>Programming</b><br>
<b>Example: Parallel Spellchecker</b><br>
<b>Parallel</b><br>
Suppose we want to write a spellchecker that runs quickly with very large documents<br>by leveraging all available cores. By formulating our algorithm into a LINQ query,<br>we can very easily parallelize it.<br>
The first step is to download a dictionary of English words into a HashSet for efficient<br>lookup:<br>
if (!File.Exists (&quot;WordLookup.txt&quot;))    // Contains about 150,000 words<br>  new WebClient().DownloadFile (<br>    &quot;http://www.albahari.com/ispell/allwords.txt&quot;, &quot;WordLookup.txt&quot;);<br>
var wordLookup = new HashSet&lt;string&gt; (<br>  File.ReadAllLines (&quot;WordLookup.txt&quot;),<br>  StringComparer.InvariantCultureIgnoreCase);<br>
We'll then use our word lookup to create a test "document" comprising an array of<br>1 million random words. After building the array, we'll introduce a couple of spelling<br>mistakes:<br>
var random = new Random();<br>string[] wordList = wordLookup.ToArray();<br>
string[] wordsToTest = Enumerable.Range (0, 1000000)<br>  .Select (i =&gt; wordList [random.Next (0, wordList.Length)])<br>  .ToArray();<br>
wordsToTest [12345] = &quot;woozsh&quot;;     // Introduce a couple<br>wordsToTest [23456] = &quot;wubsie&quot;;     // of spelling mistakes.<br>
Now  we  can  perform  our  parallel  spellcheck  by  testing  wordsToTest  against<br>wordLookup. PLINQ makes this very easy:<br>
<b>PLINQ | 881</b><br>
<hr>
<A name=902></a>var query = wordsToTest<br>
  <b>.AsParallel()<br></b>  .Select  ((word, index) =&gt; new IndexedWord { Word=word, Index=index })<br>  .Where   (iword =&gt; !wordLookup.Contains (iword.Word))<br>
  .OrderBy (iword =&gt; iword.Index);<br>
foreach (var mistake in query)<br>  Console.WriteLine (mistake.Word + &quot; - index = &quot; + mistake.Index);<br>
// OUTPUT:<br>// woozsh - index = 12345<br>// wubsie - index = 23456<br>
IndexedWord is a custom struct that we define as follows:<br>
struct IndexedWord { public string Word; public int Index; }<br>
The wordLookup.Contains method in the predicate gives the query some "meat" and<br>makes it worth parallelizing.<br>
We could simplify the query slightly by using an anonymous<br>type instead of the IndexedWord struct. However, this would de-<br>grade performance because anonymous types (being classes and<br>therefore reference types) incur the cost of heap-based alloca-<br>tion and subsequent garbage collection.<br>
The difference might not be enough to matter with sequential<br>queries, but with parallel queries, favoring stack-based alloca-<br>tion  can  be  quite  advantageous.  This  is  because  stack-based<br>allocation is highly parallelizable (as each thread has its own<br>stack), whereas all threads must compete for the same heap--<br>managed by a single memory manager and garbage collector.<br>
<b>Using ThreadLocal&lt;T&gt;<br></b>Let's extend our example by parallelizing the creation of the random test-word list<br>itself. We structured this as a LINQ query, so it should be easy. Here's the sequential<br>version:<br>
string[] wordsToTest = Enumerable.Range (0, 1000000)<br>  .Select (i =&gt; wordList [<b>random.Next</b> (0, wordList.Length)])<br>  .ToArray();<br>
Unfortunately, the call to random.Next is not thread-safe, so it's not as simple as<br>inserting AsParallel() into the query. A potential solution is to write a function that<br>locks around random.Next; however, this would limit concurrency. The better option<br>is to use ThreadLocal&lt;Random&gt; (see "Thread-Local Storage" on page 862 in the pre-<br>ceding  chapter)  to  create  a  separate  Random object for each thread. We can then<br>parallelize the query as follows:<br>
var localRandom = new ThreadLocal&lt;Random&gt;<br> ( <b>() =&gt; new Random (Guid.NewGuid().GetHashCode())</b> );<br>
string[] wordsToTest = Enumerable.Range (0, 1000000)<b>.AsParallel()</b><br>
<b>882 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=903></a>  .Select (i =&gt; wordList [<b>localRandom.Value.Next</b> (0, wordList.Length)])<br>
  .ToArray();<br>
In our factory function for instantiating a Random object, we pass in a Guid's hash<br>code to ensure that if two Random objects are created within a short period of time,<br>they'll yield different random number sequences.<br>
<b>When to Use PLINQ</b><br>
It's tempting to search your existing applications for LINQ queries and experiment<br>with parallelizing them. This is usually unproductive, because most problems for<br>which LINQ is obviously the best solution tend to execute very quickly and so<br>don't benefit from parallelization. A better approach is to find a CPU-intensive<br>bottleneck  and  then  consider,  "Can  this  be  expressed  as  a  LINQ  query?"  (A<br>welcome  side  effect  of  such  restructuring  is  that  LINQ  typically  makes  code<br>smaller and more readable.)<br>
PLINQ is well suited to embarrassingly parallel problems. It also works well for<br>structured blocking tasks, such as calling several web services at once (see "Calling<br>
<b>Programming</b><br>
Blocking or I/O-Intensive Functions" on page 884).<br>
<b>Parallel</b><br>
PLINQ can be a poor choice for imaging, because collating millions of pixels into<br>an output sequence creates a bottleneck. Instead, it's better to write pixels directly<br>to an array or unmanaged memory block and use the Parallel class or task par-<br>allelism to manage the multithreading. (It is possible, however, to defeat result<br>collation  using  ForAll--we  discuss  this  in  "Optimizing  PLINQ"  on  page  886.<br>Doing so makes sense if the image processing algorithm naturally lends itself to<br>LINQ.)<br>
<b>Functional Purity<br></b>Because PLINQ runs your query on parallel threads, you must be careful not to<br>perform  thread-unsafe  operations.  In  particular,  writing  to  variables  is  <i>side-<br>effecting</i> and therefore thread-unsafe:<br>
// The following query multiplies each element by its position.<br>// Given an input of Enumerable.Range(0,999), it should output squares.<br>int i = 0;<br>var query = from n in Enumerable.Range(0,999).AsParallel() select n * <b>i++</b>;<br>
We  could  make  incrementing  i  thread-safe  by  using  locks  or  Interlocked  (see<br>"Nonblocking  Synchronization"  on  page  825  in  the  preceding  chapter),  but  the<br>problem would still remain that i won't necessarily correspond to the position of<br>the input element. And adding AsOrdered to the query wouldn't fix the latter prob-<br>lem, because AsOrdered ensures only that the elements are output in an order con-<br>sistent with them having been processed sequentially--it doesn't actually <i>process<br></i>them sequentially.<br>
Instead, this query should be rewritten to use the indexed version of Select:<br>
var query = Enumerable.Range(0,999).AsParallel().Select ((n, i) =&gt; n * i);<br>
<b>PLINQ | 883</b><br>
<hr>
<A name=904></a>For best performance, any methods called from query operators should be thread-<br>safe by virtue of not writing to fields or properties (non-side-effecting, or <i>functionally<br>pure</i>). If they're thread-safe by virtue of <i>locking</i>, the query's parallelism potential will<br>be  limited--by  the  duration  of  the  lock  divided  by  the  total  time  spent  in  that<br>function.<br>
<b>Calling Blocking or I/O-Intensive Functions<br></b>Sometimes a query is long-running not because it's CPU-intensive, but because it<br><i>waits</i> on something--such as a web page to download or some hardware to respond.<br>PLINQ can effectively parallelize such queries, providing that you hint it by calling<br>WithDegreeOfParallelism after AsParallel. For instance, suppose we want to ping<br>six websites simultaneously. Rather than using clumsy asynchronous delegates or<br>manually spinning up six threads, we can accomplish this effortlessly with a PLINQ<br>query:<br>
from site in new[]<br>
{<br>  &quot;www.albahari.com&quot;,<br>
  &quot;www.linqpad.net&quot;,<br>
  &quot;www.oreilly.com&quot;,<br>
  &quot;www.google.com&quot;,<br>  &quot;www.takeonit.com&quot;,<br>
  &quot;stackoverflow.com&quot;<br>
}<br>.AsParallel()<b>.WithDegreeOfParallelism(6)<br></b>let p = new Ping().Send (site)<br>
select new<br>{<br>  site,<br>  Result = p.Status,<br>  Time = p.RoundtripTime<br>}<br>
WithDegreeOfParallelism forces PLINQ to run the specified number of tasks simul-<br>taneously. This is necessary when calling <i>blocking</i> functions such as Ping.Send be-<br>cause PLINQ otherwise assumes that the query is CPU-intensive and allocates tasks<br>accordingly. On a two-core machine, for instance, PLINQ may default to running<br>only two tasks at once, which is clearly undesirable in this situation.<br>
PLINQ typically serves each task with a thread, subject to allo-<br>cation by the thread pool. You can accelerate the initial ramping<br>up of threads by calling ThreadPool.SetMinThreads (see "Thread<br>Pooling" on page 800 in the preceding chapter).<br>
To give another example, suppose we were writing a surveillance system and wanted<br>to repeatedly combine images from four security cameras into a single composite<br>image for display on a CCTV. We'll represent a camera with the following class:<br>
<b>884 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=905></a>class Camera<br>
{<br>  public readonly int CameraID;<br>  public Camera (int cameraID) { CameraID = cameraID; }<br>
  // Get image from camera: return a simple string rather than an image<br>  public string GetNextFrame()<br>  {<br>
    Thread.Sleep (123);       // Simulate time taken to get snapshot<br>
    return &quot;Frame from camera &quot; + CameraID;<br>  }<br>}<br>
To obtain a composite image, we must call GetNextFrame on each of four camera<br>objects. Assuming the operation is I/O-bound, we can quadruple our frame rate with<br>parallelization--even on a single-core machine. PLINQ makes this possible with<br>minimal programming effort:<br>
Camera[] cameras = Enumerable.Range (0, 4)    // Create 4 camera objects.<br>
  .Select (i =&gt; new Camera (i))<br>
  .ToArray();<br>
<b>Programming</b><br>
<b>Parallel</b><br>
while (true)<br>
{<br>  string[] data = cameras<br>
    <b>.AsParallel().AsOrdered().WithDegreeOfParallelism (4)</b><br>
    .Select (c =&gt; c.GetNextFrame()).ToArray();<br>
  Console.WriteLine (string.Join (&quot;, &quot;, data));   // Display data...<br>}<br>
GetNextFrame is a blocking method, so we used WithDegreeOfParallelism to get the<br>desired concurrency. In our example, the blocking happens when we call Sleep; in<br>real life it would block because fetching an image from a camera is I/O-intensive<br>rather than CPU-intensive.<br>
Calling AsOrdered ensures the images are displayed in a consis-<br>tent order. Because there are only four elements in the sequence,<br>this would have a negligible effect on performance.<br>
<b>Changing the degree of parallelism<br></b>You can call WithDegreeOfParallelism only once within a PLINQ query. If you need<br>to call it again, you must force merging and repartitioning of the query by calling<br>IsParallel() again within the query:<br>
&quot;The Quick Brown Fox&quot;<br>  .AsParallel().WithDegreeOfParallelism (2)<br>  .Where (c =&gt; !char.IsWhiteSpace (c))<br>
  <b>.AsParallel().WithDegreeOfParallelism (3)   // Forces Merge + Partition<br></b>  .Select (c =&gt; char.ToUpper (c))<br>
<b>PLINQ | 885</b><br>
<hr>
<A name=906></a><b>Cancellation<br></b>Canceling a PLINQ query whose results you're consuming in a foreach loop is easy:<br>simply break out of the foreach and the query will be automatically canceled as the<br>enumerator is implicitly disposed.<br>
For a query that terminates with a conversion, element, or aggregation operator, you<br>can  cancel  it  from  another  thread  via  a  <i>cancellation  token</i>  (see  "Safe  Cancella-<br>tion" on page 857 in the preceding chapter for a discussion of cancellation tokens).<br>To  insert  a  token,  call  WithCancellation  after  calling  AsParallel,  passing  in  the<br>Token property of a CancellationTokenSource object. Another thread can then call<br>Cancel on the token source, which throws an OperationCanceledException on the<br>query's consumer:<br>
IEnumerable&lt;int&gt; million = Enumerable.Range (3, 1000000);<br>
<b>var cancelSource = new CancellationTokenSource();</b><br>
var primeNumberQuery =<br>
  from n in million.AsParallel()<b>.WithCancellation (cancelSource.Token)</b><br>
  where Enumerable.Range (2, (int) Math.Sqrt (n)).All (i =&gt; n % i &gt; 0)<br>  select n;<br>
new Thread (() =&gt; {<br>
                    Thread.Sleep (100);      // Cancel query after<br>
                    <b>cancelSource.Cancel();</b>   // 100 milliseconds.<br>
                  }<br>           ).Start();<br>
try<br>{<br>  // Start query running:<br>  int[] primes = primeNumberQuery.ToArray();<br>  // We'll never get here because the other thread will cancel us.<br>}<br>catch (<b>OperationCanceledException</b>)<br>{<br>  Console.WriteLine (&quot;Query canceled&quot;);<br>}<br>
PLINQ doesn't preemptively abort threads, because of the danger of doing so (see<br>"Interrupt and Abort" on page 855 in the preceding chapter). Instead, upon can-<br>cellation, it waits for each worker thread to finish with its current element before<br>ending the query. This means that any external methods that the query calls will run<br>to completion.<br>
<b>Optimizing PLINQ</b><br>
<b>Output-side optimization<br></b>One of PLINQ's advantages is that it conveniently collates the results from paral-<br>lelized work into a single output sequence. Sometimes, though, all that you end up<br>doing with that sequence is running some function once over each element:<br>
<b>886 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=907></a>foreach (int n in parallelQuery)<br>
  DoSomething (n);<br>
If this is the case--and you don't care about the order in which the elements are<br>processed--you can improve efficiency with PLINQ's ForAll method.<br>The ForAll method runs a delegate over every output element of a ParallelQuery. It<br>hooks right into PLINQ's internals, bypassing the steps of collating and enumerating<br>the results. To give a trivial example:<br>
&quot;abcdef&quot;.AsParallel().Select (c =&gt; char.ToUpper(c)).ForAll (Console.Write);<br>
Figure 22-3 shows the process.<br>
Collating and enumerating results is not a massively expensive<br>operation, so the ForAll optimization yields the greatest gains<br>when  there  are  large  numbers  of  quickly  executing  input<br>elements.<br>
<b>Programming</b><br>
<b>Parallel</b><br>
<i>Figure 22-3. PLINQ ForAll</i><br>
<b>Input-side optimization<br></b>PLINQ has three partitioning strategies for assigning input elements to threads:<br>
<b>Strategy</b><br>
<b>Element allocation</b><br>
<b>Relative performance</b><br>
Chunk partitioning<br>
Dynamic<br>
Average<br>
Range partitioning<br>
Static<br>
Poor to excellent<br>
Hash partitioning<br>
Static<br>
Poor<br>
For  query  operators  that  require  comparing  elements  (GroupBy,  Join,  GroupJoin,<br>Intersect, Except, Union, and Distinct), you have no choice: PLINQ always uses <br><i>hash partitioning</i>. Hash partitioning is relatively inefficient in that it must precalcu-<br>late the hash code of every element (so that elements with identical hash codes can<br>
<b>PLINQ | 887</b><br>
<hr>
<A name=908></a>be processed on the same thread). If you find this too slow, your only option is to<br>call AsSequential to disable parallelization.<br>For all other query operators, you have a choice as to whether to use range or chunk<br>partitioning. By default:<br>
· If  the  input  sequence  is  <i>indexable</i>  (if  it's  an  array  or  implements  IList&lt;T&gt;),<br>
PLINQ chooses <i>range partitioning</i>.<br>
· Otherwise, PLINQ chooses <i>chunk partitioning</i>.<br>
In a nutshell, range partitioning is faster with long sequences for which every element<br>takes a similar amount of CPU time to process. Otherwise, chunk partitioning is<br>usually faster.<br>
To force <i>range partitioning</i>:<br>
· If  the  query  starts  with  Enumerable.Range,  replace  the  latter  with<br>
ParallelEnumerable.Range.<br>
· Otherwise, simply call ToList or ToArray on the input sequence (obviously, this<br>
incurs a performance cost in itself which you should take into account).<br>
ParallelEnumerable.Range is not simply a shortcut for calling<br>Enumerable.Range(...).AsParallel().  It  changes  the  perform-<br>ance of the query by activating range partitioning.<br>
To force <i>chunk partitioning</i>, wrap the input sequence in a call to Partitioner.Cre<br>ate (in System.Collection.Concurrent) as follows:<br>
int[] numbers = { 3, 4, 5, 6, 7, 8, 9 };<br>var parallelQuery =<br>
  <b>Partitioner.Create (numbers, true)</b>.AsParallel()<br>  .Where (...)<br>
The  second  argument  to  Partitioner.Create  indicates  that  you  want  to  <i>load-<br>balance</i> the query, which is another way of saying that you want chunk partitioning.<br>
Chunk  partitioning  works  by  having  each  worker  thread  periodically  grab  small<br>"chunks" of elements from the input sequence to process (see Figure 22-4). PLINQ<br>starts by allocating very small chunks (one or two elements at a time), then increases<br>the chunk size as the query progresses: this ensures that small sequences are effec-<br>tively parallelized and large sequences don't cause excessive round-tripping. If a<br>worker happens to get "easy" elements (that process quickly) it will end up getting<br>more  chunks.  This  system  keeps  every  thread  equally  busy  (and  the  cores  "bal-<br>anced"); the only downside is that fetching elements from the shared input sequence<br>requires synchronization (typically an exclusive lock)--and this can result in some<br>overhead and contention.<br>
Range partitioning bypasses the normal input-side enumeration and preallocates an<br>equal number of elements to each worker, avoiding contention on the input se-<br>quence. But if some threads happen to get easy elements and finish early, they sit<br>idle  while  the  remaining  threads  continue  working.  Our  earlier  prime  number<br>
<b>888 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=909></a><b>Programming</b><br>
<b>Parallel</b><br>
<i>Figure 22-4. Chunk versus range partitioning</i><br>
calculator might perform poorly with range partitioning. An example of when range<br>partitioning would do well is in calculating the sum of the square roots of the first<br>10 million integers:<br>
ParallelEnumerable.Range (1, 10000000).Sum (i =&gt; Math.Sqrt (i))<br>
ParallelEnumerable.Range returns a ParallelQuery&lt;T&gt;, so you don't need to subse-<br>quently call AsParallel.<br>
Range partitioning doesn't necessarily allocate element ranges<br>in <i>contiguous</i> blocks--it might instead choose a "striping" strat-<br>egy. For instance, if there are two workers, one worker might<br>process  odd-numbered  elements  while  the  other  processes<br>even-numbered elements. The TakeWhile operator is almost cer-<br>tain  to  trigger  a  striping  strategy  to  avoid  unnecessarily  pro-<br>cessing elements later in the sequence.<br>
<b>Optimizing custom aggregations<br></b>PLINQ parallelizes the Sum, Average, Min, and Max operators efficiently without ad-<br>ditional intervention. The Aggregate operator, though, presents special challenges<br>for PLINQ. As described in Chapter 9, Aggregate performs custom aggregations. For<br>example, the following sums a sequence of numbers, mimicking the Sum operator:<br>
<b>PLINQ | 889</b><br>
<hr>
<A name=910></a>int[] numbers = { 1, 2, 3 };<br>
int sum = numbers.Aggregate (0, (total, n) =&gt; total + n);   // 6<br>
We also saw in Chapter 9 that for <i>unseeded</i> aggregations, the supplied delegate must<br>be associative and commutative. PLINQ will give incorrect results if this rule is vio-<br>lated, because it draws <i>multiple seeds</i> from the input sequence in order to aggregate<br>several partitions of the sequence simultaneously.<br>
Explicitly seeded aggregations might seem like a safe option with PLINQ, but un-<br>fortunately these ordinarily execute sequentially because of the reliance on a single<br>seed. To mitigate this, PLINQ provides another overload of Aggregate that lets you<br>specify multiple seeds--or rather, a <i>seed factory function</i>. For each thread, it executes<br>this function to generate a separate seed, which becomes a <i>thread-local</i> accumulator<br>into which it locally aggregates elements.<br>
You must also supply a function to indicate how to combine the local and main<br>accumulators. Finally, this Aggregate overload (somewhat gratuitously) expects a<br>delegate to perform any final transformation on the result (you can achieve this as<br>easily by running some function on the result yourself afterward). So, here are the<br>four delegates, in the order they are passed:<br>
seedFactory<br>
Returns a new local accumulator<br>
updateAccumulatorFunc<br>
Aggregates an element into a local accumulator<br>
combineAccumulatorFunc<br>
Combines a local accumulator with the main accumulator<br>
resultSelector<br>
Applies any final transformation on the end result<br>
In simple scenarios, you can specify a <i>seed value</i> instead of a<br>seed factory. This tactic fails when the seed is a reference type<br>that you wish to mutate, because the same instance will then be<br>shared by each thread.<br>
To give a very simple example, the following sums the values in a numbers array:<br>
numbers.AsParallel().Aggregate (<br> () =&gt; 0,                                      // seedFactory<br>  (localTotal, n) =&gt; localTotal + n,           // updateAccumulatorFunc<br>  (mainTot, localTot) =&gt; mainTot + localTot,   // combineAccumulatorFunc<br>  finalResult =&gt; finalResult)                  // resultSelector<br>
This example is contrived in that we could get the same answer just as efficiently<br>using simpler approaches (such as an unseeded aggregate, or better, the Sum opera-<br>tor). To give a more realistic example, suppose we wanted to calculate the frequency<br>of each letter in the English alphabet in a given string. A simple sequential solution<br>might look like this:<br>
<b>890 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=911></a>string text = &quot;Let's suppose this is a really long string&quot;;<br>
var letterFrequencies = new int[26];<br>foreach (char c in text)<br>{<br>  int index = char.ToUpper (c) - 'A';<br>
  if (index &gt;= 0 &amp;&amp; index &lt;= 26) letterFrequencies [index]++;<br>};<br>
An example of when the input text might be very long is in gene<br>sequencing. The "alphabet" would then consist of the letters <i>a</i>,<br><i>c</i>, <i>g</i>, and <i>t</i>.<br>
To  parallelize  this,  we  could  replace  the  foreach  statement  with  a  call  to<br>Parallel.ForEach (as we'll cover in the following section), but this will leave us to<br>deal with concurrency issues on the shared array. And locking around accessing that<br>array would all but kill the potential for parallelization.<br>
Aggregate offers a tidy solution. The accumulator, in this case, is an array just like<br>
<b>Programming</b><br>
the letterFrequencies array in our preceding example. Here's a sequential version<br>
<b>Parallel</b><br>
using Aggregate:<br>
int[] result =<br>
  text.Aggregate (<br>
    new int[26],                // Create the &quot;accumulator&quot;<br>
    (letterFrequencies, c) =&gt;   // Aggregate a letter into the accumulator<br>    {<br>      int index = char.ToUpper (c) - 'A';<br>
      if (index &gt;= 0 &amp;&amp; index &lt;= 26) letterFrequencies [index]++;<br>
      return letterFrequencies;<br>    });<br>
And now the parallel version, using PLINQ's special overload:<br>
int[] result =<br>  text.AsParallel().Aggregate (<br>   () =&gt; new int[26],             // Create a new local accumulator<br>
    (localFrequencies, c) =&gt;       // Aggregate into the local accumulator<br>    {<br>      int index = char.ToUpper (c) - 'A';<br>      if (index &gt;= 0 &amp;&amp; index &lt;= 26) localFrequencies [index]++;<br>      return localFrequencies;<br>    },<br>                                   // Aggregate local-&gt;main accumulator<br>    (mainFreq, localFreq) =&gt;<br>      mainFreq.Zip (localFreq, (f1, f2) =&gt; f1 + f2).ToArray(),<br>
    finalResult =&gt; finalResult     // Perform any final transformation<br>  );                               // on the end result.<br>
Notice that the local accumulation function <i>mutates</i> the localFrequencies array.<br>This ability to perform this optimization is important--and is legitimate because<br>localFrequencies is local to each thread.<br>
<b>PLINQ | 891</b><br>
<hr>
<A name=912></a><b>The Parallel Class<br></b>PFX provides a basic form of structured parallelism via three static methods in the<br>Parallel class:<br>
Parallel.Invoke<br>
Executes an array of delegates in parallel<br>
Parallel.For<br>
Performs the parallel equivalent of a C# for loop<br>
Parallel.ForEach<br>
Performs the parallel equivalent of a C# foreach loop<br>
All  three  methods  block  until  all  work  is  complete.  As  with  PLINQ,  after  an<br>unhandled exception, remaining workers are stopped after their current iteration<br>and the exception (or exceptions) are thrown back to the caller--wrapped in an<br>AggregateException (see "Working with AggregateException" on page 912).<br>
<b>Parallel.Invoke<br></b>Parallel.Invoke executes an array of Action delegates in parallel, and then waits for<br>them to complete. The simplest version of the method is defined as follows:<br>
public static void <b>Invoke</b> (params Action[] actions);<br>
Here's how we can use Parallel.Invoke to download two web pages at once:<br>
Parallel.Invoke (<br> () =&gt; new WebClient().DownloadFile (&quot;http://www.linqpad.net&quot;, &quot;lp.html&quot;),<br> () =&gt; new WebClient().DownloadFile (&quot;http://www.jaoo.dk&quot;, &quot;jaoo.html&quot;));<br>
On the surface, this seems like a convenient shortcut for creating and waiting on<br>two Task objects (or asynchronous delegates). But there's an important difference:<br>Parallel.Invoke still works efficiently if you pass in an array of 1 million delegates.<br>This is because it <i>partitions</i> large numbers of elements into batches which it assigns<br>to  a  handful  of  underlying  Tasks--rather  than  creating  a  separate  Task  for  each<br>delegate.<br>
As with all of Parallel's methods, you're on your own when it comes to collating<br>the results. This means you need to keep thread safety in mind. The following, for<br>instance, is thread-unsafe:<br>
var data = new List&lt;string&gt;();<br>Parallel.Invoke (<br> () =&gt; <b>data.Add</b> (new WebClient().DownloadString (&quot;http://www.foo.com&quot;)),<br> () =&gt; <b>data.Add</b> (new WebClient().DownloadString (&quot;http://www.far.com&quot;)));<br>
Locking around adding to the list would resolve this, although locking would create<br>a bottleneck if you had a much larger array of quickly executing delegates. A better<br>solution  is  to  use  the  thread-safe  collections  that  we'll  cover  in  later  sections--<br>ConcurrentBag would be ideal in this case.<br>
Parallel.Invoke is also overloaded to accept a ParallelOptions object:<br>
<b>892 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=913></a>public static void <b>Invoke</b> (ParallelOptions options,<br>
                           params Action[] actions);<br>
With ParallelOptions, you can insert a cancellation token, limit the maximum con-<br>currency, and specify a custom task scheduler. A cancellation token is relevant when<br>you're executing (roughly) more tasks than you have cores: upon cancellation, any<br>unstarted delegates will be abandoned. Any already-executing delegates will, how-<br>ever, continue to completion. See "Cancellation" on page 886 for an example of how<br>to use cancellation tokens.<br>
<b>Parallel.For and Parallel.ForEach<br></b>Parallel.For  and  Parallel.ForEach  perform  the  equivalent  of  a  C#  for  and<br>foreach loop, but with each iteration executing in parallel instead of sequentially.<br>Here are their (simplest) signatures:<br>
public static ParallelLoopResult <b>For</b> (<br>
  int fromInclusive, int toExclusive, Action&lt;int&gt; body)<br>
public static ParallelLoopResult <b>ForEach</b>&lt;TSource&gt; (<br>
<b>Programming</b><br>
  IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body)<br>
<b>Parallel</b><br>
The following sequential for loop:<br>
for (int i = 0; i &lt; 100; i++)<br>
  Foo (i);<br>
is parallelized like this:<br>
<b>Parallel.For</b> (0, 100, i =&gt; Foo (i));<br>
or more simply:<br>
<b>Parallel.For</b> (0, 100, Foo);<br>
And the following sequential foreach:<br>
foreach (char c in &quot;Hello, world&quot;)<br>  Foo (c);<br>
is parallelized like this:<br>
Parallel.ForEach (&quot;Hello, world&quot;, Foo);<br>
To give a practical example, if we import the System.Security.Cryptography name-<br>space, we can generate six public/private key-pair strings in parallel as follows:<br>
var keyPairs = new string[6];<br>
Parallel.For (0, keyPairs.Length,<br>              i =&gt; keyPairs[i] = RSA.Create().ToXmlString (true));<br>
As with Parallel.Invoke, we can feed Parallel.For and Parallel.ForEach a large<br>number of work items and they'll be efficiently partitioned onto a few tasks.<br>
<b>The Parallel Class | 893</b><br>
<hr>
<A name=914></a>The latter query could also be done with PLINQ:<br>
string[] keyPairs =<br>  ParallelEnumerable.Range (0, 6)<br>
  .Select (i =&gt; RSA.Create().ToXmlString (true))<br>
  .ToArray();<br>
<b>Outer versus inner loops<br></b>Parallel.For and Parallel.ForEach usually work best on outer rather than inner<br>loops. This is because with the former, you're offering larger chunks of work to<br>parallelize, diluting the management overhead. Parallelizing both inner and outer<br>loops is usually unnecessary. In the following example, we'd typically need more<br>than 100 cores to benefit from the inner parallelization:<br>
Parallel.For (0, 100, i =&gt;<br>
{<br>  Parallel.For (0, 50, j =&gt; Foo (i, j));   // Sequential would be better<br>
});                                        // for the inner loop.<br>
<b>Indexed Parallel.ForEach<br></b>Sometimes it's useful to know the loop iteration index. With a sequential foreach,<br>it's easy:<br>
<b>int i = 0;</b><br>
foreach (char c in &quot;Hello, world&quot;)<br>  Console.WriteLine (c.ToString() + <b>i++</b>);<br>
Incrementing a shared variable, however, is not thread-safe in a parallel context. You<br>must instead use the following version of ForEach:<br>
public static ParallelLoopResult ForEach&lt;TSource&gt; (<br>  IEnumerable&lt;TSource&gt; source, Action&lt;TSource,ParallelLoopState<b>,long</b>&gt; body)<br>
We'll ignore ParallelLoopState (which we'll cover in the following section). For<br>now, we're interested in Action's third type parameter of type long, which indicates<br>the loop index:<br>
Parallel.ForEach (&quot;Hello, world&quot;, (c, state, i) =&gt;<br>{<br>   Console.WriteLine (c.ToString() + i);<br>});<br>
To put this into a practical context, we'll revisit the spellchecker that we wrote with<br>PLINQ. The following code loads up a dictionary along with an array of 1 million<br>words to test:<br>
if (!File.Exists (&quot;WordLookup.txt&quot;))    // Contains about 150,000 words<br>  new WebClient().DownloadFile (<br>    &quot;http://www.albahari.com/ispell/allwords.txt&quot;, &quot;WordLookup.txt&quot;);<br>
var wordLookup = new HashSet&lt;string&gt; (<br>  File.ReadAllLines (&quot;WordLookup.txt&quot;),<br>  StringComparer.InvariantCultureIgnoreCase);<br>
<b>894 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=915></a>var random = new Random();<br>
string[] wordList = wordLookup.ToArray();<br>
string[] wordsToTest = Enumerable.Range (0, 1000000)<br>
  .Select (i =&gt; wordList [random.Next (0, wordList.Length)])<br>
  .ToArray();<br>
wordsToTest [12345] = &quot;woozsh&quot;;     // Introduce a couple<br>
wordsToTest [23456] = &quot;wubsie&quot;;     // of spelling mistakes.<br>
We can perform the spellcheck on our wordsToTest array using the indexed version<br>of Parallel.ForEach as follows:<br>
var misspellings = new ConcurrentBag&lt;Tuple&lt;int,string&gt;&gt;();<br>
Parallel.ForEach (wordsToTest, (word, state, i) =&gt;<br>
{<br>  if (!wordLookup.Contains (word))<br>
    misspellings.Add (Tuple.Create ((int) i, word));<br>
});<br>
Notice that we had to collate the results into a thread-safe collection: having to do<br>
<b>Programming</b><br>
this is the disadvantage when compared to using PLINQ. The advantage over PLINQ<br>
<b>Parallel</b><br>
is that we avoid the cost of applying an indexed Select query operator--which is<br>less efficient than an indexed ForEach.<br>
<b>ParallelLoopState: Breaking early out of loops<br></b>Because  the  loop  body  in  a  parallel  For  or  ForEach  is  a  delegate,  you  can't  exit<br>the loop early with a break statement. Instead, you must call Break or Stop on a<br>ParallelLoopState object:<br>
public class ParallelLoopState<br>{<br>  public void Break();<br>  public void Stop();<br>
  public bool IsExceptional { get; }<br>  public bool IsStopped { get; }<br>  public long? LowestBreakIteration { get; }<br>  public bool ShouldExitCurrentIteration { get; }<br>}<br>
Obtaining a ParallelLoopState is easy: all versions of For and ForEach are overloaded<br>to accept loop bodies of type Action&lt;TSource,ParallelLoopState&gt;. So, to parallelize<br>this:<br>
foreach (char c in &quot;Hello, world&quot;)<br>  if (c == ',')<br>    <b>break;<br></b>  else<br>    Console.Write (c);<br>
<b>The Parallel Class | 895</b><br>
<hr>
<A name=916></a>do this:<br>
Parallel.ForEach (&quot;Hello, world&quot;, <b>(c, loopState)</b> =&gt;<br>
{<br>  if (c == ',')<br>    <b>loopState.Break();<br></b>  else<br>
    Console.Write (c);<br>
});<br>
// OUTPUT: Hlloe<br>
You can see from the output that loop bodies may complete in a random order.<br>Aside from this difference, calling Break yields <i>at least</i> the same elements as executing<br>the loop sequentially: this example will always output <i>at least</i> the letters <i>H</i>, <i>e</i>, <i>l</i>, <i>l</i>,<br>and <i>o</i> in some order. In contrast, calling Stop instead of Break forces all threads to<br>finish right after their current iteration. In our example, calling Stop could give us a<br>subset of the letters <i>H</i>, <i>e</i>, <i>l</i>, <i>l</i>, and <i>o</i> if another thread was lagging behind. Calling<br>Stop  is  useful  when  you've  found  something  that  you're  looking  for--or  when<br>something has gone wrong and you won't be looking at the results.<br>
The  Parallel.For  and  Parallel.ForEach  methods  return<br>a  ParallelLoopResult  object  that  exposes  properties  called<br>IsCompleted and LowestBreakIteration. These tell you whether<br>the loop ran to completion, and if not, at what cycle the loop<br>was broken.<br>
If LowestBreakIteration returns null, it means that you called<br>Stop (rather than Break) on the loop.<br>
If your loop body is long, you might want other threads to break partway through<br>the method body in case of an early Break or Stop. You can do this by polling the<br>ShouldExitCurrentIteration property at various places in your code; this property<br>becomes true immediately after a Stop--or soon after a Break.<br>
ShouldExitCurrentIteration also becomes true after a cancel-<br>lation request--or if an exception is thrown in the loop.<br>
IsExceptional lets you know whether an exception has occurred on another thread.<br>Any unhandled exception will cause the loop to stop after each thread's current<br>iteration: to avoid this, you must explicitly handle exceptions in your code.<br>
<b>Optimization with local values<br></b>Parallel.For and Parallel.ForEach each offer a set of overloads that feature a generic<br>type argument called TLocal. These overloads are designed to help you optimize the<br>collation of data with iteration-intensive loops. The simplest is this:<br>
<b>896 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=917></a>public static ParallelLoopResult For &lt;<b>TLocal</b>&gt; (<br>
  int fromInclusive,<br>  int toExclusive,<br>  <b>Func &lt;TLocal&gt; localInit,</b><br>
  Func &lt;int, ParallelLoopState, <b>TLocal, TLocal</b>&gt; body,<br>
  <b>Action &lt;TLocal&gt; localFinally);</b><br>
These methods are rarely needed in practice because their target scenarios are cov-<br>ered mostly by PLINQ (which is fortunate because these overloads are somewhat<br>intimidating!).<br>
Essentially, the problem is this: suppose we want to sum the square roots of the<br>numbers 1 through 10,000,000. Calculating 10 million square roots is easily paral-<br>lelizable, but summing their values is troublesome because we must lock around<br>updating the total:<br>
object locker = new object();<br>
double total = 0;<br>
Parallel.For (1, 10000000,<br>              i =&gt; { lock (locker) total += Math.Sqrt (i); });<br>
<b>Programming</b><br>
The gain from parallelization is more than offset by the cost of obtaining 10 million<br>
<b>Parallel</b><br>
locks--plus the resultant blocking.<br>
The reality, though, is that we don't actually <i>need</i> 10 million locks. Imagine a team<br>of volunteers picking up a large volume of litter. If all workers shared a single trash<br>can, the travel and contention would make the process extremely inefficient. The<br>obvious solution is for each worker to have a private or "local" trash can, which is<br>occasionally emptied into the main bin.<br>
The TLocal versions of For and ForEach work in exactly this way. The volunteers are<br>internal worker threads, and the <i>local value</i> represents a local trash can. In order for<br>Parallel to do this job, you must feed it two additional delegates that indicate:<br>
1. How to initialize a new local value<br>2. How to combine a local aggregation with the master value<br>
Additionally, instead of the body delegate returning void, it should return the new<br>aggregate for the local value. Here's our example refactored:<br>
object locker = new object();<br>double grandTotal = 0;<br>
Parallel.For (1, 10000000,<br>
  () =&gt; 0.0,                        // Initialize the local value.<br>
  (i, state, localTotal) =&gt;         // Body delegate. Notice that it<br>     localTotal + Math.Sqrt (i),    // returns the new local total.<br>
  localTotal =&gt;                                    // Add the local value<br>    { lock (locker) grandTotal += localTotal; }    // to the master value.<br>);<br>
<b>The Parallel Class | 897</b><br>
<hr>
<A name=918></a>We must still lock, but only around aggregating the local value to the grand total.<br>This makes the process dramatically more efficient.<br>
As stated earlier, PLINQ is often a good fit in these scenarios.<br>Our example could be parallelized with PLINQ simply like this:<br>
ParallelEnumerable.Range (1, 10000000)<br>                  .Sum (i =&gt; Math.Sqrt (i))<br>
(Notice that we used ParallelEnumerable to force <i>range parti-<br>tioning</i>: this improves performance in this case because all num-<br>bers will take equally long to process.)<br>
In more complex scenarios, you might use LINQ's Aggregate<br>operator instead of Sum. If you supplied a local seed factory, the<br>situation would be somewhat analogous to providing a local<br>value function with Parallel.For.<br>
<b>Task Parallelism<br></b><i>Task parallelism</i> is the lowest-level approach to parallelization with PFX. The classes<br>for working at this level are defined in the System.Threading.Tasks namespace and<br>comprise the following:<br>
<b>Class</b><br>
<b>Purpose</b><br>
Task<br>
For managing a unit for work<br>
Task&lt;TResult&gt;<br>
For managing a unit for work with a return value<br>
TaskFactory<br>
For creating tasks<br>
TaskFactory&lt;TResult&gt;<br>
For creating tasks and continuations with the same return type<br>
TaskScheduler<br>
For managing the scheduling of tasks<br>
TaskCompletionSource<br>
For manually controlling a task's workflow<br>
Essentially, a task is a lightweight object for managing a parallelizable unit of work.<br>A task avoids the overhead of starting a dedicated thread by using the CLR's thread<br>pool: this is the same thread pool used by ThreadPool.QueueUserWorkItem, tweaked<br>in CLR 4.0 to work more efficiently with Tasks (and more efficiently in general).<br>Tasks can be used whenever you want to execute something in parallel. However,<br>they're <i>tuned</i> for leveraging multicores: in fact, the Parallel class and PLINQ are<br>internally built on the task parallelism constructs.<br>
Tasks do more than just provide an easy and efficient way into the thread pool. They<br>also provide powerful features for managing units of work, including the ability to:<br>
· Tune a task's scheduling<br>· Establish a parent/child relationship when one task is started from another<br>· Implement cooperative cancellation<br>
<b>898 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=919></a>· Wait on a set of tasks--without a signaling construct<br>· Attach "continuation" task(s)<br>· Schedule a continuation based on multiple antecedent tasks<br>· Propagate exceptions to parents, continuations, and task consumers<br>
Tasks also implement <i>local work queues</i>, an optimization that allows you to effi-<br>ciently create many quickly executing child tasks without incurring the contention<br>overhead that would otherwise arise with a single work queue.<br>
The  Task  Parallel  Library  lets  you  create  hundreds  (or  even<br>thousands) of tasks with minimal overhead. But if you want to<br>create millions of tasks, you'll need to partition those tasks into<br>larger work units to maintain efficiency. The Parallel class and<br>PLINQ do this automatically.<br>
Visual Studio 2010 provides a new window for monitoring tasks<br>(DebugWindowParallel  Tasks).  This  is  equivalent  to  the<br>
<b>Programming</b><br>
Threads window, but for tasks. The Parallel Stacks window also<br>
<b>Parallel</b><br>
has a special mode for tasks.<br>
<b>Creating and Starting Tasks<br></b>As we described in Chapter 21 (in our discussion of thread pooling), you can create<br>and start a Task by calling Task.Factory.StartNew, passing in an Action delegate:<br>
Task.Factory.StartNew (() =&gt; Console.WriteLine (&quot;Hello from a task!&quot;));<br>
The generic version, Task&lt;TResult&gt; (a subclass of Task), lets you get data back from<br>a task upon completion:<br>
Task&lt;string&gt; task = Task.Factory.StartNew<b>&lt;string&gt;</b> (() =&gt;    // Begin task<br>{<br>  using (var wc = new System.Net.WebClient())<br>    return wc.DownloadString (&quot;http://www.linqpad.net&quot;);<br>});<br>
RunSomeOtherMethod();         // We can do other work in parallel...<br>
string result = <b>task.Result</b>;  // Wait for task to finish and fetch result.<br>
Task.Factory.StartNew creates and starts a task in one step. You can decouple these<br>operations by first instantiating a Task object, and then calling Start:<br>
var task = new Task (() =&gt; Console.Write (&quot;Hello&quot;));<br>...<br>task.Start();<br>
A task that you create in this manner can also be run synchronously (on the same<br>thread) by calling RunSynchronously instead of Start.<br>
<b>Task Parallelism | 899</b><br>
<hr>
<A name=920></a>You can track a task's execution status via its Status property.<br>
<b>Specifying a state object<br></b>When  instantiating  a  task  or  calling  Task.Factory.StartNew,  you  can  specify  a<br><i>state</i> object, which is passed to the target method. This is useful should you want to<br>call a method directly rather than using a lambda expression:<br>
static void Main()<br>{<br>  var task = Task.Factory.StartNew (Greet<b>, &quot;Hello&quot;</b>);<br>
  task.Wait();  // Wait for task to complete.<br>
}<br>
static void Greet (object state) { Console.Write (state); }   // Hello<br>
Given  that  we  have  lambda  expressions  in  C#,  we  can  put  the  <i>state</i>  object  to<br>better use, which is to assign a meaningful name to the task. We can then use the<br>AsyncState property to query its name:<br>
static void Main()<br>{<br>  var task = Task.Factory.StartNew (state =&gt; Greet (&quot;Hello&quot;)<b>, &quot;Greeting&quot;</b>);<br>
  Console.WriteLine (task.AsyncState);   // <b>Greeting<br></b>  task.Wait();<br>}<br>
static void Greet (string message) { Console.Write (message); }<br>
Visual  Studio  displays  each  task's  AsyncState  in  the  Parallel<br>Tasks window, so having a meaningful name here can ease de-<br>bugging considerably.<br>
<b>TaskCreationOptions<br></b>You can tune a task's execution by specifying a TaskCreationOptions enum when<br>calling StartNew (or instantiating a Task). TaskCreationOptions is a flags enum with<br>the following (combinable) values:<br>
LongRunning<br>PreferFairness<br>AttachedToParent<br>
LongRunning suggests to the scheduler to dedicate a thread to the task. This is ben-<br>eficial for long-running tasks because they might otherwise "hog" the queue, and<br>force  short-running  tasks  to  wait  an  unreasonable  amount  of  time  before  being<br>scheduled. LongRunning is also good for blocking tasks.<br>
<b>900 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=921></a>The task queuing problem arises because the task scheduler or-<br>dinarily tries to keep just enough tasks active on threads at once<br>to keep each CPU core busy. Not <i>oversubscribing</i> the CPU with<br>too many active threads avoids the degradation in performance<br>that would occur if the operating system was forced to perform<br>a lot of expensive time slicing and context switching.<br>
PreferFairness tells the scheduler to try to ensure that tasks are scheduled in the<br>order they were started. It may ordinarily do otherwise, because it internally opti-<br>mizes the scheduling of tasks using local work-stealing queues. This optimization is<br>of practical benefit with very small (fine-grained) tasks.<br>
AttachedToParent is for creating <i>child tasks</i>.<br>
<b>Child tasks<br></b>When one task starts another, you can optionally establish a parent-child relation-<br>ship by specifying TaskCreationOptions.AttachedToParent:<br>
<b>Programming</b><br>
Task parent = Task.Factory.StartNew (() =&gt;<br>
<b>Parallel</b><br>
{<br>  Console.WriteLine (&quot;I am a parent&quot;);<br>
  Task.Factory.StartNew (() =&gt;        // Detached task<br>
  {<br>
    Console.WriteLine (&quot;I am detached&quot;);<br>
  });<br>
  Task.Factory.StartNew (() =&gt;        // Child task<br>
  {<br>    Console.WriteLine (&quot;I am a child&quot;);<br>  }, TaskCreationOptions.<b>AttachedToParent</b>);<br>});<br>
A child task is special in that when you wait for the <i>parent</i> task to complete, it waits<br>for any children as well. This can be particularly useful when a child task is a con-<br>tinuation, as we'll see shortly.<br>
<b>Waiting on Tasks<br></b>You can explicitly wait for a task to complete in two ways:<br>
· Calling its Wait method (optionally with a timeout)<br>· Accessing its Result property (in the case of Task&lt;TResult&gt;)<br>
You can also wait on multiple tasks at once--via the static methods Task.WaitAll<br>(waits for all the specified tasks to finish) and Task.WaitAny (waits for just one task<br>to finish).<br>
WaitAll is similar to waiting out each task in turn, but is more efficient in that it<br>requires (at most) just one context switch. Also, if one or more of the tasks throw<br>an unhandled exception, WaitAll still waits out every task--and then rethrows a<br>
<b>Task Parallelism | 901</b><br>
<hr>
<A name=922></a>single AggregateException that accumulates the exceptions from each faulted task.<br>It's equivalent to doing this:<br>
// Assume t1, t2, and t3 are tasks:<br>var exceptions = new List&lt;Exception&gt;();<br>
try { t1.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }<br>
try { t2.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }<br>try { t3.Wait(); } catch (AggregateException ex) { exceptions.Add (ex); }<br>
if (exceptions.Count &gt; 0) throw new AggregateException (exceptions);<br>
Calling WaitAny is equivalent to waiting on a ManualResetEventSlim that's signaled<br>by each task as it finishes.<br>
As well as a timeout, you can also pass in a <i>cancellation token</i> to the Wait methods:<br>this lets you cancel the wait--<i>not the task itself</i>. For a discussion on cancellation<br>tokens, see "Safe Cancellation" on page 857.<br>
<b>Exception-Handling Tasks<br></b>When you wait for a task to complete (by calling its Wait method or accessing its<br>Result property), any unhandled exceptions are conveniently rethrown to the caller,<br>wrapped  in  an  AggregateException  object  (see  "Working  with  AggregateExcep-<br>tion" on page 912). This usually avoids the need to write code within task blocks<br>to handle unexpected exceptions:<br>
int x = 0;<br>
Task&lt;int&gt; calc = Task.Factory.StartNew (() =&gt; 7 / x);<br>try<br>{<br>  Console.WriteLine (calc.Result);<br>}<br>catch (AggregateException aex)<br>{<br>  Console.Write (aex.InnerException.Message);  // Attempted to divide by 0<br>}<br>
You  still  need  to  exception-handle  detached  autonomous  tasks  (unparented<br>tasks that are not waited upon) in order to prevent an unhandled exception taking<br>down the application when the task drops out of scope and is garbage-collected<br>(subject to the following note). The same applies for tasks waited upon with a time-<br>out,  because  any  exception  thrown  <i>after</i>  the  timeout  interval  will  otherwise  be<br>"unhandled."<br>
The static TaskScheduler.UnobservedTaskException event pro-<br>vides a final last resort for dealing with unhandled task excep-<br>tions. By handling this event, you can intercept task exceptions<br>that would otherwise end the application--and provide your<br>own logic for dealing with them.<br>
For parented tasks, waiting on the parent implicitly waits on the children--and any<br>child exceptions then bubble up:<br>
<b>902 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=923></a>TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;<br>
var parent = Task.Factory.StartNew (() =&gt;<br>{<br>  Task.Factory.StartNew (() =&gt;   // Child<br>
  {<br>
    Task.Factory.StartNew (() =&gt; { throw null; }, atp);   // Grandchild<br>  }, atp);<br>});<br>
// The following call throws a NullReferenceException (wrapped<br>// in nested AggregateExceptions):<br>parent.Wait();<br>
Interestingly, if you check a task's Exception property after it<br>has thrown an exception, the act of reading that property will<br>prevent the exception from subsequently taking down your ap-<br>plication. The rationale is that PFX's designers don't want you<br><i>ignoring</i> exceptions--as long as you acknowledge them in some<br>way, they won't punish you by terminating your program.<br>
<b>Programming</b><br>
<b>Parallel</b><br>
An unhandled exception on a task doesn't cause <i>immediate</i> ap-<br>plication  termination:  instead,  it's  delayed  until  the  garbage<br>collector catches up with the task and calls its finalizer. Termi-<br>nation is delayed because it can't be known for certain that you<br>don't plan to call Wait or check its Result or Exception property<br>until the task is garbage-collected. This delay can sometimes<br>mislead you as to the original source of the error (although Vis-<br>ual Studio's debugger can assist if you enable breaking on first-<br>chance exceptions).<br>
As  we'll  see  soon,  an  alternative  strategy  for  dealing  with  exceptions  is  with<br><i>continuations</i>.<br>
<b>Canceling Tasks<br></b>You can optionally pass in a cancellation token when starting a task. This lets you<br>cancel tasks via the cooperative cancellation pattern described in "Safe Cancella-<br>tion" on page 857 in Chapter 21:<br>
var cancelSource = new CancellationTokenSource();<br>CancellationToken token = cancelSource.Token;<br>
Task task = Task.Factory.StartNew (() =&gt;<br>{<br>  // Do some stuff...<br>  token.ThrowIfCancellationRequested();  // Check for cancellation request<br>  // Do some stuff...<br>}, <b>token</b>);<br>...<br>cancelSource.Cancel();<br>
<b>Task Parallelism | 903</b><br>
<hr>
<A name=924></a>To detect a canceled task, catch an AggregateException and check the inner excep-<br>tion as follows:<br>
try<br>{<br>  task.Wait();<br>
}<br>catch (AggregateException ex)<br>{<br>  if (ex.InnerException is OperationCanceledException)<br>
    Console.Write (&quot;Task canceled!&quot;);<br>}<br>
If you want to explicitly throw an OperationCanceledException<br>(rather than calling token.ThrowIfCancellationRequested), you<br>must pass the cancellation token into OperationCanceledExcep<br>tion's constructor. If you fail to do this, the task won't end up<br>with a TaskStatus.Canceled status and won't trigger OnlyOnCan<br>celed continuations.<br>
If the task is canceled before it has started, it won't get scheduled--an Operation<br>CanceledException will instead be thrown on the task immediately.<br>
Because cancellation tokens are recognized by other APIs, you can pass them into<br>other constructs and cancellations will propagate seamlessly:<br>
var cancelSource = new CancellationTokenSource();<br>CancellationToken token = cancelSource.Token;<br>
Task task = Task.Factory.StartNew (() =&gt;<br>{<br>  // Pass our cancellation token into a PLINQ query:<br>  var query = <i>someSequence</i>.AsParallel().<b>WithCancellation (token)</b>...<br>
  ... <i>enumerate query</i> ...<br>});<br>
Calling Cancel on cancelSource in this example will cancel the PLINQ query, which<br>will throw an OperationCanceledException on the task body, which will then cancel<br>the task.<br>
The cancellation tokens that you can pass into methods such as<br>Wait and CancelAndWait allow you to cancel the <i>wait</i> operation<br>and not the task itself.<br>
<b>Continuations<br></b>Sometimes it's useful to start a task right after another one completes (or fails). The <br>ContinueWith method on the Task class does exactly this:<br>
Task task1 = Task.Factory.StartNew (() =&gt; Console.Write (&quot;antecedant..&quot;));<br>Task task2 = task1.<b>ContinueWith</b> (ant =&gt; Console.Write (&quot;..continuation&quot;));<br>
<b>904 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=925></a>As soon as task1 (the <i>antecedent</i>) finishes, fails, or is canceled, task2 (the <i>continua-<br>tion</i>) automatically starts. (If task1 had completed before the second line of code<br>ran, task2 would be scheduled to execute right away.) The ant argument passed to<br>the continuation's lambda expression is a reference to the antecedent task.<br>
Our example demonstrated the simplest kind of continuation, and is functionally<br>similar to the following:<br>
Task task = Task.Factory.StartNew (() =&gt;<br>
{<br>  Console.Write (&quot;antecedent..&quot;);<br>
  Console.Write (&quot;..continuation&quot;);<br>
});<br>
The continuation-based approach, however, is more flexible in that you could first<br>wait on task1, and then later wait on task2. This is particularly useful if task1 returns<br>data.<br>
Another (subtler) difference is that by default, antecedent and<br>
<b>Programming</b><br>
continuation tasks may execute on different threads. You can<br>
<b>Parallel</b><br>
force them to execute on the same thread by specifying TaskCon<br>tinuationOptions.ExecuteSynchronously when calling Continue<br>With: this can improve performance in very fine-grained con-<br>tinuations by lessening indirection.<br>
<b>Continuations and Task&lt;TResult&gt;<br></b>Just like ordinary tasks, continuations can be of type Task&lt;TResult&gt; and return data.<br>In the following example, we calculate Math.Sqrt(8*2) using a series of chained tasks<br>and then write out the result:<br>
Task.Factory.StartNew&lt;int&gt; (() =&gt; 8)<br>  .ContinueWith (ant =&gt; ant.Result * 2)<br>  .ContinueWith (ant =&gt; Math.Sqrt (ant.Result))<br>  .ContinueWith (ant =&gt; Console.WriteLine (ant.Result));   // 4<br>
Our example is somewhat contrived for simplicity; in real life, these lambda expres-<br>sions would call computationally intensive functions.<br>
<b>Continuations and exceptions<br></b>A  continuation  can  find  out  if  an  exception  was  thrown  by  the  antecedent<br>via the antecedent task's Exception property. The following writes the details of a<br>NullReferenceException to the console:<br>
Task task1 = Task.Factory.StartNew (() =&gt; { throw null; });<br>Task task2 = task1.ContinueWith (ant =&gt; Console.Write (ant.Exception));<br>
If an antecedent throws and the continuation fails to query the<br>antecedent's Exception property (and the antecedent isn't oth-<br>erwise  waited  upon),  the  exception  is  considered  unhandled<br>and the application dies (unless handled by TaskScheduler.Unob<br>servedTaskException).<br>
<b>Task Parallelism | 905</b><br>
<hr>
<A name=926></a>A safe pattern is to rethrow antecedent exceptions. As long as the continuation is<br>Waited upon, the exception will be propagated and rethrown to the Waiter:<br>
Task continuation = Task.Factory.StartNew     (()  =&gt; { throw null; })<br>                                .ContinueWith (ant =&gt;<br>
  {<br>
    <b>if (ant.Exception != null) throw ant.Exception;<br></b>    // Continue processing...<br>  });<br>
continuation.Wait();    // Exception is now thrown back to caller.<br>
Another way to deal with exceptions is to specify different continuations for excep-<br>tional versus nonexceptional outcomes. This is done with TaskContinuationOptions:<br>
Task task1 = Task.Factory.StartNew (() =&gt; { throw null; });<br>
Task error = task1.ContinueWith (ant =&gt; Console.Write (ant.Exception),<br>
                                 <b>TaskContinuationOptions.OnlyOnFaulted</b>);<br>
Task ok = task1.ContinueWith (ant =&gt; Console.Write (&quot;Success!&quot;),<br>
                              <b>TaskContinuationOptions.NotOnFaulted</b>);<br>
This pattern is particularly useful in conjunction with child tasks, as we'll see very<br>soon.<br>
The following extension method "swallows" a task's unhandled exceptions:<br>
public static void IgnoreExceptions (this Task task)<br>{<br>  task.ContinueWith (t =&gt; { var ignore = t.Exception; },<br>    TaskContinuationOptions.OnlyOnFaulted);<br>}<br>
(This could be improved by adding code to log the exception.) Here's how it would<br>be used:<br>
Task.Factory.StartNew (() =&gt; { throw null; }).IgnoreExceptions();<br>
<b>Continuations and child tasks<br></b>A powerful feature of continuations is that they kick off only when all child tasks<br>have completed (see Figure 22-5). At that point, any exceptions thrown by the chil-<br>dren are marshaled to the continuation.<br>
In the following example, we start three child tasks, each throwing a NullReferen<br>ceException. We then catch all of them in one fell swoop via a continuation on the<br>parent:<br>
TaskCreationOptions atp = TaskCreationOptions.AttachedToParent;<br>Task.Factory.StartNew (() =&gt;<br>{<br>  Task.Factory.StartNew (() =&gt; { throw null; }, atp);<br>  Task.Factory.StartNew (() =&gt; { throw null; }, atp);<br>  Task.Factory.StartNew (() =&gt; { throw null; }, atp);<br>})<br>.ContinueWith (p =&gt; Console.WriteLine (p.Exception),<br>                    TaskContinuationOptions.OnlyOnFaulted);<br>
<b>906 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=927></a><b>Conditional continuations<br></b>By default, a continuation is scheduled <i>unconditionally</i>--whether the antecedent<br>completes, throws an exception, or is canceled. You can alter this behavior via a set<br>of (combinable) flags included within the TaskContinuationOptions enum. The three<br>core flags that control conditional continuation are:<br>
NotOnRanToCompletion = 0x10000,<br>
NotOnFaulted = 0x20000,<br>
NotOnCanceled = 0x40000,<br>
These flags are subtractive in the sense that the more you apply, the less likely the<br>continuation is to execute. For convenience, there are also the following precom-<br>bined values:<br>
<b>OnlyOnRanToCompletion</b> = NotOnFaulted | NotOnCanceled,<br>
<b>OnlyOnFaulted</b> = NotOnRanToCompletion | NotOnCanceled,<br>
<b>OnlyOnCanceled</b> = NotOnRanToCompletion | NotOnFaulted<br>
<b>Programming</b><br>
<b>Parallel</b><br>
<i>Figure 22-5. Continuations</i><br>
(Combining all the Not* flags [NotOnRanToCompletion, NotOnFaulted, NotOnCanceled]<br>is nonsensical, as it would result in the continuation always being canceled.)<br>
"RanToCompletion"  means  the  antecedent  succeeded--without  cancellation  or<br>unhandled exceptions.<br>
"Faulted" means an unhandled exception was thrown on the antecedent.<br>
"Canceled" means one of two things:<br>
<b>Task Parallelism | 907</b><br>
<hr>
<A name=928></a>· The  antecedent  was  canceled  via  its  cancellation  token.  In  other  words,<br>
an  OperationCanceledException  was  thrown  on  the  antecedent--whose<br>CancellationToken property matched that passed to the antecedent when it was<br>started.<br>
· The antecedent was implicitly canceled because <i>it</i> didn't satisfy a conditional<br>
continuation predicate.<br>
It's essential to grasp that when a continuation doesn't execute by virtue of these<br>flags, the continuation is not forgotten or abandoned--it's <i>canceled</i>. This means that<br>any continuations on the continuation itself <i>will then run</i>--unless you predicate<br>them with NotOnCanceled. For example, consider this:<br>
Task t1 = Task.Factory.StartNew (...);<br>
Task fault = t1.ContinueWith (ant =&gt; Console.WriteLine (&quot;fault&quot;),<br>
                              TaskContinuationOptions.OnlyOnFaulted);<br>
Task t3 = fault.ContinueWith (ant =&gt; Console.WriteLine (&quot;t3&quot;));<br>
As it stands, t3 will always get scheduled--even if t1 doesn't throw an exception<br>(see Figure 22-6). This is because if t1 succeeds, the fault task will be <i>canceled</i>, and<br>with no continuation restrictions placed on t3, t3 will then execute unconditionally.<br>
<i>Figure 22-6. Conditional continuations</i><br>
If we want t3 to execute only if fault actually runs, we must instead do this:<br>
Task t3 = fault.ContinueWith (ant =&gt; Console.WriteLine (&quot;t3&quot;),<br>                              <b>TaskContinuationOptions.NotOnCanceled</b>);<br>
(Alternatively,  we  could  specify  OnlyOnRanToCompletion;  the  difference  is  that  t3<br>would not then execute if an exception was thrown within fault.)<br>
<b>Continuations with multiple antecedents<br></b>Another useful feature of continuations is that you can schedule them to execute<br>based on the completion of multiple antecedents. ContinueWhenAll schedules exe-<br>cution when all antecedents have completed; ContinueWhenAny schedules execution<br>when one antecedent completes. Both methods are defined in the TaskFactory class:<br>
var task1 = Task.Factory.StartNew (() =&gt; Console.Write (&quot;X&quot;));<br>var task2 = Task.Factory.StartNew (() =&gt; Console.Write (&quot;Y&quot;));<br>
var continuation = Task.Factory.ContinueWhenAll (<br>  new[] { task1, task2 }, tasks =&gt; Console.WriteLine (&quot;Done&quot;));<br>
<b>908 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=929></a>This writes "Done" after writing "XY" or "YX". The tasks argument in the lambda<br>expression gives you access to the array of completed tasks, which is useful when<br>the antecedents return data. The following example adds together numbers returned<br>from two antecedent tasks:<br>
// task1 and task2 would call complex functions in real life:<br>Task&lt;int&gt; task1 = Task.Factory.StartNew (() =&gt; 123);<br>
Task&lt;int&gt; task2 = Task.Factory.StartNew (() =&gt; 456);<br>
Task&lt;int&gt; task3 = Task<b>&lt;int&gt;</b>.Factory.ContinueWhenAll (<br>
  new[] { task1, task2 }, tasks =&gt; tasks.Sum (t =&gt; t.Result));<br>
Console.WriteLine (task3.Result);           // 579<br>
We've included the &lt;int&gt; type argument in our call to Task.Fac<br>tory in this example to clarify that we're obtaining a generic task<br>factory. The type argument is unnecessary, though, as it will be<br>inferred by the compiler.<br>
<b>Programming</b><br>
<b>Multiple continuations on a single antecedent</b><br>
<b>Parallel</b><br>
Calling ContinueWith more than once on the same task creates multiple continua-<br>tions on a single antecedent. When the antecedent finishes, all continuations will<br>start together (unless you specify TaskContinuationOptions.ExecuteSynchronously,<br>in which case the continuations will execute sequentially).<br>
The following waits for one second, and then writes either "XY" or "YX":<br>
var t = Task.Factory.StartNew (() =&gt; Thread.Sleep (1000));<br>
t.ContinueWith (ant =&gt; Console.Write (&quot;X&quot;));<br>t.ContinueWith (ant =&gt; Console.Write (&quot;Y&quot;));<br>
<b>Task Schedulers and UIs<br></b>A <i>task scheduler</i> allocates tasks to threads. All tasks are associated with a task sched-<br>uler, which is represented by the abstract TaskScheduler class. The Framework pro-<br>vides two concrete implementations: the <i>default scheduler</i> that works in tandem with<br>the CLR thread pool, and the <i>synchronization context scheduler</i>. The latter is de-<br>signed  (primarily)  to  help  you  with  the  threading  model  of  WPF  and  Windows<br>Forms, which requires that UI elements and controls are accessed only from the<br>thread  that  created  them  (see  "Rich  Client  Applications  and  Thread  Affin-<br>ity" on page 822 in the preceding chapter). For example, suppose we wanted to fetch<br>some data from a web service in the background, and then update a WPF label called<br>lblResult with its result. We can divide this into two tasks:<br>
1. Call a method to get data from the web service (antecedent task).<br>2. Update lblResult with the results (continuation task).<br>
If, for a continuation task, we specify the <i>synchronization context scheduler</i> obtained<br>when the window was constructed, we can safely update lblResult:<br>
<b>Task Parallelism | 909</b><br>
<hr>
<A name=930></a>public partial class MyWindow : Window<br>
{<br>  TaskScheduler _uiScheduler;   // Declare this as a field so we can use<br>                                // it throughout our class.<br>
  public MyWindow()<br>
  {<br>    InitializeComponent();<br>
    // Get the UI scheduler for the thread that created the form:<br>
    _uiScheduler = <b>TaskScheduler.FromCurrentSynchronizationContext()</b>;<br>
    Task.Factory.StartNew&lt;string&gt; (SomeComplexWebService)<br>
      .ContinueWith (ant =&gt; lblResult.Content = ant.Result, <b>_uiScheduler</b>);<br>  }<br>
  string SomeComplexWebService() { ... }<br>}<br>
It's also possible to write our own task scheduler (by subclassing TaskScheduler),<br>although this is something you'd do only in very specialized scenarios. For custom<br>scheduling,  you'd  more  commonly  use  TaskCompletionSource,  which  we'll  cover<br>soon.<br>
<b>TaskFactory<br></b>When you call Task.Factory, you're calling a static property on Task that returns a<br>default  TaskFactory  object.  The  purpose  of  a  task  factory  is  to  create  tasks--<br>specifically, three kinds of tasks:<br>
· "Ordinary" tasks (via StartNew)<br>· Continuations  with  multiple  antecedents  (via  ContinueWhenAll  and  Continue<br>
WhenAny)<br>
· Tasks that wrap methods that follow the asynchronous programming model<br>
(via FromAsync)<br>
Interestingly, TaskFactory is the <i>only</i> way to achieve the latter<br>two goals. In the case of StartNew, TaskFactory is purely a con-<br>venience and technically redundant in that you can simply in-<br>stantiate Task objects and call Start on them.<br>
We'll talk about FromAsync in the next chapter.<br>
<b>Creating your own task factories<br></b>TaskFactory is not an <i>abstract</i> factory: you can actually instantiate the class, and this<br>is useful when you want to repeatedly create tasks using the same (nonstandard)<br>values  for  TaskCreationOptions,  TaskContinuationOptions,  or  TaskScheduler.  For<br>example, if we wanted to repeatedly create long-running <i>parented</i> tasks, we could<br>create a custom factory as follows:<br>
<b>910 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=931></a>var factory = new TaskFactory (<br>
  TaskCreationOptions.LongRunning | TaskCreationOptions.AttachedToParent,<br>  TaskContinuationOptions.None);<br>
Creating tasks is then simply a matter of calling StartNew on the factory:<br>
Task task1 = factory.StartNew (Method1);<br>Task task2 = factory.StartNew (Method2);<br>
...<br>
The  custom  continuation  options  are  applied  when  calling  ContinueWhenAll  and<br>ContinueWhenAny.<br>
<b>TaskCompletionSource<br></b>The Task class achieves two distinct things:<br>
· It schedules a delegate to run on a pooled thread.<br>· It offers a rich set of features for managing work items (continuations, child<br>
tasks, exception marshaling, etc.).<br>
<b>Programming</b><br>
Interestingly, these two things are not joined at the hip: you can leverage a task's<br>
<b>Parallel</b><br>
features for managing work items without scheduling anything to run on the thread<br>pool. The class that enables this pattern of use is called TaskCompletionSource.<br>To  use  TaskCompletionSource  you  simply  instantiate  the  class.  It  exposes  a  Task<br>property that returns a task upon which you can wait and attach continuations--<br>just like any other task. The task, however, is entirely controlled by the TaskComple<br>tionSource object via the following methods:<br>
public class TaskCompletionSource&lt;TResult&gt;<br>{<br>  public void SetResult (TResult result);<br>  public void SetException (Exception exception);<br>  public void SetCanceled();<br>
  public bool TrySetResult (TResult result);<br>  public bool TrySetException (Exception exception);<br>  public bool TrySetCanceled();<br>  ...<br>}<br>
If called more than once, SetResult, SetException, or SetCanceled throws an excep-<br>tion; the Try* methods instead return false.<br>
TResult corresponds to the task's result type, so TaskCompletion<br>Source&lt;int&gt; gives you a Task&lt;int&gt;. If you want a task with no<br>result,  create  a  TaskCompletionSource  of  object  and  pass  in<br>null  when  calling  SetResult.  You  can  then  cast  the<br>Task&lt;object&gt; to Task.<br>
The following example prints 123 after waiting for 5 seconds:<br>
<b>Task Parallelism | 911</b><br>
<hr>
<A name=932></a>var source = new TaskCompletionSource&lt;int&gt;();<br>
new Thread (() =&gt; { Thread.Sleep (5000); source.SetResult (123); })<br>  .Start();<br>
Task&lt;int&gt; task = source.Task;      // Our &quot;slave&quot; task.<br>Console.WriteLine (task.Result);   // 123<br>
In  "Concurrent  Collections"  on  page  914,  we  show  how  BlockingCollection<br>can  be  used  to  write  a  producer/consumer  queue.  We  then  demonstrate  how<br>TaskCompletionSource improves the solution by allowing queued work items to be<br>waited upon and canceled.<br>
<b>Working with AggregateException<br></b>As we've seen, PLINQ, the Parallel class, and Tasks automatically marshal excep-<br>tions to the consumer. To see why this is essential, consider the following LINQ<br>query, which throws a DivideByZeroException on the first iteration:<br>
try<br>
{<br>  var query = from i in Enumerable.Range (0, 1000000)<br>
              select 100 / i;<br>  ...<br>
}<br>catch (DivideByZeroException)<br>
{<br>  ...<br>
}<br>
If we asked PLINQ to parallelize this query and it ignored the handling of exceptions,<br>a DivideByZeroException would probably be thrown on a <i>separate thread</i>, bypassing<br>our catch block and causing the application to die.<br>Hence,  exceptions  are  automatically  caught  and  rethrown  to  the  caller.  But  un-<br>fortunately, it's not quite as simple as catching a DivideByZeroException. Because<br>these libraries leverage many threads, it's actually possible for two or more excep-<br>tions to be thrown simultaneously. To ensure that all exceptions are reported, ex-<br>ceptions are therefore wrapped in an AggregateException container, which exposes<br>an InnerExceptions property containing each of the caught exception(s):<br>
try<br>{<br>  var query = from i in Enumerable.Range (0, 1000000)<br>              select 100 / i;<br>  // Enumerate query<br>  ...<br>}<br>catch (<b>AggregateException</b> aex)<br>{<br>  foreach (Exception ex in aex.<b>InnerExceptions</b>)<br>    Console.WriteLine (ex.Message);<br>}<br>
<b>912 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=933></a>Both  PLINQ  and  the  Parallel  class  end  the  query  or  loop<br>execution  upon  encountering  the  first  exception--by  not<br>processing any further elements or loop bodies. More excep-<br>tions  might  be  thrown,  however,  before  the  current  cycle  is<br>complete. The first exception in AggregateException is visible in<br>the InnerException property.<br>
<b>Flatten and Handle<br></b>The AggregateException class provides a couple of methods to simplify exception<br>handling: Flatten and Handle.<br>
<b>Flatten<br></b>AggregateExceptions will quite often contain other AggregateExceptions. An exam-<br>ple of when this might happen is if a child task throws an exception. You can elim-<br>inate any level of nesting to simplify handling by calling Flatten. This method returns<br>a new AggregateException with a simple flat list of inner exceptions:<br>
<b>Programming</b><br>
<b>Parallel</b><br>
catch (AggregateException aex)<br>
{<br>  foreach (Exception ex in aex.<b>Flatten</b>().InnerExceptions)<br>
    myLogWriter.LogException (ex);<br>}<br>
<b>Handle<br></b>Sometimes it's useful to catch only specific exception types, and have other types<br>rethrown. The Handle method on AggregateException provides a shortcut for doing<br>this. It accepts an exception predicate, which it runs over every inner exception:<br>
public void Handle (Func&lt;Exception, bool&gt; predicate)<br>
If the predicate returns true, it considers that exception "handled." After the delegate<br>has run over every exception, the following happens:<br>
· If all exceptions were "handled" (the delegate returned true), the exception is<br>
not rethrown.<br>
· If there were any exceptions for which the delegate returned false ("unhan-<br>
dled"), a new AggregateException is built up containing those exceptions, and<br>is rethrown.<br>
For instance, the following ends up rethrowing another  AggregateException that<br>contains a single NullReferenceException:<br>
var parent = Task.Factory.StartNew (() =&gt;<br>{<br>  // We'll throw 3 exceptions at once using 3 child tasks:<br>
  int[] numbers = { 0 };<br>
  var childFactory = new TaskFactory<br>   (TaskCreationOptions.AttachedToParent, TaskContinuationOptions.None);<br>
<b>Working with AggregateException | 913</b><br>
<hr>
<A name=934></a>  childFactory.StartNew (() =&gt; 5 / numbers[0]);   // Division by zero<br>
  childFactory.StartNew (() =&gt; numbers [1]);      // Index out of range<br>  childFactory.StartNew (() =&gt; { throw null; });  // Null reference<br>});<br>
try { parent.Wait(); }<br>catch (AggregateException aex)<br>{<br>  <b>aex.Flatten().Handle</b> (ex =&gt;   // Note that we still need to call Flatten<br>
  {<br>    if (ex is DivideByZeroException)<br>    {<br>
      Console.WriteLine (&quot;Divide by zero&quot;);<br>
      return true;                           // This exception is &quot;handled&quot;<br>    }<br>    if (ex is IndexOutOfRangeException)<br>
    {<br>
      Console.WriteLine (&quot;Index out of range&quot;);<br>      return true;                           // This exception is &quot;handled&quot;<br>    }<br>
    return false;    // All other exceptions will get rethrown<br>
  });<br>}<br>
<b>Concurrent Collections<br></b>Framework 4.0 provides a set of new collections in the System.Collections.Concur<br>rent namespace. All of these are fully thread-safe:<br>
<b>Concurrent collection</b><br>
<b>Nonconcurrent equivalent</b><br>
ConcurrentStack&lt;T&gt;<br>
Stack&lt;T&gt;<br>
ConcurrentQueue&lt;T&gt;<br>
Queue&lt;T&gt;<br>
ConcurrentBag&lt;T&gt;<br>
(none)<br>
BlockingCollection&lt;T&gt;<br>
(none)<br>
ConcurrentDictionary&lt;TKey,TValue&gt;<br>
Dictionary&lt;TKey,TValue&gt;<br>
The concurrent collections can sometimes be useful in general multithreading when<br>you need a thread-safe collection. However, there are some caveats:<br>
· The concurrent collections are tuned for <i>parallel programming</i>. The conven-<br>
tional collections outperform them in all but highly concurrent scenarios.<br>
· A thread-safe collection doesn't guarantee that the code using it will be thread-<br>
safe (see "Thread Safety" on page 543 in the preceding chapter).<br>
· If you enumerate over a concurrent collection while another thread is modifying<br>
it, no exception is thrown--instead, you get a mixture of old and new content.<br>
· There's no concurrent version of List&lt;T&gt;.<br>
<b>914 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=935></a>· The concurrent stack, queue, and bag classes are implemented internally with<br>
linked lists. This makes them less memory-efficient than the nonconcurrent<br>Stack and Queue classes, but better for concurrent access because linked lists are<br>conducive to lock-free or low-lock implementations. (This is because inserting<br>a node into a linked list requires updating just a couple of references, while<br>inserting an element into a List&lt;T&gt;-like structure may require moving thou-<br>sands of existing elements.)<br>
In other words, these collections don't merely provide shortcuts for using an ordi-<br>nary collection with a lock. To demonstrate, if we execute the following code on a<br><i>single</i> thread:<br>
var d = new ConcurrentDictionary&lt;int,int&gt;();<br>
for (int i = 0; i &lt; 1000000; i++) d[i] = 123;<br>
it runs three times more slowly than this:<br>
var d = new Dictionary&lt;int,int&gt;();<br>for (int i = 0; i &lt; 1000000; i++) <b>lock (d)</b> d[i] = 123;<br>
(<i>Reading</i> from a ConcurrentDictionary, however, is fast because reads are lock-free.)<br>
<b>Programming</b><br>
<b>Parallel</b><br>
The concurrent collections also differ from conventional collections in that they<br>expose special methods to perform atomic test-and-act operations, such as TryPop.<br>Most of these methods are unified via the IProducerConsumerCollection&lt;T&gt; interface.<br>
<b>IProducerConsumerCollection&lt;T&gt;<br></b>A producer/consumer collection is one for which the two primary use cases are:<br>
· Adding an element ("producing")<br>· Retrieving an element while removing it ("consuming")<br>
The classic examples are stacks and queues. Producer/consumer collections are sig-<br>nificant  in  parallel  programming  because  they're  conducive  to  efficient  lock-free<br>implementations.<br>
The IProducerConsumerCollection&lt;T&gt; interface represents a thread-safe producer/<br>consumer collection. The following classes implement this interface:<br>
ConcurrentStack&lt;T&gt;<br>ConcurrentQueue&lt;T&gt;<br>ConcurrentBag&lt;T&gt;<br>
IProducerConsumerCollection&lt;T&gt;  extends  ICollection,  adding  the  following<br>methods:<br>
void CopyTo (T[] array, int index);<br>T[] ToArray();<br><b>bool TryAdd (T item);<br>bool TryTake (out T item);</b><br>
The  TryAdd  and  TryTake  methods  test  whether  an  add/remove  operation  can  be<br>performed,  and  if  so,  they  perform  the  add/remove.  The  testing  and  acting  are<br>
<b>Concurrent Collections | 915</b><br>
<hr>
<A name=936></a>performed atomically, eliminating the need to lock as you would around a conven-<br>tional collection:<br>
int result;<br><b>lock (myStack)</b> if (myStack.Count &gt; 0) result = myStack.Pop();<br>
TryTake returns false if the collection is empty. TryAdd always succeeds and returns<br>true in the three implementations provided. If you wrote your own concurrent col-<br>lection that prohibited duplicates, however, you'd make TryAdd return false if the<br>element already existed (an example would be if you wrote a concurrent <i>set</i>).<br>
The particular element that TryTake removes is defined by the subclass:<br>
· With a stack, TryTake removes the most recently added element.<br>· With a queue, TryTake removes the least recently added element.<br>· With a bag, TryTake removes whatever element it can remove most efficiently.<br>
The three concrete classes mostly implement the TryTake and TryAdd methods ex-<br>plicitly, exposing the same functionality through more specifically named public<br>methods such as TryDequeue and TryPop.<br>
<b>ConcurrentBag&lt;T&gt;<br></b>ConcurrentBag&lt;T&gt; stores an <i>unordered</i> collection of objects (with duplicates permit-<br>ted). ConcurrentBag&lt;T&gt; is suitable in situations when you <i>don't care</i> which element<br>you get when calling Take or TryTake.<br>The benefit of ConcurrentBag&lt;T&gt; over a concurrent queue or stack is that a bag's<br>Add method suffers almost <i>no</i> contention when called by many threads at once. In<br>contrast, calling Add in parallel on a queue or stack incurs <i>some</i> contention (although<br>a lot less than locking around a <i>nonconcurrent</i> collection). Calling Take on a con-<br>current bag is also very efficient--as long as each thread doesn't take more elements<br>than it Added.<br>Inside a concurrent bag, each thread gets it own private linked list. Elements are<br>added to the private list that belongs to the thread calling Add, eliminating conten-<br>tion.  When  you  enumerate  over  the  bag,  the  enumerator  travels  through  each<br>thread's private list, yielding each of its elements in turn.<br>
When you call Take, the bag first looks at the current thread's private list. If there's<br>at least one element,* it can complete the task easily and without contention. But if<br>the list is empty, it must "steal" an element from another thread's private list and<br>incur the potential for contention.<br>
So, to be precise, calling Take gives you the element added most recently on that<br>thread; if there are no elements on that thread, it gives you the element added most<br>recently on another thread, chosen at random.<br>
* Due  to  an  implementation  detail,  there  actually  needs  to  be  at  least  two  elements  to  avoid<br>
contention entirely.<br>
<b>916 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=937></a>Concurrent bags are ideal when the parallel operation on your collection mostly<br>comprises Adding elements--or when the Adds and Takes are balanced on a thread.<br>We saw an example of the former previously, when using Parallel.ForEach to im-<br>plement a parallel spellchecker:<br>
var misspellings = new ConcurrentBag&lt;Tuple&lt;int,string&gt;&gt;();<br>
Parallel.ForEach (wordsToTest, (word, state, i) =&gt;<br>{<br>  if (!wordLookup.Contains (word))<br>
    misspellings.Add (Tuple.Create ((int) i, word));<br>
});<br>
A concurrent bag would be a poor choice for a producer/consumer queue, because<br>elements are added and removed by <i>different</i> threads.<br>
<b>BlockingCollection&lt;T&gt;<br></b>If  you  call  TryTake  on  any  of  the  producer/consumer  collections  we  discussed<br>previously:<br>
<b>Programming</b><br>
ConcurrentStack&lt;T&gt;<br>
<b>Parallel</b><br>
ConcurrentQueue&lt;T&gt;<br>
ConcurrentBag&lt;T&gt;<br>
and the collection is empty, the method returns false. Sometimes it would be more<br>useful in this scenario to <i>wait</i> until an element is available.<br>
Rather than overloading the TryTake methods with this functionality (which would<br>have caused a blowout of members after allowing for cancellation tokens and time-<br>outs), PFX's designers encapsulated this functionality into a wrapper class called<br>BlockingCollection&lt;T&gt;. A blocking collection wraps any collection that implements<br>IProducerConsumerCollection&lt;T&gt; and lets you Take an element from the wrapped<br>collection--blocking if no element is available.<br>
A blocking collection also lets you limit the total size of the collection, blocking the<br><i>producer</i>  if  that  size  is  exceeded.  A  collection  limited  in  this  manner  is  called  a<br><i>bounded blocking collection</i>.<br>
To use BlockingCollection&lt;T&gt;:<br>
1. Instantiate  the  class,  optionally  specifying  the  IProducerConsumerCollec<br>
tion&lt;T&gt; to wrap and the maximum size (bound) of the collection.<br>
2. Call Add or TryAdd to add elements to the underlying collection.<br>3. Call  Take  or  TryTake  to  remove  (consume)  elements  from  the  underlying<br>
collection.<br>
If you call the constructor without passing in a collection, the class will automatically<br>instantiate a ConcurrentQueue&lt;T&gt;. The producing and consuming methods let you<br>specify cancellation tokens and timeouts. Add and TryAdd may block if the collection<br>size is bounded; Take and TryTake block while the collection is empty.<br>Another way to consume elements is to call GetConsumingEnumerable. This returns a<br>(potentially) infinite sequence that yields elements as they become available. You<br>
<b>Concurrent Collections | 917</b><br>
<hr>
<A name=938></a>can force the sequence to end by calling CompleteAdding: this method also prevents<br>further elements from being enqueued.<br>
In  the  preceding  chapter,  we  wrote  a  producer/consumer  queue  using  Wait  and<br>Pulse  (see  "Signaling  with  Wait  and  Pulse"  on  page  840).  Here's  the  same  class<br>refactored to use BlockingCollection&lt;T&gt; (exception handling aside):<br>
public class PCQueue : IDisposable<br>
{<br>  <b>BlockingCollection&lt;Action&gt; _taskQ = new BlockingCollection&lt;Action&gt;();</b><br>
  public PCQueue (int workerCount)<br>
  {<br>
    // Create and start a separate Task for each consumer:<br>
    for (int i = 0; i &lt; workerCount; i++)<br>
      Task.Factory.StartNew (Consume);<br>  }<br>
  public void Dispose() { <b>_taskQ.CompleteAdding()</b>; }<br>
  public void EnqueueTask (Action action) { <b>_taskQ.Add (action);</b> }<br>
  void Consume()<br>
  {<br>
    // This sequence that we're enumerating will <i>block</i> when no elements<br>    // are available and will <i>end</i> when CompleteAdding is called.<br>
    foreach (Action action in <b>_taskQ.GetConsumingEnumerable()</b>)<br>      action();     // Perform task.<br>
  }<br>}<br>
Because we didn't pass anything into BlockingCollection's constructor, it instanti-<br>ated a concurrent queue automatically. Had we passed in a ConcurrentStack, we'd<br>have ended up with a producer/consumer stack.<br>
BlockingCollection also provides static methods called AddToAny and TakeFromAny,<br>which let you add or take an element while specifying several blocking collections.<br>The action is then honored by the first collection able to service the request.<br>
<b>Leveraging TaskCompletionSource<br></b>The producer/consumer that we just wrote is inflexible in that we can't track work<br>items after they've been enqueued. It would be nice if we could:<br>
· Know when a work item has completed.<br>· Cancel an unstarted work item.<br>· Deal elegantly with any exceptions thrown by a work item.<br>
An  ideal  solution  would  be  to  have  the  EnqueueTask  method  return  some  object<br>giving us the functionality just described. The good news is that a class already exists<br>to do exactly this--the Task class. All we need to do is to hijack control of the task<br>via TaskCompletionSource:<br>
<b>918 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=939></a>public class PCQueue : IDisposable<br>
{<br>  class WorkItem<br>  {<br>
    public readonly <b>TaskCompletionSource&lt;object&gt; TaskSource</b>;<br>
    public readonly Action Action;<br>    public readonly CancellationToken? CancelToken;<br>
    public WorkItem (<br>
      TaskCompletionSource&lt;object&gt; taskSource,<br>      Action action,<br>      CancellationToken? cancelToken)<br>
    {<br>
      TaskSource = taskSource;<br>      Action = action;<br>      CancelToken = cancelToken;<br>
    }<br>
  }<br>
  BlockingCollection&lt;WorkItem&gt; _taskQ = new BlockingCollection&lt;WorkItem&gt;();<br>
<b>Programming</b><br>
  public PCQueue (int workerCount)<br>
<b>Parallel</b><br>
  {<br>    // Create and start a separate Task for each consumer:<br>    for (int i = 0; i &lt; workerCount; i++)<br>
      Task.Factory.StartNew (Consume);<br>
  }<br>
  public void Dispose() { _taskQ.CompleteAdding(); }<br>
  public Task EnqueueTask (Action action)<br>
  {<br>    return EnqueueTask (action, null);<br>  }<br>
  public Task EnqueueTask (Action action, CancellationToken? cancelToken)<br>  {<br>    <b>var tcs = new TaskCompletionSource&lt;object&gt;();<br></b>    _taskQ.Add (new WorkItem (tcs, action, cancelToken));<br>    return <b>tcs.Task;<br></b>  }<br>
  void Consume()<br>  {<br>    foreach (WorkItem workItem in _taskQ.GetConsumingEnumerable())<br>      if (workItem.CancelToken.HasValue &amp;&amp;<br>          workItem.CancelToken.Value.IsCancellationRequested)<br>      {<br>        workItem.TaskSource.SetCanceled();<br>      }<br>
      else<br>        try<br>        {<br>          workItem.Action();<br>          workItem.TaskSource.<b>SetResult</b> (null);   // Indicate completion<br>        }<br>
<b>Concurrent Collections | 919</b><br>
<hr>
<A name=940></a>        catch (Exception ex)<br>
        {<br>          workItem.TaskSource.<b>SetException</b> (ex);<br>        }<br>
  }<br>
}<br>
In EnqueueTask, we enqueue a work item which encapsulates the target delegate and<br>a task completion source--which lets us later control the task that we return to the<br>consumer.<br>
In Consume, we first check whether a task has been canceled after dequeuing the work<br>item. If not, we run the delegate and then call SetResult on the task completion<br>source to indicate its completion.<br>
Here's how we can use this class:<br>
var pcQ = new PCQueue (1);<br>
Task task = pcQ.EnqueueTask (() =&gt; Console.WriteLine (&quot;Easy!&quot;));<br>
...<br>
We can now wait on task, perform continuations on it, have exceptions propagate<br>to continuations on parent tasks, and so on. In other words, we've got the richness<br>of the task model while, in effect, implementing our own scheduler.<br>
<b>SpinLock and SpinWait<br></b>In parallel programming, a brief episode of spinning is often preferable to blocking,<br>as it avoids the cost of context switching and kernel transitions. SpinLock and Spin<br>Wait are designed to help in such cases. Their main use is in writing custom syn-<br>chronization constructs.<br>
SpinLock and SpinWait are structs and not classes! This design<br>decision was an extreme optimization technique to avoid the<br>cost of indirection and garbage collection. It means that you<br>must be careful not to unintentionally <i>copy</i> instances--by pass-<br>ing them to another method without the ref modifier, for in-<br>stance, or declaring them as readonly fields. This is particularly<br>important in the case of SpinLock.<br>
<b>SpinLock<br></b>The SpinLock struct lets you lock without incurring the cost of a context switch, at<br>the expense of keeping a thread spinning (uselessly busy). This approach is valid in<br>high-contention scenarios when locking will be very brief (e.g., in writing a thread-<br>safe linked list from scratch).<br>
<b>920 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=941></a>If you leave a spinlock contended for too long (we're talking<br>milliseconds at most), it will yield its time slice, causing a con-<br>text switch just like an ordinary lock. When rescheduled, it will<br>yield again--in a continual cycle of "spin yielding." This con-<br>sumes  far  fewer  CPU  resources  than  outright  spinning--but<br>more than blocking.<br>
On a single-core machine, a spinlock will start "spin-yielding"<br>immediately if contended.<br>
Using a SpinLock is like using an ordinary lock, except:<br>
· Spinlocks are structs (as previously mentioned).<br>· Spinlocks are not reentrant, meaning that you cannot call Enter on the same<br>
SpinLock twice in a row on the same thread. If you violate this rule, it will either<br>throw an exception (if <i>owner tracking</i> is enabled) or deadlock (if owner tracking<br>is disabled). You can specify whether to enable owner tracking when construct-<br>ing the spinlock. Owner tracking incurs a performance hit.<br>
<b>Programming</b><br>
· SpinLock lets you query whether the lock is taken, via the properties IsHeld and,<br>
<b>Parallel</b><br>
if owner tracking is enabled, IsHeldByCurrentThread.<br>
· There's  no  equivalent  to  C#'s  lock  statement  to  provide  SpinLock  syntactic<br>
sugar.<br>
Another difference is that when you call Enter, you <i>must</i> follow the robust pattern<br>of  providing  a  lockTaken  argument  (which  is  nearly  always  done  within  a  try/<br>finally block).<br>
Here's an example:<br>
var spinLock = new SpinLock (true);   // Enable owner tracking<br>bool lockTaken = false;<br>try<br>{<br>  <b>spinLock.Enter (ref lockTaken);<br></b>  // Do stuff...<br>}<br>finally<br>{<br>  <b>if (lockTaken) spinLock.Exit();<br></b>}<br>
As with an ordinary lock, lockTaken will be false after calling Enter if (and only if)<br>the Enter method throws an exception and the lock was not taken. This happens in<br>very rare scenarios (such as Abort being called on the thread, or an OutOfMemoryEx<br>ception being thrown) and reliably lets you know whether to subsequently call Exit.<br>
SpinLock also provides a TryEnter method, which accepts a timeout.<br>
<b>SpinLock and SpinWait | 921</b><br>
<hr>
<A name=942></a>Given SpinLock's ungainly value-type semantics and lack of lan-<br>guage support, it's almost as if they <i>want</i> you to suffer every time<br>you use it! Think carefully before dismissing an ordinary lock.<br>
A SpinLock makes the most sense when writing your own reusable synchronization<br>constructs. Even then, a spinlock is not as useful as it sounds. It still limits concur-<br>rency. And it wastes CPU time doing <i>nothing useful</i>. Often, a better choice is to spend<br>some of that time doing something <i>speculative</i>--with the help of SpinWait.<br>
<b>SpinWait<br></b>SpinWait helps you write lock-free code that spins rather than blocks. It works by<br>implementing safeguards to avoid the dangers of resource starvation and priority<br>inversion that might otherwise arise with spinning.<br>
Lock-free programming with SpinWait is as <i>hardcore</i> as multi-<br>threading gets and is intended for when none of the higher-level<br>constructs will do. A prerequisite is to understand "Nonblock-<br>ing Synchronization" on page 825 in the previous chapter.<br>
<b>Why we need SpinWait<br></b>Suppose we wrote a spin-based signaling system based purely on a simple flag:<br>
bool _proceed;<br>void Test()<br>
{<br>  // Spin until another thread sets _proceed to true:<br>  while (!_proceed) Thread.MemoryBarrier();<br>  ...<br>
}<br>
This would be highly efficient if Test ran when _proceed was already true--or if<br>_proceed became true within a few cycles. But now suppose that _proceed remained<br>false for several seconds--and that four threads called Test at once. The spinning<br>would then fully consume a quad-core CPU! This would cause other threads to run<br>slowly (resource starvation)--including the very thread that might eventually set<br>_proceed  to  true  (priority  inversion).  The  situation  is  exacerbated  on  single-core<br>machines, where spinning will nearly <i>always</i> cause priority inversion. (And although<br>single-core machines are rare nowadays, single-core <i>virtual machines</i> are not.)<br>
SpinWait addresses these problems in two ways. First, it limits CPU-intensive spin-<br>ning to a set number of iterations, after which it yields its time slice on every spin<br>(by  calling  Thread.Yield  and  Thread.Sleep),  lowering  its  resource  consumption.<br>Second, it detects whether it's running on a single-core machine, and if so, it yields<br>on every cycle.<br>
<b>922 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=943></a><b>How to use SpinWait<br></b>There  are  two  ways  to  use  SpinWait.  The  first  is  to  call  its  static  method,<br>SpinUntil. This method accepts a predicate (and optionally, a timeout):<br>
bool _proceed;<br>
void Test()<br>{<br>  <b>SpinWait.SpinUntil (() =&gt; { Thread.MemoryBarrier(); return _proceed; });</b><br>
  ...<br>
}<br>
The other (more flexible) way to use SpinWait is to instantiate the struct and then to<br>call SpinOnce in a loop:<br>
bool _proceed;<br>void Test()<br>
{<br>  <b>var spinWait = new SpinWait();</b><br>
  while (!_proceed) { Thread.MemoryBarrier(); <b>spinWait.SpinOnce()</b>; }<br>
  ...<br>
}<br>
<b>Programming</b><br>
<b>Parallel</b><br>
The former is a shortcut for the latter.<br>
<b>How SpinWait works<br></b>In  its  current  implementation,  SpinWait performs CPU-intensive spinning for 10<br>iterations before yielding. However, it doesn't return to the caller <i>immediately</i> after<br>each of those cycles: instead, it calls Thread.SpinWait to spin via the CLR (and ulti-<br>mately the operating system) for a set time period. This time period is initially a few<br>tens of nanoseconds, but doubles with each iteration until the 10 iterations are up.<br>This ensures some predictability in the total time spent in the CPU-intensive spin-<br>ning phase, which the CLR and operating system can tune according to conditions.<br>Typically, it's in the few-tens-of-microseconds region--small, but more than the<br>cost of a context switch.<br>
On a single-core machine, SpinWait yields on every iteration. You can test whether<br>SpinWait will yield on the next spin via the property NextSpinWillYield.<br>
If a SpinWait remains in "spin-yielding" mode for long enough (maybe 20 cycles) it<br>will periodically <i>sleep</i> for a few milliseconds to further save resources and help other<br>threads progress.<br>
<b>Lock-free updates with SpinWait and Interlocked.CompareExchange<br></b>SpinWait  in  conjunction  with  Interlocked.CompareExchange  can  atomically<br>update fields with a value calculated from the original (read-modify-write). For ex-<br>ample, suppose we want to multiply field <i>x</i> by 10. Simply doing the following is not<br>thread-safe:<br>
x = x * 10;<br>
for the same reason that incrementing a field is not thread-safe, as we saw in "Non-<br>blocking Synchronization" on page 825 in the preceding chapter.<br>
<b>SpinLock and SpinWait | 923</b><br>
<hr>
<A name=944></a>The correct way to do this without locks is as follows:<br>
1. Take a "snapshot" of <i>x</i> into a local variable.<br>2. Calculate the new value (in this case by multiplying the snapshot by 10).<br>3. Write the calculated value back <i>if</i> the snapshot is still up-to-date (this step must<br>
be done atomically by calling Interlocked.CompareExchange).<br>
4. If the snapshot was stale, <i>spin</i> and return to step 1.<br>
For example:<br>
int x;<br>
void MultiplyXBy (int factor)<br>
{<br>  <b>var spinWait = new SpinWait();</b><br>
  while (true)<br>  {<br>
    int snapshot1 = x;<br>
    Thread.MemoryBarrier();<br>
    int calc = snapshot1 * factor;<br>    <b>int snapshot2 = Interlocked.CompareExchange (ref x, calc, snapshot1);<br></b>    if (snapshot1 == snapshot2) return;   // No one preempted us.<br>
    <b>spinWait.SpinOnce();</b><br>
  }<br>
}<br>
We can improve performance (slightly) by doing away with the<br>call to Thread.MemoryBarrier. We can get away with this because<br>CompareExchange generates a memory barrier anyway--so the<br>worst that can happen is an extra spin if snapshot1 happens to<br>read a stale value in its first iteration.<br>
Interlocked.CompareExchange updates a field with a specified value <i>if</i> the field's cur-<br>rent value matches the third argument. It then returns the field's old value, so you<br>can test whether it succeeded by comparing that against the original snapshot. If the<br>values differ, it means that another thread preempted you, in which case you spin<br>and try again.<br>
CompareExchange is overloaded to work with the object type, too. We can leverage<br>this overload by writing a lock-free update method that works with all reference<br>types:<br>
static void LockFreeUpdate&lt;T&gt; (ref T field, Func &lt;T, T&gt; updateFunction)<br>  where T : class<br>{<br>  <b>var spinWait = new SpinWait();<br></b>  while (true)<br>  {<br>    T snapshot1 = field;<br>    T calc = updateFunction (snapshot1);<br>    <b>T snapshot2 = Interlocked.CompareExchange (ref field, calc, snapshot1);<br></b>    if (snapshot1 == snapshot2) return;<br>
<b>924 | Chapter 22:</b><b>Parallel Programming</b><br>
<hr>
<A name=945></a>    <b>spinWait.SpinOnce();</b><br>
  }<br>}<br>
Here's how we can use this method to write a thread-safe event without locks (this<br>is, in fact, what the C# 4.0 compiler now does by default with events):<br>
EventHandler _someDelegate;<br>public event EventHandler SomeEvent<br>
{<br>  add    { LockFreeUpdate (ref _someDelegate, d =&gt; d + value); }<br>
  remove { LockFreeUpdate (ref _someDelegate, d =&gt; d - value); }<br>
}<br>
<b>SpinWait Versus SpinLock</b><br>
We could solve these problems instead by wrapping access to the shared field<br>around a SpinLock. The problem with spin locking, though, is that it allows only<br>one thread to proceed at a time--even though the spinlock (usually) eliminates<br>the context-switching overhead. With SpinWait, we can proceed speculatively and<br><i>assume</i> no contention. If we do get preempted, we simply try again. Spending CPU<br>
<b>Programming</b><br>
time  doing  something  that  <i>might</i>  work  is  better  than  wasting  CPU  time  in  a<br>
<b>Parallel</b><br>
spinlock!<br>
Finally, consider the following class:<br>
class Test<br>
{<br>  ProgressStatus _status = new ProgressStatus (0, &quot;Starting&quot;);<br>
  class ProgressStatus    // Immutable class<br>  {<br>    public readonly int PercentComplete;<br>    public readonly string StatusMessage;<br>
    public ProgressStatus (int percentComplete, string statusMessage)<br>    {<br>      PercentComplete = percentComplete;<br>      StatusMessage = statusMessage;<br>    }<br>  }<br>}<br>
We can use our LockFreeUpdate method to "increment" the PercentComplete field in<br>_status as follows:<br>
LockFreeUpdate (ref _status,<br>  s =&gt; new ProgressStatus (s.PercentComplete + 1, s.StatusMessage));<br>
Notice that we're creating a new ProgressStatus object based on existing values.<br>Thanks to the LockFreeUpdate method, the act of reading the existing PercentCom<br>plete value, incrementing it, and writing it back can't get <i>unsafely</i> preempted: any<br>preemption is reliably detected, triggering a spin and retry.<br>
<b>SpinLock and SpinWait | 925</b><br>
<hr>
<A name=946></a><hr>
<A name=947></a><b>23</b><br>
<b>Asynchronous Methods</b><br>
In Chapter 21, we saw how a thread provides a parallel execution path. We took for<br>granted that whenever you needed to run something in parallel, you could assign a<br>new or pooled thread to the job. Although this usually holds true, there are excep-<br>tions. Suppose you were writing a TCP sockets or web server application that needed<br>to process 1,000 concurrent client requests. If you dedicated a thread to each in-<br>coming request, you would consume (by default) a gigabyte of memory purely on<br>thread overhead.<br>
Asynchronous  methods  address  this  problem  through  a  pattern  by  which  many<br>concurrent activities are handled by a few pooled threads. This makes it possible to<br>write highly concurrent applications--as well as highly <i>thread-efficient</i> applications.<br>
To avoid getting lost, you'll need to be familiar with threading (Chapter 21) and<br>streams (Chapter 14).<br>
<b>Why Asynchronous Methods Exist<br></b>The problem just described might be insoluble if every thread needed to be busy all<br>of the time. But this is not the case: fetching a web page, for instance, might take up<br>to several seconds from start to end (because of a potentially slow connection) and<br>yet consume only a fraction of a millisecond of CPU time in total. Processing an<br>HTTP request and response is not computationally intensive.<br>
This means that a server thread dedicated to processing a single client request might<br>spend 99% of its time blocked--representing huge economy potential. The <i>asyn-<br>chronous method</i> pattern (also called the <i>asynchronous programming model</i> or APM)<br>exploits just this potential, allowing a handful of fully utilized threads to take on<br>thousands of concurrent jobs.<br>
<b>927</b><br>
<hr>
<A name=948></a>If you don't need such concurrency, avoid the APM; it will un-<br>necessarily  complicate  your  program.  Further,  asynchronous<br>methods  are  not  guaranteed  to  execute  in  parallel  with  the<br>caller.  If  you  need  parallel  execution,  consider  using  a  TPL<br>Task or BackgroundWorker--or simply starting a new thread.<br>
An asynchronous method aims never to block <i>any thread</i>, instead using a pattern of<br>returning with a callback. (Blocking means entering a WaitSleepJoin state--or caus-<br>ing another thread to do the same--"wasting" a precious thread resource.) To ach-<br>ieve this, an asynchronous method must abstain from calling any blocking method.<br>
The end goal of the APM is thread economy. This means that blocking <i>briefly</i> is<br>OK--such as when locking around reading/writing fields.<br>
A method that takes a while to execute because it performs computationally inten-<br>sive work does not violate the APM. The purpose of asynchronous methods isn't to<br>provide a convenient mechanism for executing a method in parallel with the caller;<br>it's to <i>optimize thread resources</i>. Here's the golden rule of the APM:<br>
Make good use of the CPU, or exit with a callback!<br>
This means an asynchronous method such as BeginRead may not return immediately<br>to the caller. It can make the caller wait as long as it likes--while making good use<br>of the processor or another constrained resource. It can even finish the entire task<br>synchronously--providing it never blocked and never caused another thread to do<br>the same.<br>
There is an exception to the don't-block rule. It's generally OK<br>to block while calling a database server--if other threads are<br>competing for the same server. This is because in a highly con-<br>current system, the database must be designed such that the<br>majority of queries execute extremely quickly. If you end up<br>with thousands of concurrent queries, it means that requests are<br>hitting  the  database  server  <i>faster  than  it  can  process  them</i>.<br>Thread economy is then the least of your worries!<br>
Similarly,  reading  or  writing  to  a  local  hard  drive  <i>synchro-<br>nously</i> is usually fine: concurrent I/O will choke the local file-<br>system <i>way</i> before exhausting the thread pool.<br>
The  primary  use  for  asynchronous  methods  is  handling  many  potentially  long-<br>running concurrent requests--typically over slow network connections.<br>
<b>Asynchronous Method Signatures<br></b>Asynchronous methods, by convention, all start with <i>Begin</i>, have a pairing method<br>starting with <i>End</i>, and have signatures like those of asynchronous delegates:<br>
<b>928 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=949></a>IAsyncResult Begin<i>XXX (in/ref-args, AsyncCallback callback, object state);</i><br>
<i>return-type EndXXX (out/ref-args</i>, IAsyncResult asyncResult);<br>
Here's an example from the Stream class:<br>
public IAsyncResult BeginRead (byte[] buffer, int offset, int size,<br>                               AsyncCallback callback, object state);<br>
public int EndRead (IAsyncResult asyncResult);<br>
The Begin method returns an IAsyncResult object, which helps you to manage the<br>asynchronous operation (as we'll see shortly). That same object is then passed to<br>the completion callback. Here's its delegate:<br>
public delegate void AsyncCallback (IAsyncResult ar);<br>
As with asynchronous delegates, the End<i>XXX</i> method allows the return value to be<br>retrieved,  as  well  as  any  out/ref  arguments.  This  is  also  where  exceptions  are<br>rethrown.<br>
If you fail to call the End<i>XXX</i> method, exceptions won't get re-<br>thrown (meaning silent failure) and resources may circumvent<br>cleanup.<br>
To avoid blocking, you will nearly always call the End<i>XXX</i> method from inside the<br>callback method. Callbacks always run on pooled threads.<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
<b>IAsyncResult<br></b>The IAsyncResult interface is defined as follows:<br>
public interface IAsyncResult<br>{<br>  object AsyncState { get; }            // &quot;state&quot; object passed to Begin.<br>  WaitHandle AsyncWaitHandle { get; }   // Signaled when complete.<br>  bool CompletedSynchronously { get; }  // Did it complete on BeginX?<br>  bool IsCompleted { get; }             // Has it completed yet?<br>
}<br>
AsyncState lets you access the state argument passed to the Begin<i>XXX</i> method.<br>
The wait handle is signaled when the operation is complete. To wait on this without<br>blocking, call ThreadPool.RegisterWaitForSingleObject:<br>
ThreadPool.RegisterWaitForSingleObject (<br>  result.AsyncWaitHandle,<br>  (data, timedOut) =&gt; { /* Callback */ },<br>  null, -1, true);<br>
The CompletedSynchronously property indicates that the operation finished imme-<br>diately after calling the Begin<i>XXX</i> method. This may be true for one of three reasons:<br>
· The  operation  could  be  completed  very  quickly--and  so  was  executed  syn-<br>
chronously to avoid the overhead of managing an asynchronous operation.<br>
<b>Asynchronous Method Signatures | 929</b><br>
<hr>
<A name=950></a>· The underlying implementation--or operating system--doesn't support APM<br>
in that scenario.<br>
· The operation was CPU-bound and could be completed without blocking.<br>
When this property returns true, the callback will still be fired--but possibly on the<br><i>same thread</i> as that which called Begin<i>XXX</i>. Failing to consider this possibility can<br>sometimes result in unintended recursion, leading to a stack overflow.<br>
<b>Asynchronous Methods Versus Asynchronous Delegates<br></b>Asynchronous delegate invocations implement the same pattern with their method<br>signatures--but without the goal of thread economy:<br>
<b>Asynchronous methods</b><br>
<b>Asynchronous delegate invocations</b><br>
Rarely or never blocks any thread<br>
May block threads for any length of time (although not the calling<br>thread)<br>
Begin method may not return immediately to the<br>
BeginInvoke returns immediately to the caller<br>
caller<br>
The purpose of asynchronous methods is to allow many tasks to run on few threads;<br>the purpose of asynchronous delegates is to execute a task in parallel with the caller.<br>
You can use an asynchronous delegate to call an asynchronous method--so that<br>execution is guaranteed to return immediately to the caller, while still following the<br>APM. Or better: you can use Framework 4.0's new Task class to wrap an asynchro-<br>nous method call to simplify management (we'll explain how to do this later in the<br>chapter).<br>
If you use an asynchronous delegate to call a blocking method, however, you're back<br>to square one: the server will either suffer limited concurrency or need thousands of<br>threads to do its job.<br>
<b>Using Asynchronous Methods<br></b>Let's rite a simple TCP sockets server that behaves as follows:<br>
1. It waits for a client request.<br>2. It reads a 5,000-byte fixed-length message.<br>3. It reverses the bytes in the message, and then returns them to the client.<br>
Let's first write this using a standard multithreaded <i>blocking</i> pattern. Here is the<br>code, exception handling aside:<br>
You can download a Visual Studio project containing all the<br>code in this chapter--along with a client test harness--at <i>http:<br>//www.albahari.com/nutshell/async40.zip</i>.<br>
<b>930 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=951></a>using System;<br>
using System.Threading;<br>using System.Net;<br>using System.Net.Sockets;<br>
public class Server<br>{<br> public void Serve (IPAddress address, int port)<br>
 {<br>
    ThreadPool.SetMinThreads (50, 50);    // Refer to Chapter 21<br>    ThreadPool.SetMaxThreads (50, 50);    // Refer to Chapter 21<br>    TcpListener listener = new TcpListener (address, port);<br>
    listener.Start();<br>
    while (true)<br>    {<br>      TcpClient c = listener.AcceptTcpClient();<br>
      ThreadPool.QueueUserWorkItem (Accept, c);<br>
    }<br>  }<br>
  void Accept (object clientObject)<br>  {<br>
    using (TcpClient client = (TcpClient) clientObject)<br>    using (NetworkStream n = client.GetStream())<br>
    {<br>      byte[] data = new byte [5000];<br>
      int bytesRead = 0; int chunkSize = 1;<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
      while (bytesRead &lt; data.Length &amp;&amp; chunkSize &gt; 0)<br>        bytesRead +=<br>          <b>chunkSize = n.Read<br></b>            <b>(data, bytesRead, data.Length - bytesRead);    // BLOCKS</b><br>
      Array.Reverse (data);<br>      <b>n.Write (data, 0, data.Length);                      // BLOCKS<br></b>    }<br>  }<br>}<br>
From  Framework  4.0,  you  can  replace  ThreadPool.QueueUser<br>WorkItem  with  Task.Factory.StartNew.  The  end  result  is  the<br>same.<br>
Our use of the thread pool prevents an arbitrarily large number of threads from being<br>created (possibly taking down the server) and eliminates the time wasted in creating<br>a new thread per request. Our program is simple and fast, but it is limited to 50<br>concurrent requests.<br>
In  order  to  scale  to  1,000  concurrent  requests--without  increasing  the  thread<br>count--we must employ the asynchronous method pattern. This means avoiding<br>the blocking I/O methods altogether and instead calling their asynchronous coun-<br>terparts. Here's how to do it:<br>
<b>Using Asynchronous Methods | 931</b><br>
<hr>
<A name=952></a>public class Server<br>
{<br>  public void Serve (IPAddress address, int port)<br>  {<br>
    ThreadPool.SetMinThreads (50, 50);<br>
    TcpListener listener = new TcpListener (address, port);<br>    listener.Start();<br>    while (true)<br>
    {<br>
      TcpClient c = listener.AcceptTcpClient();<br>      ThreadPool.QueueUserWorkItem (ReverseEcho, c);<br>    }<br>
  }<br>
  void ReverseEcho (object client)<br>  {<br>
    new ReverseEcho().Begin ((TcpClient)client);<br>  }<br>
}<br>
class ReverseEcho<br>
{<br>  TcpClient _client;<br>  NetworkStream _stream;<br>  byte[] _data = new byte [5000];<br>
  int _bytesRead = 0;<br>
  internal void Begin (TcpClient c)<br>  {<br>
    try<br>    {<br>
      _client = c;<br>      _stream = c.GetStream();<br>      Read();<br>    }<br>    catch (Exception ex) { ProcessException (ex); }<br>  }<br>
  void Read()            // Read in a nonblocking fashion.<br>  {<br>    while (true)<br>    {<br>      <b>IAsyncResult r = _stream.BeginRead<br></b>       <b>(_data, _bytesRead, _data.Length - _bytesRead, ReadCallback, null);</b><br>
      // This will nearly always return in the next line:<br>      if (!r.CompletedSynchronously) return;   // Handled by callback<br>      if (!EndRead (r)) break;<br>    }<br>    Write();<br>  }<br>
  void ReadCallback (IAsyncResult r)<br>  {<br>    try<br>    {<br>
<b>932 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=953></a>      if (r.CompletedSynchronously) return;<br>
      if (EndRead (r))<br>      {<br>        Read();       // More data to read!<br>
        return;<br>
      }<br>      Write();<br>    }<br>
    catch (Exception ex) { ProcessException (ex); }<br>
  }<br>
  bool EndRead (IAsyncResult r)   // Returns false if there's no more data<br>
  {<br>    <b>int chunkSize = _stream.EndRead (r);</b><br>
    _bytesRead += chunkSize;<br>    return chunkSize &gt; 0 &amp;&amp; _bytesRead &lt; _data.Length;   // More to read<br>
  }<br>
  void Write()<br>  {<br>    Array.Reverse (_data);<br>
    <b>_stream.BeginWrite (_data, 0, _data.Length, WriteCallback, null);</b><br>
  }<br>
  void WriteCallback (IAsyncResult r)<br>
  {<br>    try { <b>_stream.EndWrite (r);</b> }<br>
    catch (Exception ex) { ProcessException (ex); }<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
    Cleanup();<br>
  }<br>
  void ProcessException (Exception ex)<br>  {<br>    Cleanup();<br>    Console.WriteLine (&quot;Error: &quot; + ex.Message);<br>  }<br>
  void Cleanup()<br>  {<br>    if (_stream != null) _stream.Close();<br>    if (_client != null) _client.Close();<br>  }<br>}<br>
This  program  will  handle  1,000  concurrent  requests  on  fewer  than  10  pooled<br>threads.<br>
Each client request is processed without calling any blocking methods (aside from<br>the call to listener.AcceptTcpClient in the Serve method, which blocks just one<br>thread).<br>
In the Read method, we start by calling BeginRead on the stream, specifying a com-<br>pletion callback. We could simplify the entire method as follows and get the same<br>result:<br>
<b>Using Asynchronous Methods | 933</b><br>
<hr>
<A name=954></a>void Read()<br>
{<br>  <b>_stream.BeginRead<br></b>    <b>(_data, _bytesRead, _data.Length - _bytesRead, ReadCallback, null);</b><br>
}<br>
However, there's a small chance that BeginRead could finish synchronously and then<br>call ReadCallback on the same thread. Because ReadCallback calls Read again, this<br>might lead to some fairly deep recursion and a stack overflow. To protect against<br>this, we must check CompletedSynchronously after calling BeginRead, and if it returns<br>true, use a <i>loop</i> to call Read until completion rather than relying on the potentially<br>recursive call in ReadCallback.<br>This leads to why we called AcceptTcpClient in the Serve method--instead of its<br>asynchronous version, BeginAcceptTcpClient. For the benefit of saving one thread,<br>the latter would require the same pattern of use as with BeginRead to avoid a possible<br>stack overflow.<br>
The ReverseEcho class encapsulates a request's state for its lifetime. We can no longer<br>use local variables for this job, because the execution stack disappears each time we<br>exit (after each call to an asynchronous method). This also complicates cleanup and<br>means  that  a  simple  using  statement  is  no  longer  suitable  for  closing  our<br>TcpClient and stream.<br>
Another complicating factor is that we can't use types such as BinaryReader and<br>BinaryWriter, because they don't offer asynchronous versions of their methods. The<br>asynchronous  pattern  often  forces  you  to  work  at  a  lower  level  than  you  might<br>otherwise.<br>
<b>Asynchronous Methods and Tasks<br></b>We saw in the preceding chapter how Framework 4.0's Task class can manage a unit<br>of work that runs on a pooled thread. You can also use a Task to wrap asynchronous<br>method calls--via the FromAsync method on TaskFactory.<br>The task that you get from calling FromAsync is merely a lightweight wrapper over<br>calling a Begin<i>XXX</i> and End<i>XXX</i> method--it does not get <i>scheduled</i> like an ordinary<br>task. The reason to use FromAsync is to leverage features such as continuations and<br>child tasks. FromAsync is internally implemented using TaskCompletionSource.<br>The FromAsync method requires the following parameters:<br>
· A delegate specifying a Begin<i>XXX</i> method<br>· A delegate specifying an End<i>XXX</i> method<br>· Additional arguments that will get passed to these methods<br>
FromAsync is overloaded to accept delegate types and arguments that match nearly<br>all  the  asynchronous  method  signatures  found  in  the  .NET  Framework.  For  in-<br>stance, assuming stream is a Stream, instead of doing this:<br>
var buffer = new byte[1000];<br>stream.BeginRead (buffer, 0, 1000, MyCallback, null);<br>
<b>934 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=955></a>...<br>
void MyCallback (IAsyncResult r)<br>{<br>  int bytesRead;<br>
  try { bytesRead = stream.EndWrite (r); }<br>
  catch (Exception ex) { Console.Write (ex.Message); }<br>  Console.Write (bytesRead + &quot; bytes read&quot;);<br>}<br>
we can do this:<br>
var buffer = new byte[1000];<br>
<b>Task&lt;int&gt; readChunk = Task&lt;int&gt;.Factory.FromAsync (</b><br>
  <b>stream.BeginRead, stream.EndRead, buffer, 0, 1000, null);</b><br>
readChunk.ContinueWith (ant =&gt; Console.Write (ant.Result + &quot; bytes read&quot;),<br>
                               TaskContinuationOptions.NotOnFaulted);<br>
readChunk.ContinueWith (ant =&gt; Console.Write (ant.Exception.Message),<br>                               TaskContinuationOptions.OnlyOnFaulted);<br>
This doesn't deliver a huge saving in itself: the real benefit comes when you introduce<br>continuations with child antecedents. Revisiting our earlier example, suppose that<br>we refactor ReverseEcho's Begin method so that it calls Read on a new task. This<br>liberates Server.Serve from having to create a task itself, but more importantly, it<br>creates a parent for the FromAsync-created tasks upon which we can attach contin-<br>uations. This avoids having to write separate exception-handling blocks or explicit<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
fault continuations for each child task. Cleanup can also be done easily as another<br>continuation on the parent:<br>
public class Server<br>{<br>  public void Serve (IPAddress address, int port)<br>  {<br>    ThreadPool.SetMinThreads (50, 50);<br>    TcpListener listener = new TcpListener (address, port);<br>    listener.Start();<br>    while (true)<br>    {<br>      TcpClient c = listener.AcceptTcpClient();<br>      new ReverseEcho().BeginAsync (c);<br>    }<br>  }<br>}<br>
class ReverseEcho<br>{<br>  TcpClient _client;<br>  NetworkStream _stream;<br>  byte[] _data = new byte [5000];<br>  int _bytesRead = 0;<br>
  internal void BeginAsync (TcpClient c)<br>  {<br>    _client = c;<br>
<b>Asynchronous Methods and Tasks | 935</b><br>
<hr>
<A name=956></a>    _stream = c.GetStream();<br>
    var task = Task.Factory.StartNew (Read);<br>
    // Set up centralized error handling and cleanup:<br>
    task.<b>ContinueWith</b> (ant =&gt;<br>      Console.WriteLine (&quot;Error: &quot; + ant.Exception.Message),<br>
      TaskContinuationOptions.OnlyOnFaulted);<br>
    task.<b>ContinueWith</b> (ant =&gt;<br>    {<br>
      if (_stream != null) _stream.Close();<br>      if (_client != null) _client.Close();<br>
    });<br>  }<br>
  void Read()    // This will create a <i>child</i> task.<br>
  {<br>    Task&lt;int&gt; readChunk = Task&lt;int&gt;.Factory.FromAsync (<br>      _stream.BeginRead, _stream.EndRead,<br>
      _data, 0, _data.Length - _bytesRead, null,<br>
      <b>TaskCreationOptions.AttachedToParent</b>);<br>
    readChunk.ContinueWith (Write, TaskContinuationOptions.NotOnFaulted);<br>
  }<br>
  void Write (Task&lt;int&gt; readChunk)<br>  {<br>    _bytesRead += readChunk.Result;<br>    if (readChunk.Result &gt; 0 &amp;&amp; _bytesRead &lt; _data.Length)<br>
    {<br>      Read();       // More data to read!<br>      return;<br>    }<br>    Array.Reverse (_data);<br>    Task.Factory.FromAsync (_stream.BeginWrite, _stream.EndWrite,<br>                            _data, 0, _data.Length, null,<br>                            <b>TaskCreationOptions.AttachedToParent</b>);<br>  }<br>}<br>
We also need not worry about Read going recursive and performing a stack dive:<br>continuations don't happen synchronously unless you tell them to.<br>
<b>Asynchronous Methods and Iterators</b><br>
In Visual Studio 2010's parallel programming samples for PFX, you'll find an ex-<br>tension method on TaskFactory called Iterate. With this, you can move the logic<br>from the ReverseEcho class in our sample into a single iterator method. This is a<br>terrific pattern in simple scenarios because it means you can replace ReverseEcho<br>and its fields with a simple method with local variables. Here's our Server class<br>refactored:<br>
<b>936 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=957></a>public class Server<br>
{<br>  public void Serve (IPAddress address, int port)<br>  {<br>
    ThreadPool.SetMinThreads (50, 50);<br>
    TcpListener listener = new TcpListener (address, port);<br>    listener.Start();<br>    while (true)<br>
    {<br>
      TcpClient c = listener.AcceptTcpClient();<br>      Task.Factory.<b>Iterate</b> (ReverseEcho(c)).ContinueWith (t =&gt;<br>        Console.WriteLine (&quot;Error: &quot; + t.Exception.Message),<br>
        TaskContinuationOptions.OnlyOnFaulted);<br>
    }<br>  }<br>
  IEnumerable&lt;Task&gt; ReverseEcho (TcpClient client)<br>  {<br>
    using (client)<br>    using (var stream = client.GetStream())<br>
    {<br>      byte[] data = new byte[Program.MessageLength];<br>
      int bytesRead = 0;<br>      while (true)<br>
      {<br>        // ReadASync is an extension method in the samples.<br>
        Task&lt;int&gt; readChunk = stream.ReadAsync<br>          (data, bytesRead, data.Length - bytesRead);<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
        <b>yield return readChunk;<br></b>        bytesRead += readChunk.Result;<br>
        if (readChunk.Result &lt;= 0 || bytesRead &gt;= data.Length)<br>          break;<br>      }<br>      Array.Reverse(data);<br>      <b>yield return stream.WriteAsync (data, 0, bytesRead);<br></b>    }<br>  }<br>}<br>
In more complex cases, however, having a class is helpful because you can abstract<br>the code into as many methods (and classes) as you like. The problem with an<br>iterator is that any methods that you call from the iterator can't themselves yield<br>on behalf of the caller, and this cramps your ability to refactor large code blocks.<br>
<b>Writing Asynchronous Methods<br></b>Returning to our previous example, suppose that the 5,000-byte exchange was just<br>a small part of a more sophisticated communication protocol. It would be nice to<br>turn what we've already written into a method like this:<br>
public byte[] ReverseEcho (TcpClient client);<br>
The problem, of course, is that this method signature is synchronous; we need to<br>offer an asynchronous version--in other words, BeginReverseEcho. Further, if an<br>
<b>Writing Asynchronous Methods | 937</b><br>
<hr>
<A name=958></a>exception is encountered, it's no good writing it to the Console; we need to throw<br>it back to the consumer at some point. So, to usefully partake in the pattern, we<br>must also offer EndReverseEcho and write a class that implements IAsyncResult.<br>Our ReverseEcho class is an excellent candidate for IAsyncResult, since it already<br>encapsulates the operation's state. All we really need to add is some plumbing code<br>to rethrow any exception upon calling EndReverseEcho, and a wait handle to signal<br>at completion.<br>
Here's a real-world example, complete with exception handling and thread safety:<br>
// This sample can be downloaded at http://www.albahari.com/nutshell/<br>
public class MessagingServices<br>
{<br>  public static IAsyncResult <b>BeginReverseEcho (TcpClient client,</b><br>
                                               <b>AsyncCallback callback,</b><br>
                                               <b>object userState)<br></b>  {<br>
    var re = new ReverseEcho();<br>
    re.Begin (client, callback, userState);<br>
    return re;<br>  }<br>
  public static byte[] <b>EndReverseEcho (IAsyncResult r)</b><br>
  {<br>
    return ((ReverseEcho)r).End();<br>  }<br>}<br>
class ReverseEcho : IAsyncResult<br>
{<br>  TcpClient _client;<br>  NetworkStream _stream;<br>  object _userState;<br>  ManualResetEvent _waitHandle = new ManualResetEvent (false);<br>  int _bytesRead = 0;<br>  byte[] _data = new byte [5000];<br>  Exception _exception;<br>
  internal ReverseEcho() { }<br>
  // IAsyncResult members:<br>
  public object AsyncState { get { return _userState; } }<br>  public WaitHandle AsyncWaitHandle { get { return _waitHandle; } }<br>  public bool CompletedSynchronously { get { return false; } }<br>  public bool IsCompleted<br>  {<br>    get { return _waitHandle.WaitOne (0, false); }<br>  }<br>
  internal void Begin (TcpClient c, AsyncCallback callback, object state)<br>  {<br>    _client = c;<br>    _userState = state;<br>
<b>938 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=959></a>    _stream = _client.GetStream();<br>
    Task.Factory.StartNew (Read).ContinueWith (ant =&gt;<br>    {<br>
      _exception = ant.Exception;   // In case an exception occurred.<br>
      if (_stream != null)<br>        try { _stream.Close(); }<br>
        catch (Exception ex) { _exception = ex; };<br>
      _waitHandle.Set();<br>
      if (callback != null) callback (this);<br>
    });<br>
  }<br>
  internal byte[] End()     // Wait for completion + rethrow any error.<br>
  {<br>    AsyncWaitHandle.WaitOne();<br>
    if (_exception != null) throw _exception;<br>    return _data;<br>
  }<br>
  void Read()<br>  {<br>    Task&lt;int&gt; readChunk = Task&lt;int&gt;.Factory.FromAsync (<br>
      _stream.BeginRead, _stream.EndRead,<br>      _data, 0, _data.Length - _bytesRead, null);<br>
<b>Asynchronous</b><br>
<b>Methods</b><br>
    readChunk.ContinueWith (ContinueRead,<br>
                            TaskContinuationOptions.NotOnFaulted);<br>  }<br>
  void ContinueRead (Task&lt;int&gt; readChunk)<br>  {<br>    _bytesRead += readChunk.Result;<br>    if (readChunk.Result &gt; 0 &amp;&amp; _bytesRead &lt; _data.Length)<br>    {<br>      Read();       // More data to read!<br>      return;<br>
    }<br>    Array.Reverse (_data);<br>    Task.Factory.FromAsync (_stream.BeginWrite, _stream.EndWrite,<br>                            _data, 0, _data.Length, null);<br>  }<br>}<br>
In Cleanup, we closed _stream but not _client, because the caller may want to con-<br>tinue using _client after performing the reverse echo.<br>
<b>Writing Asynchronous Methods | 939</b><br>
<hr>
<A name=960></a>When writing asynchronous methods, you must meticulously<br>catch all exceptions, saving the exception object so that it can<br>be rethrown when the consumer calls the End<i>XXX</i> method. The<br>easiest  way  to  achieve  this  is  to  attach  a  continuation  to  an<br>overarching parent task (as in our example)--this catches all<br>exceptions thrown by its child tasks.<br>
<b>Fake Asynchronous Methods<br></b>In  general,  any  Framework  method  that  starts  with  <i>Begin</i>  and  that  returns  an<br>IASyncResult follows the APM. There are, however, some exceptions, based on the<br>Stream class:<br>
BufferedStream<br>
CryptoStream<br>
DeflateStream<br>
MemoryStream<br>
These types rely on fallback asynchronous implementations in the base Stream class,<br>which offer no guarantees not to block. Instead, they use an asynchronous delegate<br>to call a <i>blocking</i> method such as Read or Write. Although this approach is perfectly<br>valid in the case of MemoryStream (it never blocks in the first place, so it is excused),<br>it creates a problem with BufferedStream and CryptoStream--if wrapping anything<br>other than a MemoryStream. In other words, if you call BeginRead or BeginWrite on a<br>CryptoStream that wraps a NetworkStream, some thread is going to block at some<br>point, violating the scalability of the asynchronous method pattern. This is a shame,<br>because the CryptoStream's decorator architecture is otherwise efficient.<br>A  workaround  with  CryptoStream  is  to  first  read  the  underlying  stream<br>asynchronously  into  a  MemoryStream,  and  then  have  the  CryptoStream  wrap  the<br>MemoryStream. This means reading the whole stream into memory, though, which,<br>on a highly concurrent server, is not great for scalability, either. If you really need<br>an  asynchronous  encryption,  a  solution  is  to  work  at  a  lower  level  than<br>CryptoStream--that  is,  ICryptoTransform.  You  can  see  exactly  how  CryptoStream<br>uses ICryptoTransform to do its work with a disassembly tool such as Red Gate's<br>Reflector.<br>
DeflateStream does actually follow the asynchronous pattern--or at least tries to.<br>The problem is that it doesn't properly handle exceptions. If the underlying stream<br>is corrupt, for instance, BeginRead throws an exception on a pooled thread rather<br>than marshaling it back to EndRead. This is an uncatchable exception that takes down<br>your whole application.<br>
The FileStream class is another violator--it touts <i>fake</i> asynchronous methods (i.e.,<br>it relies on Stream's default implementation). However, it does make an attempt at<br>true asynchronous behavior if constructed as follows:<br>
Stream s = new FileStream (&quot;large.bin&quot;, FileMode.Create, FileAccess.Write,<br>                            FileShare.None, 0×1000, <b>true</b>);<br>
<b>940 | Chapter 23:</b><b>Asynchronous Methods</b><br>
<hr>
<A name=961></a>The  boolean  argument  at  the  end  instructs  FileStream  not  to  use  asynchronous<br>delegates--and  instead  (to  attempt)  a  true  APM  approach.  The  problem  is  that<br>asynchronous file I/O requires operating system support, which may not be forth-<br>coming. If the OS fails to oblige, BeginRead blocks the calling thread in a WaitSleep<br>Join state.<br>
Lack of asynchronous file I/O is rarely a problem, though, assuming you're accessing<br>a local filesystem (in fact, it can be a good idea not to use asynchronous file I/O at<br>all). Small file requests are likely to be served from an operating system or hard-drive<br>cache and so be brief and CPU-bound; large file I/O requests are going to seriously<br>limit concurrency if not broken up or throttled in some way, no matter what the<br>threading  model.  A  more  insidious  blocking  issue  arises  if  you're  using  a<br>FileStream on a UNC network path: the solution is instead to use lower-level net-<br>working classes (such as those described) for communicating between computers.<br>
<b>Alternatives to Asynchronous Methods<br></b>Chapter 21 described three analogous techniques--all of which coalesce many tasks<br>onto a few threads:<br>
· ThreadPool.RegisterWaitForSingleObject<br>· The producer/consumer queue<br>· The threading and system timers<br>
<b>Asynchronous</b><br>
ThreadPool.RegisterWaitForSingleObject can be helpful in implementing the asyn-<br>
<b>Methods</b><br>
chronous method pattern. A custom producer/consumer queue can provide a com-<br>plete alternative--with your own pool of workers--but is of no help if you want to<br>interoperate with the .NET Framework (e.g., to read from a NetworkStream). The<br>threading and system timers are excellent if your work is executed in a periodic<br>fashion, rather than in response to requests.<br>
<b>Alternatives to Asynchronous Methods | 941</b><br>
<hr>
<A name=962></a><hr>
<A name=963></a><b>24</b><br>
<b>Application Domains</b><br>
An <i>application domain</i> is the runtime unit of isolation in which a .NET program<br>runs. It provides a managed memory boundary, a container for loaded assemblies<br>and  application  configuration  settings,  as  well  as  delineating  a  communication<br>boundary for distributed applications.<br>
Each .NET process usually hosts just one application domain: the default domain,<br>created automatically by the CLR when the process starts. It's also possible--and<br>sometimes useful--to create additional application domains within the same proc-<br>ess. This provides isolation while avoiding the overhead and communication com-<br>plications that arise with having separate processes. It's useful in scenarios such as<br>load testing and application patching, and in implementing robust error recovery<br>mechanisms.<br>
<b>Application Domain Architecture<br></b>Figure  24-1  illustrates  the  application  domain  architectures  for  single-domain,<br>multidomain, and typical distributed client/server applications. In most cases, the<br>processes housing the application domains are created implicitly by the operating<br>system--when the user double-clicks your .NET executable file or starts a Windows<br>service. However, an application domain can also be hosted in other processes such<br>as IIS or in SQL Server through CLR integration.<br>
In the case of a simple executable, the process ends when the default application<br>domain  finishes  executing.  With  hosts  such  as  IIS  or  SQL  Server,  however,  the<br>process controls the lifetime, creating and destroying .NET application domains as<br>it sees fit.<br>
<b>943</b><br>
<hr>
<A name=964></a><IMG src="c#-4-nutshell-964_1.jpg"><br>
<i>Figure 24-1. Application domain architecture</i><br>
<b>944 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=965></a><b>Creating and Destroying Application Domains<br></b>You can create and destroy additional application domains in a process by calling<br>the static methods AppDomain.CreateDomain and AppDomain.Unload. In the following<br>example,  <i>test.exe</i>  is  executed  in  an  isolated  application  domain,  which  is  then<br>unloaded:<br>
static void Main()<br>
{<br>  AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;);<br>  newDomain.ExecuteAssembly (&quot;test.exe&quot;);<br>
  AppDomain.Unload (newDomain);<br>
}<br>
Note  that  when  the  default  application  domain  (the  one  created  by  the  CLR  at<br>startup) is unloaded, all other application domains automatically unload, and the<br>application closes. A domain can "know" whether it's the default domain via the<br>AppDomain property IsDefaultDomain.<br>
The AppDomainSetup class allows options to be specified for a new domain. The fol-<br>lowing properties are the most useful:<br>
public string ApplicationName { get; set; }        // &quot;Friendly&quot; name<br>
public string ApplicationBase { get; set; }        // Base folder<br>
public string ConfigurationFile { get; set; }<br>
public string LicenseFile       { get; set; }<br>
// To assist with automatic assembly resolution:<br>public string PrivateBinPath      { get; set; }<br>public string PrivateBinPathProbe { get; set; }<br>
The ApplicationBase property controls the application domain base directory, used<br>as the root for automatic assembly probing. In the default application domain, this<br>
<b>App Domains</b><br>
is the main executable's folder. In a new domain that you create, it can be anywhere<br>you like:<br>
AppDomainSetup setup = new AppDomainSetup();<br>setup.ApplicationBase = @&quot;c:\MyBaseFolder&quot;;<br>AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;, null, setup);<br>
It's also possible to subscribe a new domain to assembly resolution events defined<br>in the instigator's domain:<br>
static void Main()<br>{<br>  AppDomain newDomain = AppDomain.CreateDomain (&quot;test&quot;);<br>  newDomain.AssemblyResolve += new ResolveEventHandler (FindAssem);<br>  ...<br>}<br>
static Assembly FindAssem (object sender, ResolveEventArgs args)<br>{<br>  ...<br>}<br>
<b>Creating and Destroying Application Domains | 945</b><br>
<hr>
<A name=966></a>This is acceptable providing the event handler is a static method that is defined<br>in  a  type  available  to  both  domains.  The  CLR  is  then  able  to  execute  the  event<br>handler in the correct domain. In this example, FindAssem would execute from within<br>newDomain, even though it was subscribed from the default domain.<br>
The PrivateBinPath property is a semicolon-separated list of subdirectories below<br>the base directory that the CLR should automatically search for assemblies. (As with<br>the application base folder, this can only be set prior to the application domain<br>starting.)  Take,  for  example,  a  directory  structure  where  a  program  has  a  single<br>executable (and perhaps a configuration file) in its base folder and all the referenced<br>assemblies in subfolders as follows:<br>
c:\MyBaseFolder\                  -- Startup executable<br>
               \bin<br>               \bin\v1.23         -- Latest assembly DLLs<br>
               \bin\plugins       -- More DLLs<br>
Here's how an application domain would be set up to use this folder structure:<br>
AppDomainSetup setup  = new AppDomainSetup();<br>
setup.ApplicationBase = @&quot;c:\MyBaseFolder&quot;;<br>
setup.PrivateBinPath  = @&quot;bin\v1.23;bin\plugins&quot;;<br>
AppDomain d = AppDomain.CreateDomain (&quot;New Domain&quot;, null, setup);<br>
d.ExecuteAssembly (@&quot;c:\MyBaseFolder\Startup.exe&quot;);<br>
Note  that  PrivateBinPath  is  always  relative  to,  and  below,  the  application  base<br>folder.  Specifying  absolute  paths  is  illegal.  AppDomain  also  provides  a  PrivateBin<br>PathProbe property, which, if set to anything other than a blank string, excludes the<br>base  directory  itself  from  being  part  of  the  assembly  search  path.  (The  reason<br>PrivateBinPathProbe  is  a  string  rather  than  a  bool  type  relates  to  COM<br>compatibility.)<br>
Just before any nondefault application domain unloads, the DomainUnload event fires.<br>You can use this event for tear-down logic: the unloading of the domain (and the<br>application as a whole, if necessary) is delayed until the execution of all DomainUn<br>load event handlers completes.<br>
Just before the application itself closes, the ProcessExit event fires on all loaded<br>application domains (including the default domain). Unlike with the DomainUnload<br>event, ProcessExit event handlers are timed: the default CLR host gives event han-<br>dlers two seconds per domain, and three seconds in total, before terminating their<br>threads.<br>
<b>Using Multiple Application Domains<br></b>Multiple application domains have the following key uses:<br>
· Providing process-like isolation with minimum overhead<br>· Allowing assembly files to be unloaded without restarting the process<br>
<b>946 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=967></a>When additional application domains are created within the same process, the CLR<br>provides each with a level of isolation akin to that of running in separate processes.<br>This  means  that  each  domain  has  separate  memory,  and  objects  in  one  domain<br>cannot interfere with those in another. Furthermore, static members of the same<br>class have independent values in each domain. ASP.NET uses exactly this approach<br>to allow many sites to run in a shared process without affecting each other.<br>
With ASP.NET, the application domains are created by the infrastructure--without<br>your intervention. There are times, however, when you can benefit from explicitly<br>creating multiple domains inside a single process. Suppose you've written a custom<br>authentication system, and as part of unit testing, you want to stress-test the server<br>code by simulating 20 clients logging in at once. You have three options in simulating<br>20 concurrent logins:<br>
· Start 20 separate processes by calling Process.Start 20 times.<br>· Start 20 threads in the same process and domain.<br>· Start 20 threads in the same process--each in its own application domain.<br>
The first option is clumsy and resource-intensive. It's also hard to communicate with<br>each of the separate processes, should you want to give them more specific instruc-<br>tions on what to do.<br>
The  second  option  relies  on  the  client-side  code  being  thread-safe,  which  is<br>unlikely--especially if static variables are used to store the current authentication<br>state.  And  adding  a  lock  around  the  client-side  code  would  prevent  the  parallel<br>execution that we need to stress-test the server.<br>
The third option is ideal. It keeps each thread isolated--with independent state--<br>and yet within easy reach of the hosting program.<br>
Another reason to create a separate application domain is to allow assemblies to be<br>unloaded without ending the process. This stems from the fact that there's no way<br>
<b>App Domains</b><br>
to unload an assembly other than closing the application domain that loaded it. This<br>is a problem if it was loaded in the default domain, because closing this domain<br>means closing the application. An assembly's file is locked while loaded and so can-<br>not be patched or replaced. Loading assemblies in a separate application domain<br>that can be torn down gets around this problem--as well as helping to reduce the<br>memory footprint of an application that occasionally needs to load large assemblies.<br>
<b>Using Multiple Application Domains | 947</b><br>
<hr>
<A name=968></a><b>The LoaderOptimization Attribute</b><br>
By default, assemblies that load into an explicitly created application domain are<br>reprocessed by the JIT compiler. This includes:<br>
· Assemblies that have already been JIT-compiled in the caller's domain<br>· Assemblies for which a native image has been generated with the <i>ngen.exe</i> tool<br>· All of the .NET Framework assemblies (except for <i>mscorlib</i>)<br>
This can be a major performance hit, particularly if you repeatedly create and<br>unload application domains that reference large .NET Framework assemblies. A<br>workaround  is  to  attach  the  following  attribute  to  your  program's  main  entry<br>method:<br>
[LoaderOptimization (LoaderOptimization.MultiDomainHost)]<br>
This instructs the CLR to load GAC assemblies <i>domain-neutral</i>, so native images<br>are honored and JIT images shared across application domains. This is usually<br>ideal, because the GAC includes all .NET Framework assemblies (and possibly<br>some invariant parts of your application).<br>
You can go a stage further by specifying LoaderOptimization.MultiDomain: this<br>instructs <i>all</i> assemblies to be loaded domain-neutral (excluding those loaded out-<br>side the normal assembly resolution mechanism). This is undesirable, however, if<br>you want assemblies to unload with their domain. A domain-neutral assembly is<br>shared between all domains and so does not unload until the parent process ends.<br>
<b>Using DoCallBack<br></b>Let's revisit the most basic multidomain scenario:<br>
static void Main()<br>{<br>  AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;);<br>
  newDomain.ExecuteAssembly (&quot;test.exe&quot;);<br>  AppDomain.Unload (newDomain);<br>}<br>
Calling ExecuteAssembly on a separate domain is convenient but offers little oppor-<br>tunity to interact with the domain. It also requires that the target assembly is an<br>executable, and it commits the caller to a single entry point. The only way to incor-<br>porate flexibility is to resort to an approach such as passing a string of arguments to<br>the executable.<br>
A more powerful approach is to use AppDomain's DoCallBack method. This executes<br>on another application domain, a method on a given type. The type's assembly is<br>automatically loaded into the domain (the CLR will know where it lives if the current<br>domain can reference it). In the following example, a method in the currently exe-<br>cuting class is run in a new domain:<br>
class Program<br>{<br>
<b>948 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=969></a>  static void Main()<br>
  {<br>    AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;);<br>    newDomain.DoCallBack (new CrossAppDomainDelegate (SayHello));<br>
    AppDomain.Unload (newDomain);<br>
  }<br>
  static void SayHello()<br>
  {<br>
    Console.WriteLine (&quot;Hi from &quot; + AppDomain.CurrentDomain.FriendlyName);<br>  }<br>}<br>
The example works because the delegate is referencing a static method, meaning it<br>points to a type rather than an instance. This makes the delegate "domain-agnostic"<br>or agile. It can run in any domain, and in the same way, as there's nothing tying it<br>to the original domain. It's also possible to use DoCallBack with a delegate referencing<br>an instance method. However, the CLR will attempt to apply Remoting semantics<br>(described later), which in this case happens to be the opposite of what we want.<br>
<b>Monitoring Application Domains<br></b>From Framework 4.0, you can monitor the memory and CPU consumption of a<br>specific application domain. For this to work, you must first enable application do-<br>main monitoring as follows:<br>
AppDomain.MonitoringIsEnabled = true;<br>
This enables monitoring for the current domain. Once enabled, you can't subse-<br>quently disable it--setting this property to false throws an exception.<br>
Another way to enable to enable domain monitoring is via the<br>
<b>App Domains</b><br>
application configuration file. Add the following element:<br>
&lt;configuration&gt;<br>   &lt;runtime&gt;<br>     <b>&lt;appDomainResourceMonitoring enabled=&quot;true&quot;/&gt;<br></b>  &lt;/runtime&gt;<br>&lt;/configuration&gt;<br>
This enables monitoring for all application domains.<br>
You can then query an AppDomain's CPU and memory usage via the following three<br>instance properties:<br>
MonitoringTotalProcessorTime<br>MonitoringTotalAllocatedMemorySize<br>MonitoringSurvivedMemorySize<br>
The first two properties return the <i>total</i> CPU consumption and managed memory<br>allocated by that domain since it was started. (These figures can only grow and never<br>shrink.) The third property returns the actual managed memory consumption of the<br>domain at the time of the last garbage collection.<br>
<b>Monitoring Application Domains | 949</b><br>
<hr>
<A name=970></a>You can access these properties from the same or another domain.<br>
<b>Domains and Threads<br></b>When you call a method in another application domain, execution blocks until the<br>method finishes executing--just as though you called a method in your own domain.<br>Although this behavior is usually desirable, there are times when you need to run a<br>method concurrently. You can do that with multithreading.<br>
We talked previously about using multiple application domains to simulate 20 con-<br>current client logins in order to test an authentication system. By having each client<br>log in on a separate application domain, each would be isolated and unable to in-<br>terfere with another client via static class members. To implement this example, we<br>need to call a "Login" method on 20 concurrent threads, each in its own application<br>domain:<br>
class Program<br>
{<br>  static void Main()<br>
  {<br>
    // Create 20 domains and 20 threads.<br>
    AppDomain[] domains = new AppDomain [20];<br>    Thread[] threads = new Thread [20];<br>
    for (int i = 0; i &lt; 20; i++)<br>    {<br>
      domains [i] = AppDomain.CreateDomain (&quot;Client Login &quot; + i);<br>      threads [i] = new Thread (LoginOtherDomain);<br>
    }<br>
    // Start all the threads, passing to each thread its app domain.<br>    for (int i = 0; i &lt; 20; i++) threads [i].Start (domains [i]);<br>
    // Wait for the threads to finish<br>    for (int i = 0; i &lt; 20; i++) threads [i].Join();<br>
    // Unload the app domains<br>    for (int i = 0; i &lt; 20; i++) AppDomain.Unload (domains [i]);<br>    Console.ReadLine();<br>  }<br>
  // Parameterized thread start - taking the domain on which to run.<br>  static void LoginOtherDomain (object domain)<br>  {<br>    ((AppDomain) domain).DoCallBack (Login);<br>  }<br>
  static void Login()<br>  {<br>    Client.Login (&quot;Joe&quot;, &quot;&quot;);<br>    Console.WriteLine (&quot;Logged in as: &quot; + Client.CurrentUser + &quot; on &quot; +<br>      AppDomain.CurrentDomain.FriendlyName);<br>  }<br>}<br>
<b>950 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=971></a>class Client<br>
{<br>  // Here's a static field that would interfere with other client logins<br>  // if running in the same app domain.<br>
  public static string CurrentUser = &quot;&quot;;<br>
  public static void Login (string name, string password)<br>  {<br>
   if (CurrentUser.Length == 0)    // If we're not already logged in...<br>
    {<br>      // Sleep to simulate authentication...<br>      Thread.Sleep (500);<br>
      CurrentUser = name;           // Record that we're authenticated.<br>
    }<br>  }<br>}<br>
// Output:<br>
Logged in as: Joe on Client Login 0<br>Logged in as: Joe on Client Login 1<br>
Logged in as: Joe on Client Login 4<br>Logged in as: Joe on Client Login 2<br>
Logged in as: Joe on Client Login 3<br>Logged in as: Joe on Client Login 5<br>
Logged in as: Joe on Client Login 6<br>...<br>
See Chapter 21 for more information on multithreading.<br>
<b>Sharing Data Between Domains<br>Sharing Data via Slots</b><br>
<b>App Domains</b><br>
Application domains can use named slots to share data, as in the following example:<br>
class Program<br>{<br>  static void Main()<br>  {<br>    AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;);<br>
    // Write to a named slot called &quot;Message&quot; - any string key will do.<br>    newDomain.SetData (&quot;Message&quot;, &quot;guess what...&quot;);<br>
    newDomain.DoCallBack (SayMessage);<br>    AppDomain.Unload (newDomain);<br>  }<br>
  static void SayMessage()<br>  {<br>    // Read from the &quot;Message&quot; data slot<br>    Console.WriteLine (AppDomain.CurrentDomain.GetData (&quot;Message&quot;));<br>  }<br>
}<br>
<b>Sharing Data Between Domains | 951</b><br>
<hr>
<A name=972></a>// Output:<br>
guess what...<br>
A  slot  is  created  automatically  the  first  time  it's  used.  The  data  being<br>communicated (in this example, &quot;guess what ...&quot;) must either be <i>serializable</i> (see<br>Chapter 16), or be based on MarshalByRefObject. If the data is serializable (such as<br>the string in our example), it's copied to the other application domain. If it imple-<br>ments MarshalByRefObject, Remoting semantics are applied.<br>
<b>Intra-Process Remoting<br></b>The most flexible way to communicate with another application domain is to in-<br>stantiate objects <i>in the other domain</i> via a proxy. This is called <i>Remoting</i>.<br>
The class being "Remoted" must inherit from MarshalByRefObject. The client then<br>calls a CreateInstance<i>XXX</i> method on the remote domain's AppDomain class to re-<br>motely instantiate the object.<br>
The following instantiates the type Foo in another application domain, and then calls<br>its SayHello method:<br>
class Program<br>
{<br>  static void Main()<br>  {<br>
    AppDomain newDomain = AppDomain.CreateDomain (&quot;New Domain&quot;);<br>
    <b>Foo foo = (Foo) newDomain.CreateInstanceAndUnwrap (<br></b>                      <b>typeof (Foo).Assembly.FullName,<br></b>                      <b>typeof (Foo).FullName);</b><br>
    Console.WriteLine (foo.SayHello());<br>    AppDomain.Unload (newDomain);<br>    Console.ReadLine();<br>  }<br>}<br>
public class Foo : <b>MarshalByRefObject<br></b>{<br>  public string SayHello()<br>  {<br>    return &quot;Hello from &quot; + AppDomain.CurrentDomain.FriendlyName;<br>  }<br>
  public override object InitializeLifetimeService()<br>  {<br>    // This ensures the object lasts for as long as the client wants it<br>    return null;<br>  }<br>}<br>
When the foo object is created on the other application domain (called the "remote"<br>domain), we don't get back a direct reference to the object, because the application<br>domains are isolated. Instead, we get back a transparent proxy; transparent because<br>
<b>952 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=973></a>it <i>appears</i> as though it was a direct reference to the remote object. When we subse-<br>quently call the SayHello method on foo, a message is constructed behind the scenes,<br>which is forwarded to the "remote" application domain, where it is then executed<br>on the "real" foo. Any return value is turned into a message and sent back to the<br>caller.<br>
Before  Windows  Communication  Foundation  was  released<br>in .NET Framework 3.0, Remoting was one of the two principal<br>technologies for writing distributed applications (Web Services<br>being the other). In a distributed Remoting application, you ex-<br>plicitly set up an HTTP or TCP/IP communication channel at<br>each  end,  allowing  communication  to  cross  process  and<br>network boundaries.<br>
Although WCF is superior to Remoting for distributed appli-<br>cations, Remoting still has a niche in interdomain communica-<br>tion within a process. Its advantage in this scenario is that it<br>requires no configuration--the communication channel is au-<br>tomatically  created  (a  fast  in-memory  channel),  and  no  type<br>registration is required. You simply start using it.<br>
The methods on Foo can return more MarshalByRefObject instances, in which case<br>more transparent proxies are generated when those methods are called. Methods on<br>Foo can also accept MarshalByRefObject instances as arguments--in which Remoting<br>happens in reverse. The caller will hold the "remote" object, while the callee will<br>have a proxy.<br>
As well as marshaling objects by reference, application domains can exchange scalar<br>values, or any <i>serializable</i> object. A type is serializable if it either has the Serializa<br>ble  attribute  or  implements  ISerializable.  Then,  when  crossing  the  application<br>
<b>App Domains</b><br>
domain boundary, a complete copy of the object is returned, rather than a proxy.<br>In other words, the object is marshaled by <i>value</i> rather than reference.<br>
Remoting within the same process is client-activated, meaning that the CLR doesn't<br>attempt to share or reuse remotely created objects with the same or other clients. In<br>other words, if the client creates two Foo objects, two objects will be created in the<br>remote domain, and two proxies in the client domain. This provides the most natural<br>object semantics; however, it means that the remote domain is dependent on the<br>client's  garbage  collector:  the  foo  object  in  the  remote  domain  is  released  from<br>memory only when the client's garbage collector decides that the foo (proxy) is no<br>longer in use. If the client domain crashes, it may never get released. To protect<br>against this scenario, the CLR provides a lease-based mechanism for managing the<br>lifetime of remotely created objects. The default behavior is for remotely created<br>objects to self-destruct after five minutes of nonuse.<br>
<b>Sharing Data Between Domains | 953</b><br>
<hr>
<A name=974></a>Because in this example the client runs in the default application domain, the client<br>doesn't have the luxury of crashing. Once it ends, so does the whole process! Hence,<br>it makes sense to disable the five-minute lifetime lease. This is the purpose of over-<br>riding InitializeLifetimeService--by returning a null lease, remotely created ob-<br>jects are destroyed only when garbage-collected by the client.<br>
<b>Isolating Types and Assemblies<br></b>In the preceding example, we remotely instantiated an object of type Foo as follows:<br>
Foo foo = (Foo) newDomain.CreateInstanceAndUnwrap (<br>
                  typeof (Foo).Assembly.FullName,<br>
                  typeof (Foo).FullName);<br>
Here's the method's signature:<br>
public object CreateInstanceFromAndUnwrap (string assemblyName,<br>
                                           string typeName)<br>
Because this method accepts an assembly and type <i>name</i> rather than a Type object,<br>you can remotely instantiate an object without loading its type locally. This is useful<br>when you want to avoid loading the type's assembly into the caller's application<br>domain.<br>
AppDomain  also  provides  a  method  called  CreateIn<br>stance<b>From</b>AndUnwrap. The difference is:<br>
· CreateInstanceAndUnwrap accepts a <i>fully qualified assembly</i><br>
<i>name</i> (see Chapter 17).<br>
· CreateInstance<b>From</b>AndUnwrap accepts a <i>path or filename</i>.<br>
To illustrate, suppose we were writing a text editor that allows the user to load and<br>unload  third-party  plug-ins.  We  demonstrated  this  in  Chapter  20  in  the  section<br>"Sandboxing  Another  Assembly"  on  page  769,  from  the  perspective  of  security.<br>When it came to actually executing the plug-in, however, all we did was call Execu<br>teAssembly. With Remoting, we can interact with plug-ins in a richer fashion.<br>
The first step is to write a common library that both the host and the plug-ins will<br>reference.  This  library  will  define  an  interface  describing  what  plug-ins  can  do.<br>Here's a simple example:<br>
namespace Plugin.Common<br>{<br>  public interface ITextPlugin<br>  {<br>    string TransformText (string input);<br>
  }<br>}<br>
Next, we need to write a simple plug-in. We'll assume the following is compiled to<br><i>AllCapitals.dll</i>:<br>
<b>954 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=975></a>namespace Plugin.Extensions<br>
{<br>  public class AllCapitals : MarshalByRefObject, <b>Plugin.Common.ITextPlugin<br></b>  {<br>
    public string TransformText (string input) { return input.ToUpper(); }<br>
  }<br>}<br>
Here's how to write a host that loads <i>AllCapitals.dll</i> into a separate application do-<br>main,  calls  TransformText  using  Remoting,  and  then  unloads  the  application<br>domain:<br>
using System;<br>
using System.Reflection;<br>
using Plugin.Common;<br>
class Program<br>{<br>  static void Main()<br>
  {<br>
    AppDomain domain = AppDomain.CreateDomain (&quot;Plugin Domain&quot;);<br>
    <b>ITextPlugin plugin = (ITextPlugin) domain.CreateInstanceFromAndUnwrap</b><br>
      <b>(&quot;AllCapitals.dll&quot;, &quot;Plugin.Extensions.AllCapitals&quot;);</b><br>
    // Call the TransformText method using Remoting:<br>    Console.WriteLine (<b>plugin.TransformText (&quot;hello&quot;)</b>);   // &quot;HELLO&quot;<br>
    AppDomain.Unload (domain);<br>
    // The AllCapitals.dll file is now completely unloaded and could<br>    // be moved or deleted.<br>  }<br>}<br>
<b>App Domains</b><br>
Because this program interacts with the plug-in solely through the common inter-<br>face, ITextPlugin, the types in AllCapitals are never loaded into the caller's appli-<br>cation domain. This maintains the integrity of the caller's domain and ensures that<br>no locks are held on the plug-in assembly files after their domain is unloaded.<br>
<b>Type discovery<br></b>In our preceding example, a real application would need some means of discovering<br>plug-in type names, such as Plugin.Extensions.AllCapitals.<br>You can achieve this by writing a discovery class in the <i>common</i> assembly that uses<br>reflection as follows:<br>
<b>Sharing Data Between Domains | 955</b><br>
<hr>
<A name=976></a>public class Discoverer : MarshalByRefObject<br>
{<br>  public string[] GetPluginTypeNames (string assemblyPath)<br>  {<br>
    List&lt;string&gt; typeNames = new List&lt;string&gt;();<br>
    Assembly a = Assembly.LoadFrom (assemblyPath);<br>    foreach (Type t in a.GetTypes())<br>      if (<b>t.IsPublic</b><br>
        <b>&amp;&amp; t.IsMarshalByRef</b><br>
        <b>&amp;&amp; typeof (ITextPlugin).IsAssignableFrom (t)</b>)<br>    {<br>      typeNames.Add (t.FullName);<br>
    }<br>
    return typeNames.ToArray();<br>  }<br>}<br>
The catch is that Assembly.LoadFrom loads the assembly into the current application<br>domain. Therefore, you must call this method <i>in the plug-in domain</i>:<br>
class Program<br>
{<br>  static void Main()<br>
  {<br>    AppDomain domain = AppDomain.CreateDomain (&quot;Plugin Domain&quot;);<br>
    <b>Discoverer d = (Discoverer) domain.CreateInstanceAndUnwrap (</b><br>
      <b>typeof (Discoverer).Assembly.FullName,<br></b>      <b>typeof (Discoverer).FullName);</b><br>
    <b>string[] plugInTypeNames = d.GetPluginTypeNames (&quot;AllCapitals.dll&quot;);</b><br>
    foreach (string s in plugInTypeNames)<br>      Console.WriteLine (s);              // Plugin.Extensions.AllCapitals<br>
    ...<br>
In the <i>System.AddIn.Contract</i> assembly is an API that develops<br>these concepts into a complete framework for program exten-<br>sibility. It addresses such issues as isolation, versioning, discov-<br>ery,  activation,  and  so  on.  Visit  <i>http://blogs.msdn.com</i>  and<br>search for "CLR Add-In Team Blog" for a good source of on-<br>line information.<br>
<b>956 | Chapter 24:</b><b>Application Domains</b><br>
<hr>
<A name=977></a><b>25</b><br>
<b>Native and COM Interoperability</b><br>
This chapter describes how to integrate with native (unmanaged) DLLs and COM<br>components. Unless otherwise stated, the types mentioned in this chapter exist in<br>either the System or the System.Runtime.InteropServices namespace.<br>
<b>Calling into Native DLLs<br></b><i>P/Invoke</i>,  short  for  <i>Platform  Invocation  Services</i>,  allows  you  to  access  functions,<br>structs, and callbacks in unmanaged DLLs. For example, consider the MessageBox<br>function, defined in the Windows DLL <i>user32.dll</i> as follows:<br>
int MessageBox (HWND hWnd, LPCTSTR lpText, LPCTSTR lpCation, UINT uType);<br>
You can call this function directly by declaring a static method of the same name,<br>applying the extern keyword, and adding the DllImport attribute:<br>
using System;<br>using System.Runtime.InteropServices;<br>
class MsgBoxTest<br>
{<br>  [DllImport(&quot;user32.dll&quot;)]<br>  static extern int MessageBox (IntPtr hWnd, string text, string caption,<br>                                int type);<br>  public static void Main()<br>  {<br>    MessageBox (IntPtr.Zero,<br>                &quot;Please do not press this again.&quot;, &quot;Attention&quot;, 0);<br>  }<br>}<br>
The MessageBox classes in the System.Windows and System.Windows.Forms namespaces<br>themselves call similar unmanaged methods.<br>
The CLR includes a marshaler that knows how to convert parameters and return<br>values between .NET types and unmanaged types. In this example, the int param-<br>eters translate directly to 4-byte integers that the function expects, and the string<br>
<b>957</b><br>
<hr>
<A name=978></a>parameters are converted into null-terminated arrays of 2-byte Unicode characters.<br>IntPtr is a struct designed to encapsulate an unmanaged handle, and is 32 bits wide<br>on 32-bit platforms and 64 bits wide on 64-bit platforms.<br>
<b>Type Marshaling<br>Marshaling Common Types<br></b>On the unmanaged side, there can be more than one way to represent a given data<br>type. A string, for instance, can contain single-byte ANSI characters or double-byte<br>Unicode characters, and can be length-prefixed, null-terminated, or of fixed length.<br>With the MarshalAs attribute, you can tell the CLR marshaler the variation in use,<br>so it can provide the correct translation. Here's an example:<br>
[DllImport(&quot;...&quot;)]<br>
static extern int Foo ( <b>[MarshalAs (UnmanagedType.LPStr)]</b> string s );<br>
The UnmanagedType enumeration includes all the Win32 and COM types that the<br>marshaler understands. In this case, the marshaler was told to translate to LPStr,<br>which is a null-terminated single-byte ANSI string. (All UnmanagedType members are<br>listed at the end of this chapter.)<br>
On the .NET side, you also have some choice as to what data type to use. Unmanaged<br>handles, for instance, can map to IntPtr, int, uint, long, or ulong.<br>
Most unmanaged handles encapsulate an address or pointer,<br>and so must be mapped to IntPtr for compatibility with both<br>32- and 64-bit operating systems. A typical example is HWND.<br>
Quite often with Win32 functions, you come across an integer parameter that ac-<br>cepts a set of constants, defined in a C++ header file such as <i>WinUser.h</i>. Rather than<br>defining these as simple C# constants, you can define them within an enum instead.<br>Using an enum can make for tidier code as well as increase static type safety. We<br>provide an example in the later section "Shared Memory" on page 963.<br>
When installing Microsoft Visual Studio, be sure to install the<br>C++ header files--even if you choose nothing else in the C++<br>category. This is where all the native Win32 constants are de-<br>fined. You can then locate all header files by searching for <i>*.h</i> in<br>the Visual Studio program directory.<br>
Receiving strings from unmanaged code back to .NET requires that some memory<br>management  take  place.  The  marshaler  performs  this  work  automatically  if  you<br>declare the external method with a StringBuilder rather than a string, as follows:<br>
using System;<br>using System.Text;<br>using System.Runtime.InteropServices;<br>
<b>958 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=979></a>class Test<br>
{<br>  [DllImport(&quot;kernel32.dll&quot;)]<br>  static extern int GetWindowsDirectory (StringBuilder sb, int maxChars);<br>
  static void Main()<br>  {<br>    StringBuilder s = new StringBuilder (256);<br>
    GetWindowsDirectory (s, 256);<br>
    Console.WriteLine (s);<br>  }<br>}<br>
If you are unsure how to call a particular Win32 method, you<br>will usually find an example on the Internet if you search for the<br>method name and <i>DllImport</i>. The site <i>http://www.pinvoke.net<br></i>is a wiki that aims to document all Win32 signatures.<br>
<b>Marshaling Classes and Structs<br></b>Sometimes  you  need  to  pass  a  struct  to  an  unmanaged  method.  For  example,<br>GetSystemTime in the Win32 API is defined as follows:<br>
void GetSystemTime (LPSYSTEMTIME lpSystemTime);<br>
LPSYSTEMTIME conforms to this C struct:<br>
typedef struct _SYSTEMTIME {<br>  WORD wYear;<br>  WORD wMonth;<br>
  WORD wDayOfWeek;<br>  WORD wDay;<br>  WORD wHour;<br>  WORD wMinute;<br>  WORD wSecond;<br>  WORD wMilliseconds;<br>} SYSTEMTIME, *PSYSTEMTIME;<br>
In order to call GetSystemTime, we must define a .NET class or struct that matches<br>
<b>Native Interop</b><br>
this C struct:<br>
using System;<br>using System.Runtime.InteropServices;<br>
[StructLayout(LayoutKind.Sequential)]<br>class SystemTime<br>{<br>   public ushort Year;<br>   public ushort Month;<br>   public ushort DayOfWeek;<br>   public ushort Day;<br>   public ushort Hour;<br>   public ushort Minute;<br>   public ushort Second;<br>
<b>Type Marshaling | 959</b><br>
<hr>
<A name=980></a>   public ushort Milliseconds;<br>
}<br>
The StructLayout attribute instructs the marshaler how to map each field to its un-<br>managed counterpart. LayoutKind.Sequential means that we want the fields aligned<br>sequentially on <i>pack-size</i> boundaries (we'll see what this means shortly), just as they<br>would be in a C struct. The field names here are irrelevant; it's the ordering of fields<br>that's important.<br>
Now we can call GetSystemTime:<br>
[DllImport(&quot;kernel32.dll&quot;)]<br>
static extern void GetSystemTime (SystemTime t);<br>
static void Main()<br>
{<br>  SystemTime t = new SystemTime();<br>
  GetSystemTime (t);<br>
  Console.WriteLine (t.Year);<br>}<br>
In both C and C#, fields in an object are located at <i>n</i> number of bytes from the<br>address of that object. The difference is that in a C# program, the CLR finds this<br>offset by looking it up using the field name; C field names are compiled directly into<br>offsets. For instance, in C, wDay is just a token to represent whatever is at the address<br>of a SystemTime instance plus 24 bytes.<br>For access speed, each field is placed at an offset that is a multiple of the field's size.<br>That multiplier, however, is restricted to a maximum of <i>x</i> bytes, where <i>x</i> is the <i>pack<br>size</i>. In the current implementation, the default pack size is 8 bytes, so a struct com-<br>prising a sbyte followed by an (8-byte) long occupies 16 bytes, and the 7 bytes fol-<br>lowing the sbyte are wasted. You can lessen or eliminate this wastage by specifying<br>a <i>pack size</i> via the Pack property of the StructLayout attribute: this makes the fields<br>align to offsets that are multiples of the specified pack size. So with a pack size of 1,<br>the struct just described would occupy just 9 bytes. You can specify pack sizes of 1,<br>2, 4, 8, or 16 bytes.<br>
The StructLayout attribute also lets you specify explicit field offsets (see "Simulating<br>a C Union" on page 962).<br>
<b>In and Out Marshaling<br></b>In the previous example, we implemented SystemTime as a class. We could have<br>instead chosen a struct--providing GetSystemTime was declared with a ref or out<br>parameter:<br>
[DllImport(&quot;kernel32.dll&quot;)]<br>static extern void GetSystemTime (out SystemTime t);<br>
In most cases, C#'s directional parameter semantics work the same with external<br>methods. Pass-by-value parameters are copied in, C# ref parameters are copied in/<br>out, and C# out parameters are copied out. However, there are some exceptions for<br>types  that  have  special  conversions.  For  instance,  array  classes  and  the<br>
<b>960 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=981></a>StringBuilder class require copying when coming out of a function, so they are in/<br>out. It is occasionally useful to override this behavior, with the In and Out attributes.<br>For example, if an array should be read-only, the in modifier indicates to only copy<br>the array going into the function and not coming out of it:<br>
static extern void Foo ( <b>[In]</b> int[] array);<br>
<b>Callbacks from Unmanaged Code<br></b>The P/Invoke layer does its best to present a natural programming model on both<br>sides of the boundary, mapping between relevant constructs where possible. Since<br>C# can not only call out to C functions but also can be called back from the C<br>functions (via function pointers), the P/Invoke layer needs to map unmanaged func-<br>tion pointers onto something natural for the managed world. The managed equiv-<br>alent of a function pointer is a delegate, so the P/Invoke layer automatically maps<br>between delegates (in C#) and function pointers (in C).<br>
As an example, you can enumerate all top-level window handles with this method<br>in <i>User32.dll</i>:<br>
BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);<br>
WNDENUMPROC is a callback that gets fired with the handle of each window in sequence<br>(or until the callback returns false). Here is its definition:<br>
BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);<br>
To use this, we declare a delegate with a matching signature, and then pass a delegate<br>instance to the external method:<br>
using System;<br>using System.Runtime.InteropServices;<br>
class CallbackFun<br>{<br>  delegate bool EnumWindowsCallback (IntPtr hWnd, IntPtr lParam);<br>
  [DllImport(&quot;user32.dll&quot;)]<br>  static extern int EnumWindows (EnumWindowsCallback hWnd, IntPtr lParam);<br>
<b>Native Interop</b><br>
  static bool PrintWindow (IntPtr hWnd, IntPtr lParam)<br>  {<br>    Console.WriteLine (hWnd.ToInt64());<br>    return true;<br>  }<br>
  static void Main()<br>  {<br>    EnumWindows (PrintWindow, IntPtr.Zero);<br>  }<br>}<br>
<b>Callbacks from Unmanaged Code | 961</b><br>
<hr>
<A name=982></a><b>Simulating a C Union<br></b>Each field in a struct is given enough room to store its data. Consider a struct<br>containing one int and one char. The int is likely to start at an offset of 0 and is<br>guaranteed at least four bytes. So, the char would start at an offset of at least 4. If,<br>for some reason, the char started at an offset of 2, you'd change the value of the<br>int if you assigned a value to the char. Sounds like mayhem, doesn't it? Strangely<br>enough, the C language supports a variation on a struct called a <i>union</i> that does<br>exactly  this.  You  can  simulate  this  in  C#  using  LayoutKind.Explicit  and  the<br>FieldOffset attribute.<br>
It might be hard to think of a case in which this would be useful. However, suppose<br>you want to play a note on an external synthesizer. The Windows Multimedia API<br>provides a function for doing just this via the MIDI protocol:<br>
[DllImport (&quot;winmm.dll&quot;)]<br>public static extern uint midiOutShortMsg (IntPtr handle, uint message);<br>
The second argument, message, describes what note to play. The problem is in con-<br>structing this 32-bit unsigned integer: it's divided internally into bytes, representing<br>a MIDI channel, note, and velocity at which to strike. One solution is to shift and<br>mask via the bitwise &lt;&lt;, &gt;&gt;, &amp;, and | operators to convert these bytes to and from the<br>32-bit "packed" message. Far simpler, though, is to define a struct with explicit<br>layout:<br>
[StructLayout (LayoutKind.Explicit)]<br>public struct NoteMessage<br>{<br>  [FieldOffset(0)] public uint PackedMsg;    // 4 bytes long<br>
  [FieldOffset(0)] public byte Channel;      // FieldOffset also at 0<br>  [FieldOffset(1)] public byte Note;<br>  [FieldOffset(2)] public byte Velocity;<br>}<br>
The Channel, Note, and Velocity fields deliberately overlap with the 32-bit packed<br>message. This allows you to read and write using either. No calculations are required<br>to keep other fields in sync:<br>
NoteMessage n = new NoteMessage();<br>Console.WriteLine (n.PackedMsg);    // 0<br>
n.Channel = 10;<br>n.Note = 100;<br>n.Velocity = 50;<br>Console.WriteLine (n.PackedMsg);    // 3302410<br>
n.PackedMsg = 3328010;<br>Console.WriteLine (n.Note);         // 200<br>
<b>962 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=983></a><b>Shared Memory<br></b>Memory-mapped  files,  or  <i>shared  memory</i>,  is  a  feature  in  Windows  that  allows<br>multiple processes on the same computer to share data, without the overhead of<br>Remoting  or  WCF.  Shared  memory  is  extremely  fast  and,  unlike  pipes,  offers<br><i>random</i> access to the shared data. We saw in Chapter 14 how you can use Framework<br>4.0's new MemoryMappedFile class to access memory-mapped files; bypassing this and<br>calling the Win32 methods directly is a good way to demonstrate P/Invoke.<br>
The Win32 CreateFileMapping function allocates shared memory. You tell it how<br>many bytes you need and the name with which to identify the share. Another ap-<br>plication can then subscribe to this memory by calling OpenFileMapping with same<br>name. Both methods return a <i>handle</i>, which you can convert to a pointer by calling<br>MapViewOfFile.<br>
Here's a class that encapsulates access to shared memory:<br>
using System;<br>
using System.Runtime.InteropServices;<br>
public sealed class SharedMem : IDisposable<br>
{<br>  // Here we're using enums because they're safer than constants<br>
  enum FileProtection : uint      // constants from winnt.h<br>
  {<br>
    ReadOnly = 2,<br>    ReadWrite = 4<br>  }<br>
  enum FileRights : uint          // constants from WinBASE.h<br>  {<br>    Read = 4,<br>    Write = 2,<br>    ReadWrite = Read + Write<br>  }<br>
  static readonly IntPtr NoFileHandle = new IntPtr (-1);<br>
<b>Native Interop</b><br>
  [DllImport (&quot;kernel32.dll&quot;, SetLastError = true)]<br>  static extern IntPtr CreateFileMapping (IntPtr hFile,<br>                                          int lpAttributes,<br>                                          FileProtection flProtect,<br>                                          uint dwMaximumSizeHigh,<br>                                          uint dwMaximumSizeLow,<br>                                          string lpName);<br>
  [DllImport (&quot;kernel32.dll&quot;, SetLastError=true)]<br>  static extern IntPtr OpenFileMapping (FileRights dwDesiredAccess,<br>                                        bool bInheritHandle,<br>                                        string lpName);<br>
  [DllImport (&quot;kernel32.dll&quot;, SetLastError = true)]<br>  static extern IntPtr MapViewOfFile (IntPtr hFileMappingObject,<br>
<b>Shared Memory | 963</b><br>
<hr>
<A name=984></a>                                      FileRights dwDesiredAccess,<br>
                                      uint dwFileOffsetHigh,<br>                                      uint dwFileOffsetLow,<br>                                      uint dwNumberOfBytesToMap);<br>
  [DllImport (&quot;Kernel32.dll&quot;, SetLastError = true)]<br>  static extern bool UnmapViewOfFile (IntPtr map);<br>
  [DllImport (&quot;kernel32.dll&quot;, SetLastError = true)]<br>
  static extern int CloseHandle (IntPtr hObject);<br>
  IntPtr fileHandle, fileMap;<br>
  public IntPtr Root { get { return fileMap; } }<br>
  public SharedMem (string name, bool existing, uint sizeInBytes)<br>  {<br>
    if (existing)<br>      fileHandle = OpenFileMapping (FileRights.ReadWrite, false, name);<br>
    else<br>      fileHandle = CreateFileMapping (NoFileHandle, 0,<br>
                                      FileProtection.ReadWrite,<br>                                      0, sizeInBytes, name);<br>
    if (fileHandle == IntPtr.Zero)<br>      throw new Win32Exception();<br>
    // Obtain a read/write map for the entire file<br>    fileMap = MapViewOfFile (fileHandle, FileRights.ReadWrite, 0, 0, 0);<br>
    if (fileMap == IntPtr.Zero)<br>
      throw new Win32Exception();<br>  }<br>
  public void Dispose()<br>  {<br>    if (fileMap != IntPtr.Zero) UnmapViewOfFile (fileMap);<br>    if (fileHandle != IntPtr.Zero) CloseHandle (fileHandle);<br>    fileMap = fileHandle = IntPtr.Zero;<br>  }<br>}<br>
In this example, we set SetLastError=true on the DllImport methods that use the<br>SetLastError protocol for emitting error codes. This ensures that the  Win32Excep<br>tion is populated with details of the error when that exception is thrown. (It also<br>allows you to query the error explicitly by calling Marshal.GetLastWin32Error.)<br>In order to demonstrate this class, we need to run two applications. The first one<br>creates the shared memory, as follows:<br>
using (SharedMem sm = new SharedMem (&quot;MyShare&quot;, false, 1000))<br>{<br>  IntPtr root = sm.Root;<br>  // I have shared memory!<br>
  Console.ReadLine();         // Here's where we start a second app...<br>}<br>
<b>964 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=985></a>The  second  application  subscribes  to  the  shared  memory  by  constructing  a<br>SharedMem object of the same name, with the existing argument true:<br>
using (SharedMem sm = new SharedMem (&quot;MyShare&quot;, true, 1000))<br>{<br>  IntPtr root = sm.Root;<br>
  // I have the same shared memory!<br>  // ...<br>}<br>
The net result is that each program has an IntPtr--a pointer to (the same) unman-<br>aged memory. The two applications now need somehow to read and write to mem-<br>ory  via  this  common  pointer.  One  approach  is  to  write  a  serializable  class  that<br>encapsulates all the shared data, then serialize (and deserialize) the data to the un-<br>managed memory using an UnmanagedMemoryStream. This is inefficient, however, if<br>there's a lot of data. Imagine if the shared memory class had a megabyte worth of<br>data, and just one integer needed to be updated. A better approach is to define the<br>shared data construct as a struct, and then map it directly into shared memory. We<br>discuss this in the following section.<br>
<b>Mapping a Struct to Unmanaged Memory<br></b>A struct with a StructLayout of Sequential or Explicit can be mapped directly into<br>unmanaged memory. Consider the following struct:<br>
[StructLayout (LayoutKind.Sequential)]<br>unsafe struct MySharedData<br>
{<br>  public int Value;<br>
  public char Letter;<br>  public fixed float Numbers [50];<br>}<br>
The fixed directive allows us to define fixed-length value-type arrays, and it is what<br>takes us into the unsafe realm. Space in this struct is allocated inline for 50 floating-<br>point numbers. Unlike with standard C# arrays, NumberArray is not a <i>reference</i> to<br>an array--it <i>is</i> the array. If we run the following:<br>
static unsafe void Main()<br>
<b>Native Interop</b><br>
{<br>  Console.WriteLine (sizeof (MySharedData));<br>}<br>
the result is 208: 50 4-byte floats, plus the 4 bytes for the Value integer, plus 2 bytes<br>for the Letter character. The total, 206, is rounded to 208 due to the floats being<br>aligned on 4-byte boundaries (4 bytes being the size of a float).<br>We can demonstrate MySharedData in an unsafe context, most simply, with stack-<br>allocated memory:<br>
MySharedData d;<br>MySharedData* data = &amp;d;       // Get the address of d<br>
data-&gt;Value = 123;<br>
<b>Mapping a Struct to Unmanaged Memory | 965</b><br>
<hr>
<A name=986></a>data-&gt;Letter = 'X';<br>
data-&gt;Numbers[10] = 1.45f;<br>
or:<br>
// Allocate the array on the stack:<br>MySharedData* data = <b>stackalloc</b> MySharedData[1];<br>
data-&gt;Value = 123;<br>
data-&gt;Letter = 'X';<br>data-&gt;Numbers[10] = 1.45f;<br>
Of course, we're not demonstrating anything that couldn't otherwise be achieved<br>in  a  managed  context.  Suppose,  however,  that  we  want  to  store  an  instance  of<br>MySharedData on the <i>unmanaged heap</i>, outside the realm of the CLR's garbage col-<br>lector. This is where pointers become really useful:<br>
MySharedData* data = (MySharedData*)<br>
  <b>Marshal.AllocHGlobal</b> (sizeof (MySharedData)).ToPointer();<br>
data-&gt;Value = 123;<br>
data-&gt;Letter = 'X';<br>
data-&gt;Numbers[10] = 1.45f;<br>
Marshal.AllocHGlobal  allocates  memory  on  the  unmanaged  heap.  Here's  how  to<br>later free the same memory:<br>
<b>Marshal.FreeHGlobal</b> (new IntPtr (data));<br>
(The result of forgetting to free the memory is a good old-fashioned memory leak.)<br>
In  keeping  with  its  name,  we'll  now  use  MySharedData  in  conjunction  with  the<br>SharedMem class we wrote in the preceding section. The following program allocates<br>a block of shared memory, and then maps the MySharedData struct into that memory:<br>
static unsafe void Main()<br>{<br>  using (SharedMem sm = new SharedMem (&quot;MyShare&quot;, false, 1000))<br>  {<br>    void* root = sm.Root.ToPointer();<br>    MySharedData* data = (MySharedData*) root;<br>
    data-&gt;Value = 123;<br>    data-&gt;Letter = 'X';<br>    data-&gt;Numbers[10] = 1.45f;<br>    Console.WriteLine (&quot;Written to shared memory&quot;);<br>
    Console.ReadLine();<br>
    Console.WriteLine (&quot;Value is &quot; + data-&gt;Value);<br>    Console.WriteLine (&quot;Letter is &quot; + data-&gt;Letter);<br>    Console.WriteLine (&quot;11th Number is &quot; + data-&gt;Numbers[10]);<br>    Console.ReadLine();<br>  }<br>}<br>
<b>966 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=987></a>If  you're  targeting  Framework  4.0,  you  can  use  its<br>MemoryMappedFile class instead of SharedMem as follows:<br>
using (MemoryMappedFile mmFile =<br>       MemoryMappedFile.CreateNew (&quot;MyShare&quot;, 1000))<br>
using (MemoryMappedViewAccessor accessor =<br>
       mmFile.CreateViewAccessor())<br>
{<br>  byte* pointer = null;<br>  accessor.SafeMemoryMappedViewHandle.AcquirePointer<br>
   (ref pointer);<br>  void* root = pointer;<br>  ...<br>}<br>
Here's  a  second  program  that  attaches  to  the  same  shared  memory,  reading  the<br>values written by the first program. (It must be run while the first program is waiting<br>on the ReadLine statement, since the shared memory object is disposed upon leaving<br>its using statement.)<br>
static unsafe void Main()<br>
{<br>  using (SharedMem sm = new SharedMem (&quot;MyShare&quot;, true, 1000))<br>  {<br>
    void* root = sm.Root.ToPointer();<br>
    MySharedData* data = (MySharedData*) root;<br>
    Console.WriteLine (&quot;Value is &quot; + data-&gt;Value);<br>    Console.WriteLine (&quot;Letter is &quot; + data-&gt;Letter);<br>    Console.WriteLine (&quot;11th Number is &quot; + data-&gt;Numbers[10]);<br>
    // Our turn to update values in shared memory!<br>    data-&gt;Value++;<br>    data-&gt;Letter = '!';<br>    data-&gt;Numbers[10] = 987.5f;<br>    Console.WriteLine (&quot;Updated shared memory&quot;);<br>    Console.ReadLine();<br>  }<br>}<br>
<b>Native Interop</b><br>
The output from each of these programs is as follows:<br>
// First program:<br>
Written to shared memory<br>Value is 124<br>Letter is !<br>11th Number is 987.5<br>
// Second program:<br>
Value is 123<br>Letter is X<br>11th Number is 1.45<br>Updated shared memory<br>
<b>Mapping a Struct to Unmanaged Memory | 967</b><br>
<hr>
<A name=988></a>Don't be put off by the pointers: C++ programmers use them throughout whole<br>applications and are able to get everything working. At least most of the time! This<br>sort of usage is fairly simple by comparison.<br>
As it happens, our example is unsafe--quite literally--for another reason. We ha-<br>ven't considered the thread-safety (or more precisely, process-safety) issues that arise<br>with two programs accessing the same memory at once. To use this in a production<br>application, we'd need to add the volatile keyword to the Value and Letter fields<br>in  the  MySharedData  struct  to  prevent  fields  from  being  cached  in  CPU  registers.<br>Furthermore, as our interaction with the fields grew beyond the trivial, we would<br>most likely need to protect their access via a cross-process Mutex, just as we would<br>use lock statements to protect access to fields in a multithreaded program. We dis-<br>cussed thread safety in detail in Chapter 21.<br>
<b>fixed and fixed {...}<br></b>One limitation of mapping structs directly into memory is that the struct can contain<br>only unmanaged types. If you need to share string data, for instance, you must use<br>a  fixed  character  array  instead.  This  means  manual  conversion  to  and  from  the<br>string type. Here's how to do it:<br>
[StructLayout (LayoutKind.Sequential)]<br>
unsafe struct MySharedData<br>
{<br>  ...<br>
  // Allocate space for 200 chars (i.e., 400 bytes).<br>
  const int MessageSize = 200;<br>  <b>fixed char message [MessageSize];</b><br>
  // One would most likely put this code into a helper class:<br>  public string Message<br>  {<br>    get { fixed (char* cp = message) return new string (cp); }<br>    set<br>    {<br>      <b>fixed (char* cp = message)<br></b>      {<br>        int i = 0;<br>        for (; i &lt; value.Length &amp;&amp; i &lt; MessageSize - 1; i++)<br>          cp [i] = value [i];<br>
        // Add the null terminator<br>        cp [i] = '\0';<br>      }<br>    }<br>  }<br>}<br>
There's no such thing as a reference to a fixed array; instead,<br>you get a pointer. When you index into a fixed array, you're<br>actually performing pointer arithmetic!<br>
<b>968 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=989></a>With the first use of the fixed keyword, we allocate space, inline, for 200 characters<br>in the struct. The same keyword has a different meaning when used later, in the<br>property definition. It tells the CLR that should it decide to perform a garbage col-<br>lection inside the fixed block, not to move the underlying struct about on the mem-<br>ory heap, since its contents are being iterated via direct memory pointers. Looking<br>at our program, you might wonder how MySharedData could ever shift in memory,<br>given that it lives not on the heap, but in the unmanaged world, where the garbage<br>collector has no jurisdiction. The compiler doesn't know this, however, and is con-<br>cerned that we <i>might</i> use MySharedData in a managed context, so it insists that we<br>add the fixed keyword, to make our unsafe code safe in managed contexts. And the<br>compiler does have a point--here's all it would take to put MySharedData on the heap:<br>
object obj = new MySharedData();<br>
This results in a boxed MySharedData--on the heap and eligible for transit during<br>garbage collection.<br>
This example illustrates how a string can be represented in a struct mapped to un-<br>managed  memory.  For  more  complex  types,  you  also  have  the  option  of  using<br>existing serialization code. The one proviso is that the serialized data must never<br>exceed, in length, its allocation of space in the struct; otherwise, the result is an<br>unintended union with subsequent fields.<br>
<b>COM Interoperability<br></b>The .NET runtime has had special support for COM since its first version, enabling<br>COM objects to be used from .NET and vice versa. C# 4.0 and CLR 4.0 significantly<br>enhance the ability to use COM objects from .NET--in the aspects of both usability<br>and deployment.<br>
<b>The Purpose of COM<br></b>COM is an acronym for Component Object Model, a binary standard for APIs re-<br>leased  by  Microsoft  in  1993.  The  motivation  for  inventing  COM  was  to  enable<br>components  to  communicate  with  each  other  in  a  language-independent  and<br>version-tolerant manner. Before COM, the approach in Windows was to publish<br>
<b>Native Interop</b><br>
Dynamic Link Libraries (DLLs) that declared structures and functions using the C<br>programming language. Not only is this approach language-specific, but it's also<br>brittle. The specification of a type in such a library is inseparable from its imple-<br>mentation:  even  updating  a  structure  with  a  new  field  means  breaking  its<br>specification.<br>
The beauty of COM was to separate the specification of a type from its underlying<br>implementation through a construct known as a <i>COM interface</i>. COM also allowed<br>for the calling of methods on stateful <i>objects</i>--rather than being limited to simple<br>procedure calls.<br>
<b>COM Interoperability | 969</b><br>
<hr>
<A name=990></a>In a way, the .NET programming model is an evolution of the<br>principles  of  COM  programming:  the  .NET  platform  also<br>facilitates cross-language development and allows binary com-<br>ponents to evolve without breaking applications that depend on<br>them.<br>
<b>The Basics of the COM Type System<br></b>The COM type system revolves around interfaces. A COM interface is rather like<br>a .NET interface, but it's more prevalent because a COM type exposes its function-<br>ality <i>only</i> through an interface. In the .NET world, for instance, we could simply<br>declare a type as follows:<br>
public class Foo<br>
{<br>  public string Test() { return &quot;Hello, world&quot;; }<br>
}<br>
Consumers of that type can use Foo directly. And if we later changed the <i>implemen-<br>tation</i>  of  Test(),  calling  assemblies  would  not  require  recompilation.  In  this  re-<br>spect, .NET separates interface from implementation--without requiring interfaces.<br>We could even add an overload without breaking callers:<br>
  public string Test (string s) { return &quot;Hello, world &quot; + s; }<br>
In the COM world, Foo exposes its functionality through an interface to achieve this<br>same decoupling. So, in Foo's type library, an interface such as this would exist:<br>
public interface IFoo { string Test(); }<br>
(We've illustrated this by showing a C# interface--not a COM interface. The prin-<br>ciple, however, is the same--although the plumbing is different.)<br>
Callers would then interact with IFoo rather than Foo.<br>When it comes to adding the overloaded version of Test, life is more complicated<br>with COM than with .NET. First, we would avoid modifying the IFoo interface--<br>because this would break binary compatibility with the previous version (one of the<br>principles of COM is that interfaces, once published, are <i>immutable</i>). Second, COM<br>doesn't allow method overloading. The solution is to instead have Foo implement a<br><i>second interface</i>:<br>
public interface IFoo2 { string Test (string s); }<br>
(Again, we've transliterated this into a .NET interface for familiarity.)<br>
Supporting  multiple  interfaces  is  of  key  importance  in  making  COM  libraries<br>versionable.<br>
<b>IUnknown and IDispatch<br></b>All COM interfaces are identified with a GUID.<br>
<b>970 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=991></a>The root interface in COM is IUnknown--all COM objects must implement it. This<br>interface has three methods:<br>
· AddRef<br>· Release<br>· QueryInterface<br>
AddRef and Release are for lifetime management, since COM uses reference counting<br>rather than automatic garbage collection (COM was designed to work with unman-<br>aged code, where automatic garbage collection isn't feasible). The QueryInterface<br>method is for type discovery, and returns all the COM interfaces that the object<br>supports.<br>
To enable dynamic programming (e.g., scripting and Automation), a COM object<br>may also implement IDispatch. This enables dynamic languages such as VBScript<br>to call COM objects in a late-bound manner--just as with dynamic in C#.<br>
<b>Calling a COM Component from C#<br></b>The  CLR's  built-in  support  for  COM  means  that  you  don't  work  directly  with<br>IUnknown and IDispatch. Instead, you work with CLR objects and the runtime mar-<br>shals your calls to the COM world via Runtime-Callable Wrappers (RCWs). The<br>runtime  also  handles  lifetime  management  by  calling  AddRef  and  Release  (when<br>the .NET object is finalized) and takes care of the primitive type conversions between<br>the two worlds. Type conversion ensures that each side sees, for example, the integer<br>and string types in their familiar forms.<br>
Additionally, there needs to be some way to access RCWs in a statically typed fash-<br>ion. This is the job of <i>COM interop types</i>. COM interop types are automatically<br>generated proxy types that expose a .NET member for each COM member. The type<br>library importer tool (<i>tlimp.exe</i>) generates COM interop types from the command<br>line, based on a COM library that you choose, and compiles them into a <i>COM interop<br>assembly</i>.<br>
If  a  COM  component  implements  multiple  interfaces,  the<br>
<b>Native Interop</b><br>
<i>tlimp.exe</i> tool generates a single type that contains a union of<br>members from all interfaces.<br>
You can create a COM interop assembly in Visual Studio by going to the Add Ref-<br>erence dialog and choosing a library from the COM tab. For example, if you have<br>Microsoft Excel 2007 installed, adding a reference to the Microsoft Excel 12.0 Office<br>Library allows you to interoperate with Excel's COM classes. Here's the C# 4.0 code<br>to create and show a workbook, and then populate a cell in that workbook:<br>
using System;<br>using Excel = Microsoft.Office.Interop.Excel;<br>
class Program<br>
<b>Calling a COM Component from C# | 971</b><br>
<hr>
<A name=992></a>{<br>  static void Main()<br>  {<br>    var excel = new Excel.Application();<br>
    excel.Visible = true;<br>
    Workbook workBook = excel.Workbooks.Add();<br>    excel.Cells [1, 1].Font.FontStyle = &quot;Bold&quot;;<br>    excel.Cells [1, 1].Value2 = &quot;Hello World&quot;;<br>
    workBook.SaveAs (@&quot;d:\temp.xlsx&quot;);<br>
  }<br>}<br>
The Excel.Application class is a COM interop type whose runtime type is an RCW.<br>When we access the Workbooks and Cells properties, we get back more interop types.<br>This code is fairly simple, thanks to a number of enhancements in the C# 4.0 lan-<br>guage. In C# 3.0, we would have to write the Main method like this instead:<br>
var missing = System.Reflection.Missing.Value;<br>
var excel = new Excel.Application();<br>
excel.Visible = true;<br>
Workbook workBook = excel.Workbooks.Add (missing);<br>
var range = (Excel.Range) excel.Cells [1, 1];<br>range.Font.FontStyle = &quot;Bold&quot;;<br>range.Value2 = &quot;Hello world&quot;;<br>
workBook.SaveAs (@&quot;d:\temp.xlsx&quot;, missing, missing, missing, missing,<br>  missing, Excel.XlSaveAsAccessMode.xlNoChange, missing, missing,<br>  missing, missing, missing);<br>
We'll look now at what those language enhancements are, and how they help with<br>COM programming.<br>
<b>Optional Parameters and Named Arguments<br></b>Because COM APIs don't support function overloading, it's very common to have<br>functions with numerous parameters, many of which are optional. Prior to C# 4.0,<br>all optional parameters had to be explicitly passed default argument values. C# 4.0's<br>new support for optional parameters puts an end to this verbosity and allows us to<br>replace the following:<br>
var missing = System.Reflection.Missing.Value;<br>
workBook.SaveAs (@&quot;d:\temp.xlsx&quot;, missing, missing, missing, missing,<br>  missing, Excel.XlSaveAsAccessMode.xlNoChange, missing, missing,<br>  missing, missing, missing);<br>
with this:<br>
workBook.SaveAs (@&quot;d:\temp.xlsx&quot;);<br>
(As we stated in Chapter 3, the compiler translates the latter into the former.)<br>
With named arguments, you can easily specify additional arguments, regardless of<br>their position:<br>
<b>972 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=993></a>workBook.SaveAs (@&quot;c:\test.xlsx&quot;, <b>Password:&quot;foo&quot;</b>);<br>
<b>Implicit ref Parameters<br></b>Some  COM  APIs  (Microsoft  Word,  in  particular)  expose  functions  that  declare<br><i>every</i>  parameter  as  pass-by-reference--whether  or  not  the  function  modifies  the<br>parameter value. This is because of the perceived performance gain from not copying<br>argument values.<br>
Calling such methods from C# is clumsy because you must specify the ref keyword<br>with every argument. For instance, to open a Word document in C# 3.0, you must<br>do the following:<br>
object filename = &quot;foo.doc&quot;;<br>
object notUsed1 = Missing.Value;<br>
object notUsed2 = Missing.Value;<br>object notUsed3 = Missing.Value;<br>
...<br>
Open (ref filename, ref notUsed1, ref notUsed2, ref notUsed3, ...);<br>
C# 4.0 relaxes the rules by allowing you to omit the ref modifier on COM function<br>calls. Leveraging this feature in conjunction with optional parameters can drastically<br>simplify method calls:<br>
word.Open (&quot;foo.doc&quot;);<br>
The only caveat is that you will get neither a compile-time nor a runtime error if the<br>COM method you're calling actually does mutate an argument value.<br>
<b>Indexers<br></b>The ability to omit the ref modifier has another benefit: COM indexers with ref<br>parameters are now accessible via ordinary C# indexer syntax. Previously, this was<br>forbidden  because  ref/out  parameters  are  not  supported  with  C#  indexers  (the<br>somewhat clumsy workaround was to call the backing methods such as get_<i>XXX</i> and<br>set_<i>XXX</i>; this workaround is still legal for backward compatibility).<br>
Interop with indexers has been further enhanced in C# 4.0 such that you can now<br>call COM properties that accept arguments. In the following example, Foo is a prop-<br>erty that accepts an integer argument:<br>
<b>Native Interop</b><br>
myComObject.Foo [123] = &quot;Hello&quot;;<br>
Writing such properties yourself in C# is still prohibited: a type can expose an in-<br>dexer only on itself (the "default" indexer). Therefore, if you wanted to write code<br>in C# that would make the preceding statement legal, Foo would need to return<br>another type that exposed a (default) indexer.<br>
<b>Dynamic Binding<br></b>There are two ways that dynamic binding can help when calling COM components.<br>The first is if you want to access a COM component without a COM interop type.<br>To do this, call Type.GetTypeFromProgID with the COM component name to obtain<br>
<b>Calling a COM Component from C# | 973</b><br>
<hr>
<A name=994></a>a COM instance, and then use dynamic binding to call members from then on. Of<br>course, there's no IntelliSense, and compile-time checks are impossible:<br>
Type excelAppType = Type.GetTypeFromProgID (&quot;Excel.Application&quot;, true);<br><b>dynamic</b> excel = Activator.CreateInstance (excelAppType);<br>
excel.Visible = true;<br>
<b>dynamic</b> wb = excel.Workbooks.Add();<br>excel.Cells [1, 1].Value2 = &quot;foo&quot;;<br>
(The same thing can be achieved, much more clumsily, with reflection instead of<br>dynamic binding.)<br>
A variation of this theme is calling a COM component that sup-<br>ports <i>only</i> IDispatch. Such components are quite rare, however.<br>
Dynamic binding can also be useful (to a lesser extent) in dealing with the COM<br>variant type. COM API functions are often peppered with this type, which is roughly<br>equivalent to object in .NET. The runtime maps variant to object prior to C# 4.0,<br>with  the  effect  that  you  must  explicitly  cast  return  values--as  in  the  following<br>example:<br>
var excel = new Excel.Application();<br>
excel.Visible = true;<br>
Workbook workBook = excel.Workbooks.Add (System.Reflection.Missing.Value);<br>var range = <b>(Excel.Range</b>) excel.Cells [1, 1];<br>range.Font.FontStyle = &quot;Bold&quot;;<br>
The fact that some COM methods return variants is often due<br>to poor design more than to necessity.<br>
From C# 4.0, variant types are instead mapped to dynamic (if Embed Interop Types<br>is enabled; more on this soon), allowing you to replace the last two lines with this:<br>
excel.Cells [1, 1].Font.FontStyle = &quot;Bold&quot;;<br>
The disadvantage of working in this way is that you lose auto-completion, so you<br>must know that a property called Font happens to exist. For this reason, it's usually<br>easier to <i>dynamically</i> assign the result to its known interop type:<br>
<b>Excel.Range</b> range = excel.Cells [1, 1];<br>range.Font.FontStyle = &quot;Bold&quot;;<br>
As you can see, this saves only five characters over the old-fashioned approach!<br>
The mapping of variant to dynamic is the default from Visual Studio 2010, and is a<br>function of enabling Embed Interop Types on a reference.<br>
<b>974 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=995></a><b>Embedding Interop Types<br></b>We said previously that C# ordinarily calls COM components via interop types that<br>are generated by calling the <i>tlimp.exe</i> tool (directly, or via Visual Studio).<br>
Prior to C# 4.0, you would <i>reference</i> interop assemblies just like any other assembly.<br>This could be troublesome, however, because interop assemblies can get quite large<br>with complex COM components. A tiny add-in for Microsoft Word, for instance,<br>requires an interop assembly that is orders of magnitude larger than itself.<br>
In  C#  4.0,  rather  than  <i>referencing</i>  an  interop  assembly,  you  have  the  option  of<br><i>linking</i> to it. When you do this, the compiler analyzes the assembly to work out<br>precisely the types and members that your application actually uses. It then embeds<br>definitions for those types and members directly in your application. This means<br>that you don't have to worry about bloat, because only the COM interfaces that you<br>actually use are included in your application.<br>
Interop linking is the default in Visual Studio 2010 for COM references. If you want<br>to <i>disable</i> it, select the reference in the Solution Explorer, and then go to its properties<br>and set Embed Interop Types to False.<br>
To enable interop linking from the command-line compiler, call csc with /link in-<br>stead of /reference (or /L instead of /R).<br>
<b>Type Equivalence<br></b>CLR 4.0 supports <i>type equivalence</i> for linked interop types. That means that if two<br>assemblies each link to an interop type, those types will be considered equivalent if<br>they wrap the same COM type. This holds true even if the interop assemblies to<br>which they linked were generated independently.<br>
Type equivalence relies on the TypeIdentifierAttribute attrib-<br>ute  in  the  System.Runtime.InteropServices  namespace.  The<br>compiler automatically applies this attribute when you link to<br>interop assemblies. COM types are then considered equivalent<br>if they have the same GUID.<br>
<b>Native Interop</b><br>
Type equivalence does away with the need for <i>Primary Interop Assemblies</i>.<br>
<b>Primary Interop Assemblies<br></b>Before C# 4.0, there was no interop linking and no option of type equivalence. This<br>created a problem in that if two developers each ran the <i>tlimp.exe</i> tool on the same<br>COM component, they'd end up with incompatible interop assemblies, hindering<br>interoperability. The workaround was for the author of each COM library to release<br>an official version of the interop assembly, called the <i>Primary Interop Assembly</i> (PIA).<br>
<b>Primary Interop Assemblies | 975</b><br>
<hr>
<A name=996></a>PIAs, however, were a poor solution for the following reasons:<br>
<i>PIAs were not actually used</i><br>
Since everyone could run the type library importer tool, they often did so, rather<br>than using the official version. In some cases, there was no choice as the authors<br>of the COM library didn't actually publish a PIA.<br>
<i>PIAs require registration</i><br>
PIAs require registration in the GAC. This burden falls on developers writing<br>simple add-ins for a COM component.<br>
<i>PIAs bloat deployment</i><br>
PIAs exemplify the problem of interop assembly bloat that we described earlier.<br>In particular, the Microsoft Office team chose not to deploy their PIAs with<br>their product.<br>
<b>Exposing C# Objects to COM<br></b>It's also possible to write classes in C# that can be consumed in the COM world.<br>The  CLR  makes  this  possible  through  a  proxy  called  a  COM-Callable  Wrapper<br>(CCW). A CCW marshals types between the two worlds (as with an RCW) and<br>implements IUnknown (and optionally IDispatch) as required by the COM protocol.<br>A CCW is lifetime-controlled from the COM side via reference counting (rather than<br>through the CLR's garbage collector).<br>
You can expose any public class to COM. The one requirement is to define an as-<br>sembly attribute that assigns a GUID to identify the COM type library:<br>
 [assembly: Guid (&quot;...&quot;)]     // A unique GUID for the COM type library<br>
By default, all public types will be visible to COM consumers. You can make specific<br>types invisible, however, by applying the [ComVisible(false)] attribute. If you want<br>all types invisible by default, apply [ComVisible(false)] to the assembly, and then<br>[ComVisible(true)] to the types you wish to expose.<br>
The final step is to call the <i>tlbexp.exe</i> tool:<br>
tlbexp.exe myLibrary.dll<br>
This generates a COM type library (<i>.tlb</i>) file which you can then register and consume<br>in COM applications. COM interfaces to match the COM-visible classes are gen-<br>erated automatically.<br>
<b>976 | Chapter 25:</b><b>Native and COM Interoperability</b><br>
<hr>
<A name=997></a><b>26</b><br>
<b>Regular Expressions</b><br>
The regular expressions language identifies character patterns. The .NET types sup-<br>porting regular expressions are based on Perl 5 regular expressions and support both<br>search and search/replace functionality.<br>
Regular expressions are used for tasks such as:<br>
· Validating text input such as passwords and phone numbers (ASP.NET pro-<br>
vides the RegularExpressionValidator control just for this purpose)<br>
· Parsing textual data into more structured forms (e.g., extracting data from an<br>
HTML page for storage in a database)<br>
· Replacing patterns of text in a document (e.g., whole words only)<br>
This chapter is split into both conceptual sections teaching the basics of regular<br>expressions  in  .NET  and  reference  sections  describing  the  regular  expressions<br>language.<br>
All regular expression types are defined in System.Text.RegularExpressions.<br>
For  more  on  regular  expressions,  <i>http://regular-expressions<br>.info</i>  is  a  good  online  reference  with  lots  of  examples,  and<br><i>Mastering Regular Expressions</i> by Jeffrey E. F. Friedl, is invalu-<br>able for the serious.<br>
The samples in this chapter are all preloaded into LINQPad.<br>There  is  also  an  interactive  utility  available  called  Expresso,<br>which assists in building and visualizing regular expressions,<br>and comes with its own expression library.<br>
<b>Regular Expression Basics<br></b>One of the most common regular expression operators is a <i>quantifier</i>. ? is a quantifier<br>that matches the preceding item 0 or 1 time. In other words, ? means <i>optional</i>. An<br>
<b>977</b><br>
<hr>
<A name=998></a>item is either a single character or a complex structure of characters in square brack-<br>ets. For example, the regular expression &quot;colou?r&quot; matches color and colour, but<br>not colouur:<br>
Console.WriteLine (Regex.Match (&quot;color&quot;,   @&quot;<b>colou?r</b>&quot;).Success);  // True<br>
Console.WriteLine (Regex.Match (&quot;colour&quot;,  @&quot;<b>colou?r</b>&quot;).Success);  // True<br>Console.WriteLine (Regex.Match (&quot;colouur&quot;, @&quot;<b>colou?r</b>&quot;).Success);  // False<br>
Regex.Match searches within a larger string. The object that it returns has properties<br>for the Index and Length of the match, as well as the actual Value matched:<br>
Match m = Regex.Match (&quot;any colour you like&quot;, @&quot;<b>colou?r</b>&quot;);<br>
Console.WriteLine (m.Success);     // True<br>
Console.WriteLine (m.Index);       // 4<br>
Console.WriteLine (m.Length);      // 6<br>
Console.WriteLine (m.Value);       // colour<br>Console.WriteLine (m.ToString());  // colour<br>
You can think of Regex.Match as a more powerful version of the string's IndexOf<br>method. The difference is that it searches for a <i>pattern</i> rather than a literal string.<br>
The  IsMatch  method  is  a  shortcut  for  calling  Match  and  then  testing  the  Success<br>property.<br>
The regular expressions engine works from left to right by default, so only the left-<br>most match is returned. You can use the NextMatch method to return more matches:<br>
Match m1 = Regex.Match (&quot;One color? There are two colours in my head!&quot;,<br>                        @&quot;<b>colou?rs?</b>&quot;);<br>
Match m2 = m1.NextMatch();<br>Console.WriteLine (m1);         // color<br>
Console.WriteLine (m2);         // colours<br>
The Matches method returns all matches in an array. We can rewrite the preceding<br>example as follows:<br>
foreach (Match m in Regex.Matches<br>          (&quot;One color? There are two colours in my head!&quot;, @&quot;<b>colou?rs?</b>&quot;))<br>  Console.WriteLine (m);<br>
Another common regular expressions operator is the <i>alternator</i>, expressed with a<br>vertical bar, |. An alternator expresses alternatives. The following matches "Jen",<br>"Jenny", and "Jennifer":<br>
Console.WriteLine (Regex.IsMatch (&quot;Jenny&quot;, &quot;<b>Jen(ny|nifer)?</b>&quot;));  // True<br>
The parentheses around an alternator separate the alternatives from the rest of the<br>expression.<br>
<b>Compiled Regular Expressions<br></b>In some of the preceding examples, we called a static RegEx method repeatedly with<br>the same pattern. An alternative approach in these cases is to instantiate a Regex<br>object with the pattern and then call instance methods:<br>
<b>978 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=999></a>Regex r = new Regex (@&quot;<b>sausages?</b>&quot;);<br>
Console.WriteLine (r.Match (&quot;sausage&quot;));   // sausage<br>Console.WriteLine (r.Match (&quot;sausages&quot;));  // sausages<br>
This is not just a syntactic convenience: under the covers, a RegEx instance uses<br>lightweight  code  generation  (DynamicMethod  in  Reflection.Emit)  to  dynamically<br>build and compile code tailored to that particular regular expression. This results in<br>(up to 10 times) faster matching, at the expense of a small initial compilation cost<br>(a few tens of microseconds).<br>
A Regex instance is immutable.<br>
The regular expressions engine is fast. Even without compila-<br>tion, a simple match typically takes less than a microsecond.<br>
<b>RegexOptions<br></b>The RegexOptions flags enum lets you tweak matching behavior. A common use for<br>RegexOptions is to perform a case-insensitive search:<br>
Console.WriteLine (Regex.Match (&quot;a&quot;, &quot;<b>A</b>&quot;, RegexOptions.IgnoreCase)); // a<br>
Most of the RegexOptions flags can also be activated within a regular expression itself,<br>using a single-letter code as follows:<br>
Console.WriteLine (Regex.Match (&quot;a&quot;, @&quot;<b>(?i)A</b>&quot;));                     // a<br>
You can turn options on and off throughout an expression as follows:<br>
Console.WriteLine (Regex.Match (&quot;AAAa&quot;, @&quot;<b>(?i)a(?-i)a</b>&quot;));            // Aa<br>
Another useful option is IgnorePatternWhitespace or (?x). This allows you to insert<br>whitespace to make a regular expression more readable--without the whitespace<br>being taken literally.<br>
Table 26-1 lists all RegExOptions values along with their single-letter codes.<br>
<i>Table 26-1. Regular expression options</i><br>
<b>Enum value</b><br>
<b>Regular expressions code</b><br>
<b>Description</b><br>
None<br>
 <br>
 <br>
IgnoreCase<br>
i<br>
Ignores case (by default, regular expressions are case-sensitive)<br>
Multiline<br>
m<br>
Changes ^ and $ so that they match the start/end of a line<br>
instead of start/end of the string<br>
<b>RegEx</b><br>
ExplicitCapture<br>
n<br>
Captures only explicitly named or explicitly numbered groups<br>
Compiled<br>
c<br>
Forces compilation of regular expression to IL<br>
Singleline<br>
s<br>
Makes . match every character (instead of matching every<br>
character except \n)<br>
IgnorePattern<br>
x<br>
Eliminates unescaped whitespace from the pattern<br>
Whitespace<br>
<b>Regular Expression Basics | 979</b><br>
<hr>
<A name=1000></a><b>Enum value</b><br>
<b>Regular expressions code</b><br>
<b>Description</b><br>
RightToLeft<br>
r<br>
Searches from right to left; can't be specified midstream<br>
ECMAScript<br>
 <br>
Forces ECMA compliance (by default, the implementation is not<br>ECMA-compliant)<br>
CultureInvariant  <br>
Turns off culture-specific behavior (by default,<br>CultureInfo.CurrentCulture influences string com-<br>
parison rules)<br>
<b>Character Escapes<br></b>Regular expressions have the following metacharacters, which have a special rather<br>than literal meaning:<br>
\ * + ? | { [ () ^ $ . #<br>
To refer to a metacharacter literally, you must prefix the character with a backslash.<br>In the following example, we escape the ? character to match the string &quot;what?&quot;:<br>
Console.WriteLine (Regex.Match (&quot;what?&quot;, @&quot;<b>what\?</b>&quot;)); // what? (correct)<br>Console.WriteLine (Regex.Match (&quot;what?&quot;, @&quot;<b>what?</b>&quot;));  // what  (incorrect)<br>
If the character is inside a <i>set</i> (square brackets), this rule does<br>not apply, and the metacharacters are interpreted literally. We<br>discuss sets in the following section.<br>
The Regex's Escape and Unescape methods convert a string containing regular ex-<br>pression metacharacters by replacing them with escaped equivalents, and vice versa.<br>For example:<br>
Console.WriteLine (Regex.Escape   (@&quot;?&quot;));     // <b>\?<br></b>Console.WriteLine (Regex.Unescape (@&quot;<b>\?</b>&quot;));    // ?&gt;<br>
All the regular expression strings in this chapter we express with the C# @ literal.<br>This is to bypass C#'s escape mechanism, which also uses the backslash. Without<br>the @, a literal backslash would require four backslashes:<br>
Console.WriteLine (Regex.Match (&quot;\\&quot;, &quot;<b>\\\\</b>&quot;));    // \<br>
Unless you include the (?x) option, spaces are treated literally in regular expressions:<br>
Console.Write (Regex.IsMatch (&quot;hello world&quot;, @&quot;<b>hello world</b>&quot;));  // True<br>
<b>980 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1001></a><b>Character Sets<br></b>Character sets act as wildcards for a particular set of characters.<br>
<b>Expression</b><br>
<b>Meaning</b><br>
<b>Inverse ("not")</b><br>
[abcdef]<br>
Matches a single character in the list<br>
[^abcdef]<br>
[a-f]<br>
Matches a single character in a range<br>
[^a-f]<br>
\d<br>
Matches a decimal digit<br>
\D<br>
Same as [0­9]<br>
\w<br>
Matches a word character (by default, varies according to CultureInfo.Cur<br>
\W<br>
rentCulture; for example, in English, same as [a­zA­Z_0­9])<br>
\s<br>
Matches a whitespace character<br>
\S<br>
Same as [\n\r\t\f]<br>
\p{category}<br>
Matches a character in a specified category<br>
\P<br>
.<br>
(Default mode) Matches any character except \n<br>
\n<br>
.<br>
(SingleLine mode) Matches any character<br>
\n<br>
To match exactly one of a set of characters, put the character set in square brackets:<br>
Console.Write (Regex.Matches (&quot;That is that.&quot;, &quot;<b>[Tt]hat</b>&quot;).Count);   // 2<br>
To match any character <i>except</i> those in a set, put the set in square brackets with a<br>^ symbol before the first character:<br>
Console.Write (Regex.Match (&quot;quiz qwerty&quot;, &quot;<b>q[^aeiou]</b>&quot;).Index);    // 5<br>
You can specify a range of characters with a hyphen. The following regular expres-<br>sion captures a chess move:<br>
Console.Write (Regex.Match (&quot;b1-c4&quot;, @&quot;<b>[a-h]\d-[a-h]\d</b>&quot;).Success);  // True<br>
\d indicates a digit character, so \d will match any digit. \D matches any nondigit<br>character.<br>
\w indicates a word character, which includes letters, numbers, and the underscore.<br>\W matches any nonword character. These work as expected for non-English letters<br>too, such as Cyrillic.<br>
. matches any character except \n (but allows \r).<br>
\p matches a character in a specified category, such as {Lu} for uppercase letter or<br>{P}  for  punctuation  (we  list  the  categories  in  the  reference  section  later  in  the<br>chapter):<br>
<b>RegEx</b><br>
Console.Write (Regex.IsMatch (&quot;Yes, please&quot;, @&quot;<b>\p{P}</b>&quot;));   // True<br>
We will find more uses for \d, \w, and . when we combine them with <i>quantifiers</i>.<br>
<b>Regular Expression Basics | 981</b><br>
<hr>
<A name=1002></a><b>Quantifiers<br></b>Quantifiers match an item a specified number of times.<br>
<b>Quantifier</b><br>
<b>Meaning</b><br>
*<br>
Zero or more matches<br>
+<br>
One or more matches<br>
?<br>
Zero or one match<br>
{<i>n</i>}<br>
Exactly <i>n</i> matches<br>
{<i>n</i>,}<br>
At least <i>n</i> matches<br>
{<i>n</i>,<i>m</i>}<br>
Between <i>n</i> and <i>m</i> matches<br>
The * quantifier matches the preceding character or group zero or more times. The<br>following matches <i>cv.doc</i>, along with any numbered versions of the same file (e.g.,<br><i>cv2.doc</i>, <i>cv15.doc</i>):<br>
Console.Write (Regex.Match (&quot;cv15.doc&quot;, @&quot;<b>cv\d*\.doc</b>&quot;).Success);  // True<br>
Notice that we have to escape out the period in the file extension with a backslash.<br>
The following allows anything between <i>cv</i> and <i>.doc</i> and is equivalent to dir cv*.doc:<br>
Console.Write (Regex.Match (&quot;cvjoint.doc&quot;, @&quot;<b>cv.*\.doc</b>&quot;).Success);  // True<br>
The + quantifier matches the preceding character or group one or more times. For<br>example:<br>
Console.Write (Regex.Matches (&quot;slow! yeah slooow!&quot;, &quot;<b>slo+w</b>&quot;).Count);  // 2<br>
The {} quantifier matches a specified number (or range) of repetitions. The following<br>matches a blood pressure reading:<br>
Regex bp = new Regex (@&quot;<b>\d{2,3}/\d{2,3}</b>&quot;);<br>Console.WriteLine (bp.Match (&quot;It used to be 160/110&quot;));  // 160/110<br>Console.WriteLine (bp.Match (&quot;Now it's only 115/75&quot;));   // 115/75<br>
<b>Greedy Versus Lazy Quantifiers<br></b>By default, quantifiers are <i>greedy</i>, as opposed to <i>lazy</i>. A greedy quantifier repeats as<br><i>many</i> times as it can before proceeding. A lazy quantifier repeats as <i>few</i> times as it<br>can before proceeding. You can make any quantifier lazy by suffixing it with the ?<br>symbol. To illustrate the difference, consider the following HTML fragment:<br>
string html = &quot;&lt;i&gt;By default&lt;/i&gt; quantifiers are &lt;i&gt;greedy&lt;/i&gt; creatures&quot;;<br>
Suppose we want to extract the two phrases in italics. If we execute the following:<br>
foreach (Match m in Regex.Matches (html, @&quot;<b>&lt;i&gt;.*&lt;/i&gt;</b>&quot;))<br>  Console.WriteLine (m);<br>
the result is not two matches, but a <i>single</i> match, as follows:<br>
&lt;i&gt;By default&lt;/i&gt; quantifiers are &lt;i&gt;greedy&lt;/i&gt;<br>
<b>982 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1003></a>The problem is that our * quantifier greedily repeats as many times as it can before<br>matching &lt;/i&gt;. So, it chomps right through the first &lt;/i&gt;, stopping only at the final<br>&lt;/i&gt; (the <i>last point</i> at which the rest of the expression can still match).<br>
If we make the quantifier lazy:<br>
foreach (Match m in Regex.Matches (html, @&quot;<b>&lt;i&gt;.*?&lt;/i&gt;</b>&quot;))<br>  Console.WriteLine (m);<br>
the * bails out at the <i>first</i> point at which the rest of the expression can match. Here's<br>the result:<br>
&lt;i&gt;By default&lt;/i&gt;<br>
&lt;i&gt;greedy&lt;/i&gt;<br>
<b>Zero-Width Assertions<br></b>The regular expressions language lets you place conditions on what should occur<br><i>before</i> or <i>after</i> a match, through lookbehind, lookahead, anchors, and word boun-<br>daries. These are called <i>zero-width</i> assertions, because they don't increase the width<br>(or length) of the match itself.<br>
<b>Lookahead and Lookbehind<br></b>The (?=<i>expr</i>) construct checks whether the text that follows matches <i>expr</i>, without<br>including expr in the result. This is called <i>positive lookahead</i>. In the following ex-<br>ample, we look for a number followed by the word "miles":<br>
Console.WriteLine (Regex.Match (&quot;say 25 miles more&quot;, @&quot;<b>\d+\s(?=miles)</b>&quot;));<br>
<i>OUTPUT: 25</i><br>
Notice the word "miles" was not returned in the result, even though it was required<br>to <i>satisfy</i> the match.<br>
After a successful lookahead, matching continues as though the sneak preview never<br>took place. So, if we append .* to our expression as follows:<br>
Console.WriteLine (Regex.Match (&quot;say 25 miles more&quot;, @&quot;<b>\d+\s(?=miles).*</b>&quot;));<br>
the result is 25 miles more.<br>Lookahead can be useful in validating a strong password. Suppose a password has<br>to be at least six characters and contain at least one digit. With a lookup, we could<br>achieve this as follows:<br>
string password = &quot;...&quot;;<br>bool ok = Regex.IsMatch (password, @&quot;<b>(?=.*\d).{6,}</b>&quot;);<br>
<b>RegEx</b><br>
This first performs a lookahead to ensure that a digit occurs somewhere in the string.<br>If satisfied, it returns to its position before the sneak preview began and matches six<br>or more characters. (In "Cookbook Regular Expressions" on page 988, we include<br>a more substantial password validation example.)<br>
<b>Zero-Width Assertions | 983</b><br>
<hr>
<A name=1004></a>The opposite is the <i>negative lookahead</i> construct, (?!<i>expr</i>). This requires that the<br>match <i>not</i> be followed by <i>expr</i>. The following expression matches "good"--unless<br>"however" or "but" appears later in the string:<br>
string regex = &quot;<b>(?i)good(?!.*(however|but))&quot;;</b><br>
Console.WriteLine (Regex.IsMatch (&quot;Good work! But...&quot;,  regex));  // False<br>Console.WriteLine (Regex.IsMatch (&quot;Good work! Thanks!&quot;, regex));  // True<br>
The (?&lt;=<i>expr</i>) construct denotes <i>positive lookbehind</i> and requires that a match be<br><i>preceded</i> by a specified expression. The opposite construct, (?&lt;!<i>expr</i>), denotes <i>neg-<br>ative lookbehind</i> and requires that a match <i>not be preceded</i> by a specified expression.<br>For example, the following matches "good"--unless "however" appears <i>earlier</i> in<br>the string:<br>
string regex = &quot;<b>(?i)(?&lt;!however.*)good&quot;</b>;<br>
Console.WriteLine (Regex.IsMatch (&quot;However good, we...&quot;, regex)); // False<br>
Console.WriteLine (Regex.IsMatch (&quot;Very good, thanks!&quot;, regex));  // True<br>
We could improve these examples by adding <i>word boundary assertions</i>, which we<br>will introduce shortly.<br>
<b>Anchors<br></b>The anchors ^ and $ match a particular <i>position</i>. By default:<br>
^<br>
Matches the <i>start</i> of the string<br>
$<br>
Matches the <i>end</i> of the string<br>
^ has two context-dependent meanings: an <i>anchor</i> and a <i>char-<br>acter class negator</i>.<br>
$  has  two  context-dependent  meanings:  an  <i>anchor</i>  and  a  <i>re-<br>placement group denoter</i>.<br>
For example:<br>
Console.WriteLine (Regex.Match (&quot;Not now&quot;, &quot;^[Nn]o&quot;));   // No<br>Console.WriteLine (Regex.Match (&quot;f = 0.2F&quot;, &quot;[Ff]$&quot;));   // F<br>
If you specify RegexOptions.Multiline or include (?m) in the expression:<br>
· ^ matches the start of the string or <i>line</i> (directly after a \n).<br>· $ matches the end of the string or <i>line</i> (directly before a \n).<br>
There's a catch to using $ in multiline mode: a new line in Windows is nearly always<br>denoted with \r\n rather than just \n. This means that for $ to be useful, you must<br>usually match the \r as well, with a <i>positive lookahead</i>:<br>
(?=\r?$)<br>
<b>984 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1005></a>The positive lookahead ensures that \r doesn't become part of the result. The fol-<br>lowing matches lines that end in &quot;.txt&quot;:<br>
string fileNames = &quot;a.txt&quot; + &quot;\r\n&quot; + &quot;b.doc&quot; + &quot;\r\n&quot; + &quot;c.txt&quot;;<br>string r = @&quot;<b>.+\.txt(?=\r?$)</b>&quot;;<br>
foreach (Match m in Regex.Matches (fileNames, r, RegexOptions.Multiline))<br>
  Console.Write (m + &quot; &quot;);<br>
<i>OUTPUT: a.txt c.txt</i><br>
The following matches all empty lines in string s:<br>
MatchCollection emptyLines = Regex.Matches (s, &quot;<b>^(?=\r?$)</b>&quot;,<br>
                                            RegexOptions.Multiline);<br>
The following matches all lines that are either empty or contain only whitespace:<br>
MatchCollection blankLines = Regex.Matches (s, &quot;<b>^[ \t]*(?=\r?$)</b>&quot;,<br>
                                            RegexOptions.Multiline);<br>
Since  an  anchor  matches  a  position  rather  than  a  character,<br>specifying an anchor on its own matches an empty string:<br>
Console.WriteLine (Regex.Match (&quot;x&quot;, &quot;<b>$</b>&quot;).Length);   // 0<br>
<b>Word Boundaries<br></b>The word boundary assertion \b matches where word characters (\w) adjoin either:<br>
· Nonword characters (\W)<br>· The beginning/end of the string (^ and $)<br>
\b is often used to match whole words. For example:<br>
foreach (Match m in Regex.Matches (&quot;Wedding in Sarajevo&quot;, @&quot;<b>\b\w+\b</b>&quot;))<br>  Console.WriteLine (m);<br>
<i>Wedding<br>In<br>Sarajevo</i><br>
The following statements highlight the effect of a word boundary:<br>
int one = Regex.Matches (&quot;Wedding in Sarajevo&quot;, @&quot;<b>\bin\b</b>&quot;).Count; // 1<br>int two = Regex.Matches (&quot;Wedding in Sarajevo&quot;, @&quot;<b>in</b>&quot;).Count;     // 2<br>
The next query uses positive lookahead to return words followed by "(sic)":<br>
string text = &quot;Don't loose (sic) your cool&quot;;<br>Console.Write (Regex.Match (text, @&quot;<b>\b\w+\b\s(?=\(sic\))</b>&quot;));  // loose<br>
<b>RegEx</b><br>
<b>Groups<br></b>Sometimes it's useful to separate a regular expression into a series of subexpressions,<br>or <i>groups</i>. For instance, consider the following regular expression that represents a<br>U.S. phone number such as 206-465-1918:<br>
<b>Groups | 985</b><br>
<hr>
<A name=1006></a>\d{3}-\d{3}-\d{4}<br>
Suppose we wish to separate this into two groups: area code and local number. We<br>can achieve this by using parentheses to <i>capture</i> each group:<br>
(\d{3})-(\d{3}-\d{4})<br>
We then retrieve the groups programmatically as follows:<br>
Match m = Regex.Match (&quot;206-465-1918&quot;, @&quot;<b>(\d{3})-(\d{3}-\d{4})</b>&quot;);<br>
Console.WriteLine (m.Groups[1]);   // 206<br>
Console.WriteLine (m.Groups[2]);   // 465-1918<br>
The zeroth group represents the entire match. In other words, it has the same value<br>as the match's Value:<br>
Console.WriteLine (m.Groups[0]);   // 206-465-1918<br>Console.WriteLine (m);             // 206-465-1918<br>
Groups are part of the regular expressions language itself. This means you can refer<br>to a group within a regular expression. The \n syntax lets you index the group by<br>group  number  n  within  the  expression.  For  example,  the  expression  (\w)ee\1<br>matches deed and peep. In the following example, we find all words in a string starting<br>and ending in the same letter:<br>
foreach (Match m in Regex.Matches (&quot;pop pope peep&quot;, @&quot;<b>\b(\w)\w+\1\b</b>&quot;))<br>
  Console.Write (m + &quot; &quot;);  // pop peep<br>
The brackets around the \w instruct the regular expressions engine to store the sub-<br>match in a group (in this case, a single letter), so it can be used later. We refer to<br>that group later using \1, meaning the first group in the expression.<br>
<b>Named Groups<br></b>In a long or complex expression, it can be easier to work with groups by <i>name</i> rather<br>than index. Here's a rewrite of the previous example, using a group that we name<br>'letter':<br>
string regEx =<br>  @&quot;<b>\b</b>&quot;             +  // word boundary<br>  @&quot;<b>(?'letter'\w)</b>&quot;  +  // match first letter, and name it 'letter'<br>  @&quot;<b>\w+</b>&quot;            +  // match middle letters<br>  @&quot;<b>\k'letter'</b>&quot;     +  // match last letter, denoted by 'letter'<br>  @&quot;<b>\b</b>&quot;;               // word boundary<br>
foreach (Match m in Regex.Matches (&quot;bob pope peep&quot;, regEx))<br>  Console.Write (m + &quot; &quot;);  // bob peep<br>
To name a captured group:<br>
(?'<i>group-name</i>'group-expr)  <i>or</i>  (?&lt;<i>group-name</i>&gt;group-expr)<br>
To refer to a group:<br>
\k'<i>group-name</i>'  <i>or</i>  \k&lt;<i>group-name</i>&gt;<br>
<b>986 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1007></a>The  following  example  matches  a  simple  (nonnested)  XML/HTML  element,  by<br>looking for start and end nodes with a matching name:<br>
string regFind =<br>  @&quot;<b>&lt;(?'tag'\w+?).*&gt;</b>&quot; +  // match first tag, and name it 'tag'<br>
  @&quot;<b>(?'text'.*?)</b>&quot;     +  // match text content, name it 'text'<br>
  @&quot;<b>&lt;/\k'tag'&gt;</b>&quot;;         // match last tag, denoted by 'tag'<br>
Match m = Regex.Match (&quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;, regFind);<br>
Console.WriteLine (m.Groups [&quot;tag&quot;]);          // h1<br>
Console.WriteLine (m.Groups [&quot;text&quot;]);         // hello<br>
Allowing for all possible variations in XML structure, such as nested elements, is<br>more complex. The .NET regular expressions engine has a sophisticated extension<br>called "matched balanced constructs" that can assist with nested tags--information<br>on this is available on the Internet and in <i>Mastering Regular Expressions</i> by Jeffrey<br>E. F. Friedl.<br>
<b>Replacing and Splitting Text<br></b>The RegEx.Replace method works like string.Replace, except that it uses a regular<br>expression.<br>
The following replaces "cat" with "dog". Unlike with string.Replace, "catapult"<br>won't change into "dogapult", because we match on word boundaries:<br>
string find = @&quot;\bcat\b&quot;;<br>
string replace = &quot;dog&quot;;<br>Console.WriteLine (Regex.Replace (&quot;catapult the cat&quot;, find, replace));<br>
<i>OUTPUT: catapult the dog</i><br>
The replacement string can reference the original match with the $0 substitution<br>construct. The following example wraps numbers within a string in angle brackets:<br>
string text = &quot;10 plus 20 makes 30&quot;;<br>Console.WriteLine (Regex.Replace (text, @&quot;<b>\d+</b>&quot;, @&quot;<b>&lt;$0&gt;</b>&quot;));<br>
<i>OUTPUT: &lt;10&gt; plus &lt;20&gt; makes &lt;30&gt;</i><br>
You can access any captured groups with $1, $2, $3, and so on, or ${<i>name</i>} for a named<br>group. To illustrate how this can be useful, consider the regular expression in the<br>previous section that matched a simple XML element. By rearranging the groups,<br>we can form a replacement expression that moves the element's content into an<br>XML attribute:<br>
string regFind =<br>  @&quot;<b>&lt;(?'tag'\w+?).*&gt;</b>&quot; +  // match first tag, and name it 'tag'<br>
<b>RegEx</b><br>
  @&quot;<b>(?'text'.*?)</b>&quot;     +  // match text content, name it 'text'<br>  @&quot;<b>&lt;/\k'tag'&gt;</b>&quot;;         // match last tag, denoted by 'tag'<br>
string regReplace =<br>  @&quot;<b>&lt;${tag}</b>&quot;         +  // &lt;tag<br>  @&quot;<b>value=&quot;&quot;</b>&quot;        +  // value=&quot;<br>  @&quot;<b>${text}</b>&quot;         +  // text<br>
<b>Replacing and Splitting Text | 987</b><br>
<hr>
<A name=1008></a>  @&quot;<b>&quot;&quot;/&gt;</b>&quot;;              // &quot;/&gt;<br>
Console.Write (Regex.Replace (&quot;&lt;msg&gt;hello&lt;/msg&gt;&quot;, regFind, regReplace));<br>
Here's the result:<br>
&lt;msg value=&quot;hello&quot;/&gt;<br>
<b>MatchEvaluator Delegate<br></b>Replace has an overload that takes a MatchEvaluator delegate, which is invoked per<br>match. This allows you to delegate the content of the replacement string to C# code<br>when the regular expressions language isn't expressive enough. For example:<br>
Console.WriteLine (Regex.Replace (&quot;5 is less than 10&quot;, @&quot;<b>\d+</b>&quot;,<br>
                   m =&gt; (int.Parse (m.Value) * 10).ToString()) );<br>
<i>OUTPUT: 50 is less than 100</i><br>
In the cookbook, we show how to use a MatchEvaluator to escape Unicode characters<br>appropriately for HTML.<br>
<b>Splitting Text<br></b>The  static  Regex.Split  method  is  a  more  powerful  version  of  the  string.Split<br>method, with a regular expression denoting the separator pattern. In this example,<br>we split a string, where any digit counts as a separator:<br>
foreach (string s in Regex.Split (&quot;a5b7c&quot;, @&quot;<b>\d</b>&quot;))<br>  Console.Write (s + &quot; &quot;);     // a b c<br>
The result, here, doesn't include the separators themselves. You can include the<br>separators, however, by wrapping the expression in a positive lookahead. The fol-<br>lowing splits a camel-case string into separate words:<br>
foreach (string s in Regex.Split (&quot;oneTwoThree&quot;, @&quot;<b>(?=[A-Z])</b>&quot;))<br>  Console.Write (s + &quot; &quot;);    // one Two Three<br>
<b>Cookbook Regular Expressions<br>Recipes</b><br>
<b>Matching U.S. Social Security number/phone number</b><br>
string ssNum = @&quot;<b>\d{3}-\d{2}-\d{4}</b>&quot;;<br>
Console.WriteLine (Regex.IsMatch (&quot;123-45-6789&quot;, ssNum));      // True<br>
string phone = @&quot;<b>(?x)<br>  ( \d{3}[-\s] | \(\d{3}\)\s? )<br>    \d{3}[-\s]?<br>    \d{4}</b>&quot;;<br>
Console.WriteLine (Regex.IsMatch (&quot;123-456-7890&quot;,   phone));   // True<br>Console.WriteLine (Regex.IsMatch (&quot;(123) 456-7890&quot;, phone));   // True<br>
<b>988 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1009></a><b>Extracting &quot;name = value&quot; pairs (one per line)<br></b>Note that this starts with the <i>multiline</i> directive (?m):<br>
string r = @&quot;<b>(?m)^\s*(?'name'\w+)\s*=\s*(?'value'.*)\s*(?=\r?$)</b>&quot;;<br>
string text =<br>
  @&quot;id = 3<br>    secure = true<br>    timeout = 30&quot;;<br>
foreach (Match m in Regex.Matches (text, r))<br>
  Console.WriteLine (m.Groups[&quot;name&quot;] + &quot; is &quot; + m.Groups[&quot;value&quot;]);<br><i>id is 3 secure is true timeout is 30</i><br>
<b>Strong password validation<br></b>The following checks whether a password has at least six characters, and whether<br>it contains a digit, symbol, or punctuation mark:<br>
string r = @&quot;<b>(?x)^(?=.* ( \d | \p{P} | \p{S} )).{6,}</b>&quot;;<br>
Console.WriteLine (Regex.IsMatch (&quot;abc12&quot;, r));     // False<br>Console.WriteLine (Regex.IsMatch (&quot;abcdef&quot;, r));    // False<br>
Console.WriteLine (Regex.IsMatch (&quot;ab88yz&quot;, r));    // True<br>
<b>Lines of at least 80 characters</b><br>
string r = @&quot;<b>(?m)^.{80,}(?=\r?$)</b>&quot;;<br>
string fifty = new string ('x', 50);<br>string eighty = new string ('x', 80);<br>
string text = eighty + &quot;\r\n&quot; + fifty + &quot;\r\n&quot; + eighty;<br>
Console.WriteLine (Regex.Matches (text, r).Count);   // 2<br>
<b>Parsing dates/times (N/N/N H:M:S AM/PM)<br></b>This expression handles a variety of numeric date formats--and works whether the<br>year comes first or last. The (?x) directive improves readability by allowing white-<br>space; the (?i) switches off case-sensitivity (for the optional AM/PM designator).<br>You can then access each component of the match through the Groups collection:<br>
string r = @&quot;<b>(?x)(?i)<br> (\d{1,4}) [./-]<br></b> <b>(\d{1,2}) [./-]<br></b> <b>(\d{1,4}) [\sT]<br> (\d+):(\d+):(\d+) \s? (A\.?M\.?|P\.?M\.?)?</b>&quot;;<br>
<b>RegEx</b><br>
string text = &quot;01/02/2008 5:20:50 PM&quot;;<br>
foreach (Group g in Regex.Match (text, r).Groups)<br>  Console.WriteLine (g.Value + &quot; &quot;);<br><i>01/02/2008 5:20:50 PM 01 02 2008 5 20 50 PM</i><br>
<b>Cookbook Regular Expressions | 989</b><br>
<hr>
<A name=1010></a><b>Matching Roman numerals</b><br>
string r =<br>
  @&quot;<b>(?i)\bm*</b>&quot;         +<br>
  @&quot;<b>(d?c{0,3}|c[dm])</b>&quot; +<br>  @&quot;<b>(l?x{0,3}|x[lc])</b>&quot; +<br>  @&quot;<b>(v?i{0,3}|i[vx])</b>&quot; +<br>
  @&quot;<b>\b</b>&quot;;<br>
Console.WriteLine (Regex.IsMatch (&quot;MCMLXXXIV&quot;, r));   // True<br>
<b>Removing repeated words<br></b>Here, we capture a named grouped called dupe:<br>
string r = @&quot;<b>(?'dupe'\w+)\W\k'dupe'</b>&quot;;<br>
string text = &quot;In the the beginning...&quot;;<br>
Console.WriteLine (Regex.Replace (text, r, &quot;${dupe}&quot;));<br>
<i>In the beginning</i><br>
<b>Word count</b><br>
string r = @&quot;<b>\b(\w|[-'])+\b</b>&quot;;<br>
string text = &quot;It's all mumbo-jumbo to me&quot;;<br>Console.WriteLine (Regex.Matches (text, r).Count);   // 5<br>
<b>Matching a Guid</b><br>
string r =<br>  @&quot;<b>(?i)\b</b>&quot;           +<br>  @&quot;<b>[0-9a-fA-F]{8}\-</b>&quot; +<br>  @&quot;<b>[0-9a-fA-F]{4}\-</b>&quot; +<br>  @&quot;<b>[0-9a-fA-F]{4}\-</b>&quot; +<br>  @&quot;<b>[0-9a-fA-F]{4}\-</b>&quot; +<br>  @&quot;<b>[0-9a-fA-F]{12}</b>&quot;  +<br>  @&quot;<b>\b</b>&quot;;<br>
string text = &quot;Its key is {3F2504E0-4F89-11D3-9A0C-0305E82C3301}.&quot;;<br>Console.WriteLine (Regex.Match (text, r).Index);                    // 12<br>
<b>Parsing an XML/HTML tag<br></b>Regex is useful for parsing HTML fragments--particularly when the document may<br>be imperfectly formed:<br>
string r =<br>  @&quot;<b>&lt;(?'tag'\w+?).*&gt;</b>&quot;  +  // match first tag, and name it 'tag'<br>  @&quot;<b>(?'text'.*?)</b>&quot;      +  // match text content, name it 'textd'<br>  @&quot;<b>&lt;/\k'tag'&gt;</b>&quot;;          // match last tag, denoted by 'tag'<br>
string text = &quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;;<br>
Match m = Regex.Match (text, r);<br>
<b>990 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1011></a>Console.WriteLine (m.Groups [&quot;tag&quot;]);       // h1<br>
Console.WriteLine (m.Groups [&quot;text&quot;]);      // hello<br>
<b>Splitting a camel-cased word<br></b>This requires a positive lookahead to include the uppercase separators:<br>
string r = @&quot;<b>(?=[A-Z])</b>&quot;;<br>
foreach (string s in Regex.Split (&quot;oneTwoThree&quot;, r))<br>  Console.Write (s + &quot; &quot;);    // one Two Three<br>
<b>Obtaining a legal filename</b><br>
string input = &quot;My \&quot;good\&quot; &lt;recipes&gt;.txt&quot;;<br>
char[] invalidChars = System.IO.Path.GetInvalidPathChars();<br>string invalidString = Regex.Escape (new string (invalidChars));<br>
string valid = Regex.Replace (input, &quot;<b>[</b>&quot; + invalidString + &quot;<b>]</b>&quot;, &quot;&quot;);<br>Console.WriteLine (valid);<br>
<i>My good recipes.txt</i><br>
<b>Escaping Unicode characters for HTML</b><br>
string htmlFragment = &quot;© 2007&quot;;<br>
string result = Regex.Replace (htmlFragment, @&quot;<b>[\u0080-\uFFFF]</b>&quot;,<br>                m =&gt; @&quot;&amp;#&quot; + ((int)m.Value[0]).ToString() + &quot;;&quot;);<br>
Console.WriteLine (result);        // &amp;#169; 2007<br>
<b>Unescaping characters in an HTTP query string</b><br>
string sample = &quot;C%23 rocks&quot;;<br>
string result = Regex.Replace (<br>    sample,<br>    @&quot;%[0-9a-f][0-9a-f]&quot;,<br>    m =&gt; ((char) Convert.ToByte (m.Value.Substring (1), 16)).ToString(),<br>    RegexOptions.IgnoreCase<br>);<br>
Console.WriteLine (result);   // C# rocks<br>
<b>Parsing Google search terms from a web stats log<br></b>This should be used in conjunction with the previous example to unescape charac-<br>ters in the query string:<br>
<b>RegEx</b><br>
string sample =<br>  &quot;http://google.com/search?hl=en&amp;q=greedy+quantifiers+regex&amp;btnG=Search&quot;;<br>
Match m = Regex.Match (sample, @&quot;(?&lt;=google\..+search\?.*q=).+?(?=(&amp;|$))&quot;);<br>
string[] keywords = m.Value.Split (<br>
<b>Cookbook Regular Expressions | 991</b><br>
<hr>
<A name=1012></a>  new[] { '+' }, StringSplitOptions.RemoveEmptyEntries);<br>
foreach (string keyword in keywords)<br>  Console.Write (keyword + &quot; &quot;);       // greedy quantifiers regex<br>
<b>Regular Expressions Language Reference<br></b>Table 26-2 through Table 26-12 summarize the regular expressions grammar and<br>syntax supported in the .NET implementation.<br>
<i>Table 26-2. Character escapes</i><br>
<b>Escape code sequence</b><br>
<b>Meaning</b><br>
<b>Hexadecimal equivalent</b><br>
\a<br>
Bell<br>
\u0007<br>
\b<br>
Backspace<br>
\u0008<br>
\t<br>
Tab<br>
\u0009<br>
\r<br>
Carriage return<br>
\u000A<br>
\v<br>
Vertical tab<br>
\u000B<br>
\f<br>
Form feed<br>
\u000C<br>
\n<br>
Newline<br>
\u000D<br>
\e<br>
Escape<br>
\u001B<br>
\<i>nnn</i><br>
ASCII character nnn as octal (e.g., \n052)<br>
 <br>
\x<i>nn</i><br>
ASCII character nn as hex (e.g., \x3F)<br>
 <br>
\c<i>l</i><br>
ASCII control character l (e.g., \cG for Ctrl-G)<br>
 <br>
\u<i>nnnn</i><br>
Unicode character nnnn as hex (e.g., \u07DE)<br>
 <br>
\<i>symbol</i><br>
A nonescaped symbol<br>
 <br>
Special  case:  within  a  regular  expression,  \b  means  word  boundary,  except  in  a<br>[ ] set, in which \b means the backspace character.<br>
<i>Table 26-3. Character sets</i><br>
<b>Expression</b><br>
<b>Meaning</b><br>
<b>Inverse ("not")</b><br>
[abcdef]<br>
Matches a single character in the list<br>
[^abcdef]<br>
[a-f]<br>
Matches a single character in a range<br>
[^a-f]<br>
\d<br>
Matches a decimal digit<br>
\D<br>
Same as [0­9]<br>
\w<br>
Matches a word character (by default, varies<br>
\W<br>
according to CultureInfo.CurrentCul<br>ture; for example, in English, same as [a­<br>zA­Z_0­9])<br>
\s<br>
Matches a whitespace character<br>
\S<br>
Same as [\n\r\t\f]<br>
<b>992 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1013></a><b>Expression</b><br>
<b>Meaning</b><br>
<b>Inverse ("not")</b><br>
\p{<i>category</i>}<br>
Matches a character in a specified category (see<br>
\P<br>
Table 26-6)<br>
.<br>
(Default mode) Matches any character except<br>
\n<br>
\n<br>
.<br>
(SingleLine mode) Matches any character<br>
\n<br>
<i>Table 26-4. Character categories</i><br>
<b>Quantifier</b><br>
<b>Meaning</b><br>
\p{L}<br>
Letters<br>
\p{Lu}<br>
Uppercase letters<br>
\p{Ll}<br>
Lowercase letters<br>
\p{N}<br>
Numbers<br>
\p{P}<br>
Punctuation<br>
\p{M}<br>
Diacritic marks<br>
\p{S}<br>
Symbols<br>
\p{Z}<br>
Separators<br>
\p{C}<br>
Control characters<br>
<i>Table 26-5. Quantifiers</i><br>
<b>Quantifier</b><br>
<b>Meaning</b><br>
*<br>
Zero or more matches<br>
+<br>
One or more matches<br>
?<br>
Zero or one match<br>
{<i>n</i>}<br>
Exactly <i>n</i> matches<br>
{<i>n</i>,}<br>
At least <i>n</i> matches<br>
{<i>n,m</i>}<br>
Between <i>n</i> and <i>m</i> matches<br>
The ? suffix can be applied to any of the quantifiers to make them <i>lazy</i> rather than<br><i>greedy</i>.<br>
<i>Table 26-6. Substitutions</i><br>
<b>Expression</b><br>
<b>Meaning</b><br>
$0<br>
Substitutes the matched text<br>
<b>RegEx</b><br>
$<i>group-number</i><br>
Substitutes an indexed <i>group-number</i> within the matched text<br>
${<i>group-name</i>}<br>
Substitutes a text <i>group-name</i> within the matched text<br>
Substitutions are specified only within a replacement pattern.<br>
<b>Regular Expressions Language Reference | 993</b><br>
<hr>
<A name=1014></a><i>Table 26-7. Zero-width assertions</i><br>
<b>Expression</b><br>
<b>Meaning</b><br>
^<br>
Start of string (or line in multiline mode)<br>
$<br>
End of string (or line in multiline mode)<br>
\A<br>
Start of string (ignores multiline mode)<br>
\z<br>
End of string (ignores multiline mode)<br>
\Z<br>
End of line or string<br>
\G<br>
Where search started<br>
\b<br>
On a word boundary<br>
\B<br>
Not on a word boundary<br>
(?=<i>expr</i>)<br>
Continue matching only if expression <i>expr</i> matches on right (positive lookahead)<br>
(?!<i>expr</i>)<br>
Continue matching only if expression <i>expr</i> doesn't match on right (negative lookahead)<br>
(?&lt;=<i>expr</i>)<br>
Continue matching only if expression <i>expr</i> matches on left (positive lookbehind)<br>
(?&lt;!<i>expr</i>)<br>
Continue matching only if expression <i>expr</i> doesn't match on left (negative lookbehind)<br>
(?&gt;<i>expr</i>)<br>
Subexpression <i>expr</i> is matched once and not backtracked<br>
<i>Table 26-8. Grouping constructs</i><br>
<b>Syntax</b><br>
<b>Meaning</b><br>
(<i>expr</i>)<br>
Capture matched expression <i>expr</i> into indexed group<br>
(?<i>number</i>)<br>
Capture matched substring into a specified group <i>number</i><br>
(?'<i>name</i>')<br>
Capture matched substring into group <i>name</i><br>
(?'<i>name1-name2</i>')<br>
Undefine <i>name2</i>, and store interval and current group into <i>name1</i>; if <i>name2</i> is undefined,<br>
matching backtracks; <i>name1</i> is optional<br>
(?:<i>expr</i>)<br>
Noncapturing group<br>
<i>Table 26-9. Back references</i><br>
<b>Parameter syntax</b><br>
<b>Meaning</b><br>
\<i>index</i><br>
Reference a previously captured group by <i>index</i><br>
\k&lt;<i>name</i>&gt;<br>
Reference a previously captured group by <i>name</i><br>
<i>Table 26-10. Alternation</i><br>
<b>Expression syntax</b><br>
<b>Meaning</b><br>
|<br>
Logical OR<br>
(?(<i>expr</i>)<i>yes</i>|<i>no</i>)<br>
Matches <i>yes</i> if expression matches; otherwise, matches <i>no</i> (<i>no</i> is optional)<br>
(?(<i>name</i>)<i>yes</i>|<i>no</i>)<br>
Matches <i>yes</i> if named group has a match; otherwise, matches <i>no</i> (<i>no</i> is optional)<br>
<b>994 | Chapter 26:</b><b>Regular Expressions</b><br>
<hr>
<A name=1015></a><i>Table 26-11. Miscellaneous constructs</i><br>
<b>Expression syntax</b><br>
<b>Meaning</b><br>
(?#<i>comment</i>)<br>
Inline comment<br>
#<i>comment</i><br>
Comment to end of line (works only in IgnorePatternWhitespace mode)<br>
<i>Table 26-12. Regular expression options</i><br>
<b>Option</b><br>
<b>Meaning</b><br>
(?i)<br>
Case-insensitive match ("ignore" case)<br>
(?m)<br>
Multiline mode; changes ^ and $ so that they match beginning and end of any line<br>
(?n)<br>
Captures only explicitly named or numbered groups<br>
(?c)<br>
Compiles to IL<br>
(?s)<br>
Single-line mode; changes meaning of "." so that it matches every character<br>
(?x)<br>
Eliminates unescaped whitespace from the pattern<br>
(?r)<br>
Searches from right to left; can't be specified midstream<br>
<b>RegEx</b><br>
<b>Regular Expressions Language Reference | 995</b><br>
<hr>
<A name=1016></a><hr>
<A name=1017></a><b>A</b><br>
<b>C# Keywords</b><br>
abstract<br>
A class modifier that specifies a class cannot be instantiated and the full imple-<br>mentation will be provided by a subclass.<br>A method modifier that specifies a method is implicitly virtual and without an<br>implementation.<br>
add<br>
An event accessor for customizing the subscription to an event.<br>
alias<br>
Suffixes an extern directive.<br>
as<br>
A  binary  operator  that  performs  a  reference  conversion,  evaluating  to  null<br>(rather than throwing an exception) if the conversion fails.<br>
ascending<br>
A query syntax operator used in conjunction with orderby.<br>
base<br>
Accesses a base-class implementation of a member.<br>Calls the base class's constructor from a subclass's constructor.<br>
bool<br>
A logical data type that can be true or false.<br>
break<br>
A jump statement that exits a loop or switch statement block.<br>
by<br>
A query syntax operator used in conjunction with group.<br>
byte<br>
A 1-byte, unsigned integral data type.<br>
case<br>
A selection statement that defines a particular choice in a switch statement.<br>
<b>997</b><br>
<hr>
<A name=1018></a>catch<br>
A keyword for the clause in a try statement to catch exceptions of a specific type.<br>
char<br>
A 2-byte, Unicode character data type.<br>
checked<br>
A statement or operator that enforces arithmetic bounds checking on an ex-<br>pression or statement block.<br>
class<br>
A type declaration keyword for a custom reference type; typically used as a<br>blueprint for creating objects.<br>A generic type parameter constraint, indicating the generic type must be a ref-<br>erence type.<br>
const<br>
A modifier for a local variable or field declaration whose value is statically eval-<br>uated and immutable.<br>
continue<br>
A jump statement that forgoes the remaining statements in a loop and continues<br>to the next iteration.<br>
decimal<br>
A 16-byte floating point data type that can precisely represent real numbers<br>with a base-10 fractional component.<br>
default<br>
A  special  label  in  a  switch  statement  specifying  the  action  to  take  when  no<br>case statements match the switch expression.<br>An operator that returns the default value for a type, typically used in conjunc-<br>tion with generic type parameters.<br>
delegate<br>
A type declaration keyword for a type that defines a protocol for a method.<br>A keyword to indicate an anonymous method.<br>
descending<br>
A query syntax operator used in conjunction with orderby.<br>
do<br>
A loop statement whose statement block repeats until the while expression at<br>the end of the loop evaluates to false.<br>
double<br>
An 8-byte, floating-point data type.<br>
dynamic<br>
A dynamically typed variable.<br>
else<br>
A conditional statement that defines the action to take when a preceding if<br>expression evaluates to false.<br>
<b>998 | Appendix:</b><b>C# Keywords</b><br>
<hr>
<A name=1019></a>enum<br>
A type declaration keyword that defines a value type representing a group of<br>named numeric constants.<br>
equals<br>
A query syntax operator that performs an equi-join, used in conjunction with<br>join.<br>
event<br>
Defines an event member within a type. The event keyword is followed by a<br>delegate type; code outside the containing type can only perform  += and -=<br>operations on the event.<br>
explicit<br>
An operator that defines a custom explicit conversion.<br>
extern<br>
A method modifier that indicates that the method is implemented with un-<br>managed code.<br>A directive that declares a reference to an external namespace, which must cor-<br>respond to an argument passed to the C# compiler.<br>
false<br>
A literal of the bool type.<br>
finally<br>
The keyword in the clause of a try statement that executes whenever control<br>leaves the scope of the try block.<br>
fixed<br>
A statement to pin down a reference type object so the garbage collector won't<br>move it during pointer arithmetic operations.<br>A field modifier within an unsafe struct to declare a fixed length array.<br>
float<br>
A 4-byte floating-point data type.<br>
for<br>
A loop statement that combines an initialization statement, continuation con-<br>dition, and iterative statement into one statement.<br>
foreach<br>
A loop statement that iterates over collections that implement IEnumerable or<br>IEnumerable&lt;T&gt;.<br>
from<br>
A query syntax operator that specifies the sequence from which to query.<br>
get<br>
Identifies the accessor that returns the value of a property.<br>
global<br>
A keyword placed in front of an identifier to indicate the identifier is qualified<br>with the global namespace.<br>
<b>C# Keywords</b><br>
<b>C# Keywords | 999</b><br>
<hr>
<A name=1020></a>goto<br>
A jump statement that jumps to a label within the same method and same scope<br>as the jump point.<br>
group<br>
A query syntax operator that splits a sequence into groups given a key value to<br>group by.<br>
if<br>
A conditional statement that executes its statement block if its expression eval-<br>uates to true.<br>
implicit<br>
An operator that defines a custom implicit conversion.<br>
in<br>
The operator between a type and enumerated sequence in a foreach statement.<br>A query syntax operator used in conjunction with from.<br>A type parameter modifier indicating contravariance.<br>
int<br>
A 4-byte signed integral data type.<br>
interface<br>
A type declaration keyword for a custom reference type that defines a contract<br>for a type comprising a set of implicitly abstract members.<br>
internal<br>
An access modifier that indicates that a type or type member is accessible only<br>to other types in the same assembly.<br>
into<br>
A query syntax operator that signals either continuation or group-join.<br>
is<br>
A relational operator that evaluates to true if the left operand's type matches,<br>is derived from, implements, or can be unboxed to, the type specified by the<br>right operand.<br>
join<br>
A query syntax operator that performs an equi-join. This is used in local queries<br>to perform efficient keyed lookup-based joins.<br>
let<br>
A query syntax operator that introduces a new variable into each element in a<br>sequence.<br>
lock<br>
A statement that acquires an exclusive lock on a reference-type object to syn-<br>chronize multiple threads.<br>
long<br>
An 8-byte signed integral data type.<br>
namespace<br>
A keyword for defining a name that encloses a set of types in a hierarchical name.<br>
<b>1000 | Appendix:</b><b>C# Keywords</b><br>
<hr>
<A name=1021></a>new<br>
An operator that calls a constructor on a type, allocating a new object on the<br>heap (for reference types) or initializing it (for value types).<br>A type member modifier that hides an inherited member with a new member<br>with the same signature.<br>A generic type parameter constraint, indicating that the type must have a pa-<br>rameterless constructor.<br>
null<br>
A reference-type literal meaning no object is referenced.<br>
object<br>
A predefined type that is the ultimate base class for all types.<br>
on<br>
A query syntax operator used in conjunction with join or group.<br>
operator<br>
A modifier used to declare custom operator overloads.<br>
orderby<br>
A query syntax operator to sort a sequence.<br>
out<br>
A parameter and argument modifier that specifies that the variable is passed by<br>reference and must be assigned by the method being called.<br>A type parameter modifier indicating covariance.<br>
override<br>
A method modifier that indicates that a method overrides a virtual method in<br>a base class.<br>
params<br>
A parameter modifier that specifies that the last parameter of a method may<br>accept multiple parameters of the same type.<br>
partial<br>
A class or method modifier that indicates the definition of the class or method<br>is split (typically across files).<br>
private<br>
An access modifier that indicates that only the containing type can access the<br>member.<br>
protected<br>
An access modifier that indicates that only the containing type or derived types<br>can access the member.<br>
public<br>
An access modifier that indicates that a type or type member is accessible to all<br>other types.<br>
readonly<br>
A field modifier specifying that a field can be assigned only in its declaration or<br>its containing type's constructor.<br>
<b>C# Keywords</b><br>
<b>C# Keywords | 1001</b><br>
<hr>
<A name=1022></a>ref<br>
A parameter and argument modifier that specifies that the variable is passed by<br>reference and is assigned before being passed to the method.<br>
remove<br>
An event accessor for customizing the unsubscription to an event.<br>
return<br>
A jump statement that that exits a method, specifying a return value when the<br>method is not void.<br>
sbyte<br>
A 1-byte, signed integral data type.<br>
sealed<br>
A class modifier that indicates a class cannot be subclassed, or that an overrid-<br>den member cannot be overridden again in subclasses.<br>
select<br>
A  query  syntax  operator  used  to  project  (transform)  each  element  in  the<br>sequence.<br>
set<br>
Identifies the accessor that sets a property's value.<br>
short<br>
A 2-byte signed integral data type.<br>
sizeof<br>
An operator for use in unsafe code blocks that returns the size in bytes of a struct.<br>
stackalloc<br>
An operator that allocates memory on the stack.<br>
static<br>
A type member modifier that indicates that the member applies to the type<br>rather than to an instance of the type.<br>A class modifier indicating the class is comprised of only static members and<br>cannot be instantiated.<br>
string<br>
A predefined reference type that represents an immutable sequence of Unicode<br>characters.<br>
struct<br>
A type declaration keyword for a custom value type. Structs are used instead of<br>classes where value-type semantics are desired.<br>A generic type parameter constraint, indicating the generic type must be a value<br>type.<br>
switch<br>
A selection statement that allows a selection of choices to be made based on the<br>value of a predefined type.<br>
this<br>
A variable that references the current instance of a class or struct.<br>
<b>1002 | Appendix:</b><b>C# Keywords</b><br>
<hr>
<A name=1023></a>A keyword that allows one constructor to call another.<br>A parameter modifier for the first parameter in a static method, making the<br>method an extension method.<br>
throw<br>
Throws an exception when an abnormal condition has occurred.<br>
true<br>
A literal of the bool type.<br>
try<br>
A  statement  that  defines  a  statement  block  where  errors  can  be  caught  and<br>handled (via a catch block), and/or cleanup code can run via a finally block.<br>
typeof<br>
An operator that returns the type of an object as a System.Type object.<br>
uint<br>
A 4-byte unsigned integral data type.<br>
ulong<br>
An 8-byte unsigned integral data type.<br>
unchecked<br>
A  statement  or  operator  that  prevents  arithmetic  bounds  checking  on  an<br>expression.<br>
unsafe<br>
A type modifier, member modifier, or statement that permits executing code<br>that is not verifiable by the CLR (notably, that uses pointers).<br>
ushort<br>
A 2-byte unsigned integral data type.<br>
using<br>
A directive that specifies that types in a particular namespace can be referred to<br>without requiring their fully qualified type names.<br>A statement that ensures an object implementing IDisposable is disposed of at<br>the end of the statement's scope.<br>
value<br>
A special identifier that denotes the implicit variable assigned in the set accessor<br>of a property.<br>
var<br>
An implicitly typed local variable declaration.<br>
virtual<br>
A class method modifier that indicates that a method can be overridden by a<br>derived class.<br>
void<br>
A keyword used in place of a type for methods that don't have a return value.<br>
<b>C# Keywords</b><br>
<b>C# Keywords | 1003</b><br>
<hr>
<A name=1024></a>volatile<br>
A field modifier instructing the compiler and CLR to enforce load-acquire and<br>store-release  semantics  when  reading  or  writing  the  field  in  multithreaded<br>scenarios.<br>
where<br>
A query syntax operator used to filter each element in a sequence with a bool<br>expression.<br>
while<br>
A loop statement to iterate a statement block while an expression at the start<br>of each iteration evaluates to true.<br>
yield<br>
A statement that yields the next element from an iterator block.<br>
<b>1004 | Appendix:</b><b>C# Keywords</b><br>
<hr>
<A name=1025></a><b>Index</b><br>
<b>Symbols</b><br>
$ (dollar sign) regex end of string anchor,<br>
984<br>
#define directive, 175<br>
// (double forward slash), 7, 12<br>
#else directive, 175<br>
== (equality operator), 28, 150, 245, 247<br>
#end directive, 175<br>
Equals method compared to, 250<br>
#endif directive, 175<br>
overriding, 253<br>
#error directive, 175<br>
string comparisons with, 199<br>
#if directive, 175<br>
string equality comparisons, 200<br>
#line directive, 175<br>
= (equals sign), 12<br>
#region directive, 175<br>
!= (inequality operator), 28, 245, 247<br>
#undef directive, 175<br>
- (minus) operator, 117<br>
#warning directive, 175<br>
/*...*/ (multiline comment), 12<br>
( ) (parentheses)<br>
* (multiplication) operator, 9<br>
regex named groups, 987<br>
! (not operator), 500<br>
8- and 16-bit integral types, 25<br>
?? (null coalescing) operator, 152<br>
&lt; (less-than) operator<br>
|| (or operator), 29, 500<br>
order comparison, 28, 255, 257<br>
( ) (parentheses), 12<br>
overloading, 155<br>
regex alternator, 978<br>
use with nullable types, 151<br>
regex lookahead and lookbehind, 983<br>
&lt;&lt; (shift left) operator, 25<br>
. (period), 12<br>
&gt; (greater-than) operator<br>
regex character matching, 981<br>
order comparison, 28, 255, 257<br>
+ (plus) operator, 31, 117<br>
overloading, 155<br>
-&gt; (pointer-to-member) operator, 172<br>
use with nullable types, 151<br>
# (preprocessor directives), 499<br>
&gt;&gt; (shift right) operator, 25<br>
? (question mark)<br>
&amp; (address of) operator, 171<br>
in nullable type, 149<br>
&amp;&amp; (and) operator, 29<br>
regex quantifier, 977<br>
* (dereference operator), 171<br>
; (semicolon, 7, 12<br>
@ (at symbol), 11<br>
' (single quotes), 30<br>
\ (backslash), 31<br>
[ ] (square brackets)<br>
escaping in regex, 980<br>
arrays, 32<br>
` (backtick) and generic type names, 684<br>
attributes, 172<br>
{} (braces), 12, 51<br>
in regular expressions, 978, 981<br>
^ (caret)<br>
indexers, 71<br>
regex character set negator, 981<br>
-= (subtract from self) operator, 117<br>
regex start of string anchor, 984<br>
~ (tilde)<br>
? (conditional) operator, 29<br>
finalizers, 74<br>
/// (documentation comment), 176<br>
| (vertical bar)<br>
regex alternator, 978<br>
We'd like to hear your suggestions for improving our indexes. Send email to <i>index@oreilly.com</i>.<br>
<b>1005</b><br>
<hr>
<A name=1026></a>with enums, 98<br>
isolating types and assemblies, 954­<br>
with nullable types, 151<br>
956<br>
slots, using, 951<br>
<b>A</b><br>
DoCallBack method, 948<br>monitoring, 949<br>
aborting threads, 856<br>
threads and, 950<br>
abstract classes and abstract members, 80<br>
application manifests, 774<br>
access modifiers, 90­91<br>
ApplicationBase property, 945<br>
accessibility capping, 91<br>
APTCA, 759<br>
examples, 90<br>
ArgumentException, 140<br>
friend assemblies, 91<br>
ArgumentNullException, 139, 140<br>
restrictions on, 91<br>
ArgumentOutOfRange exception, 141<br>
ACLs (Access Control Lists), 773<br>
arguments, 8, 38<br>
Action delegate, 120<br>
arithmetic operators, 23<br>
Activator.CreateInstance method, 685<br>
Array class, 273­282<br>
add keyword, 124<br>
construction and indexing, 276<br>
AddBeforeSelf, AddAfterSelf, Remove,<br>
copying, converting and resizing, 281<br>
and ReplaceWith methods, 427<br>
enumeration, 277<br>
address of (&amp;) operator, 171<br>
length and rank queries, 278<br>
administrative elevation, 773<br>
reversing array elements, 281<br>
virtualization and, 774<br>
search methods, 278<br>
ADO.NET, 189<br>
sorting methods, 280<br>
Aes class, 780<br>
Array.ForEach method, 277<br>
Aggregate query operator, 408<br>
ArrayList class, 283, 284<br>
AggregateException class, 912<br>
arrays, 32­35, 273­282<br>
Flatten and Handle methods, 913<br>
array elements, 36<br>
aggregation query operators, 319<br>
array intialization expressions, 32<br>
All query operator, 411<br>
simplified initialization<br>
[AllowPartiallyTrustedCallers] (see<br>
expressions, 34<br>
APTCA)<br>
bounds checking, 35<br>
anchors (regex), 984<br>
covariance, 111<br>
and (&amp;&amp;) operator, 29<br>
default element initialization, 32<br>
anonymous methods, 134<br>
value types versus reference types,<br>
anonymous pipes, 550<br>
33<br>
anonymous types, 160­161, 338<br>
jagged arrays, 34<br>
var keyword and, 160<br>
multidimensional arrays, 33<br>
Any query operator, 411<br>
rectangular arrays, 33<br>
APM (asynchronous programming<br>
as reference types, 275<br>
model), 927<br>
stackalloc keyword, using on, 172<br>
AppDomain class, 948<br>
as operator, 79<br>
AppDomainSetup class, 945<br>
ASCII, 203<br>
Append method, 202<br>
AsEnumerable query operator, 345, 404<br>
AppendLine method, 202<br>
asnychronous methods<br>
application domains, 943­956<br>
asynchronous method pattern, 927<br>
architecture, 943<br>
AsParallel method, 877<br>
creating and destroying, 945­946<br>
AsQueryable query operator, 362, 404<br>
data sharing between domains, 951­<br>
AsReadOnly method, 282<br>
956<br>
assemblies, 9, 647­651<br>
intra-process remoting, 952<br>
<b>1006 | Index</b><br>
<hr>
<A name=1027></a>Assembly class, 651<br>
attribute classes, 169<br>
assembly manifest, 648<br>
attribute parameters, 169<br>
assembly names, 655­657<br>
AttributeUsage, 703<br>
AssemblyName class, 656<br>
bit-mapped attributes, 701<br>
fully qualified names, 655<br>
defining your own, 703<br>
informational and file versions,<br>
emitting, 722<br>
657<br>
pseudocustom attributes, 702<br>
assembly resolution, 671­673<br>
retrieving at runtime, 705<br>
AssemblyResolve event, 672<br>
retrieving in reflection-only context,<br>
assembly signing, 652­655<br>
706<br>
Authenticode (see Authenticode)<br>
specification of multiple attributes,<br>
delay signing, 654<br>
170<br>
cultures and subcultures, 670<br>
attributes (LINQ to XML)<br>
deploying outside base folders, 675<br>
attribute navigation, 425<br>
loading, 673­675<br>
in namespaces, 436<br>
from a filename, 674<br>
updating, 426<br>
modules, 650<br>
Attributes (XmlDocument), 464<br>
resources, 663­669<br>
attributes (XmlReader), reading, 454<br>
direct embedding, 664<br>
AttributeTargets enum, members, 703<br>
.resource files, 666<br>
authentication (networking), 588<br>
satellite assemblies, 669­670<br>
Authenticode, 657­661<br>
single-file executables, 676­678<br>
signature verification, 660<br>
strong naming, 653<br>
signing with, 659<br>
assembly isolation, 574<br>
.NET 3.5 and earlier issues, 661<br>
assembly qualified name, 682<br>
signtool utility, 660<br>
AssemblyFileVersion attribute, 657<br>
time stamping, 660<br>
AssemblyInformationalVersion attribute,<br>
validation, 660<br>
657<br>
automatic properties, 70<br>
Assert method (debug), 503<br>
AutoResetEvent, 833<br>
assertions (code contracts), 506<br>
Average query operator, 408<br>
assertions (debug), 503<br>assignment, 12<br>
<b>B</b><br>
assignment expressions, 45<br>assignment operators<br>
background threads, 796<br>
overloading, 154<br>
BackgroundWorker class, 852<br>
asymmetric cryptography, 784<br>
backslash (\), 31<br>
asynchronous delegates, 930<br>
escaping in regex, 980<br>
asynchronous methods, 927<br>
backtick (`) and generic type names, 684<br>
versus asynchronous delegates, 930<br>
banker's rounding, 233<br>
IAsyncResult interface, 929<br>
Barrier class, 849<br>
tasks and (TPL), 934<br>
base 64 conversions, 233<br>
at (@) symbol, 11<br>
base class constraint, 106<br>
atomicity (threading), 812, 831<br>
base keyword, 82<br>
atomicity pattern, 141<br>
Basic Multiclingual Plane (BMP), 205<br>
attributes, 414<br>
bclasses<br>
custom attributes, 702<br>
writing a class versus an interface, 96<br>
targets, 170<br>
big endian and little endian encoding,<br>
attributes (C#), 169­170, 701­706<br>
204<br>
BigInteger struct, 238<br>
<b>Index | 1007</b><br>
<hr>
<A name=1028></a>binary numbers (converting), 233<br>
call sites (dynamic binding), 736<br>
binary serializers, 611, 628­637<br>
callbacks from unmanaged code, 961<br>
ISerializable interface, 634­637<br>
cancellation tokens, 859<br>
subclassing serializable classes, 636<br>
captured variables, 132<br>
serialization attributes, 630­633<br>
captured variables in LINQ queries, 325<br>
[NonSerialized], 630<br>
caret (^)<br>
[OnDeserializing] and<br>
regex character set negator, 981<br>
[OnDeserialized], 631<br>
regex start of string anchor, 984<br>
[OnSerializing] and [OnSerialized],<br>
CAS (code access security), 752, 755­758<br>
632<br>
case keyword, 52<br>
[OptionalField] and versioning,<br>
Cast query operator, 402<br>
632<br>
casting, 16, 78<br>
BinaryReader, 557<br>
(see also conversions)<br>
BinaryWriter, 557<br>
catch blocks, 134<br>
binding, 161, 162<br>
ccrewrite.exe, 509<br>
(see also dynamic binding)<br>
CCW (COM Callable Wrapper), 976<br>
BitArray, 288<br>
certificates (Authenticode)<br>
BitConverter class, 235<br>
authenticode signing, 657<br>
bitwise operators, 25<br>
ChangeItemKey method, 301<br>
combined enum values, 98<br>
char, 30, 193­195<br>
blocking, 807, 928<br>
char literals, 30<br>
BlockingCollection&lt;T&gt;, 917<br>
char type, 30<br>
BMP (Basic Multilingual Plane), 205<br>
character conversions, 30<br>
boolean type, 20, 28­29<br>
static methods for categorizing<br>
conditional operators, 29<br>
characters, 194<br>
conversions, 28<br>
character escapes (regex), 980, 992<br>
equality and comparison operators, 28<br>
character sets, 203<br>
bounds checking (arrays), 35<br>
character sets (regular expressions), 981<br>
boxing, 85<br>
checked operator, 24<br>
interfaces and, 96<br>
child tasks (TPL), 901<br>
nullable values, boxing and unboxing,<br>
chunk partitioning (TPL), 888<br>
149<br>
class constraint, 107<br>
boxing conversions, 16<br>
classes, 1, 9, 63­76<br>
braces ({}), 12, 51<br>
abstract classes, 80<br>
break statement, 55<br>
access modifiers, 90­91<br>
BufferedStream class, 551<br>
examples, 90<br>
built-in types<br>
friend assemblies, 91<br>
predefined type taxonomy, 20<br>
constants, 72<br>
byte integral type, 25<br>
fields, 63<br>finalizers, 74<br>
<b>C</b><br>
generics (see generics)<br>indexers, 71<br>
&lt;c&gt; documentation tag, 177<br>
inheritance (see inheritance)<br>
C union (simulating), 962<br>
instance constructors, 65<br>
C# compiler (csc.exe), 10<br>
interfaces, contrasted with (see<br>
C++ templates, contrasted with generics,<br>
interfaces)<br>
113<br>
methods, 64<br>
calculated properties, 70<br>
object initializers, 67<br>
Calendar class, 209<br>
<b>1008 | Index</b><br>
<hr>
<A name=1029></a>object type, 85­88<br>
overridden methods and, 514<br>
partial classes, 75<br>
selective enforcement, 521­523<br>
properties, 69<br>
call-site checking, 522<br>
static classes, 74<br>
release builds, 522<br>
static constructors, 73<br>
static contract checking, 523­524<br>
structs, compared to (see structs)<br>
baselines, 524<br>
this reference, 68<br>
ContractVerification attribute, 524<br>
Close method, 477<br>
SuppressMessage attribute, 524<br>
closed generic types, 102<br>
&lt;code&gt; documentation tag, 178<br>
closures, 132<br>
code points (Unicode), 203<br>
CLR (Common Language Runtime), 3,<br>
CodeAccessPermission, 752<br>
183­187<br>
collection initializers, 144<br>
versions, 181<br>
Collection&lt;T&gt; class, 298<br>
code access security (see CAS)<br>
collections, 263<br>
code contracts, 506­510<br>
Array class (see Array class)<br>
assertions, 517<br>
customizable collections, 298­303<br>
Contract.Assert, 517<br>
dictionaries, 292­297<br>
Contract.Assume, 517<br>
sorted dictionaries, 296<br>
binary rewriter, 509<br>
enumeration, 263­270<br>
compilation, 508<br>
ICollection and IList interface, 271<br>
contract failure<br>
IEnumerable interface, 271<br>
Contract.ContractFailed event,<br>
IList interface, 271<br>
520<br>
lists, queues, stacks, and sets, 282­<br>
ContractException, 520<br>
291<br>
exceptions with contract<br>
BitArray, 288<br>
conditions, 521<br>
lists, 283­287<br>
contract failures, 519­521<br>
queues, 287<br>
contracts runtime class, 509<br>
sets, 289<br>
function purity, 510<br>
stacks, 288<br>
on interfaces and abstract methods,<br>
plug-in protocols, 304­310<br>
518<br>
comparers, 304­310<br>
object variants, 517<br>
IStructuralEquatable and<br>
postconditions, 514­517<br>
IStructuralComparable,<br>
Contract.Ensures, 514<br>
310<br>
Contract.EnsuresOnThrow&lt;TExce<br>
StringComparer class, 308<br>
ption&gt;, 515<br>
proxies, 303<br>
Contract.OldValue&lt;T&gt;, 516<br>
read-only collections, 303<br>
Contract.Result&lt;T&gt; and<br>
CollectionsBase class, 300<br>
ContractValueAtReturn&lt;<br>
collisions (hashing), 779<br>
T&gt;, 516<br>
COM (Component Object Model), 969<br>
overridden methods and, 516<br>
C# objects, exposing to, 976<br>
preconditions, 510­514<br>
calling COM components from C#,<br>
content of preconditions, 511<br>
971­974<br>
Contract.EndContractBlock<br>
dynamic binding, 973<br>
method, 513<br>
implicit ref parameters, 973<br>
Contract.Requires, 510<br>
indexers, 973<br>
Contract.Requires&lt;TException&gt;,<br>
optional parameters and named<br>
512<br>
arguments, 972<br>
<b>Index | 1009</b><br>
<hr>
<A name=1030></a>COM type system, 970<br>
constants, 13, 72<br>
IUnknown and IDispatch, 970<br>
ConstrainedCopy method, 282<br>
COM interop assemblies, 971<br>
ConstructorInfo, 685<br>
COM interop types, 971<br>
constructors, 9, 15, 65<br>
embedding, 975<br>
emitting, 721<br>
type equivalence, 975<br>
calling base constructors, 722<br>
COM interoperability, 5, 969­971<br>
inheritance and, 83<br>
command-line applications, input and<br>
modifiers allowed by, 65<br>
output, 258<br>
nonpublic constructors, 66<br>
comments, 7, 12<br>
overloading, 66<br>
documentation comments, 176<br>
static constructors, 73<br>
Common Language Runtime (see CLR)<br>
Contains method (string), 196<br>
CompareOrdinal method, 199<br>
Contains query operator, 411<br>
Comparer class, 307<br>
ContainsKey method, 293<br>
comparers, 307<br>
contextual keywords, 11<br>
CompareTo method, 199, 201<br>
continue statement, 55<br>
comparison operators, 28<br>
ContinueWith method, 904<br>
overloading, 155<br>
contravariance, 112, 122<br>
compilation, 9<br>
delegate method parameters, 122<br>
warnings, 175<br>
delegate type parameters, 123<br>
Complex struct, 239<br>
interfaces, 111<br>
Component Object Model (see COM)<br>
conversions, 16<br>
composite format strings, 198<br>
8- and 16- bit integrals, 26<br>
composite formatting, 222<br>
base 2, 8, and 16 conversions, 233<br>
compound assignment operators, 45<br>
base 64 conversions, 233<br>
Compressed file attribute, 561<br>
BitConverter, 235<br>
compression, 571­573<br>
boxing conversions, 86<br>
compressing in memory, 572<br>
char conversions, 30<br>
ComputeHash method, 778<br>
Convert class, 232<br>
Concat method, 198<br>
custom conversions, 155<br>
Concat query operator, 400<br>
dynamic conversions, 165<br>
conceptual model (Entity Framework),<br>
enum conversions, 97<br>
349<br>
formatting and parsing, 212<br>
concurrent collections, 914­920<br>
generic type parameter conversions,<br>
BlockingCollection&lt;T&gt;, 917<br>
108<br>
leveraging TaskCompletionSource,<br>
implicit versus explicit conversions,<br>
918<br>
16<br>
ConcurrentBag&lt;T&gt;, 916<br>
nullable conversions, 149<br>
IProducerConsumerCollection&lt;T&gt;,<br>
numeric conversions, 23<br>
915<br>
numeric rounding conversions, 232<br>
conditional compilation, 499­502<br>
reference conversions, 78<br>
Conditional attribute, 501<br>
rounding conversions, 232<br>
alternatives to, 502<br>
type converters, 234<br>
static variable flags, versus, 500<br>
XmlConvert, 234<br>
conditional operator (?), 29<br>
Convert class, 232­257<br>
conditional operators<br>
base 64 conversions, 233<br>
overloading, 154<br>
dynamic conversions, 233<br>
Console class, 258<br>
<b>1010 | Index</b><br>
<hr>
<A name=1031></a>parsing numbers in base 2, 8, and 16,<br>
CustomAttributeData type, 706<br>
233<br>
rounding real to integral conversions,<br>
<b>D</b><br>
232<br>
ConvertAll method, 282<br>
data contract serializers, 611, 613­622<br>
ConvertTime method, 215<br>
collections and, 622­625<br>
ConvertTimeFromUtc and<br>
collection and element names,<br>
ConvertTimeToUtc methods,<br>
customizing, 624<br>
216<br>
subclassed collection elements,<br>
cookies, 594<br>
624<br>
Copy and CopyTo methods (arrays), 282<br>
DataContractSerializer versus<br>
correlated subqueries (LINQ), 377<br>
NetDataContractSerializer,<br>
Count query operator, 407<br>
613<br>
CountDownEvent, 837<br>
IXmlSerializable, interoperating with,<br>
covariance, 109, 123<br>
628<br>
arrays, 111<br>
member ordering, 621<br>
delegate return types, 123<br>
null and empty values, 622<br>
delegate type parameters, 123<br>
object references, 618­620<br>
interfaces, 111<br>
preserving object references, 619<br>
CreateInstance method, 686<br>
[Serializable], interoperating with, 627<br>
CreateInstanceAndUnwrap method, 954<br>
serialization and deserialization hooks,<br>
CreateInstanceFromAndUnwrap method,<br>
625­628<br>
954<br>
serializing subclasses, 617­618<br>
cref attribute (XML documentation), 179<br>
version tolerance, 620<br>
cryptographically strong random number<br>
data parallelism, 874<br>
generators, 240<br>
Data Protection API, 777<br>
cryptography, 751, 776<br>
DataContext class, 350­354<br>
hashing, 778<br>
disposing, 352<br>
public key encryption, 784<br>
object tracking, 352<br>
digital signing, 787<br>
DataContractSerializer, 613<br>
RSA class, 786<br>
DataLoadOptions class, 356­358<br>
symmetric encryption, 780<br>
dates and times, 206­213, 214<br>
chaining encryption streams, 782<br>
(see also time zones)<br>
encrypting in memory, 781<br>
DateTime and DateTimeOffset, 207­<br>
encryption objects, disposing, 784<br>
213<br>
key management, 784<br>
choosing between, 208<br>
Windows Data Protection, 777<br>
constructing a DateTime, 209<br>
CryptoStream, 780, 782<br>
constructing a DateTimeOffset,<br>
csc.exe, 10<br>
210<br>
culture testing, 236<br>
current DateTime or<br>
culture-sensitive comparisons, 199<br>
DateTimeOffset, 211<br>
CultureInfo, 221<br>
format providers, 220<br>
CultureInfo object, 202<br>
format strings for, 229<br>
CultureInfo.CurrentCulture format<br>
formatting and parsing, 212<br>
provider, 221<br>
null values, 213<br>
custom attributes, 702<br>
parsing and misparsing, 230<br>
custom numeric format strings, 226<br>
DateTimeStyles, 231<br>
CustomAttributeBuilder, 722<br>
daylight saving time and DateTime,<br>
218<br>
<b>Index | 1011</b><br>
<hr>
<A name=1032></a>time zones, 213­218<br>
Descendant and DescendantNodes<br>
TimeSpan, 206<br>
methods, 423<br>
DateTimeFormatInfo, 222<br>
diagnostics, 499­506<br>
daylight saving time and DateTime, 218<br>
dictionaries, 292­297<br>
deadlocks, 813<br>
dictionary classes, 292<br>
Debug class, 502­506<br>
sorted dictionaries, 296<br>
Fail and Assert methods, 503<br>
dictionary attacks, 779<br>
Listeners property, 504<br>
Dictionary&lt;TKey,TValue&gt;, 294<br>
flushing and closing Listeners, 505<br>
DictionaryBase class, 302<br>
Debugger class, 525<br>
digital signing, 787<br>
debuggers, 524­525<br>
(see also strong-name-signing;<br>
attributes, 525<br>
Authenticode)<br>
decimal numeric conversions, 23<br>
Directory class, 563<br>
decimal numeric type<br>
directory operations (see file and directory<br>
versus double type, 27<br>
operations)<br>
decimal type<br>
DirectoryInfo class, 563<br>
suffix, 22<br>
disassemblers, writing, 729­733<br>
declaration statements, 48<br>
disposal, 475­480<br>
declarative security, 755<br>
(see also garbage collection)<br>
decorator sequences, 327<br>
automatic garbage collection, 480<br>
decrement operator, 24<br>
clearing fields, 480<br>
deep cloning (LINQ to XML, 420<br>
Close method, 477<br>
default keyword, 38<br>
Dispose method, 475<br>
generics, usage with, 105<br>
finalizers, 482­487<br>
DefaultEmpty query operator, 406<br>
IDisposable interface, 475<br>
deferred execution (LINQ), 324<br>
not disposing, scenarios for, 477<br>
DefineType method (Reflection.Emit),<br>
opt-in disposal, 478<br>
715<br>
Distinct query operator, 375<br>
definite assignment, 37<br>
DLR (Dynamic Language Runtime), 186,<br>
DeflateStream class, 571<br>
735<br>
delay signing, 654<br>
Dns class, 602<br>
delegates, 115­123<br>
do-while loops, 53<br>
delegate compatibility, 121­123<br>
DoCallBack method, 948<br>
generic parameter variance, 123<br>
document object model (DOM), 414<br>
parameter compatibility, 122<br>
documentation comments (///), 176<br>
return type compatibility, 123<br>
dollar sign ($) regex end of string anchor,<br>
delegate type and delegate instance,<br>
984<br>
115<br>
DOM (document object model), 414<br>
Func and Action delegates, 120<br>
double forward slash (//), 7, 12<br>
generic delegate types, 119<br>
double numeric type, 26<br>
instance method assignment, 118<br>
financial calculations and, 27<br>
interfaces, versus, 120<br>
versus decimal type, 27<br>
lambda expressions (see lambca<br>
double type<br>
expressions)<br>
suffix, 22<br>
multicast delegates, 117­118<br>
downcasting, 78<br>
plug-in methods with, 116<br>
DriveInfo class, 567<br>
Demand method, 753<br>
dynamic binding, 5, 161­169, 693<br>
dereference (*) operator, 171<br>
custom binding, 162<br>
<b>1012 | Index</b><br>
<hr>
<A name=1033></a>dynamic calls without dynamic<br>
dynamic objects, implementing, 744­<br>
receivers, 166<br>
747<br>
dynamic conversions, 165<br>
ExpandoObject class, 747<br>
dynamic expressions, 166<br>
dynamic programming patterns, 735<br>
language binding, 163<br>
numeric type unification, 737<br>
runtime representation of dynamic<br>
DynamicMethod class, 707<br>
types, 164<br>
arguments, passing to, 709<br>
RuntimeBinderException, 164<br>
DynamicObject class, 744<br>
static binding, versus, 161<br>static types in dynamic expressions,<br>
<b>E</b><br>
167<br>
uncallable functions, 168<br>
eager loading, 357<br>
var type versus dynamic type, 165<br>
in EF, 358<br>
dynamic code generation, 707­714<br>
EAP (event-based asynchronous pattern),<br>
awkward emission types, 725<br>
851<br>
branching, 711<br>
EDM (Entity Data Model), 349<br>
DynamicMethod class, IL generation<br>
.edmx files, 349<br>
with, 707<br>
EF (Entity Framework), 340, 346­360<br>
emitting generic methods and types,<br>
associations, 354<br>
723<br>
DataLoadOptions, 356­358<br>
evaluation stack, 708<br>
deferred execution, 355<br>
exception handling, 713<br>
entity classes, 348<br>
instance methods, calling, 712<br>
inheritance strategies, 349<br>
instantiating objects, 712<br>
L2S, versus, 347<br>
local variables, generating, 710<br>
ObjectContext, 350<br>
pass-by-reference methods, 718<br>
Element method (LINQ to XML), 423<br>
passing arguments to dynamic<br>
element query operators, 319<br>
methods, 709<br>
ElementAt query operator, 406<br>
dynamic code generation, emitting type<br>
Elements method (LINQ to XML), 422<br>
members, 717<br>
elevation of privilege attack, 759<br>
dynamic instantiation, 685<br>
else clause, 50<br>
dynamic keyword, 161<br>
Empty query operator, 412<br>
Dynamic Language Runtime (see DLR)<br>
empty strings, 195<br>
dynamic member overload resolution,<br>
Encoding class, 204<br>
738­744<br>
static properties, 204<br>
generic type members, calling<br>
Encrypted file attribute, 561<br>
anonymously, 742­744<br>
encryption (see cryptography)<br>
Visitor pattern, 738­741<br>
encryption and hashing in .NET, 776<br>
variations, 740<br>
EndReverseEcho method, 938<br>
dynamic programming, 735<br>
EndsWith method, 196<br>
DLR (see DLR)<br>
entity connection string, 350<br>
dyanamic objects, implementing<br>
Entity Data Model (see EDM)<br>
DynamicObject class, 744<br>
Entity Framework, 190 (see EF)<br>
dynamic languages, interoperating<br>
Entity SQL (ESQL), 350<br>
with, 747­749<br>
EntityRef type, 355<br>
dynamic member overload resolution<br>
EntityReferenceType, 355<br>
(see dynamic member<br>
EntitySet class, 354<br>
overload resolution)<br>
enum format strings, 231<br>enumeration, 143­148, 263­270<br>
<b>Index | 1013</b><br>
<hr>
<A name=1034></a>Array class, 277<br>
equality (==) operator, compared to,<br>
enumerators, 143<br>
250<br>
IEnumerable and IEnumerator<br>
overriding, 253<br>
interfaces, 264<br>
IEquatable&lt;T&gt; interface,<br>
IEnumerable&lt;T&gt; and<br>
implementation, 254<br>
IEnumerator&lt;T&gt;, 265<br>
error (!) XML type prefix, 179<br>
implementation of enumeration<br>
Escape and Unescape methods, 980<br>
interfaces, 266<br>
escape sequences, 30<br>
iterators, 145­148<br>
characters and strings, 30<br>
enumeration pattern, 143<br>
regular expressions, 980<br>
enums, 97­100, 240­243<br>
URIs, 584<br>
conversions, 241<br>
ESQL (Entity SQL), 350<br>
integral conversions, 241<br>
evaluation stack (Reflectioin.Emit), 708<br>
integral to enum conversions, 242<br>
event accessors<br>
string conversions, 242<br>
explicit accessors, 129<br>
enum conversions, 97<br>
event wait handles, 832­840<br>
enum operators, 99<br>
AutoResetEvent, 833<br>
enumerating enum values, 243<br>
CountdownEvent, 837<br>
flags enums, 98<br>
cross-process EventWaitHandle, 838<br>
semantics and typing, 243<br>
disposing, 834<br>
type-safety issues, 99<br>
EventWaitHandle class, 833<br>
Environment class, 260<br>
ManualResetEvent, 836<br>
Environment.SpecialFolder enum, 566<br>
thread pools and, 838<br>
Epsilon (float and double), 26<br>
two-way signaling, 835<br>
equality (==) operator, 245, 247<br>
WaitAny, WaitAll, and<br>
Equals method, compared to, 250<br>
SignalAndWait, 839<br>
overriding, 253<br>
alternatives to WaitAll and<br>
string comparisons with, 199<br>
SignalAndWait, 840<br>
string equality comparisons, 200<br>
event-based asynchronous pattern (EAP),<br>
equality comparison, 199, 245­255<br>
851<br>
custom types and, 251­255<br>
EventHandler, 128<br>
IEquatable&lt;T&gt; interface, 250<br>
events, 9, 124­130<br>
pluggable equality comparers, 255<br>
add and remove keywords, 124<br>
standard equality protocols, 247­250<br>
event accessors, 129<br>
static object.Equals method, 248<br>
event handlers and memory leaks, 491<br>
static ReferenceEquals method, 249<br>
event keyword, 124<br>
strings, 199<br>
event modifiers, 130<br>
value versus referential equality, 246<br>
EventArgs class, 125<br>
virtual Object.Equals method, 247<br>
EventHandler delegate, 126<br>
equality operators, 28, 150<br>
standard event pattern, 125<br>
overloading, 155<br>
Windows event logs, 528­530<br>
EqualityComparer, 304<br>
&lt;example&gt; documentation tag, 177<br>
EqualityComparer class, 305<br>
Except query operator, 401<br>
EqualityComparer&lt;T&gt;.Default method,<br>
&lt;exception&gt; documentation tag, 177<br>
306<br>
exceptions, 134­143<br>
equals (=) sign, 12<br>
alternatives to, 143<br>
Equals method<br>
atomicity pattern, 141<br>catch clause, 136<br>
<b>1014 | Index</b><br>
<hr>
<A name=1035></a>common patterns, 141<br>
special folders, 566<br>
common types, 140<br>
volume information, querying, 567<br>
finally block, 137<br>
File class, 560­562<br>
rethrowing exceptions, 139<br>
compression and encryption attributes,<br>
System.Exception key properties, 140<br>
561<br>
throwing exceptions, 139<br>
file security, 562<br>
TryXXX method pattern, 141<br>
File.Encrypt, 776, 777<br>
ExceptWith method (sets), 291<br>
FileInfo class, 563<br>
ExecuteAssembly method, 948<br>
filenames, manipulating with Path class,<br>
Exists method (arrays), 280<br>
564<br>
(see also any query operator)<br>
FileStream class, 543<br>
ExpandoObject class, 747<br>
advanced features, 546<br>
explicit conversions, 23<br>
constructing, 543<br>
explicit conversions, overloading, 155<br>
filemode, specifying, 545<br>
Expression class, 363<br>
filename, specifying, 544<br>
expression statements, 49<br>
FileSystemWatcher class, 567<br>
expression trees, 363­366<br>
finalizers, 74, 482­487<br>
compiling, 362<br>
finally block, 137<br>
lambda expressions and, 130<br>
using statement, 138<br>
expressions, 44­46<br>
finally blocks, 134<br>
Expresso utility, 977<br>
FindAll method, 279<br>
Extensible Stylesheet Language<br>
FindSystemTimeZoneById method, 215<br>
Transformations (see XSLT)<br>
First query operator, 405<br>
extension methods, 157­159<br>
fixed keyword, 173<br>
ambiguity and resolution, 158<br>
fixed statement, 171<br>
dynamic binding and, 168<br>
fixed-size buffers, 173<br>
interfaces, application to, 159<br>
Flags attribute, 98<br>
value in LINQ queries, 314<br>
flags enums, 98<br>
extern modifier, 73<br>
Flatten method (TPL), 913<br>float numeric type, 26<br>
<b>F</b><br>
financial calculations and, 27<br>
float type<br>
Fail method, 503<br>
suffix, 22<br>
false operator, overloading, 156<br>
floating-point conversions, 23<br>
FieldOffset attribute, 962<br>
fluent query syntax, 313­319<br>
fields, 63<br>
for loops, 53<br>
constants, 72<br>
foreach loops, 54<br>
initialization of, 66<br>
foreach statement<br>
modifiers allowed by, 64<br>
enumerators and, 145<br>
readonly modifier, 64<br>
foreground threads, 796<br>
file and directory operations, 559­568<br>
Format method, 198<br>
compression, 571<br>
format providers, 220<br>
Directory class, 563<br>
CultureInfo and, 221<br>
File class (see File class)<br>
default providers, 221<br>
FileInfo and DirectoryInfo classes, 563<br>
IFormatProvider and<br>
filesystem events, catching, 567<br>
ICustomFormatter, 223<br>
memory-mapped files (see memory-<br>
parsing with, 223<br>
mapped files)<br>
FormatException, 220<br>
Path class, 564<br>
<b>Index | 1015</b><br>
<hr>
<A name=1036></a>formatting, 219­225<br>
covariance and, 109<br>
composite formatting, 222<br>
arrays, 111<br>
custom numeric format strings, 226<br>
generic classes, 110<br>
DateTime and DateTimeOffset, 212<br>
interfaces, 111<br>
DateTime/DateTimeOffset format<br>
default values, 105<br>
strings, 229<br>
emitting, 724<br>
DateTimeFormatInfo, 222<br>
generic methods, 103<br>
enum format strings, 231<br>
generic types, 102<br>
format providers (see format providers)<br>
inheritance, compared to, 101<br>
NumberFormatInfo, 222<br>
reflection (generic members), 692<br>
standard format strings, 225<br>
reflection (generic type names), 684<br>
numeric format strings, 225<br>
reflection (invoking), 498, 694<br>
ToString method, 220<br>
reflection (obtaining generic types),<br>
type converters, 234<br>
682, 687<br>
FormatTransitionTime method, 217<br>
self-referencing generic declarations,<br>
friend assemblies, 91<br>
108<br>
from keyword, 320<br>
static data, 108<br>
FromAsync method, 934<br>
subclassing generic types, 107<br>
FTP, 600<br>
type parameters and conversions, 108<br>
command set, 600<br>
typeof operator and unbound generic<br>
full memory barriers (full fences), 826<br>
types, 105<br>
Func delegate, 120<br>
get/set blocks, 69<br>
Func delegates in LINQ, 317<br>
(see also properties)<br>
function members, 14<br>
access levels, 70<br>
functional purity (PLINQ), 884<br>
GetAdjustmentRules method, 216<br>GetAmbiguousTimeOffsets method, 216<br>
<b>G</b><br>
GetArrayRank, 683<br>GetCustomAttributes method, 705<br>
GAC, 661­663<br>
GetData and SetData, 864<br>
garbage collection, 475, 480­482<br>
GetDaylightChanges method, 215<br>
(see also disposal)<br>
GetEncodings method, 204<br>
forcing garbage collection, 490<br>
GetFolderPath method, 566<br>
memory pressure, 491<br>
GetGenericTypeDefinition method, 687<br>
optimization, 488­490<br>
GetHashCode method, 252<br>
roots and, 482<br>
overriding, 252<br>
GC.Collect, 487<br>
Area struct example, 254<br>
GC.ReRegisterForFinalize, 486<br>
GetHostAddresses method, 602<br>
GC.SuppressFinalize, 485<br>
GetHostEntry method, 602<br>
generic delegate types, 119<br>
GetKeyForItem method, 301<br>
generic methods<br>
GetLength and GetLongLength methods,<br>
defining, 103<br>
278<br>
emitting, 723­724<br>
GetLowerBound and GetUpperBound<br>
generic types, emitting, 724<br>
methods, 278<br>
GenericPrincipal and GenericIdentity<br>
GetManifestResourceStream, 665<br>
classes, 776<br>
GetMembers method, 688<br>
generics, 101­114<br>
GetNestedTypes, 683<br>
C++ templates, contrasted with, 113<br>
GetString method, 205<br>
constraints, 106<br>
GetType method, 87<br>
contravariance, 112<br>
<b>1016 | Index</b><br>
<hr>
<A name=1037></a>GetUnicodeCategory method, 195<br>
versus Equals method, 256<br>
GetUtcOffset method, 214, 215<br>
IComparable interfaces, 255<br>
GetValue method, 276<br>
implementation, 257<br>
Global Assembly Cache (see GAC)<br>
IComparer interface, 307<br>
globalization, 235<br>
identifiers, 10<br>
checklist, 236<br>
IDictionary interface, 293<br>
testing, 236<br>
IDictionary&lt;TKey,TValue&gt;, 293<br>
goto statement, 55<br>
IDispatch interface, 971<br>
greater-than (&gt;) operator<br>
IDisposable interface, 266, 475­480<br>
order comparison, 28, 255, 257<br>
IDMOP (IDynamicMetaObjectProvider),<br>
greedy quantifiers (regex)<br>
162<br>
greedy versus lazy quantifiers, 982<br>
IDynamicMetaObjectProvider, 162 (see<br>
groups (regex), 985<br>
IDMOP)<br>
Guid struct, 245<br>
IEnumerable interface, 143, 264<br>
GZipStream class, 571<br>
IEnumerable&lt;T&gt;, 265<br>
IDisposable and, 266<br>
<b>H</b><br>
LINQ, querying with (see LINQ)<br>
IEnumerator interface, 143, 264<br>
hash partitioning (PLINQ), 887<br>
IEnumerator&lt;T&gt;, 266<br>
HashAlgorithm class, 778<br>
IEqualityComparer, 255<br>
hashing (cryptography), 776, 778<br>
IEqualityComparer interface, 304<br>
HashSet&lt;T&gt;, 289<br>
IEqualityComparer&lt;T&gt;, 304<br>
Hashtable class, 292<br>
IEquatable&lt;T&gt;, 254<br>
hashtables, 252<br>
IEquatable&lt;T&gt; interface, 250<br>
heap, 36<br>
if statement, 50<br>
hexadecimal (converting), 233<br>
IFormatProvider and ICustomFormatter,<br>
Hexadecimal, specifying literals, 21<br>
223<br>
HideBySig, 719<br>
IFormatProvider interface, 221<br>
hiding inherited members, 81<br>
IFormattable, 220<br>
hiding interface members, 93<br>
IIdentity, 776<br>
HTTP, 580, 592<br>
IL (Intermediate Language), 3<br>
cookies, 594<br>
DynamicMethod class, generating<br>
form data, uploading, 593<br>
with, 707<br>
forms, authentication, 595<br>
evaluation stack, 708<br>
headers, 592<br>
parsing, 728­733<br>
HttpListener class, writing servers<br>
disassemblers, writing, 729­733<br>
with, 597­600<br>
ILGenerator class, 713<br>
query strings, 593<br>
IList and IList&lt;T&gt; interfaces, 283<br>
SSL, 596<br>
IList&lt;T&gt; and IList interfaces, 273<br>
HybridDictionary, 296<br>
immutable objects, 823<br>imperative security, 755<br>
<b>I</b><br>
implicit conversions, 23<br>
I/O (input/output) types, 537<br>
implicit conversions, overloading, 155<br>
IAsyncResult interface, 929<br>
implicit parameterless constructors, 66<br>
ICollection interface, 271<br>
&lt;include&gt; documentation tag, 178<br>
ICollection&lt;T&gt; and ICollection<br>
increment operator, 24<br>
interfaces, 272<br>
indexed filtering, 373<br>
IComparable interface, 256<br>
indexers, 71<br>
<b>Index | 1017</b><br>
<hr>
<A name=1038></a>IndexOf method, 196, 279<br>
internationalization, 235<br>
IndexOfAny method, 196<br>
Internet addressing protocols, 581<br>
inequality (!=) operator, 245, 247<br>
interpreted queries, 339<br>
Infinity (float and double), 26<br>
AsEnumerable query operator, 345<br>
inheritance, 76­84<br>
deferred execution model, 342<br>
abstract classes and members, 80<br>
Intersect query operator, 401<br>
base keyword, 82<br>
IntersectsWith method, 291<br>
casting and reference conversions, 78<br>
into keyword, 335<br>
constructors and, 83<br>
InvalidOperationException, 141<br>
generics, compared to, 101<br>
invariant culture, 199, 222<br>
inherited members, hiding, 81<br>
IPAddress class, 581<br>
overloading and resolution, 84<br>
IPEndPoint class, 582<br>
polymorphism, 77<br>
IPermission interface, 753<br>
sealing functions and classes, 82<br>
IPrincipal, 776<br>
virtual function members, 79<br>
IProducerConsumerCollection&lt;T&gt;, 915<br>
inherited members, hiding, 81<br>
IPv4 and IPv6, 581<br>
initialization vectors, 781<br>
IQueryable&lt;T&gt;, 339<br>
InnerException, 140<br>
IronPython, interoperation with, 747<br>
InnerXml property, 465<br>
passing state between C# and scripts,<br>
Insert method, 197<br>
748<br>
instance constructors, 65<br>
is operator, 79<br>
instance members, 15<br>
IsAmbiguousTime method, 216<br>
instruction atomicity, 813<br>
IsAssignableFrom, 685<br>
integral division, 24<br>
IsCapitalized extension method, 157<br>
integral overflow, 24<br>
IsDaylightSavingTime method, 214<br>
integral overflow check operators, 24<br>
ISerializable interface, 634­637<br>
integral to integral numeric conversions,<br>
IsInstanceOfType, 685<br>
23<br>
IsInvalidTime method, 216<br>
integral types, 21<br>
IsNullOrEmpty method, 196<br>
interface generic constraint, 106<br>
isolated storage, 573­578<br>
interfaces, 92­97<br>
enumeration, 577<br>
boxing and, 96<br>
IsolatedStorageFile, 575<br>
delegates, versus, 120<br>
isolation types, 574<br>
dynamic binding and, 168<br>
reading and writing, 575<br>
enumeration interfaces, 263­270<br>
store location, 576<br>
explicit implementation, 93<br>
IStructuralEquatable and<br>
extending, 93<br>
IStructuralComparable, 310<br>
implementing members virtually, 94<br>
IsWhiteSpace method, 193<br>
using nongeneric interfaces, 270<br>
iteration statements, 53­54<br>
reimplementation as a subclass<br>
iterators, 145­148, 267<br>
alternatives to reimplementation,<br>
catch/try/finally blocks and, 147<br>
95<br>
enumerable versus enumerator<br>
reimplementation in a subclass, 94<br>
interfaces, 146<br>
writing a class versus an interface, 96<br>
enumerators and, 145<br>
Interlocked class, 830­832<br>
semantics, 146<br>
Interlocked.CompareExchange, 923<br>
sequences, composing, 147<br>
Intermediate Language (see IL)<br>
IUnknown interface, 971<br>
internal access modifier, 90<br>
IXmlSerializable interface, 612, 645­646<br>
<b>1018 | Index</b><br>
<hr>
<A name=1039></a><b>J</b><br>
LINQ (Language Integrated Query), 311­<br>
313<br>
jagged arrays, 34<br>
deferred execution, 324­330<br>
Join method, 198<br>
captured variables, 325<br>
joining (LINQ queries), 319<br>
execution of queries, 329<br>
<b>K</b><br>
explanation of, 327<br>
fluent syntax, 314­319<br>
KeyedCollection&lt;TKey,TItem&gt;, 300<br>
lambda expressions, 316<br>
KeyValuePair struct, 293<br>
natural ordering, 319<br>
keywords, 10<br>
IEnumerable&lt;T&gt;, implementation by,<br>
contextual keywords, 11<br>
311<br>
reference, 997­1004<br>
interpreted queries, 339­346<br>
AsEnumerable query operator, 345<br>
<b>L</b><br>
local queries, combining with, 343<br>
into keyword, 335<br>
L2S (LINQ to SQL), 340, 346­360<br>
L2S and EF, 346­360<br>
associations, 354<br>
API differences, 360<br>
DataContext, 350<br>
associations, 354­355<br>
DataLoadOptions, 356­358<br>
comparison, 347<br>
deferred execution, 355<br>
DataContext and ObjectContext,<br>
EF, versus, 347<br>
350­354<br>
entity classes, 347<br>
DataLoadOptions, 356­358<br>
label statement, 55<br>
deferred execution, 355<br>
lambda expressions, 130­133<br>
eager loading (EF), 358<br>
anonymous methods, contrasted with,<br>
entity classes, EF, 348<br>
134<br>
entity classes, L2S, 347<br>
as LINQ query arguments, 313<br>
updates, 358­360<br>
element typing and, 317<br>
PLINQ (see PLINQ)<br>
Func delegates and, 317<br>
progressive query building, 334<br>
in LINQ queries, 316­318<br>
projection, 337­339<br>
iteration variables, capturing, 133<br>
anonymous types, 338<br>
outer variables, capturing, 132<br>
let keyword, 338<br>
specification of parameter types, 131<br>
object initializers, 337<br>
as statement blocks, 131<br>
query expressions, 320­324<br>
Last query operator, 405<br>
building, 361­366<br>
LastIndexOf method, 196, 279<br>
mixed syntax expressions, 323<br>
LastIndexOfAny method, 196<br>
query syntax versus fluent syntax,<br>
lazy execution (LINQ), 324<br>
323<br>
lazy initialization (threads), 860­862<br>
query syntax versus SQL syntax,<br>
lazy quantifier (regex)<br>
322<br>
greedy versus lazy quantifiers, 982<br>
range variables, 322<br>
Lazy&lt;T&gt; class, 861<br>
query syntax, 320<br>
LazyInitializer class, 861<br>
subqueries, 322, 330­333<br>
left-associative operators, 46<br>
wrapping queries, 336<br>
less-than (&lt;) operator<br>
X-DOM (see X-DOM)<br>
order comparison, 28, 255, 257<br>
LINQ operators, 367­371<br>
let keyword, 338<br>
aggregation methods, 406­410<br>
link demands (security), 752<br>
Aggregate, 408<br>
LinkedList&lt;T&gt;, 285<br>
<b>Index | 1019</b><br>
<hr>
<A name=1040></a>Count and LongCount, 407<br>
ListDictionary class, 292<br>
Min and Max, 407<br>
Listeners property, 504<br>
Sum and Average, 408<br>
literals, 8, 12<br>
conversion methods, 402­404<br>
little endian and big endian encoding,<br>
AsEnumerable and AsQueryable,<br>
204<br>
404<br>
LoaderOptimization attribute, 948<br>
OfType and Cast, 402<br>
local queries, 339<br>
ToArray, ToList, ToDictionary, and<br>
local variable, 13<br>
ToLookup, 404<br>
localization, 235<br>
element query operators, 404­406<br>
lock statement, 808<br>
DefaultEmpty, 406<br>
locking, 808<br>
ElementAt, 406<br>
upgradeable locks, 867<br>
First, Last, and Single, 405<br>
lockTaken overloads, 810<br>
filtering methods, 371­375<br>
logical type (see boolean type)<br>
Distinct, 375<br>
long or ulong types<br>
indexed filtering, 373<br>
suffixes, 22<br>
Take and Skip, 374<br>
LongCount query operator, 407<br>
TakeWhile and SkipWhile, 375<br>
lookahead and lookbehind, 983<br>
Where, 372<br>
loop statements<br>
generation methods, 412<br>
iteration statements, 53<br>
Empty, 412<br>Range and Repeat, 412<br>
<b>M</b><br>
grouping methods, 397<br>Join and GroupJoin, 388­394<br>
Main method, 8<br>
joining, 387­394<br>
MakeArrayType, 683<br>
ordering methods, 394­400<br>
MakeGenericType method, 687<br>
projecting methods, 375­387<br>
managed code, 3<br>
indexed projection, 376<br>
manifests, application and assembly, 647<br>
Select, 376­379<br>
ManualResetEvent, 836<br>
SelectMany, 380­387<br>
Marshal class, 966<br>
subqueries and joins in L2S and Ef,<br>
MarshalByRefObject class, 952<br>
377<br>
MatchEvaluator delegate, 988<br>
quantifiers, 411<br>
Math class, 237<br>
All and SequenceEqual, 411<br>
Max query operator, 407<br>
Contains and Any, 411<br>
MD5, 779<br>
set operators, 400­401<br>
member metadata, retrieval, 690<br>
Concat and Union, 400<br>
member prefixes, XML types, 179<br>
Intersect and Except, 401<br>
MemberInfo, 690<br>
standard query operators, 369<br>
memory barriers, 826<br>
Zip operator, 401<br>
memory leaks, 491<br>
LINQ to SQL, 190<br>
diagnosis, 494<br>
LINQ to XML, 413<br>
managed memory leaks, 491­494<br>
LINQPad, 368<br>
timers, 493<br>
List class, 283<br>
tools for finding, 494<br>
list comprehensions, 320<br>
memory pressure, 491<br>
&lt;list&gt; documentation tag, 178<br>
memory-mapped files, 569­571, 963<br>
List&lt;T&gt;, 283<br>
MemoryStream<br>
ListDictionary, 296<br>
encryption with, 781<br>
MemoryStream class, 546, 572<br>
<b>1020 | Index</b><br>
<hr>
<A name=1041></a>metadata token, 701<br>
using directive, 57<br>
methods, 8­9, 64<br>
XML namespaces, 435<br>
anonymous methods, 134<br>
NaN (Not a Number), 26<br>
emitting, 718<br>
native interoperability, 957<br>
generating instance methods, 719<br>
negative lookahead, 984<br>
HideBySig, 719<br>
negative lookbehind, 984<br>
extension methods, 157<br>
nested locking, 813<br>
modifiers allowed by, 64<br>
nested types, 100<br>
overloading, 65<br>
reflecting, 683<br>
partial methods, 76<br>
type names, 684<br>
plug-in methods and delegates, 116<br>
.NET Framework versions, 181<br>
reflecting, 688<br>
NetDataContractSerializer, 613<br>
Min query operator, 407<br>
.NETFramework<br>
minus (-) operator, 117<br>
format strings and parsing flags, 225­<br>
mixed syntax queries, 323<br>
231<br>
modules, 650<br>
networking, 579­608<br>
reflection of assemblies and, 701<br>
addressing protocols and ports, 581<br>
Monitor.Enter and Monitor.Exit, 810<br>
DNS, 602<br>
lockTaken overloads, 810<br>
FTP, 600­602<br>
TryEnter method, 810<br>
HTTP servers, writing, 597­600<br>
MoveToContent method, 452<br>
HTTP-specific support, 592­596<br>
mscorlib.dll, 181, 183<br>
cookies, 594<br>
multicast delegates, 117­118<br>
form data, uploading, 593<br>
multidimensional arrays, 33<br>
forms, authentication of, 595<br>
multiline comments, 12<br>
query strings, 593<br>
multiple dispatch, 741<br>
SSL, 596<br>
multiplication operator (*), 9<br>
mail via SmtpClient class, 603<br>
multithreaded timers, 870<br>
mail, receiving via POP3, 606­608<br>
multithreading, 186<br>
networking acronyms, 580<br>
parallel programming (see parallel<br>
request/response architecture, 584­<br>
programming)<br>
592<br>
Mutex class, 815<br>
authentication, 588­590<br>concurrency, 590­591<br>
<b>N</b><br>
exception handling, 591­592<br>proxies, 587<br>
naked type constraint, 107<br>
WebRequest and WebResponse<br>
named arguments, 5, 43<br>
classes, 585­587<br>
named attribute parameters, 169<br>
TCP, 604­606<br>
named groups (regex), 986<br>
concurrency, 606<br>
named pipes, 548<br>
URIs, 582­584<br>
namespaces, 9, 56­62<br>
WebClient class, 584<br>
aliasing types and namespaces, 60<br>
new line sequence in Windows, 553<br>
extern aliases, 60<br>
new member modifier, 81<br>
name hiding, 58<br>
new operator, 14<br>
name scoping, 58<br>
NextMatch method, 978<br>
namespace alias qualifiers, 61<br>
nonblocking synchronization, 825­832<br>
nested using direcives, 59<br>
Interlocked class, 830­832<br>
repeated namespaces, 59<br>rules within namespaces, 58­59<br>
<b>Index | 1021</b><br>
<hr>
<A name=1042></a>memory barriers and volatility, 825­<br>
object type, 20, 85­88<br>
830<br>
boxing and unboxing, 86<br>
full memory barriers, 826<br>
GetType method and typeof operator,<br>
shared writable fields, 828<br>
87<br>
volatile keyword, 828<br>
object member listing, 88<br>
[NonSerialized] attribute, 630<br>
static and runtime type checking, 87<br>
NotImplementedException, 141<br>
ToString method, 88<br>
NotSupportedException, 141<br>
Object.Equals method, 247<br>
null coalescing (??) operator, 152<br>
ObjectContext, 350­354<br>
null keyword, 19<br>
disposing, 352<br>
null strings, 196<br>
object tracking, 352<br>
nullable types, 148­153<br>
ObjectDisposedException, 141<br>
alternatives to, 153<br>
OfType query operator, 402<br>
boxing and unboxing nullable values,<br>
opcodes<br>
149<br>
Add (add), 709<br>
implicit and explicit nullable<br>
Br, Brtrue, and Blt (branch), 711<br>
conversions, 149<br>
Call (call a method), 708<br>
operator lifting, 150<br>
Callvirt (virtual call), 712<br>
operators and, 150­152<br>
Div(divide), 709<br>
bool? with &amp; and |, 151<br>
EmitWriteLine, 707<br>
mixing nullable and non-nullable<br>
Ldarg_0 (push arg onto stack) , 709<br>
operators, 151<br>
Ldc_i4 (push 4-byte integer), 709<br>
scenarios, 152<br>
ldfld (load a field), 720<br>
NumberFormatInfo, 222<br>
Ldind (load indirectly), 719<br>
NumberStyles argument, 227<br>
Ldloc (load a local variable), 710<br>
numeric conversions, 16, 237<br>
Ldstr (load a string), 708<br>
numeric type unification, 737<br>
Mul (multiply), 711<br>
numeric types, 20, 21­28<br>
Newobj (new object), 712<br>
8- and 16-bit integrals, 25<br>
Pop (remove from stack), 710<br>
arithmetic operators, 23<br>
Ret (return), 707<br>
bitwise operators, 25<br>
stfld (store to a field), 721<br>
boolean type, 28­29<br>
Stind (store indirectly), 719<br>
double versus decimal types, 27<br>
Stloc (store a local variable), 710<br>
increment and decrement operators,<br>
Throw (throw exception), 713<br>
24<br>
open generic types, 102<br>
numeric conversions, 23<br>
operator functions, 154<br>
numeric literals, 21<br>
operator lifting, 150<br>
numeric suffixes, 22<br>
operator overloading, 153­156<br>
type inference, 22<br>
equality and comparison operators,<br>
real number rounding errors, 27<br>
155<br>
special float and double values, 26<br>
implicit and explicit conversions, 155<br>
specialized integral operations, 24<br>
operator functions, 154<br>true and false operators, 156<br>
<b>O</b><br>
operators, 12, 44­48<br>
arithmetic operators, 23<br>
object initializers, 67, 337<br>
bitwise operators, 25<br>
versus optional parameters, 68<br>
conditional operators, 29<br>
object invariant methods (code contracts),<br>
equality and comparison operators, 28<br>
517<br>
<b>1022 | Index</b><br>
<hr>
<A name=1043></a>increment and decrement operators,<br>
passing arguments by value, 39<br>
24<br>
passing by reference, implications, 41<br>
precedence and associativity, 46<br>
ref parameter modifier, 39<br>
table of operators, 46<br>
&lt;paramref&gt; documentation tag, 178<br>
optional parameters, 5, 42<br>
parentheses ( ), 12<br>
or (||) operator, 29<br>
regex alternator, 978<br>
order comparison, 199, 255­257<br>
regex lookahead and lookbehind, 983<br>
&lt; and &gt; operators, 257<br>
regex named groups, 987<br>
IComparable interfaces, 256<br>
Parse method, 210<br>
implementation, 257<br>
ParseExact method, 210<br>
OrderBy operator, 314<br>
parsing, 219<br>
OrderedDictionary class, 292, 295<br>
DateTime and DateTimeOffset, 212,<br>
ordinal comparisons, 199<br>
230<br>
out modifier, 40, 111<br>
DateTimeStyles and, 231<br>
outer variables, 132<br>
enum format strings, 231<br>
overflow checking, 25<br>
with format providers, 223<br>
overloading<br>
Parse method, 220<br>
inheritance, impact on method<br>
parsing and misparsing of DateTimes,<br>
overloading, 84<br>
230<br>
operator overloading, 153<br>
TryParse method, 220<br>
override keyword, 80<br>
type converters, 234<br>
partial classes, 75<br>
<b>P</b><br>
partial methods, 76<br>partially trusted callers, 758<br>
P/Invoke (Platform Invocation Services),<br>
passing by reference<br>
957<br>
ref modifier, 39<br>
PadRight and PadLeft, 197<br>
password hashing, 778<br>
&lt;para&gt;documentation tag, 178<br>
Path class, 559, 564<br>
Parallel class, 892­898<br>
PE (Portable Executable) file, 647<br>
Parallel.For and Parallel.ForEach, 893<br>
Peek method, 288<br>
breaking out of loops, 895<br>
performance counters, 530­535<br>
indexed Parallel.ForEach, 894<br>
creating counters, 533<br>
optimization with local values, 896<br>
enumeration of available counters,<br>
outer versus inner loops, 894<br>
531<br>
Parallel.Invoke, 892<br>
reading counter data, 532<br>
Parallel Framework (see PFX)<br>
writing performance data, 533<br>
Parallel LINQ (see PLINQ)<br>
period (.), 12<br>
parallel programming, 874, 876<br>
regex character matching, 981<br>
PFX (see PFX)<br>
&lt;permission&gt; documentation tag, 177<br>
parallel queries, 879<br>
permissions, 751­755<br>
&lt;param&gt; documentation tag, 177<br>
CodeAccessPermission and<br>
parameterless constructors, 66<br>
PrincipalPermission, 752<br>
parameters, 8, 38­44<br>
IPermission interface, 753<br>
named arguments, 43<br>
declarative versus imperative security,<br>
object initializers versus optional<br>
755<br>
parameters, 68<br>
PermissionSet, 754<br>
optional parameters, 42<br>
PFX (Parallel Framework), 874­877<br>
out modifier, 40<br>
PIA (Primary Interop Assembly), 975<br>
params modifier, 41<br>
<b>Index | 1023</b><br>
<hr>
<A name=1044></a>PipeStream class, 547<br>
PrivateBinPath property, 946<br>
anonymous pipes, 550<br>
Process class, 260, 525<br>
named pipes, 548<br>
processes, 525<br>
PLINQ (Parallel LINQ), 877­891<br>
running processes, examining, 526<br>
calls to blocking or I/O-intensive<br>
threads in, examining, 526<br>
functions, 884<br>
projection (LINQ), 315<br>
cancellation of queries, 886<br>
properties, 69, 70<br>
functional purity, 883<br>
protected access modifier, 90<br>
limitations, 880<br>
protected internal access modifier, 90<br>
occasions for use, 883<br>
ProtectedData class, 777<br>
optimization, 886­891<br>
proxy servers, 587<br>
custom aggregations, 889<br>
public access modifier, 90<br>
input-side, 887<br>
Public Key Encryption, 776<br>
ordering and, 880<br>
public key encryption<br>
parallel execution ballistics, 879<br>
digital signing, 787<br>
parallel spellchecker example, 881<br>
RSA class, 786<br>
partitioning strategies, 887<br>
public keyword, 16<br>
plug-ins, sandboxing, 769<br>
Push method, 288<br>
plus (+) operator, 31, 117<br>pointer-to-member (-&gt;) operator, 171,<br>
<b>Q</b><br>
172<br>
pointers, 3, 171<br>
quantifiers (LINQ), 319<br>
arrays and, 172<br>
quantifiers (regex), 977<br>
fixed-size buffers, 173<br>
queries, 312<br>
pointer operators, 171<br>
query expression syntax, 313<br>
to unmanaged code, 174<br>
query expressions, 320<br>
unsafe code and, 170­174<br>
building, 361­366<br>
void pointers, 173<br>
AsQueryable operator, 362<br>
polymorphism, 77<br>
delegates versus expression trees,<br>
Pop method, 288<br>
361<br>
POP3, 606<br>
expression trees, 363­366<br>
positional attribute parameters, 169<br>
expression trees, compiling, 362<br>
positive lookahead, 983<br>
query strings (HTTP), 593<br>
positive lookbehind, 984<br>
query syntax, 320<br>
pragma warning, 175<br>
versus SQL syntax, 322<br>
precedence of operators, 46<br>
question mark (?)<br>
predefined types, 13<br>
conditional operator, 29<br>
predefined type taxonomy, 20<br>
in nullable types, 149<br>
predicates in LINQ, 279, 316<br>
regex quantifier, 977<br>
prefixes (XML), 435, 439<br>
Queue class, 287<br>
preprocessor directives, 174­176, 499<br>
Queue&lt;T&gt;, 287<br>
pragma warning, 175<br>
QueueUserWork Item method, 802<br>
Primary Interop Assembly (PIA), 975<br>primitive types, 20<br>
<b>R</b><br>
PrincipalPermission, 752<br>
Random class, 239<br>
PrincipalPermission class, 775<br>
RandomNumberGenerator<br>
private access modifier, 90<br>
(cryptographically strong), 781<br>
private working set, 481<br>
range partitioning, 888<br>
<b>1024 | Index</b><br>
<hr>
<A name=1045></a>Range query operator, 412<br>
members, reflecting and invoking,<br>
range variables (LINQ), 320, 322<br>
688­699<br>
RCWs (Runtime-Callable Wrappers),<br>
C# members versus CLR members,<br>
971<br>
691<br>
read-only properties, 70<br>
delegates, 695<br>
Reader/Writer locks, 865­869<br>
dynamic invocation, 693<br>
readonly modifier, 64<br>
generic methods, 697<br>
ReadOnlyCollection&lt;T&gt;, 303<br>
generic type members, 692<br>
real number rounding, 27<br>
member types, 690<br>
real number types, 21<br>
members of generic interfaces, 697­<br>
rectangular arrays, 33<br>
699<br>
recursion, 36<br>
method parameters, 693­695<br>
ref modifier, 39<br>
nonpublic members, accessing,<br>
ref parameter modifier, 39<br>
696<br>
reference conversions, 16, 78<br>
Reflection.Emit object model, 716<br>
reference types, 17, 18<br>
types, reflecting and activating, 682­<br>
in arrays, 33<br>
688<br>
classes (see classes)<br>
base types and interfaces, 685<br>
nulls, 19<br>
generic types, 687<br>
predefined, 20<br>
instantiating types, 685<br>
ReferenceEquals method, 249<br>
obtaining types, 682<br>
references, 39<br>
type names, 683<br>
weak references, 494­498<br>
uncreated closed generics, 725<br>
caching and, 495<br>
RegEx method, 978<br>
events and, 496<br>
Regex.Match, 978<br>
referential equality, 246<br>
regular expressions, 977<br>
reflection, 681<br>
character categories, 993<br>
assemblies, reflecting, 700<br>
character escapes, 980<br>
assembly loading, reflection-only<br>
character sets, 981, 992<br>
context, 700<br>
compiled regular expressions, 978<br>
modules, 701<br>
cookbook recipes, 988­991<br>
circular dependencies, 726<br>
groups, 985<br>
dynamic code generation (see dynamic<br>
named groups, 986<br>
code generation)<br>
language reference, 992­995<br>
emitting assemblies and types, 714­<br>
options, 979<br>
717<br>
quantifiers, 982, 993<br>
Reflection.Emit object model, 716<br>
greedy versus lazy quantifiers, 982<br>
saving emitted assemblies, 715<br>
RegexOptions flags enum, 979<br>
emitting generic methods and types,<br>
replacing and splitting text, 987<br>
723­724<br>
MatchEvaluator delegate, 988<br>
emitting type members, 717­722<br>
Regex.Split method, 988<br>
attaching attributes, 722<br>
zero-width assertions, 983<br>
constructors, 721<br>
anchors, 984<br>
emitting methods, 718<br>
lookahead and lookbehind, 983<br>
fields and properties, 719<br>
word boundary assertions, 985<br>
methods, 718<br>
reimplementing an interface, 94<br>
IL, parsing, 728­733<br>
relational operators, 151<br>&lt;remarks&gt; documentation tag, 177<br>
<b>Index | 1025</b><br>
<hr>
<A name=1046></a>Remoting, 952<br>
operating system security, 772­775<br>
remove keyword, 124<br>
partially trusted callers, 758<br>
Remove method (string), 197<br>
APTCA and [SecurityTransparent],<br>
Repeat query operator, 412<br>
759<br>
Resize method (arrays), 282<br>
elevation of privilege attack, 759<br>
ResourceManager class, 667<br>
permissions (see permissions)<br>
resources, 663­669<br>
sandboxing plug-ins, 769<br>
direct embedding of, 664<br>
security transparency model, CLR 4.0,<br>
pack URI resources, creating in Visual<br>
761­772<br>
Studio, 668<br>
standard user account restrictions,<br>
.resource files, 666<br>
773<br>
reading, 667<br>
Windows Data Protection, 777<br>
resource localization, 669<br>
[SecurityTransparent], 759<br>
.resx files, 666<br>
&lt;see&gt; documentation tag, 178<br>
creating via command line, 667<br>
&lt;seealso&gt; documentation tag, 178<br>
resueection<br>
Select query operator, 314, 376<br>
GC.ReRegisterForFinalize, 486<br>
selection statements, 50­53<br>
rethrowing an exception, 139<br>
SelectMany query operator, 380­387<br>
&lt;return&gt; documentation tag, 177<br>
Semaphore class, 816<br>
return statement, 56<br>
semicolon (;), 7, 12<br>
Reverse query operator, 319<br>
SequenceEqual query operator, 411<br>
ReverseEcho class, 934<br>
sequences (LINQ), 311<br>
right-associative operators, 46<br>
[Serializable] attribute, 629<br>
Rijndael class, 780<br>
serialization, 609­613<br>
role-based security, 775<br>
(see also data contract serializers)<br>
roots for garbage collection, 482<br>
serialization engines, 610­612<br>
rounding errors, real numbers, 27<br>
binary serializers (see binary<br>
rounding numeric conversions, 232<br>
serializers)<br>
RSA class, 786<br>
IXmlSerializable interface (see<br>
RSACryptoServiceProvider class, 788<br>
IXmlSerializable<br>
Runtime-Callable Wrappers (RCWs),<br>
interface)<br>
971<br>
XmlSerializer (see XmlSerializer<br>
RuntimeBinderException, 164<br>
engine)<br>
SetCustomAttribute method, 722<br>
<b>S</b><br>
SetData and GetData, 864<br>SHA256, 779<br>
safe cancellation (threads), 857­860<br>
shared memory, 569, 963<br>
sandboxing, 751, 758<br>
shift left (&lt;&lt;) operator, 25<br>
sandboxing another assembly, 769<br>
shift right (&gt;&gt;) operator, 25<br>
satellite assemblies, 669­670<br>
short integral type, 25<br>
sbyte integral type, 25<br>
side-by-side execution, 663<br>
sealing functions and classes, 82<br>
SignalAndWait, WaitAny, and WaitAll,<br>
security, 751<br>
839<br>
CAS, 755­758<br>
signaling, 832<br>
cryptography (see cryptography)<br>
with event wait handles (see event wait<br>
declarative versus imperative security,<br>
handles)<br>
755<br>
with Wait and Pulse (see Wait and<br>
identity and role security, 775­776<br>
Pulse1)<br>
isolated storage (see isolated storage)<br>
<b>1026 | Index</b><br>
<hr>
<A name=1047></a>Silverlight, 188<br>
lock statement, 56<br>
Single query operator, 405<br>
return statement, 56<br>
single quotes ('), 30<br>
selection statements, 50­53<br>
single-line comments, 12<br>
switch statement, 52<br>
single-threaded timers, 871<br>
throw statement, 56<br>
sizeof operator, 47, 173<br>
try statement, 134­143<br>
Skip query operator, 319, 374<br>
using statement, 56<br>
SkipWhile query operator, 375<br>
while and do-while loops, 53<br>
SmtpClient class, 603<br>
yield break statement, 146<br>
sn (strong-name) utility, 653<br>
yield return statement, 147<br>
SortedDictionary&lt;TKey,TValue&gt;, 296<br>
static binding, 161, 693<br>
SortedList class, 292<br>
static classes, 74, 559<br>
SortedList&lt;K,V&gt; class, 292<br>
static constructors, 73<br>
SortedSet&lt;T&gt;, 289<br>
static contract checking, 523­524<br>
SpecialFolder enum, 566<br>
baselines, 524<br>
SpinLock struct, 920<br>
ContractVerification attribute, 524<br>
spinning, 808<br>
SuppressMessage attribute, 524<br>
SpinWait struct, 922­925<br>
static members, 15<br>
Split method, 197<br>
thread safety, 820<br>
square brackets ([ ])<br>
Stopwatch class, 535<br>
arrays, 9, 32<br>
stream adapters, 552­559<br>
attributes, 172<br>
binary adapters, 557<br>
in regular expressions, 978, 981<br>
closing and disposing, 558<br>
indexers, 71<br>
text adapters, 553­557<br>
SSL, 596<br>
Stream class, 537<br>
stack, 36, 85<br>
StreamReader, 554<br>
Stack class, 288<br>
streams, 537<br>
Stack&lt;T&gt;, 288<br>
adapters, 538<br>
stackalloc keyword, 172<br>
backing store streams, 538, 543<br>
StackTrace and StackFrame classes, 526­<br>
BufferedStream class, 551<br>
528<br>
closing and flushing, 542<br>
standard numeric format strings, 225<br>
compression, 571<br>
standard query operators, 311, 369<br>
decorator streams, 538<br>
StartsWith method, 196<br>
FileStream class, 543<br>
statement blocks, 8<br>
isolated storage (see isolated storage)<br>
statements, 7, 48­56<br>
MemoryStream class, 546<br>
break statement, 55<br>
PipeStream class, 547<br>
continue statement, 55<br>
reading and writing, 540<br>
declaration statements, 48<br>
seeking, 542<br>
expression statements, 49<br>
stream adapters (see stream adapters)<br>
fixed statement, 171<br>
stream architecture, 537<br>
for loops, 53<br>
thread safety, 543<br>
foreach loops, 54<br>
timeouts, 542<br>
foreach statement, 143<br>
StreamWriter, 554<br>
goto statement, 55<br>
string.IsNullOrEmpty method, 196<br>
if statement, 50<br>
StringComparer class, 308<br>
iteration statements, 53­54<br>
StringComparison enum, 200<br>
jump statements, 54­56<br>
StringInfo class<br>
<b>Index | 1027</b><br>
<hr>
<A name=1048></a>two-word characters and, 206<br>
switch statement, 52<br>
StringReader, 557<br>
symmetric encryption, 776, 780<br>
strings, 30­31, 195­203<br>
synchronization context scheduler, 909<br>
characters, accessing within strings,<br>
synchronization of threads, 805<br>
196<br>
syntax, 10­12<br>
comparing strings, 199­202<br>
comments, 12<br>
equality comparisons, 200<br>
identifiers and keywords, 10<br>
ordinal versus culture comparisons,<br>
literals, punctuators and operators, 12<br>
199<br>
System.Attribute class, 169<br>
constructing, 195<br>
System.Collections namespaces, 263<br>
escape sequences, 31<br>
System.Numerics.dll, 239<br>
Format method, 198<br>
System.Reflection.Emit namespace, 716<br>
formatting (see formatting)<br>
System.Security.Cryptography<br>
indexers, 196<br>
namespaces, 777<br>
manipulating, 197<br>
System.Threading.Timer, 870<br>
null and empty strings, 195<br>searching within, 196<br>
<b>T</b><br>
splitting and joining, 197<br>string comparisons<br>
Take query operator, 319, 374<br>
string order comparisons, 201<br>
TakeWhile query operator, 375<br>
StringBuilder class, 202<br>
Target property (System.Delegate class),<br>
releasing memory, 203<br>
118<br>
text encodings and unicode, 203­206<br>
Task class, 904<br>
StringWriter, 557<br>
Task Parallel Library (TPL), 800<br>
strong-name-signing, 652<br>
task parallelism, 874, 898­912<br>
StrongName object, 771<br>
task schedulers and UIs, 909<br>
struct generic constraint, 107<br>
TaskCompletionSource class, 911<br>
StructLayout attribute, 960<br>
TaskFactory, 910<br>
structs, 89, 310<br>
tasks (see tasks)<br>
construction semantics, 89<br>
tasks, 898<br>
Equals method, 251<br>
canceling, 903<br>
mapping to unmanaged memory, 965<br>
coninuations<br>
fixed and fixed {...}, 968<br>
conditional continuations, 907<br>
parameterless constructors and, 66<br>
continuations, 904­909<br>
simulating a C union, 962<br>
child tasks and, 906<br>
speeding up equality comparisons,<br>
exceptions and, 905<br>
251<br>
with multiple antecedents, 908<br>
structural equality, 246<br>
multiple continuations on one<br>
subqueries<br>
antecedent, 909<br>
deferred execution and, 332<br>
Task&lt;TResult&gt;, 905<br>
subqueries (LINQ), 330­333<br>
creating and starting, 899<br>
Substring method, 197<br>
child tasks, 901<br>
subtract from self (-=) operator, 117<br>
specifying state objects, 900<br>
suffixes for numeric literals, 22<br>
TaskCreationOptions, 900<br>
Sum query operator, 408<br>
exception-handling tasks, 902<br>
&lt;summary&gt; documentation tag, 177<br>
waiting on tasks, 901<br>
SurnameComparer example, 308<br>
TCP, 582, 604<br>
surrogate character pairs, 206<br>
TcpClient and TcpListener classes, 604<br>text encoding<br>
<b>1028 | Index</b><br>
<hr>
<A name=1049></a>byte arrays, encoding to, 205<br>
nonblocking synchronization (see<br>
UTF-16 and surrogate pairs, 205<br>
nonblocking<br>
text encodings, 203­206<br>
synchronization)<br>
Encoding class, 204<br>
passing data to threads, 793­795<br>
file and stream I/O, encoding for, 204<br>
Lambda expressions and captured<br>
text encodings and text encoders, 203<br>
variables, 794<br>
TextReader and TextWriter classes, 553<br>
preemption, 792<br>
this keyword (overloading constructors),<br>
priority, 797<br>
66<br>
Reader/Writer locks, 865­869<br>
this reference, 68<br>
reader/writer locks, 867<br>
thread safety, 817­825<br>
recursion, 868<br>
.NET Framework types and<br>
safe cancellation<br>
read-only thread safety, 820<br>
cancellation tokens, 859<br>
static methods, 820<br>
sharing data between threads, 795<br>
thread-safe objects, locking around,<br>
signaling, 832<br>
819<br>
Wait and Pulse (see Wait and Pulse)<br>
application servers, 821<br>
synchronization, 805­808<br>
immutable objects, 823<br>
blocking, 807<br>
.NET Framework types and, 818<br>
blocking versus spinning, 808<br>
rich clients and thread affinity, 822<br>
thread execution barriers, 849<br>
worker threads versus UI threads,<br>
thread pooling, 800­807<br>
823<br>
thread pools<br>
threading, 789­793<br>
asynchronous delegates, 803<br>
BackgroundWorker class, 852<br>
entry with TPL, 801<br>
Barrier class, 849<br>
entry without TPL, 802­805<br>
blocking, 792<br>
optimization, 805<br>
EAP, 851<br>
QueueUserWorkItem method, 802<br>
event wait handles (see event wait<br>
thread safety (see thread safety)<br>
handlies)<br>
thread-agnostic classes, 816<br>
exception handling, 798­800, 799<br>
thread-local storage, 862­865<br>
foreground and background threads,<br>
GetData and SetData, 864<br>
796<br>
ThreadLocal&lt;T&gt; class, 863<br>
lazy initialization, 860­862<br>
[ThreadStatic] attribute, 863<br>
Lazy&lt;T&gt; class, 861<br>
Thread.Sleep method, 792<br>
LazyInitializer class, 861<br>
timers, 869­872<br>
locking, 808­817<br>
multithreaded timers, 870<br>
deadlocks, 813­815<br>
single-threaded timers, 871<br>
Monitor.Enter and Monitor.Exit<br>
uses, 789<br>
(see Monitor.Enter and<br>
ThreadLocal&lt;T&gt;, 882<br>
Monitor.Exit)<br>
ThreadPool.RegisterWaitForSingleObject<br>
Mutex class, 815<br>
, 941<br>
nested locking, 813<br>
threads, 789<br>
performance, 815<br>
throw statement, 56<br>
Semaphore class, 816<br>
throwing exceptions, 139<br>
synchronization objects, choosing,<br>
tilde (~)<br>
811<br>
finalizers, 74<br>
when to lock, 811<br>
tilde (~),complement operator, 25<br>time zones<br>
<b>Index | 1029</b><br>
<hr>
<A name=1050></a>DateTime and, 213<br>
type discovery, 955<br>
DateTimeOffset and, 214<br>
type marshaling, 958­961<br>
TimeZone, 214<br>
type parameters and type arguments, 102<br>
TimeZone.CurrentTimeZone method,<br>
TypeConverter class, 234<br>
214<br>
typeof operator, 87, 105, 682<br>
TimeZoneInfo, 215­218<br>
types, 12­20<br>
timers, 869­872<br>
anonymous types, 160<br>
multithreaded timers, 870<br>
classes (see classes)<br>
single-threaded timers, 871<br>
constructors and instantiation, 14<br>
timers and memory leaks, 493<br>
custom types, 14<br>
TimeSpan, 206<br>
data members and function members,<br>
TimeZone, 214<br>
14<br>
TimeZoneInfo, 214<br>
delegates, 115­123<br>
ToArray query operator, 404<br>
enums, 97­100<br>
ToCharArray method, 195<br>
generic types, 102<br>
ToDictionary query operator, 404<br>
instance versus static members, 15<br>
ToList query operator, 404<br>
interfaces, 92­97<br>
ToLookup query opperator, 404<br>
nested types, 100<br>
ToLower method, 193, 197<br>
object type, 85­88<br>
ToShortDateString and<br>
predefined types, 13, 20<br>
ToLongDateString methods,<br>
structs, 89<br>
212<br>
type conversions, 16<br>
ToString method, 88<br>
type names, 683<br>
ToUpper and ToLower methods, 193<br>
value types versus reference types, 16­<br>
ToUpper method, 193, 197<br>
20, 19<br>
TPL (Task Parallel Library), 800<br>Trace class, 502­506<br>
<b>U</b><br>
Fail and Assert methods, 503<br>Listeners property, 504<br>
UAC (User Access Control), 773<br>
flushing and closing Listeners, 505<br>
UDP, 582, 604<br>
TraceListener, 504<br>
UI threads, 823<br>
TrimStart and TrimEnd, 197<br>
uint or ulong types<br>
true operator, overloading, 156<br>
suffixes, 22<br>
try statement, 134­143<br>
unary operators<br>
catch clause, 136<br>
overloading of, 153<br>
finally block, 137<br>
unbound generic types, 105<br>
throwing exceptions, 139<br>
unboxing, 85<br>
TryEnter method, 810<br>
nullable values, boxing and unboxing,<br>
TryGetValue method, 293<br>
149<br>
TryParse method, 220<br>
uncallable functions, 168<br>
tuples, 244<br>
unchecked operator, 25<br>
comparing, 244<br>
Unicode, 203<br>
type conversions<br>
Union query operator, 400<br>
Convert class (see Convert class)<br>
UnionWith method, 291<br>
dynamic type conversion, 165<br>
unsafe keyword, 171<br>
XmlConvert class (see XmlConvert<br>
(see also native interoperability)<br>
class)<br>
upcasting, 78<br>
type converters, 234<br>
URIs, 582­584<br>
Uri class, 582<br>
<b>1030 | Index</b><br>
<hr>
<A name=1051></a>ushort integral type, 25<br>
WaitAny, WaitAll, and SignalAndWait,<br>
using directive, 57<br>
839<br>
contrasted with using statement, 56<br>
Warnings, compiler<br>
nested using directives, 59<br>
pragma warning, 175<br>
using statement, 56, 138<br>
weak references, 494<br>
UTC, 208<br>
WeakReference class, 494­498<br>
UTF-8, UTF-16, and UTF-32, 203<br>
WebClient, 584<br>
utility classes, 258­261<br>
WebExceptionStatus enum, 591<br>
Console class, 258<br>
WebProxy, 587<br>
Environment class, 260<br>
WebRequest and WebResponse classes,<br>
Process class, 260<br>
585­587<br>
WebRequestMethods.FTP, 600<br>
<b>V</b><br>
Where query operator, 314, 372<br>while loops, 53<br>
value equality, 246<br>
Windows authentication (networking),<br>
value types, 17<br>
587<br>
in arrays, 33<br>
Windows Data Protection, 776, 777<br>
nullable types and, 149<br>
Windows event logs, 528­530<br>
predefined, 20<br>
monitoring, 530<br>
var keyword, 44, 160<br>
reading, 529<br>
variables, 12, 36­44<br>
writing to, 528<br>
captured variables, 132<br>
Windows Forms, 187, 189<br>
default values, 38<br>
Windows Forms libraries<br>
definite assignment, 37<br>
thread affinity, 822<br>
heap, 36<br>
Windows Presentation Foundation, 187<br>
implicitly typed local variables, 44<br>
Windows Workflow, 190<br>
stack, 36<br>
WithDegreeOfParallelism method, 884<br>
verbatim string literals, 31<br>
WMI, 561<br>
versioning (assemblies), 655, 656<br>
word boundary assertions (regex), 984<br>
versioning (assembly informational), 657<br>
worker threads, 823<br>
Versioning (with GAC), 663<br>
working set, 481<br>
vertical bar (|)<br>
WPF (Windows Presentation<br>
regex alternator, 978<br>
Foundation), 188<br>
with enums, 98<br>
thread affinity, 822<br>
with nullable types, 151<br>
Write and WriteLine methods, 259<br>
virtual function members, 79<br>
WriteAllText method, 204<br>
virtual keyword, 79<br>virtualization, 775<br>Visitor pattern, 738­741<br>
<b>X</b><br>
void keyword, 8<br>
X-DOM, 414­417, 414<br>
volatile keyword, 828<br>
(see also LINQ to XML)<br>annotations, 440<br>
<b>W</b><br>
documents and declarations, 431­434<br>
Wait and Pulse, 840­849<br>
XDocument, 431<br>
producer/consumer queue, 844­847<br>
XML declarations, 433<br>
simulating Wait handles, 848<br>
instantiating, 418­420<br>
Wait timeout, 847<br>
automatic deep cloning, 420<br>content, specifying, 419<br>functional construction, 418<br>
<b>Index | 1031</b><br>
<hr>
<A name=1052></a>loading and parsing, 416<br>
XmlDocument, 463­466<br>
names and namespaces, 434­440<br>
InnerText and InnerXml, 464<br>
default namespaces, 438<br>
loading and saving, 463<br>
prefixes, 439<br>
namespaces, 466<br>
specifying namespaces, 437<br>
nodes, creating and manipulating, 465<br>
XML namespaces, 435<br>
traversing, 464<br>
navigating and querying, 420­425<br>
XmlElementAttribute constructor, 722<br>
attribute navigation, 425<br>
XmlNodeType, 449<br>
child node navigation, 420­423<br>
XmlReader class, 448­456<br>
parent navigation, 424<br>
attributes, reading, 454<br>
peer node navigation, 425<br>
attribute nodes, 455<br>
projecting into, 441­446<br>
start element positioning, 455<br>
empty elements, eliminating, 443<br>
elements reading<br>
streaming projections, 443<br>
validation failure, 451<br>
transforming X-DOMs with<br>
elements, reading, 451­454<br>
reprojection, 444<br>
empty elements, 452<br>
saving and serializing, 417<br>
optional elements, 452<br>
updating, 425­428<br>
random element order, 452<br>
child nodes and attributes, 426<br>
Read methods, 453<br>
simple value updates, 426<br>
namespaces, 456<br>
through the parent, 427<br>
nodes, reading, 449­451<br>
values, working with, 428­431<br>
patterns for use, 459­463<br>
automatic XText concatenation,<br>
X-DOM, mixing with, 461<br>
430<br>
XElement, usage with, 461<br>
getting values, 429<br>
XmlSerializer engine, 611, 637­644<br>
mixed content nodes and, 430<br>
attribute-based serialization, 637<br>
setting, 429<br>
attributes, names, and namespaces,<br>
XmlReader and XmlWriter, mixing<br>
639<br>
with, 461<br>
XML element order, 639<br>
XAML (Extensible Application Markup<br>
collections, serializing, 642<br>
Language), 234<br>
subclassed collection elements,<br>
XDocument, 414<br>
644<br>
XElement type, 414<br>
subclasses and child object, 639<br>
XML documentation, 176<br>
serializing child objects, 640<br>
standard documentation tags, 177<br>
subclassing child objects, 641<br>
type prefixes, 179<br>
XmlWriter class, 457­458<br>
user-defined tags, 178<br>
attributes, writing, 458<br>
XML namespaces, 435<br>
namespaces and prefixes, 458<br>
attributes, 436<br>
patterns for use, 459­463<br>
prefixes, 435<br>
X-DOM, mixing with, 461<br>
specifying in X-DOM, 437<br>
XElement, using with, 462<br>
XML nodes, 449<br>
XNode class, 415<br>
reading, 449<br>
XObject class, 415<br>
XML Schema Definition (see XSD)<br>
XPath, 466­470<br>
XML serailization (see XmlSerializer<br>
common operators, 468<br>
engine; IXmlSerializable<br>
namespaces, querying with, 470<br>
interface)<br>
writing queries within code, 467<br>
XmlConvert class, 234<br>
XPathDocument, 470<br>
<b>1032 | Index</b><br>
<hr>
<A name=1053></a>XPathNavigator, 469<br>XSD (XML Schema Definition), 471­474<br>
schema validation, 472<br>
on X-DOMs and XmlDocuments,<br>
473<br>
XmlReader, using, 472<br>
XSLT (Extensible Stylesheet Language<br>
Transformations), 474<br>
XStreamingElement, 443<br>
<b>Y<br></b>yield break statement, 146<br>yield return statement, 147<br>
<b>Z<br></b>zero-width assertions, 983<br>Zip query operator, 401<br>
<b>Index | 1033</b><br>
<hr>
<A name=1054></a><hr>
<A name=1055></a><b>About the Authors<br>Joe Albahari</b> is the author of LINQPad and other C# tools, and he writes about<br>C# at <i>http://www.albahari.com/nutshell/</i>. He is a C# MVP and has been developing<br>large-scale applications on .NET and other platforms for more than 15 years. Joe is<br>currently a freelance consultant.<br>
<b>Ben Albahari</b> is a former program manager at Microsoft and has been a coauthor<br>of <i>C# in a Nutshell</i> since the first edition. He is the founder of TakeOnIt, a website<br>for comparing opinions of experts, leaders, and organizations on important topics.<br>
<b>Colophon<br></b>The animal on the cover of <i>C# 4.0 in a Nutshell</i> is a numidian crane. The Numidian<br>crane (<i>Antropoides virgo</i>) is also called the demoiselle crane because of its grace and<br>symmetry. This species of crane is native to Europe and Asia and migrates to India,<br>Pakistan, and northeast Africa in the winter.<br>
Though numidian cranes are the smallest cranes, they defend their territories as<br>aggressively as other crane species, using their loud voices to warn others of tres-<br>passing. If necessary, they will fight. Numidian cranes nest in uplands rather than<br>wetlands and will even live in the desert if there is water within 200 to 500 meters.<br>They sometimes make nests out of pebbles in which to lay their eggs, though more<br>often they will lay eggs directly on the ground, protected only by spotty vegetation.<br>
Numidian cranes are considered a symbol of good luck in some countries and are<br>sometimes even protected by law.<br>
The cover image is an original engraving from the 19th century. The cover font is<br>Adobe ITC Garamond. The text font is Linotype Birka; the heading font is Adobe<br>Myriad Condensed; and the code font is LucasFont's TheSansMonoCondensed.<br>
<hr>
<A name=1056></a><hr>
<A name="outline"></a><h1>Document Outline</h1>
<ul><li>Table of Contents
<li>Preface
<ul><li>Intended Audience
<li>How This Book Is Organized
<li>What You Need to Use This Book
<li>Conventions Used in This Book
<li>Using Code Examples
<li>Wed Like to Hear from You
<li>Safari® Books Online
<li>Acknowledgments
<ul><li>Joseph Albahari
<li>Ben Albahari
</ul></ul><li>Chapter 1. Introducing C#
  and the .NET Framework
<ul><li>Object Orientation
<li>Type Safety
<li>Memory Management
<li>Platform Support
<li>C#s Relationship with the CLR
<li>The CLR and .NET Framework
<li>Whats New in C# 4.0
</ul><li>Chapter 2. C# Language Basics
<ul><li>A First C# Program
<ul><li>Compilation
</ul><li>Syntax
<ul><li>Identifiers and Keywords
<ul><li>Avoiding conflicts
<li>Contextual keywords
</ul><li>Literals, Punctuators, and Operators
<li>Comments
</ul><li>Type Basics
<ul><li>Predefined Type Examples
<li>Custom Type Examples
<ul><li>Members of a type
<li>Symmetry of predefined types and custom types
<li>Constructors and instantiation
<li>Instance versus static members
<li>The public keyword
</ul><li>Conversions
<li>Value Types Versus Reference Types
<ul><li>Value types
<li>Reference types
<li>Null
<li>Storage overhead
</ul><li>Predefined Type Taxonomy
</ul><li>Numeric Types
<ul><li>Numeric Literals
<ul><li>Numeric literal type inference
<li>Numeric suffixes
</ul><li>Numeric Conversions
<ul><li>Integral to integral conversions
<li>Floating-point to floating-point conversions
<li>Floating-point to integral conversions
<li>Decimal conversions
</ul><li>Arithmetic Operators
<li>Increment and Decrement Operators
<li>Specialized Integral Operations
<ul><li>Integral division
<li>Integral overflow
<li>Integral arithmetic overflow check operators
<li>Overflow checking for constant expressions
<li>Bitwise operators
</ul><li>8- and 16-Bit Integrals
<li>Special Float and Double Values
<li>double Versus decimal
<li>Real Number Rounding Errors
</ul><li>Boolean Type and Operators
<ul><li>Bool Conversions
<li>Equality and Comparison Operators
<li>Conditional Operators
</ul><li>Strings and Characters
<ul><li>Char Conversions
<li>String Type
<ul><li>String concatenation
<li>String comparisons
</ul></ul><li>Arrays
<ul><li>Default Element Initialization
<ul><li>Value types versus reference types
</ul><li>Multidimensional Arrays
<ul><li>Rectangular arrays
<li>Jagged arrays
</ul><li>Simplified Array Initialization Expressions
<li>Bounds Checking
</ul><li>Variables and Parameters
<ul><li>The Stack and the Heap
<ul><li>Stack
<li>Heap
</ul><li>Definite Assignment
<li>Default Values
<li>Parameters
<ul><li>Passing arguments by value
<li>The ref modifier
<li>The out modifier
<li>Implications of passing by reference
<li>The params modifier
<li>Optional parameters (C# 4.0)
<li>Named arguments (C# 4.0)
</ul><li>varImplicitly Typed Local Variables
</ul><li>Expressions and Operators
<ul><li>Primary Expressions
<li>Void Expressions
<li>Assignment Expressions
<li>Operator Precedence and Associativity
<ul><li>Precedence
<li>Left-associative operators
<li>Right-associative operators
</ul><li>Operator Table
</ul><li>Statements
<ul><li>Declaration Statements
<ul><li>Local variables
</ul><li>Expression Statements
<li>Selection Statements
<ul><li>The if statement
<li>The else clause
<li>Changing the flow of execution with braces
<li>The switch statement
</ul><li>Iteration Statements
<ul><li>while and do-while loops
<li>for loops
<li>foreach loops
</ul><li>Jump Statements
<ul><li>The break statement
<li>The continue statement
<li>The goto statement
<li>The return statement
<li>The throw statement
</ul><li>Miscellaneous Statements
</ul><li>Namespaces
<ul><li>The using Directive
<li>Rules Within a Namespace
<ul><li>Name scoping
<li>Name hiding
<li>Repeated namespaces
<li>Nested using directive
</ul><li>Aliasing Types and Namespaces
<li>Advanced Namespace Features
<ul><li>Extern
<li>Namespace alias qualifiers
</ul></ul></ul><li>Chapter 3. Creating Types in
  C#
<ul><li>Classes
<ul><li>Fields
<ul><li>The readonly modifier
<li>Field initialization
<li>Declaring multiple fields together
</ul><li>Methods
<ul><li>Overloading methods
<li>Pass-by-value versus pass-by-reference
</ul><li>Instance Constructors
<ul><li>Overloading constructors
<li>Implicit parameterless constructors
<li>Constructor and field initialization order
<li>Nonpublic constructors
</ul><li>Object Initializers
<li>The this Reference
<li>Properties
<ul><li>Read-only and calculated properties
<li>Automatic properties
<li>get and set accessibility
<li>CLR property implementation
</ul><li>Indexers
<ul><li>Implementing an indexer
<li>CLR indexer implementation
</ul><li>Constants
<li>Static Constructors
<ul><li>Static constructors and field initialization order
</ul><li>Static Classes
<li>Finalizers
<li>Partial Types and Methods
<ul><li>Partial methods
</ul></ul><li>Inheritance
<ul><li>Polymorphism
<li>Casting and Reference Conversions
<ul><li>Upcasting
<li>Downcasting
<li>The as operator
<li>The is operator
</ul><li>Virtual Function Members
<li>Abstract Classes and Abstract Members
<li>Hiding Inherited Members
<ul><li>new versus virtual
</ul><li>Sealing Functions and Classes
<li>The base Keyword
<li>Constructors and Inheritance
<ul><li>Implicit calling of the parameterless base class constructor
<li>Constructor and field initialization order
</ul><li>Overloading and Resolution
</ul><li>The object Type
<ul><li>Boxing and Unboxing
<ul><li>Copying semantics of boxing and unboxing
</ul><li>Static and Runtime Type Checking
<li>The GetType Method and typeof Operator
<li>The ToString Method
<li>Object Member Listing
</ul><li>Structs
<ul><li>Struct Construction Semantics
</ul><li>Access Modifiers
<ul><li>Examples
<li>Friend Assemblies
<li>Accessibility Capping
<li>Restrictions on Access Modifiers
</ul><li>Interfaces
<ul><li>Extending an Interface
<li>Explicit Interface Implementation
<li>Implementing Interface Members Virtually
<li>Reimplementing an Interface in a Subclass
<ul><li>Alternatives to interface reimplementation
</ul><li>Interfaces and Boxing
</ul><li>Enums
<ul><li>Enum Conversions
<li>Flags Enums
<li>Enum Operators
<li>Type-Safety Issues
</ul><li>Nested Types
<li>Generics
<ul><li>Generic Types
<li>Why Generics Exist
<li>Generic Methods
<li>Declaring Type Parameters
<li>typeof and Unbound Generic Types
<li>The default Generic Value
<li>Generic Constraints
<li>Subclassing Generic Types
<li>Self-Referencing Generic Declarations
<li>Static Data
<li>Type Parameters and Conversions
<li>Covariance
<ul><li>Classes
<li>Arrays
<li>Interfaces
</ul><li>Contravariance
<li>C# Generics Versus C++ Templates
</ul></ul><li>Chapter 4. Advanced C#
<ul><li>Delegates
<ul><li>Writing Plug-in Methods with Delegates
<li>Multicast Delegates
<ul><li>Multicast delegate example
</ul><li>Instance Versus Static Method Targets
<li>Generic Delegate Types
<li>The Func and Action Delegates
<li>Delegates Versus Interfaces
<li>Delegate Compatibility
<ul><li>Type compatibility
<li>Parameter compatibility
<li>Return type compatibility
<li>Generic delegate type parameter variance (C# 4.0)
</ul></ul><li>Events
<ul><li>Standard Event Pattern
<li>Event Accessors
<li>Event Modifiers
</ul><li>Lambda Expressions
<ul><li>Explicitly Specifying Lambda Parameter Types
<li>Capturing Outer Variables
<ul><li>Capturing iteration variables
</ul></ul><li>Anonymous Methods
<li>try Statements and Exceptions
<ul><li>The catch Clause
<li>The finally Block
<ul><li>The using statement
</ul><li>Throwing Exceptions
<ul><li>Rethrowing an exception
</ul><li>Key Properties of System.Exception
<li>Common Exception Types
<li>Common Patterns
<ul><li>The TryXXX method pattern
<li>The atomicity pattern
<li>Alternatives to exceptions
</ul></ul><li>Enumeration and Iterators
<ul><li>Enumeration
<li>Collection Initializers
<li>Iterators
<li>Iterator Semantics
<ul><li>yield break
<li>Iterators and try/catch/finally blocks
</ul><li>Composing Sequences
</ul><li>Nullable Types
<ul><li>Nullable<T> Struct
<li>Implicit and Explicit Nullable Conversions
<li>Boxing and Unboxing Nullable Values
<li>Operator Lifting
<ul><li>þÿ
<li>þÿ
<li>þÿ
<li>Mixing nullable and non-nullable operators
</ul><li>bool? with & and | Operators
<li>Null Coalescing Operator
<li>Scenarios for Nullable Types
<li>Alternatives to Nullable Types
</ul><li>Operator Overloading
<ul><li>Operator Functions
<li>Overloading Equality and Comparison Operators
<li>Custom Implicit and Explicit Conversions
<li>Overloading true and false
</ul><li>Extension Methods
<ul><li>Extension Method Chaining
<li>Ambiguity and Resolution
<ul><li>Namespaces
<li>Extension methods versus instance methods
<li>Extension methods versus extension methods
</ul><li>Extension Methods on Interfaces
</ul><li>Anonymous Types
<li>Dynamic Binding
<ul><li>Static Binding Versus Dynamic Binding
<li>Custom Binding
<li>Language Binding
<li>RuntimeBinderException
<li>Runtime Representation of Dynamic
<li>Dynamic Conversions
<li>var Versus dynamic
<li>Dynamic Expressions
<li>Dynamic Calls Without Dynamic Receivers
<li>Static Types in Dynamic Expressions
<li>Uncallable Functions
</ul><li>Attributes
<ul><li>Attribute Classes
<li>Named and Positional Attribute Parameters
<li>Attribute Targets
<li>Specifying Multiple Attributes
</ul><li>Unsafe Code and Pointers
<ul><li>Pointer Basics
<li>Unsafe Code
<li>The fixed Statement
<li>The Pointer-to-Member Operator
<li>Arrays
<ul><li>The stackalloc keyword
<li>Fixed-size buffers
</ul><li>void*
<li>Pointers to Unmanaged Code
</ul><li>Preprocessor Directives
<ul><li>Conditional Attributes
<li>Pragma Warning
</ul><li>XML Documentation
<ul><li>Standard XML Documentation Tags
<li>User-Defined Tags
<li>Type or Member Cross-References
</ul></ul><li>Chapter 5. Framework Overview
<ul><li>The CLR and Core Framework
<ul><li>System Types
<li>Text Processing
<li>Collections
<li>Queries
<li>XML
<li>Diagnostics and Code Contracts
<li>Streams and I/O
<li>Networking
<li>Serialization
<li>Assemblies, Reflection, and Attributes
<li>Dynamic Programming
<li>Security
<li>Threading and Parallel Programming
<li>Application Domains
<li>Native and COM Interoperability
</ul><li>Applied Technologies
<ul><li>User Interface Technologies
<ul><li>ASP.NET
<li>Silverlight
<li>Windows Presentation Foundation (WPF)
<li>Windows Forms
</ul><li>Backend Technologies
<ul><li>ADO.NET
<li>Windows Workflow
<li>COM+ and MSMQ
</ul><li>Distributed System Technologies
<ul><li>Windows Communication Foundation (WCF)
<li>Remoting and Web Services
<li>CardSpace
</ul></ul></ul><li>Chapter 6. Framework
  Fundamentals
<ul><li>String and Text Handling
<ul><li>Char
<li>String
<ul><li>Constructing strings
<li>Null and empty strings
<li>Accessing characters within a string
<li>Searching within strings
<li>Manipulating strings
<li>Splitting and joining strings
<li>String.Format and composite format strings
</ul><li>Comparing Strings
<ul><li>Ordinal versus culture comparison
<li>String equality comparison
<li>String order comparison
</ul><li>StringBuilder
<li>Text Encodings and Unicode
<ul><li>Obtaining an Encoding object
<li>Encoding for file and stream I/O
<li>Encoding to byte arrays
<li>UTF-16 and surrogate pairs
</ul></ul><li>Dates and Times
<ul><li>TimeSpan
<li>DateTime and DateTimeOffset
<ul><li>Choosing between DateTime and DateTimeOffset
<li>Constructing a DateTime
<li>Constructing a DateTimeOffset
<li>The current DateTime/DateTimeOffset
<li>Working with dates and times
<li>Formatting and parsing
<li>Null DateTime and DateTimeOffset values
</ul></ul><li>Dates and Time Zones
<ul><li>DateTime and Time Zones
<li>DateTimeOffset and Time Zones
<li>TimeZone and TimeZoneInfo
<ul><li>TimeZone
<li>TimeZoneInfo
</ul><li>Daylight Saving Time and DateTime
</ul><li>Formatting and Parsing
<ul><li>ToString and Parse
<li>Format Providers
<ul><li>Format providers and CultureInfo
<li>Using NumberFormatInfo or DateTimeFormatInfo
<li>Composite formatting
<li>Parsing with format providers
<li>IFormatProvider and ICustomFormatter
</ul></ul><li>Standard Format Strings and Parsing Flags
<ul><li>Numeric Format Strings
<li>NumberStyles
<li>Date/Time Format Strings
<ul><li>Parsing and misparsing DateTimes
</ul><li>DateTimeStyles
<li>Enum Format Strings
</ul><li>Other Conversion Mechanisms
<ul><li>Convert
<ul><li>Rounding real to integral conversions
<li>Parsing numbers in base 2, 8, and 16
<li>Dynamic conversions
<li>Base 64 conversions
</ul><li>XmlConvert
<li>Type Converters
<li>BitConverter
</ul><li>Globalization
<ul><li>Globalization Checklist
<li>Testing
</ul><li>Working with Numbers
<ul><li>Conversions
<li>Math
<li>BigInteger
<li>Complex
<li>Random
</ul><li>Enums
<ul><li>Enum Conversions
<ul><li>Enum to integral conversions
<li>Integral to enum conversions
<li>String conversions
</ul><li>Enumerating Enum Values
<li>How Enums Work
</ul><li>Tuples
<ul><li>Comparing Tuples
</ul><li>The Guid Struct
<li>Equality Comparison
<ul><li>Value Versus Referential Equality
<li>Standard Equality Protocols
<ul><li>== and !=
<li>The virtual Object.Equals method
<li>The static object.Equals method
<li>The static object.ReferenceEquals method
<li>The IEquatable<T> interface
<li>When Equals and == are not equal
</ul><li>Equality and Custom Types
<ul><li>Changing the meaning of equality
<li>Speeding up equality comparisons with structs
<li>How to override equality semantics
<li>Overriding GetHashCode
<li>Overriding Equals
<li>Overloading == and !=
<li>Implementing IEquatable<T>
<li>An example: The Area struct
<li>Pluggable equality comparers
</ul></ul><li>Order Comparison
<ul><li>IComparable
<ul><li>IComparable versus Equals
</ul><li>< and >
<li>Implementing the IComparable Interfaces
</ul><li>Utility Classes
<ul><li>Console
<li>Environment
<li>Process
</ul></ul><li>Chapter 7. Collections
<ul><li>Enumeration
<ul><li>IEnumerable and IEnumerator
<li>IEnumerable<T> and IEnumerator<T>
<ul><li>IEnumerable<T> and IDisposable
</ul><li>Implementing the Enumeration Interfaces
</ul><li>The ICollection and IList Interfaces
<ul><li>ICollection<T> and ICollection
<li>IList<T> and IList
</ul><li>The Array Class
<ul><li>Construction and Indexing
<li>Enumeration
<li>Length and Rank
<li>Searching
<li>Sorting
<li>Reversing Elements
<li>Copying, Converting, and Resizing
</ul><li>Lists, Queues, Stacks, and Sets
<ul><li>List<T> and ArrayList
<li>LinkedList<T>
<li>Queue<T> and Queue
<li>Stack<T> and Stack
<li>BitArray
<li>HashSet<T> and SortedSet<T>
</ul><li>Dictionaries
<ul><li>IDictionary<TKey,TValue>
<li>IDictionary
<li>Dictionary<TKey,TValue> and Hashtable
<li>OrderedDictionary
<li>ListDictionary and HybridDictionary
<li>Sorted Dictionaries
</ul><li>Customizable Collections and Proxies
<ul><li>Collection<T> and CollectionBase
<ul><li>CollectionBase
</ul><li>KeyedCollection<TKey,TItem> and DictionaryBase
<ul><li>DictionaryBase
</ul><li>ReadOnlyCollection<T>
</ul><li>Plugging in Equality and Order
<ul><li>IEqualityComparer and EqualityComparer
<ul><li>EqualityComparer<T>.Default
</ul><li>IComparer and Comparer
<li>StringComparer
<li>IStructuralEquatable and IStructuralComparable
</ul></ul><li>Chapter 8. LINQ Queries
<ul><li>Getting Started
<li>Fluent Syntax
<ul><li>Chaining Query Operators
<ul><li>Why extension methods are important
</ul><li>Composing Lambda Expressions
<ul><li>Lambda expressions and Func signatures
<li>Lambda expressions and element typing
</ul><li>Natural Ordering
<li>Other Operators
</ul><li>Query Expressions
<ul><li>Range Variables
<li>Query Syntax Versus SQL Syntax
<li>Query Syntax Versus Fluent Syntax
<li>Mixed Syntax Queries
</ul><li>Deferred Execution
<ul><li>Reevaluation
<li>Captured Variables
<li>How Deferred Execution Works
<li>Chaining Decorators
<li>How Queries Are Executed
</ul><li>Subqueries
<ul><li>Subqueries and Deferred Execution
</ul><li>Composition Strategies
<ul><li>Progressive Query Building
<li>The into Keyword
<ul><li>Scoping rules
</ul><li>Wrapping Queries
</ul><li>Projection Strategies
<ul><li>Object Initializers
<li>Anonymous Types
<li>The let Keyword
</ul><li>Interpreted Queries
<ul><li>How Interpreted Queries Work
<ul><li>Execution
</ul><li>Combining Interpreted and Local Queries
<li>AsEnumerable
</ul><li>LINQ to SQL and Entity Framework
<ul><li>LINQ to SQL Entity Classes
<li>Entity Framework Entity Classes
<li>DataContext and ObjectContext
<ul><li>Typed contexts
<li>Object tracking
</ul><li>Associations
<li>Deferred Execution with L2S and EF
<li>DataLoadOptions
<ul><li>Specifying a filter in advance
<li>Eager loading
</ul><li>Eager Loading in Entity Framework
<li>Updates
<li>API Differences Between L2S and EF
</ul><li>Building Query Expressions
<ul><li>Delegates Versus Expression Trees
<ul><li>Compiling expression trees
<li>AsQueryable
</ul><li>Expression Trees
<ul><li>The Expression DOM
</ul></ul></ul><li>Chapter 9. LINQ Operators
<ul><li>Overview
<ul><li>þÿ
<ul><li>Filtering
<li>Projecting
<li>Joining
<li>Ordering
<li>Grouping
<li>Set operators
<li>Zip operator
<li>Conversion methods: Import
<li>Conversion methods: Export
</ul><li>þÿ
<ul><li>Element operators
<li>Aggregation methods
<li>Quantifiers
</ul><li>þÿ
<ul><li>Generation methods
</ul></ul><li>Filtering
<ul><li>Where
<ul><li>Query syntax
<li>Enumerable.Where implementation
<li>Overview
<li>Indexed filtering
<li>SQL LIKE comparisons in LINQ to SQL and EF
<li>< and > string comparisons in LINQ to SQL and EF
<li>WHERE x IN (..., ..., ...) in LINQ to SQL and EF
</ul><li>Take and Skip
<li>TakeWhile and SkipWhile
<li>Distinct
</ul><li>Projecting
<ul><li>Select
<ul><li>Query syntax
<li>Enumerable implementation
<li>Overview
<li>Indexed projection
<li>Select subqueries and object hierarchies
<li>Subqueries and joins in LINQ to SQL and EF
<li>Projecting into concrete types
</ul><li>SelectMany
<ul><li>Query syntax
<li>Enumerable implementation
<li>Overview
<li>Outer range variables
<li>Thinking in query syntax
<li>Joining with SelectMany
<li>SelectMany in LINQ to SQL and EF
<li>Outer joins with SelectMany
</ul></ul><li>Joining
<ul><li>Join and GroupJoin
<ul><li>Join arguments
<li>GroupJoin arguments
<li>Query syntax
<li>Overview
<li>Join
<li>Joining on multiple keys
<li>Joining in fluent syntax
<li>GroupJoin
<li>Flat outer joins
<li>Joining with lookups
<li>Enumerable implementations
</ul></ul><li>Ordering
<ul><li>OrderBy, OrderByDescending, ThenBy, and ThenByDescending
<ul><li>OrderBy and OrderByDescending arguments
<li>ThenBy and ThenByDescending arguments
<li>Query syntax
<li>Overview
<li>Comparers and collations
<li>IOrderedEnumerable and IOrderedQueryable
</ul></ul><li>Grouping
<ul><li>GroupBy
<ul><li>Query syntax
<li>Overview
<li>GroupBy in LINQ to SQL and EF
<li>Grouping by multiple keys
<li>Custom equality comparers
</ul></ul><li>Set Operators
<ul><li>Concat and Union
<li>Intersect and Except
</ul><li>The Zip Operator
<li>Conversion Methods
<ul><li>OfType and Cast
<li>ToArray, ToList, ToDictionary, and ToLookup
<li>AsEnumerable and AsQueryable
</ul><li>Element Operators
<ul><li>First, Last, and Single
<li>ElementAt
<li>DefaultIfEmpty
</ul><li>Aggregation Methods
<ul><li>Count and LongCount
<li>Min and Max
<li>Sum and Average
<li>Aggregate
<ul><li>Unseeded aggregations
<li>Traps with unseeded aggregations
</ul></ul><li>Quantifiers
<ul><li>Contains and Any
<li>All and SequenceEqual
</ul><li>Generation Methods
<ul><li>Empty
<li>Range and Repeat
</ul></ul><li>Chapter 10. LINQ to XML
<ul><li>Architectural Overview
<ul><li>What Is a DOM?
<li>The LINQ to XML DOM
</ul><li>X-DOM Overview
<ul><li>Loading and Parsing
<li>Saving and Serializing
</ul><li>Instantiating an X-DOM
<ul><li>Functional Construction
<li>Specifying Content
<li>Automatic Deep Cloning
</ul><li>Navigating and Querying
<ul><li>Child Node Navigation
<ul><li>FirstNode, LastNode, and Nodes
<li>Retrieving elements
<li>Retrieving a single element
<li>Recursive functions
</ul><li>Parent Navigation
<li>Peer Node Navigation
<li>Attribute Navigation
</ul><li>Updating an X-DOM
<ul><li>Simple Value Updates
<li>Updating Child Nodes and Attributes
<li>Updating Through the Parent
<ul><li>Removing a sequence of nodes or attributes
</ul></ul><li>Working with Values
<ul><li>Setting Values
<li>Getting Values
<li>Values and Mixed Content Nodes
<li>Automatic XText Concatenation
</ul><li>Documents and Declarations
<ul><li>XDocument
<li>XML Declarations
<ul><li>Writing a declaration to a string
</ul></ul><li>Names and Namespaces
<ul><li>Namespaces in XML
<ul><li>Prefixes
<li>Attributes
</ul><li>Specifying Namespaces in the X-DOM
<li>The X-DOM and Default Namespaces
<li>Prefixes
</ul><li>Annotations
<li>Projecting into an X-DOM
<ul><li>Eliminating Empty Elements
<li>Streaming a Projection
<li>Transforming an X-DOM
<ul><li>Advanced transformations
</ul></ul></ul><li>Chapter 11. Other XML Technologies
<ul><li>XmlReader
<ul><li>Reading Nodes
<li>Reading Elements
<ul><li>Optional elements
<li>Random element order
<li>Empty elements
<li>Other ReadXXX methods
</ul><li>Reading Attributes
<ul><li>Attribute nodes
</ul><li>Namespaces and Prefixes
</ul><li>XmlWriter
<ul><li>Writing Attributes
<li>Writing Other Node Types
<li>Namespaces and Prefixes
</ul><li>Patterns for Using XmlReader/XmlWriter
<ul><li>Working with Hierarchical Data
<li>Mixing XmlReader/XmlWriter with an X-DOM
<ul><li>Using XmlReader with XElement
<li>Using XmlWriter with XElement
</ul></ul><li>XmlDocument
<ul><li>Loading and Saving an XmlDocument
<li>Traversing an XmlDocument
<li>InnerText and InnerXml
<li>Creating and Manipulating Nodes
<li>Namespaces
</ul><li>XPath
<ul><li>Common XPath Operators
<li>XPathNavigator
<li>Querying with Namespaces
<li>XPathDocument
</ul><li>XSD and Schema Validation
<ul><li>Performing Schema Validation
<ul><li>Validating with an XmlReader
<li>Validating an X-DOM or XmlDocument
</ul></ul><li>XSLT
</ul><li>Chapter 12. Disposal and Garbage
  Collection
<ul><li>IDisposable, Dispose, and Close
<ul><li>Standard Disposal Semantics
<ul><li>Close and Stop
</ul><li>When to Dispose
<li>Opt-in Disposal
<li>Clearing Fields in Disposal
</ul><li>Automatic Garbage Collection
<ul><li>Roots
</ul><li>Finalizers
<ul><li>Calling Dispose from a Finalizer
<li>Resurrection
<ul><li>GC.ReRegisterForFinalize
</ul></ul><li>How the Garbage Collector Works
<ul><li>Optimization Techniques
<ul><li>Generational collection
<li>The large object heap
<li>Concurrent and background collection
<li>GC notifications (server CLR)
</ul><li>Forcing Garbage Collection
<li>Memory Pressure
</ul><li>Managed Memory Leaks
<ul><li>Timers
<li>Diagnosing Memory Leaks
</ul><li>Weak References
<ul><li>Weak References and Caching
<li>Weak References and Events
</ul></ul><li>Chapter 13. Diagnostics and Code Contracts
<ul><li>Conditional Compilation
<ul><li>Conditional Compilation Versus Static Variable Flags
<li>The Conditional Attribute
<ul><li>Alternatives to the Conditional attribute
</ul></ul><li>Debug and Trace Classes
<ul><li>Fail and Assert
<li>TraceListener
<li>Flushing and Closing Listeners
</ul><li>Code Contracts Overview
<ul><li>Why Use Code Contracts?
<li>Contract Principles
<ul><li>Compilation
<li>The binary rewriter
<li>Asserting versus throwing on failure
<li>Purity
</ul></ul><li>Preconditions
<ul><li>Contract.Requires
<li>Contract.Requires<TException>
<li>Contract.EndContractBlock
<li>Preconditions and Overridden Methods
</ul><li>Postconditions
<ul><li>Contract.Ensures
<li>Contract.EnsuresOnThrow<TException>
<li>Contract.Result<T> and Contract.ValueAtReturn<T>
<li>Contract.OldValue<T>
<li>Postconditions and Overridden Methods
</ul><li>Assertions and Object Invariants
<ul><li>Assertions
<ul><li>Contract.Assert
<li>Contract.Assume
</ul><li>Object Invariants
</ul><li>Contracts on Interfaces and Abstract Methods
<li>Dealing with Contract Failure
<ul><li>The ContractFailed Event
<li>Exceptions Within Contract Conditions
</ul><li>Selectively Enforcing Contracts
<ul><li>Contracts in Release Builds
<li>Call-Site Checking
</ul><li>Static Contract Checking
<ul><li>The ContractVerification Attribute
<li>Baselines
<li>The SuppressMessage Attribute
</ul><li>Debugger Integration
<ul><li>Attaching and Breaking
<li>Debugger Attributes
</ul><li>Processes and Process Threads
<ul><li>Examining Running Processes
<li>Examining Threads in a Process
</ul><li>StackTrace and StackFrame
<li>Windows Event Logs
<ul><li>Writing to the Event Log
<li>Reading the Event Log
<li>Monitoring the Event Log
</ul><li>Performance Counters
<ul><li>Enumerating the Available Counters
<li>Reading Performance Counter Data
<li>Creating Counters and Writing Performance Data
</ul><li>The Stopwatch Class
</ul><li>Chapter 14. Streams and I/O
<ul><li>Stream Architecture
<li>Using Streams
<ul><li>Reading and Writing
<li>Seeking
<li>Closing and Flushing
<li>Timeouts
<li>Thread Safety
<li>Backing Store Streams
<li>FileStream
<ul><li>Constructing a FileStream
<li>Specifying a filename
<li>Specifying a FileMode
<li>Advanced FileStream features
</ul><li>MemoryStream
<li>PipeStream
<ul><li>Named pipes
<li>Anonymous pipes
</ul><li>BufferedStream
</ul><li>Stream Adapters
<ul><li>Text Adapters
<ul><li>StreamReader and StreamWriter
<li>Character encodings
<li>StringReader and StringWriter
</ul><li>Binary Adapters
<li>Closing and Disposing Stream Adapters
</ul><li>File and Directory Operations
<ul><li>The File Class
<ul><li>Compression and encryption attributes
<li>File security
</ul><li>The Directory Class
<li>FileInfo and DirectoryInfo
<li>Path
<li>Special Folders
<li>Querying Volume Information
<li>Catching Filesystem Events
</ul><li>Memory-Mapped Files
<ul><li>Memory-Mapped Files and Random File I/O
<li>Memory-Mapped Files and Shared Memory
<li>Working with View Accessors
</ul><li>Compression
<ul><li>Compressing in Memory
</ul><li>Isolated Storage
<ul><li>Isolation Types
<li>Reading and Writing Isolated Storage
<li>Store Location
<li>Enumerating Isolated Storage
</ul></ul><li>Chapter 15. Networking
<ul><li>Network Architecture
<li>Addresses and Ports
<li>URIs
<li>Request/Response Architecture
<ul><li>WebClient
<li>WebRequest and WebResponse
<li>Proxies
<li>Authentication
<ul><li>CredentialCache
</ul><li>Concurrency
<li>Exception Handling
</ul><li>HTTP-Specific Support
<ul><li>Headers
<li>Query Strings
<li>Uploading Form Data
<li>Cookies
<li>Forms Authentication
<li>SSL
</ul><li>Writing an HTTP Server
<li>Using FTP
<li>Using DNS
<li>Sending Mail with SmtpClient
<li>Using TCP
<ul><li>Concurrency
</ul><li>Receiving POP3 Mail with TCP
</ul><li>Chapter 16. Serialization
<ul><li>Serialization Concepts
<ul><li>Serialization Engines
<ul><li>Why three engines?
<li>The data contract serializer
<li>The binary serializer
<li>XmlSerializer
<li>IXmlSerializable
</ul><li>Formatters
<li>Explicit Versus Implicit Serialization
</ul><li>The Data Contract Serializer
<ul><li>DataContractSerializer Versus NetDataContractSerializer
<li>Using the Serializers
<ul><li>Specifying a binary formatter
</ul><li>Serializing Subclasses
<li>Object References
<ul><li>Preserving object references
</ul><li>Version Tolerance
<ul><li>Required members
</ul><li>Member Ordering
<li>Null and Empty Values
</ul><li>Data Contracts and Collections
<ul><li>Subclassed Collection Elements
<li>Customizing Collection and Element Names
</ul><li>Extending Data Contracts
<ul><li>Serialization and Deserialization Hooks
<li>Interoperating with [Serializable]
<li>Interoperating with IXmlSerializable
</ul><li>The Binary Serializer
<ul><li>Getting Started
</ul><li>Binary Serialization Attributes
<ul><li>[NonSerialized]
<li>[OnDeserializing] and [OnDeserialized]
<li>[OnSerializing] and [OnSerialized]
<li>[OptionalField] and Versioning
</ul><li>Binary Serialization with ISerializable
<ul><li>Subclassing Serializable Classes
</ul><li>XML Serialization
<ul><li>Getting Started with Attribute-Based Serialization
<ul><li>Attributes, names, and namespaces
<li>XML element order
</ul><li>Subclasses and Child Objects
<ul><li>Subclassing the root type
<li>Serializing child objects
<li>Subclassing child objects
</ul><li>Serializing Collections
<ul><li>Working with subclassed collection elements
</ul><li>IXmlSerializable
</ul></ul><li>Chapter 17. Assemblies
<ul><li>Whats in an Assembly?
<ul><li>The Assembly Manifest
<ul><li>Specifying assembly attributes
</ul><li>The Application Manifest
<ul><li>Deploying an application manifest
</ul><li>Modules
<li>The Assembly Class
</ul><li>Strong Names and Assembly Signing
<ul><li>How to Strongly Name an Assembly
<li>Delay Signing
</ul><li>Assembly Names
<ul><li>Fully Qualified Names
<li>The AssemblyName Class
<li>Assembly Informational and File Versions
</ul><li>Authenticode Signing
<ul><li>How to Sign with Authenticode
<ul><li>Obtaining and installing a certificate
<li>Signing with signtool.exe
<li>Time stamping
<li>Verifying that a program has been signed
</ul><li>Authenticode Validation
</ul><li>The Global Assembly Cache
<ul><li>How to Install Assemblies to the GAC
<li>GAC and Versioning
</ul><li>Resources and Satellite Assemblies
<ul><li>Directly Embedding Resources
<li>.resources Files
<li>.resx Files
<ul><li>Creating a .resx file at the command line
<li>Reading .resources files
<li>Creating a pack URI resource in Visual Studio
</ul><li>Satellite Assemblies
<ul><li>Building satellite assemblies
<li>Testing satellite assemblies
<li>Visual Studio designer support
</ul><li>Cultures and Subcultures
</ul><li>Resolving and Loading Assemblies
<ul><li>Assembly and Type Resolution Rules
<li>AssemblyResolve
<li>Loading Assemblies
<ul><li>Loading from a filename
</ul></ul><li>Deploying Assemblies Outside the Base Folder
<li>Packing a Single-File Executable
<ul><li>Selective Patching
</ul><li>Working with Unreferenced Assemblies
</ul><li>Chapter 18. Reflection and
  Metadata
<ul><li>Reflecting and Activating Types
<ul><li>Obtaining a Type
<ul><li>Obtaining array types
<li>Obtaining nested types
</ul><li>Type Names
<ul><li>Nested type names
<li>Generic type names
<li>Array and pointer type names
<li>ref and out parameter type names
</ul><li>Base Types and Interfaces
<li>Instantiating Types
<li>Generic Types
</ul><li>Reflecting and Invoking Members
<ul><li>Member Types
<li>C# Members Versus CLR Members
<li>Generic Type Members
<li>Dynamically Invoking a Member
<li>Method Parameters
<ul><li>Dealing with ref and out parameters
<li>Retrieving and invoking generic methods
</ul><li>Using Delegates for Performance
<li>Accessing Nonpublic Members
<ul><li>The BindingFlags enum
</ul><li>Generic Methods
<li>Anonymously Calling Members of a Generic Interface
</ul><li>Reflecting Assemblies
<ul><li>Loading an Assembly into a Reflection-Only Context
<li>Modules
</ul><li>Working with Attributes
<ul><li>Attribute Basics
<li>The AttributeUsage Attribute
<li>Defining Your Own Attribute
<li>Retrieving Attributes at Runtime
<li>Retrieving Attributes in the Reflection-Only Context
</ul><li>Dynamic Code Generation
<ul><li>Generating IL with DynamicMethod
<li>The Evaluation Stack
<li>Passing Arguments to a Dynamic Method
<li>Generating Local Variables
<li>Branching
<li>Instantiating Objects and Calling Instance Methods
<li>Exception Handling
</ul><li>Emitting Assemblies and Types
<ul><li>Saving Emitted Assemblies
<li>The Reflection.Emit Object Model
</ul><li>Emitting Type Members
<ul><li>Emitting Methods
<ul><li>Generating instance methods
<li>HideBySig
</ul><li>Emitting Fields and Properties
<li>Emitting Constructors
<ul><li>Calling base constructors
</ul><li>Attaching Attributes
</ul><li>Emitting Generic Methods and Types
<ul><li>Defining Generic Methods
<li>Defining Generic Types
</ul><li>Awkward Emission Targets
<ul><li>Uncreated Closed Generics
<li>Circular Dependencies
</ul><li>Parsing IL
<ul><li>Writing a Disassembler
</ul></ul><li>Chapter 19. Dynamic Programming
<ul><li>The Dynamic Language Runtime
<li>Numeric Type Unification
<li>Dynamic Member Overload Resolution
<ul><li>Simplifying the Visitor Pattern
<ul><li>Variations
</ul><li>Anonymously Calling Members of a Generic Type
</ul><li>Implementing Dynamic Objects
<ul><li>DynamicObject
<li>ExpandoObject
</ul><li>Interoperating with Dynamic Languages
<ul><li>Passing State Between C# and a Script
</ul></ul><li>Chapter 20. Security
<ul><li>Permissions
<ul><li>CodeAccessPermission and PrincipalPermission
<ul><li>IPermission
</ul><li>PermissionSet
<li>Declarative Versus Imperative Security
</ul><li>Code Access Security (CAS)
<ul><li>How Code Access Security Is Applied
<li>Testing for Full Trust
</ul><li>Allowing Partially Trusted Callers
<ul><li>Elevation of Privilege
<li>APTCA and [SecurityTransparent]
</ul><li>The Transparency Model in CLR 4.0
<ul><li>How the Transparency Model Works
<ul><li>Transparent code
<li>Settings the transparency default for an assembly
</ul><li>How to Write APTCA Libraries with Transparency
<ul><li>Securing unsafe methods
<li>P/Invokes and [SuppressUnmanagedSecurity]
</ul><li>Transparency in Full-Trust Scenarios
</ul><li>Sandboxing Another Assembly
<ul><li>Asserting Permissions
</ul><li>Operating System Security
<ul><li>Running in a Standard User Account
<li>Administrative Elevation and Virtualization
</ul><li>Identity and Role Security
<ul><li>Assigning Users and Roles
</ul><li>Cryptography Overview
<li>Windows Data Protection
<li>Hashing
<li>Symmetric Encryption
<ul><li>Encrypting in Memory
<li>Chaining Encryption Streams
<li>Disposing Encryption Objects
<li>Key Management
</ul><li>Public Key Encryption and Signing
<ul><li>The RSA Class
<li>Digital Signing
</ul></ul><li>Chapter 21. Threading
<ul><li>Threadings Uses and Misuses
<li>Getting Started
<ul><li>Passing Data to a Thread
<ul><li>Lambda expressions and captured variables
</ul><li>Sharing Data Between Threads
<li>Foreground and Background Threads
<li>Thread Priority
<li>Exception Handling
</ul><li>Thread Pooling
<ul><li>Entering the Thread Pool via TPL
<li>Entering the Thread Pool Without TPL
<ul><li>QueueUserWorkItem
<li>Asynchronous delegates
</ul><li>Optimizing the Thread Pool
</ul><li>Synchronization
<ul><li>Blocking
<li>Blocking Versus Spinning
</ul><li>Locking
<ul><li>Monitor.Enter and Monitor.Exit
<ul><li>The lockTaken overloads
<li>TryEnter
</ul><li>Choosing the Synchronization Object
<li>When to Lock
<li>Locking and Atomicity
<li>Nested Locking
<li>Deadlocks
<li>Performance
<li>Mutex
<li>Semaphore
</ul><li>Thread Safety
<ul><li>Thread Safety and .NET Framework Types
<ul><li>Locking around thread-safe objects
<li>Static methods
<li>Read-only thread safety
</ul><li>Thread Safety in Application Servers
<li>Rich Client Applications and Thread Affinity
<ul><li>Worker threads versus UI threads
</ul><li>Immutable Objects
</ul><li>Nonblocking Synchronization
<ul><li>Memory Barriers and Volatility
<ul><li>Full fences
<li>The volatile keyword
<li>VolatileRead and VolatileWrite
<li>Memory barriers and locking
</ul><li>Interlocked
</ul><li>Signaling with Event Wait Handles
<ul><li>AutoResetEvent
<ul><li>Two-way signaling
</ul><li>ManualResetEvent
<li>CountdownEvent
<li>Creating a Cross-Process EventWaitHandle
<li>Wait Handles and the Thread Pool
<li>WaitAny, WaitAll, and SignalAndWait
<ul><li>Alternatives to WaitAll and SignalAndWait
</ul></ul><li>Signaling with Wait and Pulse
<ul><li>How to Use Wait and Pulse
<li>Producer/Consumer Queue
<li>Wait Timeouts
<li>Simulating Wait Handles
</ul><li>The Barrier Class
<li>The Event-Based Asynchronous Pattern
<li>BackgroundWorker
<ul><li>Using BackgroundWorker
</ul><li>Interrupt and Abort
<ul><li>Interrupt
<li>Abort
</ul><li>Safe Cancellation
<ul><li>Cancellation Tokens
</ul><li>Lazy Initialization
<ul><li>Lazy<T>
<li>LazyInitializer
</ul><li>Thread-Local Storage
<ul><li>[ThreadStatic]
<li>ThreadLocal<T>
<ul><li>ThreadLocal<T> and instance fields
</ul><li>GetData and SetData
</ul><li>Reader/Writer Locks
<ul><li>Upgradeable Locks and Recursion
<ul><li>Lock recursion
</ul></ul><li>Timers
<ul><li>Multithreaded Timers
<li>Single-Threaded Timers
</ul></ul><li>Chapter 22. Parallel Programming
<ul><li>Why PFX?
<ul><li>PFX Concepts
<li>PFX Components
<li>When to Use PFX
</ul><li>PLINQ
<ul><li>Parallel Execution Ballistics
<li>PLINQ and Ordering
<li>PLINQ Limitations
<li>Example: Parallel Spellchecker
<ul><li>Using ThreadLocal<T>
</ul><li>Functional Purity
<li>Calling Blocking or I/O-Intensive Functions
<ul><li>Changing the degree of parallelism
</ul><li>Cancellation
<li>Optimizing PLINQ
<ul><li>Output-side optimization
<li>Input-side optimization
<li>Optimizing custom aggregations
</ul></ul><li>The Parallel Class
<ul><li>Parallel.Invoke
<li>Parallel.For and Parallel.ForEach
<ul><li>Outer versus inner loops
<li>Indexed Parallel.ForEach
<li>ParallelLoopState: Breaking early out of loops
<li>Optimization with local values
</ul></ul><li>Task Parallelism
<ul><li>Creating and Starting Tasks
<ul><li>Specifying a state object
<li>TaskCreationOptions
<li>Child tasks
</ul><li>Waiting on Tasks
<li>Exception-Handling Tasks
<li>Canceling Tasks
<li>Continuations
<ul><li>Continuations and Task<TResult>
<li>Continuations and exceptions
<li>Continuations and child tasks
<li>Conditional continuations
<li>Continuations with multiple antecedents
<li>Multiple continuations on a single antecedent
</ul><li>Task Schedulers and UIs
<li>TaskFactory
<ul><li>Creating your own task factories
</ul><li>TaskCompletionSource
</ul><li>Working with AggregateException
<ul><li>Flatten and Handle
<ul><li>Flatten
<li>Handle
</ul></ul><li>Concurrent Collections
<ul><li>IProducerConsumerCollection<T>
<li>ConcurrentBag<T>
<li>BlockingCollection<T>
<ul><li>Leveraging TaskCompletionSource
</ul></ul><li>SpinLock and SpinWait
<ul><li>SpinLock
<li>SpinWait
<ul><li>Why we need SpinWait
<li>How to use SpinWait
<li>How SpinWait works
<li>Lock-free updates with SpinWait and Interlocked.CompareExchange
</ul></ul></ul><li>Chapter 23. Asynchronous Methods
<ul><li>Why Asynchronous Methods Exist
<li>Asynchronous Method Signatures
<ul><li>IAsyncResult
</ul><li>Asynchronous Methods Versus Asynchronous Delegates
<li>Using Asynchronous Methods
<li>Asynchronous Methods and Tasks
<li>Writing Asynchronous Methods
<li>Fake Asynchronous Methods
<li>Alternatives to Asynchronous Methods
</ul><li>Chapter 24. Application Domains
<ul><li>Application Domain Architecture
<li>Creating and Destroying Application Domains
<li>Using Multiple Application Domains
<li>Using DoCallBack
<li>Monitoring Application Domains
<li>Domains and Threads
<li>Sharing Data Between Domains
<ul><li>Sharing Data via Slots
<li>Intra-Process Remoting
<li>Isolating Types and Assemblies
<ul><li>Type discovery
</ul></ul></ul><li>Chapter 25. Native and COM
  Interoperability
<ul><li>Calling into Native DLLs
<li>Type Marshaling
<ul><li>Marshaling Common Types
<li>Marshaling Classes and Structs
<li>In and Out Marshaling
</ul><li>Callbacks from Unmanaged Code
<li>Simulating a C Union
<li>Shared Memory
<li>Mapping a Struct to Unmanaged Memory
<ul><li>fixed and fixed {...}
</ul><li>COM Interoperability
<ul><li>The Purpose of COM
<li>The Basics of the COM Type System
<ul><li>IUnknown and IDispatch
</ul></ul><li>Calling a COM Component from C#
<ul><li>Optional Parameters and Named Arguments
<li>Implicit ref Parameters
<li>Indexers
<li>Dynamic Binding
</ul><li>Embedding Interop Types
<ul><li>Type Equivalence
</ul><li>Primary Interop Assemblies
<li>Exposing C# Objects to COM
</ul><li>Chapter 26. Regular Expressions
<ul><li>Regular Expression Basics
<ul><li>Compiled Regular Expressions
<li>RegexOptions
<li>Character Escapes
<li>Character Sets
</ul><li>Quantifiers
<ul><li>Greedy Versus Lazy Quantifiers
</ul><li>Zero-Width Assertions
<ul><li>Lookahead and Lookbehind
<li>Anchors
<li>Word Boundaries
</ul><li>Groups
<ul><li>Named Groups
</ul><li>Replacing and Splitting Text
<ul><li>MatchEvaluator Delegate
<li>Splitting Text
</ul><li>Cookbook Regular Expressions
<ul><li>Recipes
<ul><li>Matching U.S. Social Security number/phone number
<li>Extracting "name = value" pairs (one per line)
<li>Strong password validation
<li>Lines of at least 80 characters
<li>Parsing dates/times (N/N/N H:M:S AM/PM)
<li>Matching Roman numerals
<li>Removing repeated words
<li>Word count
<li>Matching a Guid
<li>Parsing an XML/HTML tag
<li>Splitting a camel-cased word
<li>Obtaining a legal filename
<li>Escaping Unicode characters for HTML
<li>Unescaping characters in an HTTP query string
<li>Parsing Google search terms from a web stats log
</ul></ul><li>Regular Expressions Language Reference
</ul><li>Appendix. C# Keywords
<li>Index
</ul><hr>
</BODY>
</HTML>

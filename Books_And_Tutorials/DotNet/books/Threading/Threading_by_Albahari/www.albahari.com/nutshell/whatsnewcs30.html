<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">

<!-- Mirrored from www.albahari.com/nutshell/whatsnewcs30.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 02 Jan 2014 03:52:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
    <link rel="stylesheet" type="text/css" href="styles.css" /><link rel="stylesheet" type="text/css" media="print" href="print.css" />
    <script type="text/javascript" src="sh_main.min.js"></script>
    <script type="text/javascript" src="sh_csharp.js"></script>
    <link type="text/css" rel="stylesheet" href="sh_style.css" />
    <!--[if IE 6]>
    <link href="ie.css" rel="stylesheet" type="text/css" media="screen" />
    <![endif]-->
    <!--[if IE 7]>
    <link href="ie7.css" rel="stylesheet" type="text/css" media="screen" />
    <![endif]-->
<title>
	What's new in C# 3.0 - Primer
</title></head>
<body onload="sh_highlightDocument();">
    <form name="aspnetForm" method="post" action="http://www.albahari.com/nutshell/whatsnewcs30.aspx" id="aspnetForm">
<div>
<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="/wEPDwUKLTcwODg1MTE2Ng9kFgJmD2QWAgIDD2QWAgILDxYCHgRUZXh0BYwYDQo8dHI+DQogICAgPHRkIGFsaWduPSJjZW50ZXIiIHZhbGlnbj0idG9wIj4NCiAgICAgICAgPHRhYmxlIHdpZHRoPSI5MCUiIGNlbGxwYWRkaW5nPSIwIiBjZWxsc3BhY2luZz0iMCIgY2xhc3M9InNpZGVsaW5rIj4NCiAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICA8dGQgYWxpZ249ImxlZnQiIHZhbGlnbj0iYm90dG9tIj4NCiAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9ImFuaW1hbHNtYWxsLnBuZyIgYWx0PSIiIC8+DQogICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8dGQgYWxpZ249InJpZ2h0IiB2YWxpZ249ImJvdHRvbSI+DQogICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPSJzaWRlbGluayIgaHJlZj0iYWJvdXQuYXNweCI+QWJvdXQgdGhlIEJvb2s8L2E+DQogICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgIDwvdHI+DQogICAgICAgIDwvdGFibGU+DQogICAgPC90ZD4NCjwvdHI+DQo8dHI+DQogICAgPHRkIGFsaWduPSJjZW50ZXIiIHZhbGlnbj0idG9wIj4NCiAgICAgICAmbmJzcDsNCiAgICA8L3RkPg0KPC90cj4NCjx0cj4NCiAgICA8dGQgYWxpZ249ImNlbnRlciIgdmFsaWduPSJ0b3AiPg0KICAgICAgICA8dGFibGUgd2lkdGg9IjkwJSIgY2VsbHBhZGRpbmc9IjAiIGNlbGxzcGFjaW5nPSIwIiBjbGFzcz0ic2lkZWxpbmsiPg0KICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj0ibGVmdCIgdmFsaWduPSJib3R0b20iPg0KICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0iYW5pbWFsc21hbGwucG5nIiBhbHQ9IiIgLz4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj0icmlnaHQiIHZhbGlnbj0iYm90dG9tIj4NCiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9InNpZGVsaW5rIiBocmVmPSJjb2RlLmFzcHgiPkNvZGUgTGlzdGluZ3M8L2E+DQogICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgIDwvdHI+DQogICAgICAgIDwvdGFibGU+DQogICAgPC90ZD4NCjwvdHI+DQo8dHI+DQogICAgPHRkIGFsaWduPSJjZW50ZXIiIHZhbGlnbj0idG9wIj4NCiAgICAgICAmbmJzcDsNCiAgICA8L3RkPg0KPC90cj4NCjx0cj4NCiAgICA8dGQgYWxpZ249ImNlbnRlciIgdmFsaWduPSJ0b3AiPg0KICAgICAgICA8dGFibGUgd2lkdGg9IjkwJSIgY2VsbHBhZGRpbmc9IjAiIGNlbGxzcGFjaW5nPSIwIiBjbGFzcz0ic2lkZWxpbmsiPg0KICAgICAgICAgICAgPHRyPg0KICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj0ibGVmdCIgdmFsaWduPSJib3R0b20iPg0KICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0iYW5pbWFsc21hbGwucG5nIiBhbHQ9IiIgLz4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDx0ZCBhbGlnbj0icmlnaHQiIHZhbGlnbj0iYm90dG9tIj4NCiAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9InNpZGVsaW5rYSIgaHJlZj0iZXh0cmFzLmFzcHgiPkV4dHJhczwvYT4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgPC90cj4NCiAgICAgICAgPC90YWJsZT4NCiAgICA8L3RkPg0KPC90cj4NCjx0cj4NCiAgICA8dGQgYWxpZ249ImNlbnRlciIgdmFsaWduPSJ0b3AiPg0KICAgICAgIDx0YWJsZSB3aWR0aD0iOTAlIiBjZWxscGFkZGluZz0iMCIgY2VsbHNwYWNpbmc9IjAiIGNsYXNzPSJzdWJjb250ZW50Ij48dHI+PHRkIGFsaWduPSJyaWdodCI+PGEgaHJlZj0iZXh0cmFzLmFzcHgiIGNsYXNzPSJzdWJsaW5rIj5MSU5RUGFkPC9hPjwvdGQ+PC90cj4NCiAgICAgICA8dHI+PHRkIGFsaWduPSJyaWdodCI+PGEgaHJlZj0iV2hhdHNOZXdDczQuYXNweCIgY2xhc3M9InN1YmxpbmsiPlZJREVPOiBXaGF0J3MgbmV3IGluIEMjIDQuMDwvYT48L3RkPjwvdHI+DQogICAgICAgPHRyPjx0ZCBhbGlnbj0icmlnaHQiPjxhIGhyZWY9ImxpbnFraXQuYXNweCIgY2xhc3M9InN1YmxpbmsiPkxJTlFLaXQ8L2E+PC90ZD48L3RyPg0KICAgICAgIDx0cj48dGQgYWxpZ249InJpZ2h0Ij48YSBocmVmPSJwcmVkaWNhdGVidWlsZGVyLmFzcHgiIGNsYXNzPSJzdWJsaW5rIj5QcmVkaWNhdGVCdWlsZGVyPC9hPjwvdGQ+PC90cj4NCiAgICAgICA8dHI+PHRkIGFsaWduPSJyaWdodCI+PGEgaHJlZj0ibGlucWJyaWRnZS5hc3B4IiBjbGFzcz0ic3VibGluayI+TElOUUJyaWRnZTwvYT48L3RkPjwvdHI+DQogICAgICAgPHRyPjx0ZCBhbGlnbj0icmlnaHQiPjxhIGhyZWY9ImxpbnFxdWl6LmFzcHgiIGNsYXNzPSJzdWJsaW5rIj5UaGUgTElOUSBRdWl6PC9hPjwvdGQ+PC90cj4NCiAgICAgICA8dHI+PHRkIGFsaWduPSJyaWdodCI+PGEgaHJlZj0iMTBsaW5xbXl0aHMuYXNweCIgY2xhc3M9InN1YmxpbmsiPlRlbiBMSU5RIE15dGhzPC9hPjwvdGQ+PC90cj4NCiAgICAgICA8dHI+PHRkIGFsaWduPSJyaWdodCI+PGEgaHJlZj0iZXh0cmFzLmFzcHgiIGNsYXNzPSJzdWJsaW5rIj5Bc3luY2hyb25hdG9yPC9hPjwvdGQ+PC90cj48L3RhYmxlPg0KICAgIDwvdGQ+DQo8L3RyPg0KPHRyPg0KICAgIDx0ZCBhbGlnbj0iY2VudGVyIiB2YWxpZ249InRvcCI+DQogICAgICAgIDx0YWJsZSB3aWR0aD0iOTAlIiBjZWxscGFkZGluZz0iMCIgY2VsbHNwYWNpbmc9IjAiIGNsYXNzPSJzaWRlbGluayI+DQogICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgPHRkIGFsaWduPSJsZWZ0IiB2YWxpZ249ImJvdHRvbSI+DQogICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPSJhbmltYWxzbWFsbC5wbmciIGFsdD0iIiAvPg0KICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgPHRkIGFsaWduPSJyaWdodCIgdmFsaWduPSJib3R0b20iPg0KICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz0ic2lkZWxpbmsiIGhyZWY9ImNvbnRhY3QuYXNweCI+Q29udGFjdCBBdXRob3JzPC9hPg0KICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICA8L3RyPg0KICAgICAgICA8L3RhYmxlPg0KICAgIDwvdGQ+DQo8L3RyPg0KPHRyPg0KICAgIDx0ZCBhbGlnbj0iY2VudGVyIiB2YWxpZ249InRvcCI+DQogICAgICAgJm5ic3A7DQogICAgPC90ZD4NCjwvdHI+ZGRWeynH/YzCNKMiIwJlHimGx+Dpjw==" />
</div>

    

<div id="maincode">

<h1>What's new in C# 3.0: Primer</h1>
<p>The following extracts from <i>C# 3.0 in a Nutshell</i> explain four of the 
new features of C# 3.0: <b>Lambda Expressions</b>, <b>Extension Methods</b>, <b>
Implicit Typing</b>, and <b>Anonymous Types</b>. These are the core features 
upon which LINQ queries build.</p>
<h2>Lambda Expressions</h2>
<p>A lambda expression is an unnamed method written in place of a delegate 
instance. The compiler immediately converts the lambda expression to either:</p><ul>
	<li>A delegate instance</li>
	<li>An <i>expression tree</i>, of type <span class="lit">Expression&lt;TDelegate&gt;</span>, 
	representing the code inside the lambda expression in a traversable object 
	model. This allows the lambda expression to be interpreted later at runtime.</li>
	</ul>
	<p>Given the following delegate type:<pre>delegate int Transformer (int i);</pre>
	<p>we could assign and invoke the lambda expression<span class="lit"> x =&gt; x 
	* x</span> as follows:</p>
	<pre>Transformer sqr = <b>x =&gt; x * x</b>;
Console.WriteLine (sqr(3));    // 9</pre>
	<p>Internally, the compiler resolves lambda expressions of this type writing 
	a private method, and moving the expression’s code into that method.</p>
	<p>A lambda expression has the following form:</p>
	<pre>(parameters) =&gt; <i>expression-or-statement-block</i></pre>
	<p>For convenience, you can omit the parentheses if and only if there is 
	exactly one parameter of an inferable type. <br>
	In our example, there is a single parameter, <span class="lit">x</span>, and 
	the expression is <span class="lit">x * x</span>:</p>
	<pre>x =&gt; x * x;</pre>
	<p>Each parameter of the lambda expression corresponds to a delegate 
	parameter, and the type of the expression (which may be void) corresponds to 
	the return type of the delegate.</p>
	<p>In our example, <b>x</b> corresponds to parameter <b>i</b>, and the 
	expression <b>x * x</b> corresponds to the return type <b>int</b>, therefore 
	being compatible with the <b>Transformer</b> delegate:</p>
	<pre>delegate int Transformer (int i);</pre>
	<p>A lambda expression’s code can be a statement block instead of an 
	expression. We can rewrite our example as follows:</p>
	<pre>x =&gt; {return x * x;};</pre>
	<h3>Explicitly Specifying Lambda Parameter Types</h3>
	<p>The compiler can usually <i>infer</i> the type of lambda parameters 
	contextually. When this is not the case, you must specify the type of each 
	parameter explicitly. Consider the following delegate type:</p>
	<pre>delegate int Transformer (int i);</pre>
	<p>The compiler uses type inference to infer that <b>x</b> is an <b>int</b>, 
	by examining <b>Transfomer</b>’s parameter type:</p>
	<pre>Transformer d = x =&gt; x * x;</pre>
	<p>We could explicitly specify <b>x</b>’s type as follows:</p>
	<pre>Transformer d = (int x) =&gt; x * x;</pre>
	<h3>Generic Lambda Expressions and the Func Delegates</h3>
	<p>With generic delegates, it becomes possible to write a small set of 
	delegate types that are so general they can work for methods of any return 
	type and any (reasonable) number of arguments. These delegates are the <b>
	Func</b> and <b>Action</b> delegates, defined in the <b>System</b> 
	namespace. Here are the <b>Func</b> delegates (notice that <b>TResult</b> is 
	always the last type parameter):</p>
	<pre>delegate TResult Func &lt;T&gt; ();

delegate TResult Func &lt;T, TResult&gt;
                      (T arg1);

delegate TResult Func &lt;T1, T2, TResult&gt;
                      (T1 arg1, T2 arg2);

delegate TResult Func &lt;T1, T2, T3, TResult&gt;
                      (T1 arg1, T2 arg2, T3 arg3);

delegate TResult Func &lt;T1, T2, T3, T4, TResult&gt;
                      (T1 arg1, T2 arg2, T3 arg3, T4 arg4);</pre>
	<p>Here are the <b>Action</b> delegates:</p>
	<pre>delegate void Action();

delegate void Action &lt;T&gt;
                     (T1 arg1);

delegate void Action &lt;T1, T2&gt;
                     (T1 arg1, T2 arg2);

delegate void Action &lt;T1, T2, T3&gt;
                     (T1 arg1, T2 arg2, T3 arg3);

delegate void Action &lt;T1, T2, T3, T4&gt;
                     (T1 arg1, T2 arg2, T3 arg3, T4 arg4);</pre>
	<p>These delegates are extremely general. The <b>Transformer</b> delegate in 
	our previous example can be replaced with a <b>Func</b> delegate that takes 
	a single <b>int</b> argument and returns an <b>int</b> value:</p>
	<pre>Func&lt;int,int&gt; sqr = x =&gt; x * x;
Console.WriteLine (sqr(3));     // 9</pre>
	<h3>Outer Variables</h3>
	<p>A lambda expression can reference the local variables and parameters of 
	the method in which it’s defined. For example:</p>
	<pre>static void Main()
{
   int factor = 2;
   Func&lt;int, int&gt; multiplier = n =&gt; n * <b>factor</b>;
   Console.WriteLine (multiplier (3));           // 6
}</pre>
	<p>Local variables and parameters referenced by a lambda expression are 
	called <i>outer variables</i> or <i>captured variables</i>. A lambda 
	expression that includes outer variables is called a <i>closure</i>.</p>
	<p>Outer variables are evaluated when the delegate is actually <i>invoked</i>, 
	not when the variables were <i>captured</i>:</p>
	<pre>int factor = 2;
Func&lt;int, int&gt; multiplier = n =&gt; n * factor;
<b>factor = 10;</b>
Console.WriteLine (multiplier (2));   // 20</pre>
	<p>Lambda expressions can themselves update captured variables:</p>
	<pre>int seed = 0;
Func&lt;int&gt; natural = () =&gt; seed++;
Console.WriteLine (natural());      // 0
Console.WriteLine (natural());      // 1</pre>
	<p>Outer variables have their lifetimes extended to that of the delegate. In 
	the following example, the local variable <b>seed</b> would ordinarily 
	disappear from scope when <b>Natural</b> finished executing. But because <b>
	seed</b> has been captured, its lifetime is extended to that of the 
	capturing delegate, <b>natural</b>:</p>
	<pre>static Func&lt;int&gt; Natural()
{
   int seed = 0;
   return () =&gt; seed++; // Returns a <i>closure</i>
}

static void Main()
{
   Func&lt;int&gt; natural = Natural();
   Console.WriteLine (natural()); // 0
   Console.WriteLine (natural()); // 1
}</pre>
	<p>A local variable <i>instantiated</i> within a lambda expression is unique 
	per invocation of the delegate instance. If we refactor our previous example 
	to instantiate <b>seed</b> <i>within</i> the lambda expression, we get a 
	different (in this case, undesirable) result:</p>
	<pre>static Func&lt;int&gt; Natural()
{ 
   return() =&gt; { int seed = 0; return seed++; };
}

static void Main()
{
   NumericSequence natural = Natural();
   Console.WriteLine (natural());      // 0
   Console.WriteLine (natural());      // 0
}</pre>
	<h2>Extension Methods</h2>
	<p><i>Extension methods</i> allow an existing type to be extended with new 
	methods, without altering the definition of the original type. An extension 
	method is a static method of a static class, where the <b>this</b> modifier 
	is applied to the first parameter. The type of the first parameter will be 
	the type that is extended. For example:</p>
	<pre>public static class StringHelper
{
   public static bool IsCapitalized (this string s)
   {
      if (string.IsNullOrEmpty (s)) return false;
      return char.IsUpper (s[0]);
   }
}</pre>
	<p>The <b>IsCapitalized</b> extension method can be called as though it were 
	an instance method on a string, as follows:</p>
	<pre>Console.Write (&quot;Perth&quot;.IsCapitalized());</pre>
	<p>An extension method call, when compiled, is translated back into an 
	ordinary static method call:</p>
	<pre>Console.Write (StringHelper.IsCapitalized (&quot;Perth&quot;));</pre>
	<p>Interfaces can be extended, too:</p>
	<pre>public static T First&lt;T&gt; (this <b>IEnumerable&lt;T&gt;</b> sequence)
{
   foreach (T element in sequence)
      return element;

   throw new InvalidOperationException (&quot;No elements!&quot;);
}
...
Console.WriteLine (&quot;Seattle&quot;.First());   // S</pre>
	<h3>Extension Method Chaining</h3>
	<p>Extension methods, like instance methods, provide a tidy way to chain 
	functions. Consider the following two functions:</p>
	<pre>public static class StringHelper
{
   public static string Pluralize (this string s) {...}
   public static string Capitalize (this string s) {...}
}</pre>
	<p><b>x</b> and <b>y</b> are equivalent and both evaluate to &quot;Sausages&quot;, but
	<b>x</b> uses extension methods, whereas <b>y</b> uses static methods:</p>
	<pre>string x = &quot;sausage&quot;.Pluralize().Capitalize();

string y = StringHelper.Capitalize (StringHelper.Pluralize (&quot;sausage&quot;));</pre>
	<h3>Ambiguity and Resolution</h3>
	<h4>Namespaces</h4>
	<p>An extension method cannot be accessed unless the namespace is in scope 
	(typically imported with a <b>using</b> statement.) </p>
	<h4>Extension methods versus instance methods</h4>
	<p>Any compatible instance method will always take precedence over an 
	extension method. In the following example, <b>Test</b>’s <b>Foo</b> method 
	will always take precedence—even when called with an argument <b>x</b> of 
	type <b>int</b>:</p>
	<pre>class Test
{
   public void Foo (object x) { }    // This method always wins
}

static class Extensions
{
   public static void Foo (this Test t, int x) { }
}</pre>
	<p>The only way to call the extension method in this case is via normal 
	static syntax; in other words, <b>Extensions.Foo(…)</b>.</p>
	<h4>Extension methods versus extension methods</h4>
	<p>If two extension methods have the same signature, the extension method 
	must be called as an ordinary static method to disambiguate the method to 
	call. If one extension method has more specific arguments, however, the more 
	specific method takes precedence.</p>
	<p>To illustrate, consider the following two classes:</p>
	<pre>static class StringHelper
{
   public static bool IsCapitalized (this string s) {...}
}

static class ObjectHelper
{
   public static bool IsCapitalized (this object s) {...}
}</pre>
	<p>The following code calls <b>StringHelper</b>’s <b>IsCapitalized</b> 
	method:</p>
	<pre>bool test1 = &quot;Perth&quot;.IsCapitalized();</pre>
	<p>To call <b>ObjectHelper</b>’s <b>IsCapitalized</b> method, we must 
	specify it explicitly:</p>
	<pre>bool test2 = (ObjectHelper.IsCapitalized (&quot;Perth&quot;));</pre>
	<h2>var—Implicitly Typed Local Variables</h2>
	<p>It is often the case that you declare and initialize a variable in one 
	step. If the compiler is able to infer the type from the initialization 
	expression, you can use the word <b>var</b> in place of the type 
	declaration. For example:</p>
	<pre>var x = 5;
var y = &quot;hello&quot;;
var z = new System.Text.StringBuilder();
var req = (System.Net.FtpWebRequest) System.Net.WebRequest.Create (&quot;...&quot;);</pre>
	<p>This is precisely equivalent to:</p>
	<pre>int x = 5;
string y = &quot;hello&quot;;

System.Text.StringBuilder z = new System.Text.StringBuilder();

System.Net.FtpWebRequest req = 
   (System.Net.FtpWebRequest) System.Net.WebRequest.Create (&quot;...&quot;);</pre>
	<p>Because of this direct equivalence, implicitly typed variables are 
	statically typed. For example, the following generates a compile-time error:</p>
	<pre>var x = 5;
x = &quot;hello&quot;; // Compile-time error; x is of type int</pre>
	<p class="note"><b>var</b> can decrease code readability in the case you 
	can’t deduce the type purely from looking at the variable declaration. For 
	example:<br>
	<br>
	<span class="lit">Random r = new Random();<br>
	var x = r.Next();</span><br>
	<br>
	What type is <b>x</b>?</p>
	<p>Implicit typing is mandatory with <i>anonymous types</i>.</p>
	<h2>Anonymous Types</h2>
	<p>An anonymous type is a simple class created on the fly to store a set of 
	values. To create an anonymous type, you use the <b>new</b> keyword followed 
	by an object initializer, specifying the properties and values the type will 
	contain. For example:</p>
	<pre>var dude = new { Name = &quot;Bob&quot;, Age = 1 };</pre>
	<p>The compiler resolves this by writing a private nested type with 
	read-only properties for <b>Name</b> (type <b>string</b>) and <b>Age</b> 
	(type <b>int</b>). You must use the <b>var </b>keyword to reference an 
	anonymous type, because the type’s name is compiler-generated.</p>
	<p>The property name of an anonymous type can be inferred from an expression 
	that is itself an identifier. For example:</p>
	<pre>int Age = 1;
var dude = new { Name = &quot;Bob&quot;, Age };</pre>
	<p>is equivalent to:</p>
	<pre>var dude = new { Name = &quot;Bob&quot;, Age = Age };</pre>
	<p>Anonymous types are used primarily when writing LINQ queries. <br>
	<br>
&nbsp;</p>

</div>


    <p>
        &nbsp;</p>
    <p>
        <span style="font-size: 80%">© 2007-2012, Joe Albahari, Ben Albahari and O'Reilly Media,
            Inc. All rights reserved</span></p>
    <div id="side">
        
            <table width="100%" cellpadding="0" cellspacing="0" border="0">
                <tr>
                    <td align="center" valign="top">
                        <a href="index.html">
                            <img src="animal.png" alt="C# 5.0 in a Nutshell" />
                        </a>
                    </td>
                </tr>
            </table>
            <div class="shadow">
                <div class="shadowinner">
                    <table width="100%" cellpadding="0" cellspacing="0"
                        border="0" class="sidetable">
                        <tr>
                            <td align="center" valign="middle">
                                <a href="index.html">
                                    <img src="cs50.png" alt="C# 5.0" />
                                </a>
                            </td>
                        </tr>
                        <tr>
                            <td align="center" valign="middle" style="background: #BF2C19">
                                <a href="index.html">
                                    <img src="inanutshell.png" alt="in a Nutshell" />
                                </a>
                            </td>
                        </tr>
                        <tr>
                            <td align="center" valign="middle">
                                <a href="index.html">
                                    <img src="authors.png" alt="Joseph Albahari &amp; Ben Albahari" />
                                </a>
                            </td>
                        </tr>
                       
                        
<tr>
    <td align="center" valign="top">
        <table width="90%" cellpadding="0" cellspacing="0" class="sidelink">
            <tr>
                <td align="left" valign="bottom">
                    <img src="animalsmall.png" alt="" />
                </td>
                <td align="right" valign="bottom">
                    <a class="sidelink" href="about.html">About the Book</a>
                </td>
            </tr>
        </table>
    </td>
</tr>
<tr>
    <td align="center" valign="top">
       &nbsp;
    </td>
</tr>
<tr>
    <td align="center" valign="top">
        <table width="90%" cellpadding="0" cellspacing="0" class="sidelink">
            <tr>
                <td align="left" valign="bottom">
                    <img src="animalsmall.png" alt="" />
                </td>
                <td align="right" valign="bottom">
                    <a class="sidelink" href="code.html">Code Listings</a>
                </td>
            </tr>
        </table>
    </td>
</tr>
<tr>
    <td align="center" valign="top">
       &nbsp;
    </td>
</tr>
<tr>
    <td align="center" valign="top">
        <table width="90%" cellpadding="0" cellspacing="0" class="sidelink">
            <tr>
                <td align="left" valign="bottom">
                    <img src="animalsmall.png" alt="" />
                </td>
                <td align="right" valign="bottom">
                    <a class="sidelinka" href="extras.html">Extras</a>
                </td>
            </tr>
        </table>
    </td>
</tr>
<tr>
    <td align="center" valign="top">
       <table width="90%" cellpadding="0" cellspacing="0" class="subcontent"><tr><td align="right"><a href="extras.html" class="sublink">LINQPad</a></td></tr>
       <tr><td align="right"><a href="WhatsNewCs4-2.html" class="sublink">VIDEO: What's new in C# 4.0</a></td></tr>
       <tr><td align="right"><a href="linqkit.html" class="sublink">LINQKit</a></td></tr>
       <tr><td align="right"><a href="predicatebuilder.html" class="sublink">PredicateBuilder</a></td></tr>
       <tr><td align="right"><a href="linqbridge.html" class="sublink">LINQBridge</a></td></tr>
       <tr><td align="right"><a href="linqquiz.html" class="sublink">The LINQ Quiz</a></td></tr>
       <tr><td align="right"><a href="10linqmyths.html" class="sublink">Ten LINQ Myths</a></td></tr>
       <tr><td align="right"><a href="extras.html" class="sublink">Asynchronator</a></td></tr></table>
    </td>
</tr>
<tr>
    <td align="center" valign="top">
        <table width="90%" cellpadding="0" cellspacing="0" class="sidelink">
            <tr>
                <td align="left" valign="bottom">
                    <img src="animalsmall.png" alt="" />
                </td>
                <td align="right" valign="bottom">
                    <a class="sidelink" href="contact.html">Contact Authors</a>
                </td>
            </tr>
        </table>
    </td>
</tr>
<tr>
    <td align="center" valign="top">
       &nbsp;
    </td>
</tr>
                    </table>
                </div>
            </div>
            <div style="margin-top: 0.5em">
                <table>
                    <tr>
                        <td>
                            <a href="http://www.amazon.com/gp/product/1449320104?ie=UTF8&amp;tag=cinanu-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=1449320104">
                                <img src="amazon.gif" alt="Buy from amazon.com" />
                            </a>
                        </td>
                        <td>
                            Available now
                        </td>
                    </tr>
                </table>
            </div>
        
    </div>
    </form>
</body>

<!-- Mirrored from www.albahari.com/nutshell/whatsnewcs30.aspx by HTTrack Website Copier/3.x [XR&CO'2008], Thu, 02 Jan 2014 03:52:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8"><!-- /Added by HTTrack -->
</html>

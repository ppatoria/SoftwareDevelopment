<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Memory Management in C#</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-12-29 22:58:48 "/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title">Memory Management in C#</h1>


<meta http-equiv="Content-Style-Type" content="text/css">
<link rel="stylesheet" href="org-style.css" type="text/css" />
<style type="text/css"/><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
<div id="postamble">
<p class="author"> Author: Pralay Patoria
<a href="mailto:ppatoria@gmail.com">&lt;ppatoria@gmail.com&gt;</a>
</p>
<p class="date"> Date: 24-12-2013</p>
</div>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 What Causes Finalize Methods to Be Called? </a>
<ul>
<li><a href="#sec-1_1">1.1 Generation 0 is full. </a></li>
<li><a href="#sec-1_2">1.2 Code explicitly calls System.GC’s static Collect method. </a></li>
<li><a href="#sec-1_3">1.3 Windows is reporting low memory conditions. </a></li>
<li><a href="#sec-1_4">1.4 The CLR is unloading an AppDomain. </a></li>
<li><a href="#sec-1_5">1.5 The CLR is shutting down. </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Garbage Collection. </a>
<ul>
<li><a href="#sec-2_1">2.1 Finalization </a></li>
<li><a href="#sec-2_2">2.2 Generations </a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> What Causes Finalize Methods to Be Called? </h2>
<div class="outline-text-2" id="text-1">


<p>
Finalize methods are called at the completion of a garbage collection, which is started by
one of the following five events:
</p>

</div>

<div id="outline-container-1_1" class="outline-3">
<h3 id="sec-1_1"><span class="section-number-3">1.1</span> Generation 0 is full. </h3>
<div class="outline-text-3" id="text-1_1">

<p>When generation 0 is full, a garbage collection starts. This event is
by far the most common way for Finalize methods to be called because
it occurs naturally as the application code runs, allocating new objects.
</p>
</div>

</div>

<div id="outline-container-1_2" class="outline-3">
<h3 id="sec-1_2"><span class="section-number-3">1.2</span> Code explicitly calls System.GC’s static Collect method. </h3>
<div class="outline-text-3" id="text-1_2">

<p>Code can explicitly request that the CLR perform a
collection. Although Microsoft strongly discourages such requests, at
times it might make sense for an application to force a collection.
</p>
</div>

</div>

<div id="outline-container-1_3" class="outline-3">
<h3 id="sec-1_3"><span class="section-number-3">1.3</span> Windows is reporting low memory conditions. </h3>
<div class="outline-text-3" id="text-1_3">

<p>The CLR internally uses the Win32 CreateMemoryResourceNotification and
QueryMemoryResourceNotification functions to monitor system memory
overall. If Windows reports low memory, the CLR will force a garbage
collection in an effort to free up dead objects to reduce the size of a process’s working set.
</p>
</div>

</div>

<div id="outline-container-1_4" class="outline-3">
<h3 id="sec-1_4"><span class="section-number-3">1.4</span> The CLR is unloading an AppDomain. </h3>
<div class="outline-text-3" id="text-1_4">

<p>When an AppDomain unloads, the CLR considers nothing in the AppDomain
to be a root, and a garbage collection consisting of all generations
is performed. I’ll discuss AppDomains in Chapter 22, “CLR
Hosting and AppDomains.”
</p>
</div>

</div>

<div id="outline-container-1_5" class="outline-3">
<h3 id="sec-1_5"><span class="section-number-3">1.5</span> The CLR is shutting down. </h3>
<div class="outline-text-3" id="text-1_5">

<p>The CLR shuts down when a process terminates normally (as opposed to
an external shutdown via Task Manager, for example). During this
shutdown, the CLR considers nothing in the process to be a root and
calls the Finalize method for all objects in the managed heap. Note
that the CLR does not attempt to compact or free memory here because
the whole process is terminating, and Windows will reclaim all of the
processes’ memory.
</p>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Garbage Collection. </h2>
<div class="outline-text-2" id="text-2">


<p>
<a href="#sec-2"><img src="gc1.jpg"/></a>
</p>
<p>
<b>Figure 1 Managed Heap</b>
</p>
<p>
<b>Figure 1</b> shows a managed heap consisting of three objects: A, B, and C. The next object to be allocated will be placed where NextObjPtr points (immediately after object C).
When a process is initialized, the runtime reserves a contiguous region of address space that initially has no storage allocated for it. This address space region is the managed heap. The heap also maintains a pointer, which I'll call the NextObjPtr. This pointer indicates where the next object is to be allocated within the heap. Initially, the NextObjPtr is set to the base address of the reserved address space region.
An application creates an object using the new operator. This operator first makes sure that the bytes required by the new object fit in the reserved region (committing storage if necessary). If the object fits, then NextObjPtr points to the object in the heap, this object's constructor is called, and the new operator returns the address of the object. 
</p>
<p>
At this point, NextObjPtr is incremented past the object so that it points to where the next object will be placed in the heap. Figure 1 shows a managed heap consisting of three objects: A, B, and C. The next object to be allocated will be placed where NextObjPtr points (immediately after object C).
</p>
<p>
<a href="#sec-2"><img src="gc2.jpg"/></a>
</p>
<p>
<b>Figure 2 Allocated Objects in Heap</b>
</p>
<p>
<b>Figure 2</b> shows a heap with several allocated objects where the application's roots refer directly to objects A, C, D, and F. All of these objects become part of the graph. When adding object D, the collector notices that this object refers to object H, and object H is also added to the graph. The collector continues to walk through all reachable objects recursively. 
</p>
<p>
<b>Roots</b> <br/>
Every application has a set of roots. Roots identify storage locations, which refer to objects on the managed heap or to objects that are set to null. 
For example, all the global and static object pointers in an application are considered part of the application's roots. 
In addition, any local variable/parameter object pointers on a thread's stack are considered part of the application's roots. 
Finally, any CPU registers containing pointers to objects in the managed heap are also considered part of the application's roots. 
The list of active roots is maintained by the just-in-time (JIT) compiler and common language runtime, and is made accessible to the garbage collector's algorithm.
</p>
<p>
<a href="#sec-2"><img src="gc3.jpg"/></a>
</p>
<p>
<b>Figure 3 Managed Heap after Collection</b>
</p>
<p>
After all the garbage has been identified, all the non-garbage has been compacted, and all the non-garbage pointers have been fixed-up, the NextObjPtr is positioned just after the last non-garbage object. At this point, the new operation is tried again and the resource requested by the application is successfully created.
</p>


</div>

<div id="outline-container-2_1" class="outline-3">
<h3 id="sec-2_1"><span class="section-number-3">2.1</span> Finalization </h3>
<div class="outline-text-3" id="text-2_1">

<p><a href="#sec-2_1"><img src="gc4.jpg"/></a>
</p>
<p>
<b>Figure 4 A Heap with Many Objects</b> 
</p>
<p>
<b>Figure 4</b> shows a heap containing several objects. Some of these objects are reachable from the application's roots, and some are not. When objects C, E, F, I, and J were created, the system detected that these objects had Finalize methods and pointers to these objects were added to the finalization queue. 
</p>

<p>
<a href="#sec-2_1"><img src="gc5.jpg"/></a>
</p>
<p>
<b>Figure 5 Managed Heap after Garbage Collection</b>
</p>
<p>
After the collection, the managed heap looks like **Figure 5**. Here, you see that the memory occupied by objects B, G, and H has been reclaimed because these objects did not have a Finalize method that needed to be called. However, the memory occupied by objects E, I, and J could not be reclaimed because their Finalize method has not been called yet. 
</p>
<p>
<a href="#sec-2_1"><img src="gc6.jpg"/></a>
</p>
<p>
<b>Figure 6 Managed Heap after Second Garbage Collection</b>
</p>
<p>
**Figure 6** shows what the managed heap looks like after the second GC. 
</p>

</div>

</div>

<div id="outline-container-2_2" class="outline-3">
<h3 id="sec-2_2"><span class="section-number-3">2.2</span> Generations </h3>
<div class="outline-text-3" id="text-2_2">


<p>
A generational garbage collector (also known as an ephemeral garbage collector) makes the following assumptions:
</p><ul>
<li>
The newer an object is, the shorter its lifetime will be.
</li>
<li>
The older an object is, the longer its lifetime will be.
</li>
<li>
Newer objects tend to have strong relationships to each other and are frequently accessed around the same time.
</li>
<li>
Compacting a portion of the heap is faster than compacting the whole heap.

</li>
</ul>

<p>When initialized, the managed heap contains no objects. Objects added to the heap are said to be in generation 0, as you can see in **Figure 2**. Stated simply, objects in generation 0 are young objects that have never been examined by the garbage collector.
</p>
<p>
<a href="#sec-2_2"><img src="gc7.jpg"/></a>
</p>
<p>
<b>Figure 2 Generation 0</b>
</p>
<p>
Now, if more objects are added to the heap, the heap fills and a garbage collection must occur. When the garbage collector analyzes the heap, it builds the graph of garbage (shown here in purple) and non-garbage objects. Any objects that survive the collection are compacted into the left-most portion of the heap. These objects have survived a collection, are older, and are now considered to be in generation 1 (see **Figure 3**).
</p>
<p>
<a href="#sec-2_2"><img src="gc8.jpg"/></a>
</p>
<p>
<b>Figure 3 Generations 0 and 1</b>
</p>
<p>
As even more objects are added to the heap, these new, young objects are placed in generation 0. If generation 0 fills again, a GC is performed. This time, all objects in generation 1 that survive are compacted and considered to be in generation 2 (see **Figure 4**). All survivors in generation 0 are now compacted and considered to be in generation 1. Generation 0 currently contains no objects, but all new objects will go into generation 0.
</p>

<p>
<a href="#sec-2_2"><img src="gc9.jpg"/></a>
</p>
<p>
<b>Figure 4 Generations 0, 1, and 2</b>
</p>
<p>
Currently, generation 2 is the highest generation supported by the runtime's garbage collector. When future collections occur, any surviving objects currently in generation 2 simply stay in generation 2. 
</p>
</div>
</div>
</div>
<div id="postamble">
<p class="date"> Date: 2013-12-29 22:58:48 </p>
</div>
</div>
</body>
</html>

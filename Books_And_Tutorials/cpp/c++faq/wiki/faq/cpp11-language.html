<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/cpp11-language by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="24eabbcdf0c3eeef6f81e907e00185a2cc529de2" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="63ade7ba7169d17e795540196ef78fab987f5c20" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="9bd4058c8ec99b525bd6002c50eb25f5cfceea66" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        cpp11 language
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="cpp11-language.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    cpp11 language
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=cpp11%20language" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="cpp11-language">C++11 Language Extensions &#8212; General Features</h2>

<h3 id="auto"><code>auto</code></h3>

<p>Consider</p>

<pre><code>    auto x = 7;
</code></pre>

<p>Here <code>x</code> will have the type <code>int</code> because that&#8217;s the type of its initializer. In general, we can write</p>

<pre><code>    auto x = expression;
</code></pre>

<p>and the type of <code>x</code> will be the type of the value computed from &#8220;expression&#8221;.</p>

<p>The use of <code>auto</code> to deduce the type of a variable from its initializer is obviously most useful when that type is either hard to know exactly or hard to write. Consider:</p>

<pre><code>    template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
    {
        for (auto p = v.begin(); p!=v.end(); ++p)
            cout &lt;&lt; *p &lt;&lt; "\n";
    }
</code></pre>

<p>In C++98, we&#8217;d have to write</p>

<pre><code>    template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
    {
        for (typename vector&lt;T&gt;::const_iterator p = v.begin(); p!=v.end(); ++p)
            cout &lt;&lt; *p &lt;&lt; "\n";
    }
</code></pre>

<p>When the type of a variable depends critically on template argument it can be really hard to write code without <code>auto</code>. For example:</p>

<pre><code>    template&lt;class T, class U&gt; void multiply(const vector&lt;T&gt;&amp; vt, const vector&lt;U&gt;&amp; vu)
    {
        // ...
        auto tmp = vt[i]*vu[i];
        // ...
    }
</code></pre>

<p>The type of <code>tmp</code> should be what you get from multiplying a <code>T</code> by a <code>U</code>, but exactly what that is can be hard for the human reader to figure out, though of course the compiler knows once it has figured out what particular <code>T</code> and <code>U</code> it is dealing with.</p>

<p>The <code>auto</code> feature has the distinction to be the earliest to be suggested and implemented: Stroustrup had it working in his Cfront implementation in early 1984, but was forced to take it out because of C compatibility problems. Those compatibility problems disappeared when C++98 and C99 accepted the removal of &#8220;implicit <code>int</code>&#8221;; that is, both languages now require every variable and function to be defined with an explicit type. The old meaning of <code>auto</code> (namely &#8220;this is a local variable&#8221;) is now illegal. Several committee members trawled through millions of lines of code finding only a handful of uses &#8211; and most of those were in test suites or appeared to be bugs.</p>

<p>Being primarily a facility to simplify notation in code, <code>auto</code> does not affect the standard library specification.</p>

<p>See also:</p>

<ul>
<li>the C++ draft section 7.1.6.2, 7.1.6.4, 8.3.5 (for return types) </li>
<li>[N1984=06-0054] Jaakko Jarvi, Bjarne Stroustrup, and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">Deducing the type of variable from its initializer expression (revision 4)</a>.</li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/06/07/gotw-92-solution-auto-variables-part-1/">GotW #92: Auto Variables, Part 1</a></li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/">GotW #93: Auto Variables, Part 2</a></li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">GotW #94: AAA Style (Almost Always Auto)</a></li>
</ul>

<h3 id="decltype"><code>decltype</code></h3>

<p><code>decltype(E)</code> is the type (&#8220;declared type&#8221;) of the name or expression <code>E</code> and can be used in declarations. For example:</p>

<pre><code>    void f(const vector&lt;int&gt;&amp; a, vector&lt;float&gt;&amp; b)
    {
        typedef decltype(a[0]*b[0]) Tmp;
        for (int i=0; i&lt;b.size(); ++i) {
            Tmp* p = new Tmp(a[i]*b[i]);
            // ...
        }
        // ...
    }
</code></pre>

<p>This notion has been popular in generic programming under the label &#8220;typeof&#8221; for a long time, but the &#8220;typeof&#8221; implementations in actual use were incomplete and incompatible, so the standard version is named <code>decltype</code>.</p>

<p>Note: Prefer just using <a href="cpp11-language.html#auto" title="FAQ: auto"><code>auto</code></a> when you just need the type for a variable that you are about to initialize. You really need <code>decltype</code> if you need a type for something that is not a variable, such as a <a href="cpp11-language-misc.html#suffix-return" title="FAQ: Suffix return type syntax">return type</a>.</p>

<p>See also:</p>

<ul>
<li>the C++ draft 7.1.6.2 Simple type specifiers </li>
<li>[Str02] Bjarne Stroustrup. Draft proposal for &#8220;typeof&#8221;. C++ reflector message c++std-ext-5364, October 2002. (original suggestion). </li>
<li>[N1478=03-0061] Jaakko Jarvi, Bjarne Stroustrup, Douglas Gregor, and Jeremy Siek: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf">Decltype and auto</a> (original proposal). </li>
<li>[N2343=07-0203] Jaakko Jarvi, Bjarne Stroustrup, and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">Decltype (revision 7): proposed wording</a>. </li>
</ul>

<h3 id="range-for">Range-<code>for</code> statement</h3>

<p>A range <code>for</code> statement allows you to iterate through a &#8220;range&#8221;, which is anything you can iterate through like an STL-sequence defined by a <code>begin()</code> and <code>end()</code>. All standard containers can be used as a range, as can a <code>std::string</code>, an initializer list, an array, and anything for which you define <code>begin()</code> and <code>end()</code>, e.g. an istream. For example:</p>

<pre><code>void f(vector&lt;double&gt;&amp; v)
{
    for (auto x : v) cout &lt;&lt; x &lt;&lt; '\n';
    for (auto&amp; x : v) ++x;  // using a reference to allow us to change the value
}
</code></pre>

<p>You can read that as &#8220;for all <code>x</code> in <code>v</code>&#8221; going through starting with <code>v.begin()</code> and iterating to <code>v.end()</code>. Another example:</p>

<pre><code>    for (const auto x : { 1,2,3,5,8,13,21,34 }) cout &lt;&lt; x &lt;&lt; '\n';
</code></pre>

<p>The <code>begin()</code> (and <code>end()</code>) can be a member to be called as <code>x.begin()</code> or a free-standing function to be called as <code>begin(x)</code>. The member version takes precedence.</p>

<p>See also:</p>

<ul>
<li>the C++ draft section 6.5.4 (note: changed not to use concepts) </li>
<li>[N2243==07-0103] Thorsten Ottosen: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">Wording for range-based for-loop (revision 2)</a>. </li>
<li>[N3257=11-0027 ] Jonathan Wakely and Bjarne Stroustrup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf">Range-based for statements and ADL</a> (Option 5 was chosen). </li>
</ul>

<h3 id="init-list">Initializer lists</h3>

<p>Consider</p>

<pre><code>    vector&lt;double&gt; v = { 1, 2, 3.456, 99.99 };
    list&lt;pair&lt;string,string&gt;&gt; languages = {
        {"Nygaard","Simula"}, {"Richards","BCPL"}, {"Ritchie","C"}
    }; 
    map&lt;vector&lt;string&gt;,vector&lt;int&gt;&gt; years = {
        { {"Maurice","Vincent", "Wilkes"},{1913, 1945, 1951, 1967, 2000} },
        { {"Martin", "Ritchards"}, {1982, 2003, 2007} }, 
        { {"David", "John", "Wheeler"}, {1927, 1947, 1951, 2004} }
    }; 
</code></pre>

<p>Initializer lists are not just for arrays any more. The mechanism for accepting a <code>{}</code>-list is a function (often a constructor) accepting an argument of type <code>std::initializer_list&lt;T&gt;</code>. For example:</p>

<pre><code>    void f(initializer_list&lt;int&gt;);
    f({1,2});
    f({23,345,4567,56789});
    f({});  // the empty list
    f{1,2}; // error: function call ( ) missing

    years.insert({{"Bjarne","Stroustrup"},{1950, 1975, 1985}});
</code></pre>

<p>The initializer list can be of arbitrary length, but must be homogeneous (all elements must be of the template argument type, <code>T</code>, or convertible to <code>T</code>).</p>

<p>A container might implement an initializer-list constructor like this:</p>

<pre><code>    template&lt;class E&gt; class vector {
    public:
        vector (std::initializer_list&lt;E&gt; s) // initializer-list constructor
        {
                reserve(s.size());  // get the right amount of space
                uninitialized_copy(s.begin(), s.end(), elem);   // initialize elements (in elem[0:s.size()))
            sz = s.size();  // set vector size
        }

        // ... as before ...
    };
</code></pre>

<p>The distinction between direct initialization and copy initialization is maintained for <code>{}</code>-initialization, but becomes relevant less frequently because of <code>{}</code>-initialization. For example, <code>std::vector</code> has an <code>explicit</code> constructor from <code>int</code> and an <code>initializer_list</code> constructor:</p>

<pre><code>    vector&lt;double&gt; v1(7);   // ok: v1 has 7 elements
    v1 = 9;                 // error: no conversion from int to vector
    vector&lt;double&gt; v2 = 9;  // error: no conversion from int to vector

    void f(const vector&lt;double&gt;&amp;);
    f(9);                           // error: no conversion from int to vector

    vector&lt;double&gt; v1{7};           // ok: v1 has 1 element (with its value 7.0)
    v1 = {9};                       // ok v1 now has 1 element (with its value 9.0)
    vector&lt;double&gt; v2 = {9};        // ok: v2 has 1 element (with its value 9.0)
    f({9});                         // ok: f is called with the list { 9 }

    vector&lt;vector&lt;double&gt;&gt; vs = {
        vector&lt;double&gt;(10),         // ok: explicit construction (10 elements)
        vector&lt;double&gt;{10},         // ok explicit construction (1 element with the value 10.0)
        10                          // error: vector's constructor is explicit
    };  
</code></pre>

<p>The function can access the <code>initializer_list</code> as an immutable sequence. For example:</p>

<pre><code>    void f(initializer_list&lt;int&gt; args)
    {
        for (auto p=args.begin(); p!=args.end(); ++p) cout &lt;&lt; *p &lt;&lt; "\n";
    }
</code></pre>

<p>A constructor that takes a single argument of type <code>std::initializer_list</code> is called an initializer-list constructor.</p>

<p>The standard library containers, <code>string</code>, and <code>regex</code> have initializer-list constructors, assignment, etc. An initializer-list can be used as a range, e.g. in a <a href="cpp11-language.html#range-for" title="FAQ: Range-for statement">range for statement</a>.</p>

<p>The initializer lists are part of the scheme for <a href="cpp11-language.html#uniform-init" title="FAQ: Uniform initialization syntax and semantics">uniform and general initialization</a>. They also <a href="cpp11-language-misc.html#cpp11-narrowing" title="FAQ: Preventing narrowing">prevent narrowing</a>. In general, you should usually prefer initializing using <code>{}</code> instead of <code>()</code> unless you want to share code with a C++98 compiler or (rarely) need to use <code>()</code> to call a non-<code>initializer_list</code> overloaded constructor.</p>

<p>See also:</p>

<ul>
<li>the C++ draft 8.5.4 List-initialization [dcl.init.list] </li>
<li>[N1890=05-0150 ] Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">Initialization and initializers</a> (an overview of initialization-related problems with suggested solutions). </li>
<li>[N1919=05-0179] Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">Initializer lists</a>. </li>
<li>[N2215=07-0075] Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">Initializer lists (Rev. 3)</a>. </li>
<li>[N2640=08-0150] Jason Merrill and Daveed Vandevoorde: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">Initializer Lists &#8211; Alternative Mechanism and Rationale (v. 2)</a> (final proposal). </li>
</ul>

<h3 id="uniform-init">Uniform initialization syntax and semantics</h3>

<p>C++98 offers several ways of initializing an object depending on its type and the initialization context. When misused, the error can be surprising and the error messages obscure. Consider:</p>

<pre><code>    string a[] = { "foo", " bar" };          // ok: initialize array variable
    vector&lt;string&gt; v = { "foo", " bar" };    // error: initializer list for non-aggregate vector
    void f(string a[]);
    f( { "foo", " bar" } );                  // syntax error: block as argument
</code></pre>

<p>and</p>

<pre><code>    int a = 2;              // "assignment style"
    int aa[] = { 2, 3 };    // assignment style with list
    complex z(1,2);         // "functional style" initialization
    x = Ptr(y);             // "functional style" for conversion/cast/construction
</code></pre>

<p>and</p>

<pre><code>    int a(1);   // variable definition
    int b();    // function declaration
    int b(foo); // variable definition or function declaration
</code></pre>

<p>It can be hard to remember the rules for initialization and to choose the best way.</p>

<p>The C++11 solution is to allow <code>{}</code>-initializer lists for all initialization:</p>

<pre><code>    X x1 = X{1,2}; 
    X x2 = {1,2};   // the = is optional
    X x3{1,2}; 
    X* p = new X{1,2}; 

    struct D : X {
        D(int x, int y) :X{x,y} { /* ... */ };
    };

    struct S {
        int a[3];
        S(int x, int y, int z) :a{x,y,z} { /* ... */ }; // solution to old problem
    };
</code></pre>

<p>Importantly, <code>X{a}</code> constructs the same value in every context, so that <code>{}</code>-initialization gives the same result in all places where it is legal. For example:</p>

<pre><code>    X x{a}; 
    X* p = new X{a};
    z = X{a};         // use as cast
    f({a});           // function argument (of type X)
    return {a};       // function return value (function returning X)
</code></pre>

<p>C++11 uniform initialization is not perfectly uniform, but it&#8217;s very nearly so. C++11&#8217;s <code>{}</code> initialization syntax and semantics provide a much simpler and consistent way to perform initialization, that is also more powerful (e.g., <code>vector&lt;int&gt; v = { 1, 2, 3, 4 }</code>) and safer (e.g., <code>{}</code> does not allow narrowing conversions). Prefer initializing using <code>{}</code>.</p>

<p>See also:</p>

<ul>
<li>[N2215==07-0075 ] Bjarne Stroustrup and Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">Initializer lists (Rev. 3)</a>. </li>
<li>[N2640==08-0150] Jason Merrill and Daveed Vandevoorde: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">Initializer Lists &#8211; Alternative Mechanism and Rationale (v. 2)</a> (final proposal). </li>
</ul>

<h3 id="rval">Rvalue references and move semantics</h3>

<p>The distinction between lvalues (what can be used on the left-hand side of an assignment) and rvalues (what can be used on the right-hand side of an assignment) goes back to Christopher Strachey (the father of C++&#8217;s distant ancestor CPL and of denotational semantics). In C++98, references to non-<code>const</code> can bind to lvalues and references to <code>const</code> can bind to lvalues or rvalues, but there is nothing that can bind to a non-<code>const</code> rvalue. That&#8217;s to protect people from changing the values of temporaries that are destroyed before their new value can be used. For example:</p>

<pre><code>    void incr(int&amp; a) { ++a; }
    int i = 0;
    incr(i);    // i becomes 1
    incr(0);    // error: 0 in not an lvalue
</code></pre>

<p>If that <code>incr(0)</code> were allowed either some temporary that nobody ever saw would be incremented or &#8211; far worse &#8211; the value of <code>0</code> would become <code>1</code>. The latter sounds silly, but there was actually a bug like that in early Fortran compilers that set aside a memory location to hold the value <code>0</code>.</p>

<p>So far, so good, but consider</p>

<pre><code>    template&lt;class T&gt; swap(T&amp; a, T&amp; b)      // "old style swap"
    {
        T tmp(a);   // now we have two copies of a
        a = b;      // now we have two copies of b
        b = tmp;    // now we have two copies of tmp (aka a)
    } 
</code></pre>

<p>If <code>T</code> is a type for which it can be expensive to copy elements, such as <code>string</code> and <code>vector</code>, <code>swap</code> becomes an expensive operation (for the standard library, we have specializations of <code>string</code> and <code>vector</code> <code>swap()</code> to deal with that). Note something curious: We didn&#8217;t want any copies at all. We just wanted to move the values of <code>a</code>, <code>b</code>, and <code>tmp</code> around a bit.</p>

<p>In C++11, we can define &#8220;move constructors&#8221; and &#8220;move assignments&#8221; to move rather than copy their argument:</p>

<pre><code>    template&lt;class T&gt; class vector {
        // ...
        vector(const vector&amp;);          // copy constructor
        vector(vector&amp;&amp;);           // move constructor
        vector&amp; operator=(const vector&amp;);   // copy assignment
        vector&amp; operator=(vector&amp;&amp;);        // move assignment
    };  // note: move constructor and move assignment takes non-const &amp;&amp;
        // they can, and usually do, write to their argument
</code></pre>

<p>The <code>&amp;&amp;</code> indicates an &#8220;rvalue reference&#8221;. An rvalue reference can bind to an rvalue (but not to an lvalue):</p>

<pre><code>    X a;
    X f();
    X&amp; r1 = a;      // bind r1 to a (an lvalue)
    X&amp; r2 = f();        // error: f() is an rvalue; can't bind

    X&amp;&amp; rr1 = f();  // fine: bind rr1 to temporary
    X&amp;&amp; rr2 = a;    // error: bind a is an lvalue
</code></pre>

<p>The idea behind a move assignment is that instead of making a copy, it simply takes the representation from its source and replaces it with a cheap default. For example, for <code>string</code>s <code>s1=s2</code> using the move assignment would not make a copy of <code>s2</code>&#8217;s characters; instead, it would just let <code>s1</code> treat those characters as its own and somehow delete <code>s1</code>&#8217;s old characters (maybe by leaving them in <code>s2</code>, which presumably is just about to be destroyed).</p>

<p>How do we know whether it&#8217;s ok to simply move from a source? We tell the compiler:</p>

<pre><code>    template&lt;class T&gt; 
    void swap(T&amp; a, T&amp; b)   // "perfect swap" (almost)
    {
        T tmp = move(a);    // could invalidate a
        a = move(b);        // could invalidate b
        b = move(tmp);      // could invalidate tmp
    }
</code></pre>

<p><code>move(x)</code> is <em>just a cast</em> that means &#8220;you can treat <code>x</code> as an rvalue&#8221;. Maybe it would have been better if <code>move()</code> had been called <code>rval()</code>, but by now <code>move()</code> has been used for years. The <code>move()</code> template function can be written in C++11 (see the &#8220;brief introduction&#8221;) and and uses rvalue references.</p>

<p>Rvalue references can also be used to provide perfect forwarding.</p>

<p>In the C++11 standard library, all containers are provided with move constructors and move assignments, and operations that insert new elements, such as <code>insert()</code> and <code>push_back()</code>, have versions that take rvalue references. The net result is that the standard containers and algorithms quietly &#8211; without user intervention &#8211; improve in performance because they copy less.</p>

<p>See also:</p>

<ul>
<li>N1385 N1690 N1770 N1855 N1952 </li>
<li>[N2027==06-0097] Howard Hinnant, Bjarne Stroustrup, and Bronek Kozicki: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">A brief introduction to rvalue references</a> </li>
<li>[N1377=02-0035] Howard E. Hinnant, Peter Dimov, and Dave Abrahams: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language (original proposal)</a>. </li>
<li>[N2118=06-0188] Howard Hinnant: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html">A Proposal to Add an Rvalue Reference to the C++ Language Proposed Wording (Revision 3)</a> (final proposal). </li>
</ul>

<h3 id="lambda">Lambdas</h3>

<p>A lambda expression is a mechanism for specifying a function object. The primary use for a lambda is to specify a simple action to be performed by some function. For example:</p>

<pre><code>    vector&lt;int&gt; v = {50, -10, 20, -30};

    std::sort(v.begin(), v.end());  // the default sort
    // now v should be { -30, -10, 20, 50 }

    // sort by absolute value:
    std::sort(v.begin(), v.end(), [](int a, int b) { return abs(a)&lt;abs(b); });
    // now v should be { -10, 20, -30, 50 }
</code></pre>

<p>The argument <code>[](int a, int b) { return abs(a)&lt;abs(b); }</code> is a &#8220;lambda&#8221; (or &#8220;lambda function&#8221; or &#8220;lambda expression&#8221;), which specifies an operation that given two integer arguments <code>a</code> and <code>b</code> returns the result of comparing their absolute values.</p>

<p>A lambda expression can access local variables in the scope in which it is used. For example:</p>

<pre><code>    void f(vector&lt;Record&gt;&amp; v)
    {
        vector&lt;int&gt; indices(v.size());
        int count = 0;
        generate(indices.begin(),indices.end(),[&amp;count](){ return count++; });

        // sort indices in the order determined by the name field of the records:
        std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) { return v[a].name&lt;v[b].name; });
        // ...
    }
</code></pre>

<p>Some consider this &#8220;really neat!&#8221;; others see it as a way to write dangerously obscure code. Both are right.</p>

<p>The <code>[&amp;]</code> is a &#8220;capture list&#8221; specifying that local names used will be passed by reference. Had we wanted to &#8220;capture&#8221; only <code>v</code>, we could have said so: <code>[&amp;v]</code>. Had we wanted to pass <code>v</code> by value, we could have said so: <code>[=v]</code> or <code>[v]</code>. Capture nothing is <code>[]</code>, capture all by reference is <code>[&amp;]</code>, and capture all by value is <code>[=]</code>.</p>

<p>If an action is neither common nor simple, consider using a named function object or function. For example, the example above could have been written:</p>

<pre><code>    void f(vector&lt;Record&gt;&amp; v)
    {
        vector&lt;int&gt; indices(v.size());
        int count = 0;
        generate(indices.begin(),indices.end(),[&amp;](){ return ++count; });

        struct Cmp_names {
            const vector&lt;Record&gt;&amp; vr;
            Cmp_names(const vector&lt;Record&gt;&amp; r) :vr(r) { }
            bool operator()(int a, int b) const { return vr[a].name&lt;vr[b].name; }
        };

        // sort indices in the order determined by the name field of the records:
        std::sort(indices.begin(), indices.end(), Cmp_names(v));
        // ...
    }
</code></pre>

<p>For a tiny function, such as this <code>Record</code> name field comparison, the function object notation is verbose, though the generated code is likely to be identical. In C++98, such function objects had to be non-local to be used as template argument; in C++ <a href="cpp11-language-templates.html#local-types" title="FAQ: Local types as template arguments">this is no longer necessary</a>.</p>

<p>To specify a lambda you must provide</p>

<ul>
<li>Its capture list: the list of variables it can use (in addition to its arguments), if any (<code>[&amp;]</code> meaning &#8220;all local variables passed by reference&#8221; in the Record comparison example). If no names need to be captured, a lambda starts with plain <code>[]</code>. </li>
<li>(optionally) Its arguments and their types (e.g, <code>(int a, int b)</code>) </li>
<li>The action to be performed as a block (e.g., <code>{ return v[a].name&lt;v[b].name; }</code>). </li>
<li>(optionally) The return type using the new <a href="cpp11-language-misc.html#suffix-return" title="FAQ: Suffix return type syntax">suffix return type syntax</a>; but typically we just deduce the return type from the <code>return</code> statement. If no value is returned then <code>void</code> is deduced. </li>
</ul>

<p>See also:</p>

<ul>
<li>Standard 5.1.2 Lambda expressions </li>
<li>[N1968=06-0038] Jeremiah Willcock, Jaakko Jarvi, Doug Gregor, Bjarne Stroustrup, and Andrew Lumsdaine: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.htm">Lambda expressions and closures for C++</a> (original proposal with a different syntax) </li>
<li>[N2550=08-0060] Jaakko Jarvi, John Freeman, and Lawrence Crowl: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)</a> (final proposal). </li>
<li>[N2859=09-0049] Daveed Vandevoorde: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf">New wording for C++0x Lambdas</a>. </li>
</ul>

<h3 id="noexcept"><code>noexcept</code> to prevent exception propagation</h3>

<p>If a function cannot throw an exception or if the program isn&#8217;t written to handle exceptions thrown by a function, that function can be declared <code>noexcept</code>. For example:</p>

<pre><code>    extern "C" double sqrt(double) noexcept;    // will never throw

    vector&lt;double&gt; my_computation(const vector&lt;double&gt;&amp; v) noexcept // I'm not prepared to handle memory exhaustion
    {
        vector&lt;double&gt; res(v.size());   // might throw
        for(int i; i&lt;v.size(); ++i) res[i] = sqrt(v[i]);
        return res;
    }
</code></pre>

<p>If a function declared <code>noexcept</code> throws (so that the exception tries to escape the <code>noexcept</code> function) the program is terminated by a call to <code>std::terminate()</code>. The call of <code>terminate()</code> cannot rely on objects being in well-defined states; that is, there is no guarantee that destructors have been invoked, no guaranteed stack unwinding, and no possibility for resuming the program as if no problem had been encountered. This is deliberate and makes <code>noexcept</code> a simple, crude, and very efficient mechanism &#8211; much more efficient than the old dynamic <code>throw()</code> exception specification mechanism.</p>

<p>It is possible to make a function conditionally <code>noexcept</code>. For example, an algorithm can be specified to be <code>noexcept</code> if (and only if) the operations it uses on a template argument are <code>noexcept</code>:</p>

<pre><code>    template&lt;class T&gt;
    void do_f(vector&lt;T&gt;&amp; v) noexcept(noexcept(f(v.at(0)))) // can throw if f(v.at(0)) can
    {
        for(int i; i&lt;v.size(); ++i)
            v.at(i) = f(v.at(i));
    }
</code></pre>

<p>Here, we first use <code>noexcept</code> as an operator: <code>noexcept(f(v.at(0)))</code> is true if <code>f(v.at(0))</code> can&#8217;t throw, that is if the <code>f()</code> and <code>at()</code> used are <code>noexcept</code>.</p>

<p>The <code>noexcept()</code> operator is a constant expression and does not evaluate its operand.</p>

<p>The general form of a <code>noexcept</code> declaration is <code>noexcept(expression)</code> and &#8220;plain <code>noexcept</code>&#8221; is simply a shorthand for <code>noexcept(true)</code>. All declarations of a function must have compatible <code>noexcept</code> specifications.</p>

<p>A destructor shouldn&#8217;t throw; a generated destructor is implicitly <code>noexcept</code> (independently of what code is in its body) if all of the members of its class have <code>noexcept</code> destructors (which, ahem, they too will have by default).</p>

<p>It is typically a bad idea to have a move operation throw, so declare those <code>noexcept</code> wherever possible. A generated copy or move operation is implicitly <code>noexcept</code> if all of the copy or move operations it uses on members of its class have <code>noexcept</code> destructors.</p>

<p><code>noexcept</code> is widely and systematically used in the standard library to improve performance and clarify requirements.</p>

<p>See also:</p>

<ul>
<li>Standard: 15.4 Exception specifications [except.spec]. </li>
<li>Standard: 5.3.7 noexcept operator [expr.unary.noexcept]. </li>
<li>[N3103==10-0093] D. Kohlbrenner, D. Svoboda, and A. Wesie: Security impact of noexcept. (Noexcept <strong>must</strong> terminate, as it does). </li>
<li>[N3167==10-0157] David Svoboda: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3205.htm">Delete operators default to noexcept</a>. </li>
<li>[N3204==10-0194] Jens Maurer: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3204.htm">Deducing &#8220;noexcept&#8221; for destructors</a>.</li>
<li>[N3050==10-0040] D. Abrahams, R. Sharoni, and D. Gregor: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">Allowing Move Constructors to Throw (Rev. 1)</a>. </li>
</ul>

<h3 id="cpp11-constexpr"><code>constexpr</code></h3>

<p>The <code>constexpr</code> mechanism</p>

<ul>
<li>provides more general constant expressions </li>
<li>allows constant expressions involving user-defined types </li>
<li>provides a way to guarantee that an initialization is done at compile time </li>
</ul>

<p>Consider</p>

<pre><code>    enum Flags { good=0, fail=1, bad=2, eof=4 };

    constexpr int operator|(Flags f1, Flags f2) { return Flags(int(f1)|int(f2)); }

    void f(Flags x)
    {
        switch (x) {
        case bad:         /* ... */ break;
        case eof:         /* ... */ break;
        case bad|eof:     /* ... */ break;
        default:          /* ... */ break;
        }
    }
</code></pre>

<p>Here <code>constexpr</code> says that the function must be of a simple form so that it can be evaluated at compile time if given constant expressions arguments.</p>

<p>In addition to be able to evaluate expressions at compile time, we want to be able to require expressions to be evaluated at compile time; <code>constexpr</code> in front of a variable definition does that (and implies <code>const</code>):</p>

<pre><code>    constexpr int x1 = bad|eof; // ok

    void f(Flags f3)
    {
        constexpr int x2 = bad|f3;  // error: can't evaluate at compile time
        int x3 = bad|f3;        // ok
    }
</code></pre>

<p>Typically we want the compile-time evaluation guarantee for global or namespace objects, often for objects we want to place in read-only storage.</p>

<p>This also works for objects for which the constructors are simple enough to be <code>constexpr</code> and expressions involving such objects:</p>

<pre><code>    struct Point {
        int x,y;
        constexpr Point(int xx, int yy) : x(xx), y(yy) { }
    };

    constexpr Point origo(0,0);
    constexpr int z = origo.x;

    constexpr Point a[] = {Point(0,0), Point(1,1), Point(2,2) };
    constexpr int x = a[1].x;   // x becomes 1
</code></pre>

<p>Please note that <code>constexpr</code> is not a general purpose replacement for <code>const</code> (or vice versa):</p>

<ul>
<li><code>const</code>&#8217;s primary function is to express the idea that an object is not modified through an interface (even though the object may very well be modified through other interfaces). It just so happens that declaring an object <code>const</code> provides excellent optimization opportunities for the compiler. In particular, if an object is declared <code>const</code> and its address isn&#8217;t taken, a compiler is often able to evaluate its initializer at compile time (though that&#8217;s not guaranteed) and keep that object in its tables rather than emitting it into the generated code. </li>
<li><code>constexpr</code>&#8217;s primary function is to extend the range of what can be computed at compile time, making such computation type safe and also usable in compile-time contexts (such as to initialize enumerator or integral template parameters). Objects declared <code>constexpr</code> have their initializer evaluated at compile time; they are basically values kept in the compiler&#8217;s tables and only emitted into the generated code if needed. </li>
</ul>

<p>See also:</p>

<ul>
<li>the C++ draft 3.6.2 Initialization of non-local objects, 3.9 Types [12], 5.19 Constant expressions, 7.1.5 The <code>constexpr</code> specifier </li>
<li>[N1521=03-0104] Gabriel Dos Reis: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1521.pdf">Generalized Constant Expressions</a> (original proposal). </li>
<li>[N2235=07-0095] Gabriel Dos Reis, Bjarne Stroustrup, and Jens Maurer: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">Generalized Constant Expressions &#8211; Revision 5</a>. </li>
</ul>

<h3 id="nullptr"><code>nullptr</code> &#8211; a null pointer literal</h3>

<p><code>nullptr</code> is a literal denoting the null pointer; it is not an integer:</p>

<pre><code>    char* p = nullptr;
    int* q = nullptr;
    char* p2 = 0;           // 0 still works and p==p2

    void f(int);
    void f(char*);

    f(0);                   // call f(int)
    f(nullptr);             // call f(char*)

    void g(int);
    g(nullptr);             // error: nullptr is not an int
    int i = nullptr;        // error: nullptr is not an int
</code></pre>

<p>See also:</p>

<ul>
<li>[N1488==/03-0071] Herb Sutter and Bjarne Stroustrup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1488.pdf">A name for the null pointer: nullptr</a>. </li>
<li>[N2214 = 07-0074 ] Herb Sutter and Bjarne Stroustrup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">A name for the null pointer: nullptr (revision 4)</a>. </li>
<li>ECMA-372 for a description of this feature as originally designed in <a href="http://www.ecma-international.org/publications/standards/Ecma-372.htm">C++/CLI</a> before being proposed for ISO C++.</li>
</ul>

<h3 id="exception-ptr">Copying and rethrowing exceptions</h3>

<p>How do you catch an exception and then rethrow it on another thread? Use a bit of library magic as described in the standard 18.8.5 Exception Propagation:</p>

<ul>
<li><code>exception_ptr current_exception();</code> Returns: An <code>exception_ptr</code> object that refers to the currently handled exception (15.3) or a copy of the currently handled exception, or a null <code>exception_ptr</code> object if no exception is being handled. The referenced object shall remain valid at least as long as there is an <code>exception_ptr</code> object that refers to it. &#8230;  </li>
<li><code>void rethrow_exception(exception_ptr p);</code> </li>
<li><code>template&lt;class E&gt; exception_ptr copy_exception(E e);</code> Effects: as if </li>
</ul>

<pre><code>    try {
        throw e;
    } catch(...) {
        return current_exception();
    }
</code></pre>

<p>This is particularly useful for <a href="cpp11-library-concurrency.html#cpp11-future" title="FAQ: Futures and promises">transmitting an exception from one thread to another</a>.</p>

<h3 id="inline-namespace">Inline namespaces</h3>

<p>The <code>inline namespace</code> mechanism is intended to support library evolution by providing a mechanism that supports a form of versioning. Consider:</p>

<pre><code>    // file V99.h:
    inline namespace V99 {
        void f(int);    // does something better than the V98 version
        void f(double); // new feature
        // ...
    }

    // file V98.h:
    namespace V98 {
        void f(int);    // does something
        // ...
    }

    // file Mine.h:
    namespace Mine {
    #include "V99.h"
    #include "V98.h"
    }
</code></pre>

<p>We here have a namespace <code>Mine</code> with both the latest release (<code>V99</code>) and the previous one (<code>V98</code>). If you want to be specific, you can:</p>

<pre><code>    #include "Mine.h"
    using namespace Mine;
    // ...
    V98::f(1);  // old version
    V99::f(1);  // new version
    f(1);       // default version
</code></pre>

<p>The point is that the <code>inline</code> specifier makes the declarations from the nested namespace appear exactly as if they had been declared in the enclosing namespace.</p>

<p>This is a very &#8220;static&#8221; and implementer-oriented facility in that the <code>inline</code> specifier has to be placed by the designer of the namespaces &#8211; thus making the choice for all users. It is not possible for a user of <code>Mine</code> to say &#8220;I want the default to be <code>V98</code> rather than <code>V99</code>.&#8221;</p>

<p>See</p>

<ul>
<li>Standard 7.3.1 Namespace definition [7]-[9]. </li>
</ul>

<h3 id="udls">User-defined literals</h3>

<p>C++ has always provided literals for a variety of built-in types (2.14 Literals):</p>

<pre><code>    123 // int
    1.2 // double
    1.2F    // float
    'a' // char
    1ULL    // unsigned long long
    0xD0    // hexadecimal unsigned
    "as"    // string
</code></pre>

<p>However, in C++98 there are no literals for user-defined types. This can be a bother and also seen as a violation of the principle that user-defined types should be supported as well as built-in types are. In particular, people have requested:</p>

<pre><code>    "Hi!"s          // std::string, not ``zero-terminated array of char''
    1.2i            // imaginary
    123.4567891234df    // decimal floating point (IBM)
    101010111000101b    // binary
    123s            // seconds
    123.56km        // not miles! (units)
    1234567890123456789012345678901234567890x   // extended-precision
</code></pre>

<p>C++11 supports &#8220;user-defined literals&#8221; through the notion of literal operators that map literals with a given suffix into a desired type. For example:</p>

<pre><code>    constexpr complex&lt;double&gt; operator "" i(long double d)  // imaginary literal
    {
        return {0,d};   // complex is a literal type
    }

    std::string operator""s (const char* p, size_t n)   // std::string literal
    {
        return string(p,n); // requires free store allocation
    }
</code></pre>

<p>Note the use of <code>constexpr</code> to enable compile-time evaluation. Given those, we can write</p>

<pre><code>    template&lt;class T&gt; void f(const T&amp;);
    f("Hello"); // pass pointer to char*
    f("Hello"s);    // pass (5-character) string object
    f("Hello\n"s);  // pass (6-character) string object

    auto z = 2+1i;  // complex(2,1)
</code></pre>

<p>The basic (implementation) idea is that after parsing what could be a literal, the compiler always checks for a suffix. The user-defined literal mechanism simply allows the user to specify a new suffix and what is to be done with the literal before it. It is not possible to redefine the meaning of a built-in literal suffix or augment the syntax of literals. A literal operator can request to get its (preceding) literal passed &#8220;cooked&#8221; (with the value it would have had if the new suffix hadn&#8217;t been defined) or &#8220;uncooked&#8221; (as a string).</p>

<p>To get an &#8220;uncooked&#8221; string, simply request a single <code>const char*</code> argument:</p>

<pre><code>    Bignum operator"" x(const char* p)
    {
        return Bignum(p);
    }

    void f(Bignum);
    f(1234567890123456789012345678901234567890x);
</code></pre>

<p>Here the C-style string <code>"1234567890123456789012345678901234567890"</code> is passed to <code>operator"" x()</code>. Note that we did not explicitly put those digits into a string.</p>

<p>There are four kinds of literals that can be suffixed to make a user-defined literal.</p>

<ul>
<li>Integer literal: accepted by a literal operator taking a single <code>unsigned long long</code> or <code>const char*</code> argument. </li>
<li>Floating-point literal: accepted by a literal operator taking a single <code>long double</code> or <code>const char*</code> argument. </li>
<li>String literal: accepted by a literal operator taking a pair of (<code>const char*</code>, <code>size_t</code>) arguments. </li>
<li>Character literal: accepted by a literal operator taking a single <code>char</code> argument. </li>
</ul>

<p>Note that you cannot make a literal operator for a string literal that takes just a <code>const char*</code> argument (and no size). For example:</p>

<pre><code>    string operator"" S(const char* p);     // warning: this will not work as expected

    "one two"S; // error: no applicable literal operator
</code></pre>

<p>The rationale is that if we want to have &#8220;a different kind of string&#8221; we almost always want to know the number of characters anyway.</p>

<p>Suffixes will tend to be short (e.g. <code>s</code> for <code>string</code>, <code>i</code> for imaginary, <code>m</code> for meter, and <code>x</code> for extended), so different uses could easily clash. Use namespaces to prevent clashes:</p>

<pre><code>    namespace Numerics { 
        // ...
        class Bignum { /* ... */ }; 
        namespace literals { 
            operator"" X(char const*); 
        } 
    } 

    using namespace Numerics::literals; 
</code></pre>

<p>See also:</p>

<ul>
<li>Standard 2.14.8 User-defined literals </li>
<li>[N2378==07-0238] Ian McIntosh, Michael Wong, Raymond Mak, Robert Klarer, Jens Mauer, Alisdair Meredith, Bjarne Stroustrup, David Vandevoorde: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2378.pdf">User-defined Literals (aka. Extensible Literals (revision 3))</a>. </li>
</ul>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance  Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance  virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance  Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance  Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance  What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance  private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance  Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/cpp11-language",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/cpp11-language",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/cpp11-language by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
</html>
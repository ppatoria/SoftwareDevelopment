<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/ctors by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="b9eb506f41b2105f323242dcd9f52eeb10c4e98d" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="2934bdf94a075c2befd95fc5789371cc2bc628b2" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="912873ebd6f37b644d892edbec4f60f716860aaa" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        ctors
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="ctors.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    ctors
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=ctors" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="ctors">Constructors</h2>

<h3 id="overview-ctors">What&#8217;s the deal with constructors?</h3>

<p>Constructors build objects from dust.</p>

<p>Constructors are like &#8220;init functions&#8221;. They turn a pile of arbitrary bits into a living object. Minimally they
initialize internally used fields. They may also allocate resources (memory, files, semaphores, sockets, etc).</p>

<p>&#8220;ctor&#8221; is a typical abbreviation for constructor.</p>

<h3 id="empty-parens-in-object-decl">Is there any difference between <code>List x;</code> and <code>List x();</code>?</h3>

<p>A <em>big</em> difference!</p>

<p>Suppose that <code>List</code> is the name of some class. Then function <code>f()</code> declares a local <code>List</code> object called <code>x</code>:</p>

<pre><code>void f()
{
  List x;     // Local object named x (of class List)
  // ...
}
</code></pre>

<p>But function <code>g()</code> declares a function called <code>x()</code> that returns a <code>List</code>:</p>

<pre><code>void g()
{
  List x();   // Function named x (that returns a List)
  // ...
}
</code></pre>

<h3 id="init-methods">Can one constructor of a class call another constructor of the same class to initialize the <code>this</code> object?</h3>

<p>This answer will be updated due to C++11 constructor chaining. Watch this space for updates in the near future!!</p>

<p>Nope.</p>

<p>Let&#8217;s work an example. Suppose you want your constructor <code>Foo::Foo(char)</code> to call another constructor of the same class,
say <code>Foo::Foo(char,int)</code>, in order that <code>Foo::Foo(char,int)</code> would help initialize the <code>this</code> object. Unfortunately
there&#8217;s no way to do this in C++.</p>

<p>Some people do it anyway. Unfortunately it doesn&#8217;t do what they want. For example, the line <code>Foo(x, 0);</code> does <em>not</em> call
<code>Foo::Foo(char,int)</code> on the <code>this</code> object. Instead it calls <code>Foo::Foo(char,int)</code> to initialize a temporary, local object
(<em>not</em> <code>this</code>), then it immediately destructs that temporary when control flows over the <code>;</code>.</p>

<pre><code>class Foo {
public:
  Foo(char x);
  Foo(char x, int y);
  // ...
};

Foo::Foo(char x)
{
  // ...
  Foo(x, 0);  // Does NOT help initialize the this object!!
  // ...
}
</code></pre>

<p>You can sometimes combine two constructors via a default parameter:</p>

<pre><code>class Foo {
public:
  Foo(char x, int y = 0);  // Has the effect of combining the two constructors
  // ...
};
</code></pre>

<p>If that doesn&#8217;t work, e.g., if there isn&#8217;t an appropriate default parameter that combines the two constructors,
sometimes you can share their common code in a private <code>init()</code> member function:</p>

<pre><code>class Foo {
public:
  Foo(char x);
  Foo(char x, int y);
  // ...
private:
  void init(char x, int y);
};

Foo::Foo(char x)
{
  init(x, int(x) + 7);
  // ...
}

Foo::Foo(char x, int y)
{
  init(x, y);
  // ...
}

void Foo::init(char x, int y)
{
  // ...
}
</code></pre>

<p>BTW do <em>NOT</em> try to achieve this via <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement new</a>. Some people think they can say
<code>new(this) Foo(x, int(x)+7)</code> within the body of <code>Foo::Foo(char)</code>. However that is bad, bad, bad. Please don&#8217;t write me
and tell me that it <em>seems</em> to work on your particular version of your particular compiler; it&#8217;s bad. Constructors do a
bunch of little magical things behind the scenes, but that bad technique steps on those partially constructed bits. Just
say no.</p>

<h3 id="default-ctor">Is the default constructor for <code>Fred</code> always <code>Fred::Fred()</code>?</h3>

<p>No.</p>

<p>A &#8220;default constructor&#8221; is a constructor that <em>can be called</em> with no arguments. One example of this is a
constructor that takes no parameters:</p>

<pre><code>class Fred {
public:
  Fred();   // Default constructor: can be called with no args
  // ...
};
</code></pre>

<p>Another example of a &#8220;default constructor&#8221; is one that can take arguments, provided they are given default values:</p>

<pre><code>class Fred {
public:
  Fred(int i=3, int j=5);   // Default constructor: can be called with no args
  // ...
};
</code></pre>

<h3 id="arrays-call-default-ctor">Which constructor gets called when I create an array of <code>Fred</code> objects?</h3>

<p><code>Fred</code>&#8217;s <a href="ctors.html#default-ctor" title="FAQ: Is the default constructor for Fred always Fred::Fred()?">default constructor</a> (except as discussed below).</p>

<pre><code>class Fred {
public:
  Fred();
  // ...
};

int main()
{
  Fred a[10];              // Calls the default constructor 10 times
  Fred* p = new Fred[10];  // Calls the default constructor 10 times
  // ...
}
</code></pre>

<p>If your class doesn&#8217;t have a <a href="ctors.html#default-ctor" title="FAQ: Is the default constructor for Fred always Fred::Fred()?">default constructor</a>, you&#8217;ll get a compile-time error when you attempt to
create an array using the above simple syntax:</p>

<pre><code>class Fred {
public:
  Fred(int i, int j);      // Assume there is no default constructor
  // ...
};

int main()
{
  Fred a[10];              // ERROR: Fred doesn't have a default constructor
  Fred* p = new Fred[10];  // ERROR: Fred doesn't have a default constructor
  // ...
}
</code></pre>

<p>However, even if your class already has a default constructor, you should try to use <a href="class-libraries.html#stl" title="FAQ: What is the 'STL'?"><code>std::vector&lt;Fred&gt;</code></a> rather
than an array (<a href="containers.html#arrays-are-evil" title="FAQ: Why should I use container classes rather than simple arrays?">arrays are evil</a>). <code>std::vector</code> lets you decide to use any constructor, not just the
default constructor:</p>

<pre><code>#include &lt;vector&gt;

int main()
{
  std::vector&lt;Fred&gt; a(10, Fred(5,7));  // The 10 Fred objects in std::vector a will be initialized with Fred(5,7)
  // ...
}
</code></pre>

<p>Even though you <em>ought</em> to use a <code>std::vector</code> rather than an array, there are times when an array might be the right
thing to do, and for those, you might need the &#8220;explicit initialization of arrays&#8221; syntax. Here&#8217;s how:</p>

<pre><code>class Fred {
public:
  Fred(int i, int j);      // Assume there is no default constructor
  // ...
};

int main()
{
  Fred a[10] = {
    Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7),  // The 10 Fred objects are
    Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7), Fred(5,7)   // initialized using Fred(5,7)
  };
  // ...
}
</code></pre>

<p>Of course you don&#8217;t have to do <code>Fred(5,7)</code> for every entry &#8212; you can put in any numbers you want, even parameters or
other variables.</p>

<p>Finally, <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">you can use placement-new</a> to manually initialize the elements of the array. Warning: it&#8217;s
ugly: the raw array can&#8217;t be of type <code>Fred</code>, so you&#8217;ll need a bunch of pointer-casts to do things like compute array
index operations. Warning: it&#8217;s compiler- and hardware-dependent: you&#8217;ll need to make sure the storage is aligned
with an alignment that is at least as strict as is required for objects of class <code>Fred</code>. Warning: it&#8217;s tedious to make
it exception-safe: you&#8217;ll need to manually destruct the elements, including in the case when an exception is thrown
part-way through the loop that calls the constructors. But if you really want to do it anyway, <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">read up on
placement-new</a>. (BTW placement-new is the magic that is used inside of <code>std::vector</code>. The complexity of
getting everything right is yet another reason to use <code>std::vector</code>.)</p>

<p>By the way, did I ever mention that <a href="containers.html#arrays-are-evil" title="FAQ: Why should I use container classes rather than simple arrays?">arrays are evil</a>? Or did I mention that you ought to use a
<code>std::vector</code> unless there is a compelling reason to use an array?</p>

<h3 id="init-lists">Should my constructors use &#8220;initialization lists&#8221; or &#8220;assignment&#8221;?</h3>

<p>Initialization lists. In fact, constructors should initialize as a rule <em>all</em> member objects in the initialization list.
One exception is discussed further down.</p>

<p><em>Watch this space for discussion of Non Static Data Member Initialization in C++11</em></p>

<pre><code>// Here is the taste of standard C++ NSDMI
struct Point {
      int X = 0; // Look at that!!!
      int Y = 0; // 
};
</code></pre>

<p>Consider the following constructor that initializes member object <code>x_</code> using an initialization list:
<code>Fred::Fred() : x_(</code><em>whatever</em><code>) { }</code>. The most common benefit of doing this is improved performance. For example, if
the expression <em>whatever</em> is the same type as member variable <code>x_</code>, the result of the <em>whatever</em> expression is
constructed directly inside <code>x_</code> &#8212; the compiler does not make a separate copy of the object. Even if the types are not
the same, the compiler is usually able to do a better job with initialization lists than with assignments.</p>

<p>The other (inefficient) way to build constructors is via assignment, such as: <code>Fred::Fred() { x_ = </code><em>whatever</em><code>; }</code>. In
this case the expression <em>whatever</em> causes a separate, temporary object to be created, and this temporary object is
passed into the <code>x_</code> object&#8217;s assignment operator. Then that temporary object is destructed at the <code>;</code>. That&#8217;s
inefficient.</p>

<p>As if that wasn&#8217;t bad enough, there&#8217;s another source of inefficiency when using assignment in a constructor: the member
object will get fully constructed by its default constructor, and this might, for example, allocate some default amount
of memory or open some default file. All this work could be for naught if the <em>whatever</em> expression and/or assignment
operator causes the object to close that file and/or release that memory (e.g., if the default constructor didn&#8217;t
allocate a large enough pool of memory or if it opened the wrong file).</p>

<p>Conclusion: All other things being equal, your code will run faster if you use initialization lists rather than
assignment.</p>

<p>Note: There is no performance difference if the type of <code>x_</code> is some built-in/intrinsic type, such as <code>int</code> or <code>char*</code>
or <code>float</code>. But even in these cases, my personal preference is to set those data members in the initialization list
rather than via assignment for consistency. Another symmetry argument in favor of using initialization lists even for
built-in/intrinsic types: non-static <code>const</code> and non-static reference data members <em>can&#8217;t</em> be assigned a value in
the constructor, so for symmetry it makes sense to initialize everything in the initialization list.</p>

<p>Now for the exceptions. Every rule has exceptions (hmmm; does &#8220;every rule has exceptions&#8221; have exceptions? reminds me of
Gödel&#8217;s Incompleteness Theorems), and there are a couple of exceptions to the &#8220;use initialization lists&#8221; rule. Bottom
line is to use common sense: if it&#8217;s cheaper, better, faster, etc. to not use them, then by all means, don&#8217;t use them.
This might happen when your class has two constructors that need to initialize the <code>this</code> object&#8217;s data members in
different orders. Or it might happen when two data members are self-referential. Or when a data-member needs a
reference to the <code>this</code> object, and you want to avoid a compiler warning about using the <code>this</code> keyword prior to the <code>{</code>
that begins the constructor&#8217;s body (when your particular compiler happens to issue that particular warning). Or when you
need to do <a href="operator-overloading.html#matrix-subscript-op" title="FAQ: How do I create a subscript operator for a Matrix class?">an <code>if</code>&#8230;<code>throw</code> test on a variable</a> (parameter, global, etc.) prior to using that
variable to initialize one of your <code>this</code> members. This list is not exhaustive; please don&#8217;t write me asking me to add
another &#8220;Or when&#8230;&#8221;. The point is simply this: use common sense.</p>

<h3 id="ctor-initializer-order">How should initializers be ordered in a constructor&#8217;s initialization list?</h3>

<p>Immediate base classes (left to right), then member objects (top to bottom).</p>

<p>In other words, the order of the initialization list should mimic the order in which initializations will take place.
This guideline discourages a particularly subtle class of order dependency errors by giving an obvious, visual clue. For
example, the following contains a hideous error.</p>

<pre><code>#include &lt;iostream&gt;

class Y {
public:
  Y();
  void f();
};

Y::Y()      { std::cout &lt;&lt; "Initializing Y\n"; }
void Y::f() { std::cout &lt;&lt; "Using Y\n"; }

class X {
public:
  X(Y&amp; y);
};

X::X(Y&amp; y) { y.f(); }

class Z {
public:
  Z();
protected:
  X x_;
  Y y_;
};

Z::Z() throw()
  : y_()
  , x_(y_)
    ↑↑   // Bad: should have listed x_ before y_
{ }

int main()
{
  Z z;
  return 0;
}
</code></pre>

<p>The output of this program follows.</p>

<pre><code>Using Y
Initializing Y
</code></pre>

<p>Note that <code>y_</code> is used (<code>Y::f()</code>) <em>before</em> it is initialized (<code>Y::Y()</code>). If instead the programmer had read and abided
by the guidline in this FAQ, the error would be more obvious: the initialization list of <code>Z::Z()</code> would have read
<code>x_(y_), y_()</code>, visually indicating that <code>y_</code> was being used before being initialized.</p>

<p>Not all compilers issue diagnostic messages for these cases. You have been warned.</p>

<h3 id="initializing-members-from-other-members">Is it moral for one member object to be initialized using another member object in the initializer expression?</h3>

<p>Yes, but use care and do that only when it adds value.</p>

<p>In a constructor&#8217;s initialization list, it is easiest and safest to avoid using one member object from <code>this</code> object in
the initialization expression of a subsequent initializer for <code>this</code> object. This guideline prevents <a href="ctors.html#ctor-initializer-order" title="FAQ: How should initializers be ordered in a constructor's initialization list?">subtle
order-dependency errors if someone reorganizes the layout of member objects within the class</a>.</p>

<p>Because of this guideline, the constructor that follows uses <code>s.len_ + 1u</code> rather than <code>len_ + 1u</code>, even though they are
otherwise equivalent. The <code>s.</code> prefix avoids an unnecessary and avoidable order dependency.</p>

<pre><code>#include &lt;memory&gt;

class MyString {
public:
  MyString();
 ~MyString();
  MyString(const MyString&amp; s);              // copy constructor
  MyString&amp; operator= (const MyString&amp; s);  // assignment
  // ...
protected:
  unsigned len_;
  char*    data_;
};

MyString::MyString()
  : len_(0u)
  , data_(new char[1])
{
  data_[0] = '\0';
}

MyString::~MyString()
{ delete[] data_; }

MyString::MyString(const MyString&amp; s)
  : len_ (s.len_)
  , data_(new char[s.len_ + 1u])       &lt;--Not {tt{new char[len_+1]}tt}
{                  ↑↑↑↑↑↑   // not len_
  memcpy(data_, s.data_, len_ + 1u);
}                        ↑↑↑↑   // no issue using len_ in ctor's {body}

int main()
{
  MyString a;      // default ctor; zero length MyString ("")
  MyString b = a;  // copy constructor
  return 0;
}
</code></pre>

<p>An unnecessary order dependency on the class layout of <code>len_</code> and <code>data_</code> would have been introduced if the
constructor&#8217;s initialization of <code>data_</code> had used <code>len_ + 1u</code> rather than <code>s.len_ + 1u</code>. However using <code>len_</code> within a
constructor body (<code>{...}</code>) is okay. No order dependency is introduced since the entire initialization list is guaranteed
to finish before the constructor body begins executing.</p>

<h3 id="order-dependency-in-members">What if one member object has to be initialized using another member object?</h3>

<p>Comment the declaration of the effected data members with <code>//ORDER DEPENDENCY</code>.</p>

<p>If a constructor initializes a member object of <code>this</code> object using another member object of <code>this</code> object, <a href="ctors.html#initializing-members-from-other-members" title="FAQ: Is it moral for one member object to be initialized using another member object in the initializer expression?">rearranging
the data members of the class could break the constructor</a>. This important
maintenance constraint should be documented in the class body.</p>

<p>For example, in the constructor below, the initializer for <code>data_</code> uses <code>len_</code> to avoid a redundant call to
<code>std::strlen(s)</code>, which introduces an order dependency in the class body.</p>

<pre><code>#include &lt;memory&gt;

class MyString {
public:
  MyString(const char* s);                // promote const char*
  MyString(const MyString&amp; s);            // copy constructor
  MyString&amp; operator= (const MyString&amp;);  // assignment
 ~MyString();
  // ...
protected:
  unsigned len_;   // ORDER DEPENDENCY
  char*    data_;  // ORDER DEPENDENCY
};

MyString::MyString(const char* s)
  : len_ (std::strlen(s))
  , data_(new char[len_ + 1u])
{
  std::memcpy(data_, s, len_ + 1u);
}

MyString::~MyString()
{
  delete[] data_;
}

int main()
{
  MyString s = "xyzzy";
  return 0;
}
</code></pre>

<p>Note that the <code>//ORDER DEPENDENCY</code> comment is listed with the effected <em>data members in the class body</em>, not with the
constructor initialization list where the order dependency was actually created. That is because the order of member
objects in the class body is critical; <a href="ctors.html#ctor-initializer-order" title="FAQ: How should initializers be ordered in a constructor's initialization list?">the order of initializers in the constructor initialization list is
irrelevant</a>.</p>

<h3 id="using-this-in-ctors">Should you use the <code>this</code> pointer in the constructor?</h3>

<p>Some people feel you should not use the <code>this</code> pointer in a constructor because the object is not fully formed yet.
However you can use <code>this</code> in the constructor (in the <code>{</code>body<code>}</code> and even in the <a href="ctors.html#init-lists" title="FAQ: Should my constructors use 'initialization lists' or 'assignment'?">initialization list</a>) if
you are careful.</p>

<p>Here is something that <em>always</em> works: the <code>{</code>body<code>}</code> of a constructor (or a function called from the constructor) can
reliably access the data members declared in a base class and/or the data members declared in the constructor&#8217;s own
class. This is because all those data members are guaranteed to have been fully constructed by the time the
constructor&#8217;s <code>{</code>body<code>}</code> starts executing.</p>

<p>Here is something that <em>never</em> works: the <code>{</code>body<code>}</code> of a constructor (or a function called from the constructor)
can<em>not</em> get down to a derived class by calling a <code>virtual</code> member function that is overridden in the derived class. If
your goal was to get to the overridden function in the derived class, <a href="strange-inheritance.html#calling-virtuals-from-ctors" title="FAQ: When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">you won&#8217;t get what you
want</a>. Note that you won&#8217;t get to the override in the derived class independent of <em>how</em>
you call the <code>virtual</code> member function: explicitly using the <code>this</code> pointer (e.g., <code>this-&gt;method()</code>), implicitly using
the <code>this</code> pointer (e.g., <code>method()</code>), or even calling some other function that calls the <code>virtual</code> member function on
your <code>this</code> object. The bottom line is this: even if the caller is constructing an object of a derived class, during
the constructor of the base class, <a href="strange-inheritance.html#calling-virtuals-from-ctors" title="FAQ: When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?">your object is not yet of that derived class</a>. You have
been warned.</p>

<p>Here is something that <em>sometimes</em> works: if you pass any of the data members in <code>this</code> object to another data member&#8217;s
<a href="ctors.html#init-lists" title="FAQ: Should my constructors use 'initialization lists' or 'assignment'?">initializer</a>, you must make sure that the other data member has already been initialized. The good news is
that you can determine whether the other data member has (or has not) been initialized using some straightforward
language rules that are independent of the particular compiler you&#8217;re using. The bad news is that you have to know those
language rules (e.g., base class sub-objects are initialized first (look up the order if you have multiple and/or
<code>virtual</code> inheritance!), then data members defined in the class are initialized in the order in which they appear in the
class declaration). If you don&#8217;t know these rules, then don&#8217;t pass any data member from the <code>this</code> object (regardless of
whether or not you explicitly use the <code>this</code> keyword) to any other data member&#8217;s <a href="ctors.html#init-lists" title="FAQ: Should my constructors use 'initialization lists' or 'assignment'?">initializer</a>! And if you
do know the rules, please be careful.</p>

<h3 id="named-ctor-idiom">What is the &#8220;Named Constructor Idiom&#8221;?</h3>

<p>A technique that provides more intuitive and/or safer construction operations for users of your class.</p>

<p>The problem is that constructors always have the same name as the class. Therefore the only way to differentiate between
the various constructors of a class is by the parameter list. But if there are lots of constructors, the differences
between them become somewhat subtle and error prone.</p>

<p>With the Named Constructor Idiom, you declare all the class&#8217;s constructors in the <code>private</code> or <code>protected</code> sections, and
you provide <code>public</code> <code>static</code> methods that return an object. These <code>static</code> methods are the so-called &#8220;Named
Constructors.&#8221; In general there is one such <code>static</code> method for each different way to construct an object.</p>

<p>For example, suppose we are building a <code>Point</code> class that represents a position on the X-Y plane. Turns out there are
two common ways to specify a 2-space coordinate: rectangular coordinates (X+Y), polar coordinates (Radius+Angle).
(Don&#8217;t worry if you can&#8217;t remember these; the point isn&#8217;t the particulars of coordinate systems; the point is that there
are several ways to create a <code>Point</code> object.) Unfortunately the parameters for these two coordinate systems are the
same: two <code>float</code>s. This would create an ambiguity error in the overloaded constructors:</p>

<pre><code>class Point {
public:
  Point(float x, float y);     // Rectangular coordinates
  Point(float r, float a);     // Polar coordinates (radius and angle)
  // ERROR: Overload is Ambiguous: Point::Point(float,float)
};

int main()
{
  Point p = Point(5.7, 1.2);   // Ambiguous: Which coordinate system?
  // ...
}
</code></pre>

<p>One way to solve this ambiguity is to use the Named Constructor Idiom:</p>

<pre><code>#include &lt;cmath&gt;               // To get std::sin() and std::cos()

class Point {
public:
  static Point rectangular(float x, float y);      // Rectangular coord's
  static Point polar(float radius, float angle);   // Polar coordinates
  // These static methods are the so-called "named constructors"
  // ...
private:
  Point(float x, float y);     // Rectangular coordinates
  float x_, y_;
};

inline Point::Point(float x, float y)
  : x_(x), y_(y) { }

inline Point Point::rectangular(float x, float y)
{ return Point(x, y); }

inline Point Point::polar(float radius, float angle)
{ return Point(radius*std::cos(angle), radius*std::sin(angle)); }
</code></pre>

<p>Now the users of <code>Point</code> have a clear and unambiguous syntax for creating <code>Point</code>s in either coordinate system:</p>

<pre><code>int main()
{
  Point p1 = Point::rectangular(5.7, 1.2);   // Obviously rectangular
  Point p2 = Point::polar(5.7, 1.2);         // Obviously polar
  // ...
}
</code></pre>

<p>Make sure your constructors are in the <code>protected</code> section if you expect <code>Point</code> to have derived classes.</p>

<p>The Named Constructor Idiom can also be used to <a href="freestore-mgmt.html#static-create-methods" title="FAQ: How can I force objects of my class to always be created via new rather than as local, namespace-scope, global, or static?">make sure your objects are always created via
<code>new</code></a>.</p>

<p>Note that the Named Constructor Idiom, at least as implemented above, is just as fast as directly calling a constructor
&#8212; <a href="ctors.html#return-by-value-optimization" title="FAQ: Does return-by-value mean extra copies and extra overhead?">modern compilers will not make any extra copies of your object</a>.</p>

<h3 id="return-by-value-optimization">Does return-by-value mean extra copies and extra overhead?</h3>

<p>Not necessarily.</p>

<p>All(?) commercial-grade compilers optimize away the extra copy, at least in cases as illustrated in <a href="ctors.html#named-ctor-idiom" title="FAQ: What is the 'Named Constructor Idiom'?">the previous
FAQ</a>.</p>

<p>To keep the example clean, let&#8217;s strip things down to the bare essentials. Suppose function <code>caller()</code> calls <code>rbv()</code>
(&#8220;rbv&#8221; stands for &#8220;return by value&#8221;) which returns a <code>Foo</code> object by value:</p>

<pre><code>class Foo { /*...*/ };

Foo rbv();

void caller()
{
  Foo x = rbv();  // The return-value of rbv() goes into x
  // ...
}
</code></pre>

<p>Now the question is, How many <code>Foo</code> objects will there be? Will <code>rbv()</code> create a temporary <code>Foo</code> object that gets
copy-constructed into <code>x</code>? How many temporaries? Said another way, does return-by-value necessarily degrade
performance?</p>

<p>The point of this FAQ is that the answer is No, commercial-grade C++ compilers implement return-by-value in a way
that lets them eliminate the overhead, at least in simple cases like those shown in the previous FAQ. In particular,
all(?) commercial-grade C++ compilers will optimize this case:</p>

<pre><code>Foo rbv()
{
  // ...
  return Foo(42, 73);  // Suppose Foo has a ctor Foo::Foo(int a, int b)
}
</code></pre>

<p>Certainly the compiler is <em>allowed</em> to create a temporary, local <code>Foo</code> object, then copy-construct that temporary into
variable <code>x</code> within <code>caller()</code>, then destruct the temporary. But all(?) commercial-grade C++ compilers won&#8217;t do
that: the <code>return</code> statement will directly construct <code>x</code> itself. Not a copy of <code>x</code>, not a pointer to <code>x</code>, not a
reference to <code>x</code>, but <code>x</code> itself.</p>

<p>You can stop here if you don&#8217;t want to genuinely understand the previous paragraph, but if you want to know the secret
sauce (so you can, for example, reliably predict when the compiler can and cannot provide that optimization for you),
the key is to know that compilers usually implement return-by-value using pass-by-pointer. When <code>caller()</code> calls
<code>rbv()</code>, the compiler secretly passes a pointer to the location where <code>rbv()</code> is supposed to construct the &#8220;returned&#8221;
object. It might look something like this (it&#8217;s shown as a <code>void*</code> rather than a <code>Foo*</code> since the <code>Foo</code> object has not
yet been constructed):</p>

<pre><code>// Pseudo-code
void rbv(void* put_result_here)  // Original C++ code: Foo rbv()
{
  // ...code that initializes (not assigns to) the variable pointed to by put_result_here
}

// Pseudo-code
void caller()
{
  // Original C++ code: Foo x = rbv()
  struct Foo x;  // Note: x does not get initialized prior to calling rbv()
  rbv(&amp;x);       // Note: rbv() initializes a local variable defined in caller()
  // ...
}
</code></pre>

<p>So the first ingredient in the secret sauce is that the compiler (usually) transforms return-by-value into
pass-by-pointer. This means that commercial-grade compilers don&#8217;t bother creating a temporary: they directly
construct the returned object in the location pointed to by <code>put_result_here</code>.</p>

<p>The second ingredient in the secret sauce is that compilers typically implement constructors using a similar technique.
This is compiler-dependent and somewhat idealized (I&#8217;m intentionally ignoring how to handle <code>new</code> and overloading), but
compilers typically implement <code>Foo::Foo(int a, int b)</code> using something like this:</p>

<pre><code>// Pseudo-code
void Foo_ctor(Foo* this, int a, int b)  // Original C++ code: Foo::Foo(int a, int b)
{
  // ...
}
</code></pre>

<p>Putting these together, the compiler might implement the <code>return</code> statement in <code>rbv()</code> by simply passing
<code>put_result_here</code> as the constructor&#8217;s <code>this</code> pointer:</p>

<pre><code>// Pseudo-code
void rbv(void* put_result_here)  // Original C++ code: Foo rbv()
{
  // ...
  Foo_ctor((Foo*)put_result_here, 42, 73);  // Original C++ code: return Foo(42,73);
  return;
}
</code></pre>

<p>So <code>caller()</code> passes <code>&amp;x</code> to <code>rbv()</code>, and <code>rbv()</code> in turn passes <code>&amp;x</code> to the constructor (as the <code>this</code> pointer). That
means constructor <em>directly</em> constructs <code>x</code>.</p>

<p>In the early 90s I did a seminar for IBM&#8217;s compiler group in Toronto, and one of their engineers told me that they found
this return-by-value optimization to be so fast that you get it even if you don&#8217;t compile with optimization turned on.
Because the return-by-value optimization causes the compiler to generate less code, it actually improves
compile-times in addition to making your generated code smaller and faster. The point is that the return-by-value
optimization is almost universally implemented, at least in code cases like those shown above.</p>

<p>Final thought: this discussion was limited to whether there will be any extra copies of the returned object in a
return-by-value call. Don&#8217;t confuse that with other things that could happen in <code>caller()</code>. For example, if you
changed <code>caller()</code> from <code>Foo x = rbv();</code> to <code>Foo x;</code> <code>x = rbv();</code> (note the <code>;</code> after the declaration), the compiler is
required to use <code>Foo</code>&#8217;s assignment operator, and unless the compiler can prove that <code>Foo</code>&#8217;s default constructor followed
by assignment operator is exactly the same as its copy constructor, the compiler is required by the language to put the
returned object into an unnamed temporary within <code>caller()</code>, use the assignment operator to copy the temporary into <code>x</code>,
then destruct the temporary. The return-by-value optimization still plays its part since there will be only one
temporary, but by changing <code>Foo x = rbv();</code> to <code>Foo x;</code> <code>x = rbv();</code>, you have prevented the compiler from eliminating
that last temporary.</p>

<h3 id="return-local-var-by-value-optimization">What about returning a local variable by value? Does the local exist as a separate object, or does it get optimized away?</h3>

<p>When your code returns a local variable by value, your compiler <em>might</em> optimize away the local variable completely -
zero space-cost and zero time-cost - the local variable never actually exists as a distinct object from the caller&#8217;s
target variable (see below for specifics about exactly what this means). Other compilers do not optimize it away.</p>

<p>These are some(!) of the compilers that optimize away the local variable completely:</p>

<ul>
<li>GNU C++ (g++) since at least version 3.3.3</li>
<li>(Others need to be added; need more info)</li>
</ul>

<p>These are some(!) of the compilers that do not optimize away the local variable:</p>

<ul>
<li>Microsoft Visual C++.NET 2003</li>
<li>(Others need to be added; need more info)</li>
</ul>

<p>Here is an example showing what we mean in this FAQ:</p>

<pre><code>class Foo {
public:
  Foo(int a, int b);
  void some_method();
  // ...
};

void do_something_with(Foo&amp; z);

Foo rbv()
{
  Foo y = Foo(42, 73);
  y.some_method();
  do_something_with(y);
  return y;
}

void caller()
{
  Foo x = rbv();
  // ...
}
</code></pre>

<p>The question addressed in this FAQ is this: How many <code>Foo</code> objects actually get created in the runtime system?
Conceptually there could be as many as three distinct objects: the temporary created by <code>Foo(42, 73)</code>, variable <code>y</code> (in
<code>rbv()</code>), and variable <code>x</code> (in <code>caller()</code>). However as we saw earlier <a href="ctors.html#return-by-value-optimization" title="FAQ: Does return-by-value mean extra copies and extra overhead?">most compilers merge <code>Foo(42, 73)</code> and variable
<code>y</code></a> into the same object, reducing the total number of objects from 3 to 2. But this FAQ
pushes it one step further: does <code>y</code> (in <code>rbv()</code>) show up as a distinct, runtime object from <code>x</code> (in <code>caller()</code>)?</p>

<p>Some compilers, including but not limited to those listed above, completely optimize away local variable <code>y</code>. In those
compilers, there is only one <code>Foo</code> object in the above code: <code>caller()</code>&#8217;s variable <code>x</code> is exactly identically the same
object as <code>rbv()</code>&#8217;s variable <code>y</code>.</p>

<p>They do this the same way as described <a href="ctors.html#return-by-value-optimization" title="FAQ: Does return-by-value mean extra copies and extra overhead?">earlier</a>: the return-by-value in function
<code>rbv()</code> is implemented as pass-by-pointer, where the pointer points to the location where the returned object is to be
initialized.</p>

<p>So instead of constructing <code>y</code> as a local object, these compilers simply construct <code>*put_result_here</code>, and everytime
they see variable <code>y</code> used in the original source code, they substitute <code>*put_result_here</code> instead. Then the line
<code>return y;</code> becomes simply <code>return;</code> since the returned object has already been constructed <em>in the location designated
by the caller</em>.</p>

<p>Here is the resulting (pseudo)code:</p>

<pre><code>// Pseudo-code
void rbv(void* put_result_here)             // Original C++ code: Foo rbv()
{
  Foo_ctor((Foo*)put_result_here, 42, 73);  // Original C++ code: Foo y = Foo(42,73);
  Foo_some_method(*(Foo*)put_result_here);  // Original C++ code: y.some_method();
  do_something_with((Foo*)put_result_here); // Original C++ code: do_something_with(y);
  return;                                   // Original C++ code: return y;
}

void caller()
{
  struct Foo x;                             // Note: x is not initialized here!
  rbv(&amp;x);                                  // Original C++ code: Foo x = rbv();
  // ...
}
</code></pre>

<p>Caveat: this optimization can be applied only when <em>all</em> a function&#8217;s <code>return</code> statements return the same local
variable. If one <code>return</code> statement in <code>rbv()</code> returned local variable <code>y</code> but another returned something else, such as
a global or a temporary, the compiler could not alias the local variable into the caller&#8217;s destination, <code>x</code>. Verifying
that all the function&#8217;s return statements return the same local variable requires extra work on the part of the compiler
writers, which is usually why some compilers fail to implement that return-local-by-value optimization.</p>

<p>Final thought: this discussion was limited to whether there will be any extra copies of the returned object in a
return-by-value call. Don&#8217;t confuse that with other things that could happen in <code>caller()</code>. For example, if you
changed <code>caller()</code> from <code>Foo x = rbv();</code> to <code>Foo x;</code> <code>x = rbv();</code> (note the <code>;</code> after the declaration), the compiler is
required to use <code>Foo</code>&#8217;s assignment operator, and unless the compiler can prove that <code>Foo</code>&#8217;s default constructor followed
by assignment operator is exactly the same as its copy constructor, the compiler is required by the language to put the
returned object into an unnamed temporary within <code>caller()</code>, use the assignment operator to copy the temporary into <code>x</code>,
then destruct the temporary. The return-by-value optimization still plays its part since there will be only one
temporary, but by changing <code>Foo x = rbv();</code> to <code>Foo x;</code> <code>x = rbv();</code>, you have prevented the compiler from eliminating
that last temporary.</p>

<h3 id="explicit-define-static-data-mems">Why can&#8217;t I initialize my <code>static</code> member data in my constructor&#8217;s initialization list?</h3>

<p>Because you must <em>explicitly</em> define your class&#8217;s <code>static</code> data members.</p>

<p><code>Fred.h</code>:</p>

<pre><code>class Fred {
public:
  Fred();
  // ...
private:
  int i_;
  static int j_;
};
</code></pre>

<p><code>Fred.cpp</code> (or <code>Fred.C</code> or whatever):</p>

<pre><code>Fred::Fred()
  : i_(10)  // Okay: you can (and should) initialize member data this way
  , j_(42)  // Error: you cannot initialize static member data like this
{
  // ...
}

// You must define static data members this way:
int Fred::j_ = 42;
</code></pre>

<p>Note: in some cases, the definition of <code>Fred::j_</code> might not contain the <code>=</code> <em>initializer</em> part. For details, see
<a href="ctors.html#link-errs-static-data-mems" title="FAQ: Why are classes with static data members getting linker errors?">here</a> and <a href="ctors.html#static-const-with-initializers" title="FAQ: Can I add = initializer; to the declaration of a class-scope static const data member?">here</a>.</p>

<h3 id="link-errs-static-data-mems">Why are classes with <code>static</code> data members getting linker errors?</h3>

<p>Because <a href="ctors.html#explicit-define-static-data-mems" title="FAQ: Why can't I initialize my static member data in my constructor's initialization list?"><code>static</code> data members must be explicitly defined in exactly one compilation
unit</a>. If you didn&#8217;t do this, you&#8217;ll probably get an <code>"undefined external"</code> linker
error. For example:</p>

<pre><code>// Fred.h

class Fred {
public:
  // ...
private:
  static int j_;   // Declares static data member Fred::j_
  // ...
};
</code></pre>

<p>The linker will holler at you (<code>"Fred::j_ is not defined"</code>) unless you define (as opposed to merely declare) <code>Fred::j_</code>
in (exactly) one of your source files:</p>

<pre><code>// Fred.cpp

#include "Fred.h"

int Fred::j_ = some_expression_evaluating_to_an_int;

// Alternatively, if you wish to use the implicit 0 value for static ints:
// int Fred::j_;
</code></pre>

<p>The usual place to define <code>static</code> data members of <code>class</code> <code>Fred</code> is file <code>Fred.cpp</code> (or <code>Fred.C</code> or whatever source
file extension you use).</p>

<p>Note: <a href="ctors.html#static-const-with-initializers" title="FAQ: Can I add = initializer; to the declaration of a class-scope static const data member?">in some cases, you can add <code>=</code> <em>initializer</em><code>;</code> to the declaration of class-scope <code>static</code>
declarations</a>, however if you ever use the data member, you still need to explicitly
define it in exactly one compilation unit. In this case you don&#8217;t include an <code>=</code> <em>initializer</em> in the definition. <a href="ctors.html#static-const-with-initializers" title="FAQ: Can I add = initializer; to the declaration of a class-scope static const data member?">A
separate FAQ</a> covers this topic.</p>

<h3 id="static-const-with-initializers">Can I add <code>=</code> <em>initializer</em><code>;</code> to the declaration of a class-scope <code>static</code> <code>const</code> data member?</h3>

<p>Yes, though with some important caveats.</p>

<p>Before going through the caveats, here is a simple example that is allowed:</p>

<pre><code>// Fred.h

class Fred {
public:
  static const int maximum = 42;
  // ...
};
</code></pre>

<p>And, <a href="ctors.html#link-errs-static-data-mems" title="FAQ: Why are classes with static data members getting linker errors?">as with other <code>static</code> data members</a>, it must be defined in exactly one compilation
unit, though this time without the <code>=</code> <em>initializer</em> part:</p>

<pre><code>// Fred.cpp

#include "Fred.h"

const int Fred::maximum;

// ...
</code></pre>

<p>The caveats are that you may do this only with integral or enumeration types, and that the <em>initializer</em> expression must
be an expression that can be evaluated at compile-time: it must only contain other constants, possibly combined with
built-in operators. For example, <code>3*4</code> is a compile-time constant expression, as is <code>a*b</code> provided <code>a</code> and <code>b</code> are
compile-time constants. After the declaration above, <code>Fred::maximum</code> is also a compile-time constant: it can be used
in other compile-time constant expressions.</p>

<p>If you ever take the address of <code>Fred::maximum</code>, such as passing it by reference or explicitly saying <code>&amp;Fred::maximum</code>,
the compiler will make sure it has a unique address. If not, <code>Fred::maximum</code> won&#8217;t even take up space in your process&#8217;s
static data area.</p>

<h3 id="static-init-order">What&#8217;s the &#8220;<code>static</code> initialization order fiasco&#8221;?</h3>

<p>A subtle way to crash your program.</p>

<p>The <em><code>static</code> initialization order fiasco</em> is a very subtle and commonly misunderstood aspect of C++. Unfortunately
it&#8217;s very hard to detect &#8212; the errors often occur before <code>main()</code> begins.</p>

<p>In short, suppose you have two <code>static</code> objects <code>x</code> and <code>y</code> which exist in separate source files, say <code>x.cpp</code> and
<code>y.cpp</code>. Suppose further that the initialization for the <code>y</code> object (typically the <code>y</code> object&#8217;s constructor) calls some
method on the <code>x</code> object.</p>

<p>That&#8217;s it. It&#8217;s that simple.</p>

<p>The tragedy is that you have a 50%-50% chance of dying. If the compilation unit for <code>x.cpp</code> happens to get initialized
first, all is well. But if the compilation unit for <code>y.cpp</code> get initialized first, then <code>y</code>&#8217;s initialization will get
run before <code>x</code>&#8217;s initialization, and you&#8217;re toast. E.g., <code>y</code>&#8217;s constructor could call a method on the <code>x</code> object, yet
the <code>x</code> object hasn&#8217;t yet been constructed.</p>

<p>I hear they&#8217;re hiring down at McDonalds. Enjoy your new job flipping burgers.</p>

<p>If you think it&#8217;s &#8220;exciting&#8221; to play Russian Roulette with live rounds in half the chambers, you can stop reading here.
On the other hand if you like to improve your chances of survival by preventing disasters in a systematic way, you
probably want to read <a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?">the next FAQ</a>.</p>

<p>Note: The static initialization order fiasco can also, <a href="ctors.html#static-init-order-on-intrinsics" title="FAQ: Do I need to worry about the 'static initialization order fiasco' for variables of built-in/intrinsic types?">in some cases</a>, apply to
built-in/intrinsic types.</p>

<h3 id="static-init-order-on-first-use">How do I prevent the &#8220;<code>static</code> initialization order fiasco&#8221;?</h3>

<p>To prevent the <a href="ctors.html#static-init-order" title="FAQ: What's the 'static initialization order fiasco'?">static initialization order fiasco</a>, use the <em>Construct On First Use Idiom</em>,
described below.</p>

<p>The basic idea of the <em>Construct On First Use Idiom</em> is to wrap your <code>static</code> object inside a function. For example,
suppose you have two classes, <code>Fred</code> and <code>Barney</code>. There is a namespace-scope / global <code>Fred</code> object called <code>x</code>, and a
namespace-scope / global <code>Barney</code> object called <code>y</code>. <code>Barney</code>&#8217;s constructor invokes the <code>goBowling()</code> method on the <code>x</code>
object. The file <code>x.cpp</code> defines the <code>x</code> object:</p>

<pre><code>// File x.cpp
#include "Fred.h"
Fred x;
</code></pre>

<p>The file <code>y.cpp</code> defines the <code>y</code> object:</p>

<pre><code>// File y.cpp
#include "Barney.h"
Barney y;
</code></pre>

<p>For completeness the <code>Barney</code> constructor might look something like this:</p>

<pre><code>// File Barney.cpp
#include "Barney.h"

Barney::Barney()
{
  // ...
  x.goBowling();
  // ...
}
</code></pre>

<p>You would have a <a href="ctors.html#static-init-order" title="FAQ: What's the 'static initialization order fiasco'?"><code>static</code> initialization disaster</a> if <code>y</code> got constructed before <code>x</code>. As written
above, this disaster would occur roughly 50% of the time, since the two objects are declared in different source files
and those source files give no hints to the compiler or linker as to the order of static initialization.</p>

<p>There are many solutions to this problem, but a very simple and completely portable solution is the <em>Construct On First
Use Idiom</em>: replace the namespace-scope / global <code>Fred</code> object <code>x</code> with a namespace-scope / global function <code>x()</code>
that returns the <code>Fred</code> object by reference.</p>

<pre><code>// File x.cpp

#include "Fred.h"

Fred&amp; x()
{
  static Fred* ans = new Fred();
  return *ans;
}
</code></pre>

<p>Since <code>static</code> local objects are constructed the first time control flows over their declaration (only), the above
<code>new Fred()</code> statement will only happen once: the first time <code>x()</code> is called. Every subsequent call will return the
same <code>Fred</code> object (the one pointed to by <code>ans</code>). Then all you do is change your usages of <code>x</code> to <code>x()</code>:</p>

<pre><code>// File Barney.cpp
#include "Barney.h"

Barney::Barney()
{
  // ...
  x().goBowling();
  // ...
}
</code></pre>

<p>This is called the <em>Construct On First Use Idiom</em> because it does just that: the (logically namespace-scope / global)
<code>Fred</code> object is constructed on its first use.</p>

<p>The downside of this approach is that the <code>Fred</code> object is never destructed. If the <code>Fred</code> object has a destructor with
important side effects, there is <a href="ctors.html#construct-on-first-use-v2" title="FAQ: Why doesn't the Construct On First Use Idiom use a static object instead of a static pointer?">another technique</a> that answers this concern; but it needs
to be used with care since it creates the possibility of another (equally nasty) problem.</p>

<p>Note: The static initialization order fiasco can also, <a href="ctors.html#static-init-order-on-intrinsics" title="FAQ: Do I need to worry about the 'static initialization order fiasco' for variables of built-in/intrinsic types?">in some cases</a>, apply to
built-in/intrinsic types.</p>

<h3 id="construct-on-first-use-v2">Why doesn&#8217;t the Construct On First Use Idiom use a <code>static</code> object instead of a <code>static</code> pointer?</h3>

<p>Short answer: it&#8217;s possible to use a static object <a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?">rather than a static pointer</a>, but
doing so opens up another (equally subtle, equally nasty) problem.</p>

<p>Long answer: sometimes people worry about the fact that <a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?">the previous solution</a>
&#8220;leaks.&#8221; In many cases, this is not a problem, but it is a problem in some cases. Note: even though the object pointed
to by <code>ans</code> in the previous FAQ is never deleted, the memory doesn&#8217;t actually &#8220;leak&#8221; when the program exits since the
operating system automatically reclaims all the memory in a program&#8217;s heap when that program exits. In other words, the
only time you&#8217;d need to worry about this is when the destructor for the <code>Fred</code> object performs some important action
(such as writing something to a file) that must occur sometime while the program is exiting.</p>

<p>In those cases where the construct-on-first-use <em>object</em> (the <code>Fred</code>, in this case) needs to eventually get
destructed, you might consider changing function <code>x()</code> as follows:</p>

<pre><code>// File x.cpp

#include "Fred.h"

Fred&amp; x()
{
  static Fred ans;  // was static Fred* ans = new Fred();
  return ans;       // was return *ans;
}
</code></pre>

<p>However there is (or rather, may be) a rather subtle problem with this change. To understand this potential problem,
let&#8217;s remember why we&#8217;re doing all this in the first place: we need to make 100% sure our static object (a) gets
constructed prior to its first use and (b) doesn&#8217;t get destructed until after its last use. Obviously it would be a
disaster if any static object got used either before construction or after destruction. The message here is that you
need to worry about two situations (static initialization and static deinitialization), not just one.</p>

<p>By changing the declaration from <code>static Fred* ans = new Fred();</code> to <code>static Fred ans;</code>, we still correctly handle the
initialization situation but we no longer handle the deinitialization situation. For example, if there are 3 static
objects, say <code>a</code>, <code>b</code> and <code>c</code>, that use <code>ans</code> during their destructors, the only way to avoid a static deinitialization
disaster is if <code>ans</code> is destructed after all three.</p>

<p>The point is simple: if there are any other static objects whose destructors might use <code>ans</code> after <code>ans</code> is destructed,
bang, you&#8217;re dead. If the <em>constructors</em> of <code>a</code>, <code>b</code> and <code>c</code> use <code>ans</code>, you <em>should</em> normally be okay since the runtime
system will, during static deinitialization, destruct <code>ans</code> after the last of those three objects is destructed. However
if <code>a</code> and/or <code>b</code> and/or <code>c</code> fail to use <code>ans</code> in their constructors and/or if any code anywhere gets the address of
<code>ans</code> and hands it to some other static object, all bets are off and you have to be very, very careful.</p>

<p>There is <a href="ctors.html#nifty-counter-idiom" title="FAQ: What is a technique to guarantee both static initialization and static deinitialization?">a third approach that handles both the static initialization and static deinitialization
situations</a>, but it has other non-trivial costs.</p>

<h3 id="nifty-counter-idiom">What is a technique to guarantee both <code>static</code> initialization and <code>static</code> deinitialization?</h3>

<p>Short answer: use the <em>Nifty Counter Idiom</em> (but make sure you understand the non-trivial tradeoffs!).</p>

<p>Motivation:</p>

<ul>
<li>The <a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?"><em>Construct On First Use Idiom</em></a> uses a pointer and intentionally leaks the
object. That is often innocuous, since the operating system will typically clean up a process&#8217;s memory when the
process terminates. However if the object has a non-trivial destructor with important side effects, such as writing
to a file or some other non-volatile action, then you need more.</li>
<li>That&#8217;s where <a href="ctors.html#construct-on-first-use-v2" title="FAQ: Why doesn't the Construct On First Use Idiom use a static object instead of a static pointer?">the second version of the <em>Construct On First Use Idiom</em></a> came in: it
doesn&#8217;t leak the object, but it does not control the order of static deinitialization, so it is (very!) unsafe to use
the object during static deinitialization, that is, from a destructor of another statically declared object.</li>
<li>If you need to control the order of both static initialization and static deinitialization, meaning if you wish to
access a statically allocated object from both constructors and destructors of other static objects, then keep
reading.</li>
<li>Otherwise run away.</li>
</ul>

<p>TODO: WRITE THIS UP</p>

<p>TODO: WRITE UP TRADEOFFS &#8212; now that you know <em>how</em> to use the <em>Nifty Counter Idiom</em>, be sure you understand both
<em>when</em> and (especially!) <em>when not</em> to use it! One size does not fit all.</p>

<h3 id="static-init-order-on-first-use-members">How do I prevent the &#8220;<code>static</code> initialization order fiasco&#8221; for my <code>static</code> data members?</h3>

<p>Use the <em>Construct Members On First Use Idiom</em>, which is basically the same as <a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?">the regular <em>Construct On First Use
Idiom</em></a>, or perhaps <a href="ctors.html#construct-on-first-use-v2" title="FAQ: Why doesn't the Construct On First Use Idiom use a static object instead of a static pointer?">one of its variants</a>, but it uses a
<code>static</code> member function instead of a namespace-scope / global function.</p>

<p>Suppose you have a class <code>X</code> that has a <code>static</code> <code>Fred</code> object:</p>

<pre><code>// File X.h

class X {
public:
  // ...

private:
  static Fred x_;
};
</code></pre>

<p>Naturally this <code>static</code> member is initialized separately:</p>

<pre><code>// File X.cpp

#include "X.h"

Fred X::x_;
</code></pre>

<p>Naturally also the <code>Fred</code> object will be used in one or more of <code>X</code>&#8217;s methods:</p>

<pre><code>void X::someMethod()
{
  x_.goBowling();
}
</code></pre>

<p>But now the &#8220;disaster scenario&#8221; is if someone somewhere somehow calls this method before the <code>Fred</code> object gets
constructed. For example, if someone else creates a static <code>X</code> object and invokes its <code>someMethod()</code> method during
<code>static</code> initialization, then you&#8217;re at the mercy of the compiler as to whether the compiler will construct <code>X::x_</code>
before or after the <code>someMethod()</code> is called. (Note that the ANSI/ISO C++ committee is working on this problem, but
compilers aren&#8217;t yet generally available that handle these changes; watch this space for an update in the future.)</p>

<p>In any event, it&#8217;s always portable and safe to change the <code>X::x_</code> <code>static</code> data member into a <code>static</code> member function:</p>

<pre><code>// File X.h

class X {
public:
  // ...

private:
  static Fred&amp; x();
};
</code></pre>

<p>Naturally this <code>static</code> member is initialized separately:</p>

<pre><code>// File X.cpp

#include "X.h"

Fred&amp; X::x()
{
  static Fred* ans = new Fred();
  return *ans;
}
</code></pre>

<p>Then you simply change any usages of <code>x_</code> to <code>x()</code>:</p>

<pre><code>void X::someMethod()
{
  x().goBowling();
}
</code></pre>

<p>If you&#8217;re super performance sensitive and you&#8217;re concerned about the overhead of an extra function call on each
invocation of <code>X::someMethod()</code> you can set up a <code>static</code> <code>Fred&amp;</code> instead. As you recall, <code>static</code> local are only
initialized once (the first time control flows over their declaration), so this will call <code>X::x()</code> only once: the first
time <code>X::someMethod()</code> is called:</p>

<pre><code>void X::someMethod()
{
  static Fred&amp; x = X::x();
  x.goBowling();
}
</code></pre>

<p>Note: The static initialization order fiasco can also, <a href="ctors.html#static-init-order-on-intrinsics" title="FAQ: Do I need to worry about the 'static initialization order fiasco' for variables of built-in/intrinsic types?">in some cases</a>, apply to
built-in/intrinsic types.</p>

<h3 id="static-init-order-on-intrinsics">Do I need to worry about the &#8220;<code>static</code> initialization order fiasco&#8221; for variables of built-in/intrinsic types?</h3>

<p>Yes.</p>

<p>If you initialize your built-in/intrinsic type using a function call, the static initialization order fiasco is able to
kill you just as bad as with user-defined/class types. For example, the following code shows the failure:</p>

<pre><code>#include &lt;iostream&gt;

int f();  // forward declaration
int g();  // forward declaration

int x = f();
int y = g();

int f()
{
  std::cout &lt;&lt; "using 'y' (which is " &lt;&lt; y &lt;&lt; ")\n";
  return 3*y + 7;
}

int g()
{
  std::cout &lt;&lt; "initializing 'y'\n";
  return 5;
}
</code></pre>

<p>The output of this little program will show that it uses <code>y</code> before initializing it. The solution, as before, is the
<a href="ctors.html#static-init-order-on-first-use" title="FAQ: How do I prevent the 'static initialization order fiasco'?"><em>Construct On First Use Idiom</em></a>:</p>

<pre><code>#include &lt;iostream&gt;

int f();  // forward declaration
int g();  // forward declaration

int&amp; x()
{
  static int ans = f();
  return ans;
}

int&amp; y()
{
  static int ans = g();
  return ans;
}

int f()
{
  std::cout &lt;&lt; "using 'y' (which is " &lt;&lt; y() &lt;&lt; ")\n";
  return 3*y() + 7;
}

int g()
{
  std::cout &lt;&lt; "initializing 'y'\n";
  return 5;
}
</code></pre>

<p>Of course you might be able to simplify this by moving the initialization code for <code>x</code> and <code>y</code> into their respective
functions:</p>

<pre><code>#include &lt;iostream&gt;

int&amp; y();  // forward declaration

int&amp; x()
{
  static int ans;

  static bool firstTime = true;
  if (firstTime) {
    firstTime = false;
    std::cout &lt;&lt; "using 'y' (which is " &lt;&lt; y() &lt;&lt; ")\n";
    ans = 3*y() + 7;
  }

  return ans;
}

int&amp; y()
{
  static int ans;

  static bool firstTime = true;
  if (firstTime) {
    firstTime = false;
    std::cout &lt;&lt; "initializing 'y'\n";
    ans = 5;
  }

  return ans;
}
</code></pre>

<p>And, if you can get rid of the print statements you can further simplify these to something really simple:</p>

<pre><code>int&amp; y();  // forward declaration

int&amp; x()
{
  static int ans = 3*y() + 7;
  return ans;
}

int&amp; y()
{
  static int ans = 5;
  return ans;
}
</code></pre>

<p>Furthermore, since <code>y</code> is initialized using a constant expression, it no longer needs its wrapper function &#8212; it can be
a simple variable again.</p>

<h3 id="ctors-can-throw2">How can I handle a constructor that fails?</h3>

<p>Throw an exception. For details, see <a href="exceptions.html#ctors-can-throw" title="FAQ: How can I handle a constructor that fails?">here</a>.</p>

<h3 id="named-parameter-idiom">What is the &#8220;Named Parameter Idiom&#8221;?</h3>

<p>It&#8217;s a fairly useful way to exploit <a href="references.html#method-chaining" title="FAQ: What does object.method1().method2() mean?">method chaining</a>.</p>

<p>The fundamental problem solved by the Named Parameter Idiom is that C++ only supports <em>positional parameters</em>. For
example, a caller of a function isn&#8217;t allowed to say, &#8220;Here&#8217;s the value for formal parameter <code>xyz</code>, and this other thing
is the value for formal parameter <code>pqr</code>.&#8221; All you can do in C++ (and C and Java) is say, &#8220;Here&#8217;s the first parameter,
here&#8217;s the second parameter, etc.&#8221; The alternative, called <em>named parameters</em> and implemented in the language Ada, is
especially useful if a function takes a large number of mostly default-able parameters.</p>

<p>Over the years people have cooked up lots of workarounds for the lack of named parameters in C and C++. One of these
involves burying the parameter values in a string parameter then parsing this string at run-time. This is what&#8217;s done
in the second parameter of <code>fopen()</code>, for example. Another workaround is to combine all the boolean parameters in a
bit-map, then the caller <em>or</em>&#8217;s a bunch of bit-shifted constants together to produce the actual parameter. This is
what&#8217;s done in the second parameter of <code>open()</code>, for example. These approaches work, but the following technique
produces caller-code that&#8217;s more obvious, easier to write, easier to read, and is generally more elegant.</p>

<p>The idea, called the Named Parameter Idiom, is to change the function&#8217;s parameters to methods of a newly created class,
where all these methods return <code>*this</code> by reference. Then you simply rename the main function into a parameterless
&#8220;do-it&#8221; method on that class.</p>

<p>We&#8217;ll work an example to make the previous paragraph easier to understand.</p>

<p>The example will be for the &#8220;open a file&#8221; concept. Let&#8217;s say that concept logically requires a parameter for the file&#8217;s
name, and optionally allows parameters for whether the file should be opened read-only vs. read-write vs. write-only,
whether or not the file should be created if it doesn&#8217;t already exist, whether the writing location should be at the end
(&#8220;append&#8221;) or the beginning (&#8220;overwrite&#8221;), the block-size if the file is to be created, whether the I/O is buffered or
non-buffered, the buffer-size, whether it is to be shared vs. exclusive access, and probably a few others. If we
implemented this concept using a normal function with positional parameters, the caller code would be very difficult to
read: there&#8217;d be as many as 8 positional parameters, and the caller would probably make a lot of mistakes. So instead
we use the Named Parameter Idiom.</p>

<p>Before we go through the implementation, here&#8217;s what the caller code might look like, assuming you are willing to accept
all the function&#8217;s default parameters:</p>

<pre><code>File f = OpenFile("foo.txt");
</code></pre>

<p>That&#8217;s the easy case. Now here&#8217;s what it might look like if you want to change a bunch of the parameters.</p>

<pre><code>File f = OpenFile("foo.txt")
           .readonly()
           .createIfNotExist()
           .appendWhenWriting()
           .blockSize(1024)
           .unbuffered()
           .exclusiveAccess();
</code></pre>

<p>Notice how the &#8220;parameters&#8221;, if it&#8217;s fair to call them that, are in random order (they&#8217;re not positional) and they all
have names. So the programmer doesn&#8217;t have to remember the order of the parameters, and the names are (hopefully)
obvious.</p>

<p>So here&#8217;s how to implement it: first we create a class (<code>OpenFile</code>) that houses all the parameter values as <code>private</code>
data members. The required parameters (in this case, the only required parameter is the file&#8217;s name) is implemented as a
normal, positional parameter on <code>OpenFile</code>&#8217;s constructor, but that constructor doesn&#8217;t actually open the file. Then all
the optional parameters (readonly vs. readwrite, etc.) become methods. These methods (e.g., <code>readonly()</code>,
<code>blockSize(unsigned)</code>, etc.) return a reference to their <code>this</code> object so the method calls can be
<a href="references.html#method-chaining" title="FAQ: What does object.method1().method2() mean?">chained</a>.</p>

<pre><code>class File;

class OpenFile {
public:
  OpenFile(const std::string&amp; filename);
    // sets all the default values for each data member
  OpenFile&amp; readonly();  // changes readonly_ to true
  OpenFile&amp; readwrite(); // changes readonly_ to false
  OpenFile&amp; createIfNotExist();
  OpenFile&amp; blockSize(unsigned nbytes);
  // ...
private:
  friend class File;
  std::string filename_;
  bool readonly_;          // defaults to false [for example]
  bool createIfNotExist_;  // defaults to false [for example]
  // ...
  unsigned blockSize_;     // defaults to 4096 [for example]
  // ...
};

inline OpenFile::OpenFile(const std::string&amp; filename)
  : filename_         (filename)
  , readonly_         (false)
  , createIfNotExist_ (false)
  , blockSize_        (4096u)
{ }

inline OpenFile&amp; OpenFile::readonly()
{ readonly_ = true; return *this; }

inline OpenFile&amp; OpenFile::readwrite()
{ readonly_ = false; return *this; }

inline OpenFile&amp; OpenFile::createIfNotExist()
{ createIfNotExist_ = true; return *this; }

inline OpenFile&amp; OpenFile::blockSize(unsigned nbytes)
{ blockSize_ = nbytes; return *this; }
</code></pre>

<p>The only other thing to do is make the constructor for class <code>File</code> to take an <code>OpenFile</code> object:</p>

<pre><code>class File {
public:
  File(const OpenFile&amp; params);
  // ...
};
</code></pre>

<p>This constructor gets the actual parameters from the OpenFile object, then actually opens the file:</p>

<pre><code>File::File(const OpenFile&amp; params)
{
  // ...
}
</code></pre>

<p>Note that <code>OpenFile</code> declares <code>File</code> as its <a href="friends.html" title="Section: Friends"><code>friend</code></a>, that way <a href="friends.html#friends-and-encap" title="FAQ: Do friends violate encapsulation?"><code>OpenFile</code> doesn&#8217;t need a bunch of (otherwise
useless) <code>public:</code> <em>get</em> methods</a>.</p>

<p>Since each member function in the chain returns a reference, there is no copying of objects and the chain is highly
efficient. Furthermore, if the various member functions are <code>inline</code>, the generated object code will probably be on par
with C-style code that sets various members of a <code>struct</code>. Of course if the member functions are not <code>inline</code>, there
may be a slight increase in code size and a slight decrease in performance (but only if the construction occurs on the
critical path of a CPU-bound program; this is a can of worms I&#8217;ll try to avoid opening), so it may, in this case, be a
tradeoff for making the code more reliable.</p>

<h3 id="fn-decl-vs-obj-instantiation">Why am I getting an error after declaring a <code>Foo</code> object via <code>Foo x(Bar())</code>?</h3>

<p>Because that doesn&#8217;t create a <code>Foo</code> object - it declares a non-member function that <em>returns</em> a <code>Foo</code> object.  The term &#8220;Most Vexing Parse&#8221; was coined by Scott Myers to describe this situation.</p>

<p>This is really going to hurt; you might want to sit down.</p>

<p>First, here&#8217;s a better explanation of the problem. Suppose there is a class called <code>Bar</code> that has a default ctor. This
might even be a library class such as <code>std::string</code>, but for now we&#8217;ll just call it <code>Bar</code>:</p>

<pre><code>class Bar {
public:
  Bar();
  // ...
};
</code></pre>

<p>Now suppose there&#8217;s another class called <code>Foo</code> that has a ctor that takes a <code>Bar</code>. As before, this might be defined by someone other than you.</p>

<pre><code>class Foo {
public:
  Foo(const Bar&amp; b);  // or perhaps Foo(Bar b)
  // ...
  void blah();
  // ...
};
</code></pre>

<p>Now you want to create a <code>Foo</code> object using a temporary <code>Bar</code>. In other words, you want to create an object via <code>Bar()</code>,
and pass that to the <code>Foo</code> ctor to create a local <code>Foo</code> object called <code>x</code>:</p>

<pre><code>void yourCode()
{
  Foo x(Bar());  // You think this creates a Foo object called x...
  x.blah();      // ...But it doesn't, so this line gives you a bizarre error message
  // ...
}
</code></pre>

<p>It&#8217;s a long story, but one solution (hope you&#8217;re sitting down!) is to add an extra pair of <code>()</code>s around the <code>Bar()</code> part:</p>

<pre><code>void yourCode()
{
  Foo x((Bar()));
        ↑     ↑ // These parens save the day

  x.blah();
  ↑↑↑↑↑↑↑↑ // Ahhhh, this now works: no more error messages

  // ...
}
</code></pre>

<p>Another solution is to use <code>=</code> in your declaration (see the fine print below):</p>

<pre><code>void yourCode()
{
  Foo x = Foo(Bar());  // Yes, Virginia, that thar syntax works; see below for fine print
  x.blah();            // Ahhhh, this now works: no more error messages
  // ...
}
</code></pre>

<p><em>Note:</em> The above solution requires <code>yourCode()</code> to be able to access the <code>Foo</code> copy constructor. In most situations that means the <code>Foo</code> copy constructor needs to be <code>public</code>, though it needn&#8217;t be <code>public</code> in the less common case where <code>yourCode()</code> is a <a href="friends.html" title="Section: Friends">friend</a> of <code>class Foo</code>. If you&#8217;re not sure what any of that means, try it: if your code compiles, you passed the test.</p>

<p>Here&#8217;s another solution (more fine print below):</p>

<pre><code>void yourCode()
{
  Foo x = Bar();  // Usually works; see below for fine print on "usually"
  x.blah();
  // ...
}
</code></pre>

<p><em>Note:</em> The word &#8220;usually&#8221; in the above means this: the above fails only when <code>Foo::Foo(const Bar&amp;)</code> <a href="ctors.html#explicit-ctors" title="FAQ: What is the purpose of the explicit keyword?">constructor is <code>explicit</code></a>, or when <code>Foo</code>&#8217;s copy constructor is inaccessible (typically when it is <code>private</code> or <code>protected</code>, and your code is not a <code>friend</code>). If you&#8217;re not sure what any of that means, take 60 seconds and compile it. You are guaranteed to find out whether it works or fails at compile-time, so if it compiles cleanly, it will work
at runtime.</p>

<p>However, the <em>best</em> solution, the creation of which was at least partially motivated by the fact that this FAQ exists, is to use <a href="cpp11-language.html#uniform-init" title="FAQ: Uniform initialization syntax and semantics">uniform initialization</a>, which replaces the <code>()</code> around the <code>Bar()</code> call with <code>{}</code> instead.</p>

<pre><code>void yourCode()
{
  Foo x{Bar()};  
  x.blah();      // Ahhhh, this now works: no more error messages
  // ...
}
</code></pre>

<p>That&#8217;s the end of the solutions; the rest of this is about <em>why</em> this is needed (this is optional; you can skip this section if you don&#8217;t care enough about your career to actually understand what&#8217;s going on; ha ha): When the compiler sees <code>Foo x(Bar())</code>, it thinks that the <code>Bar()</code> part is declaring a non-member function that returns a <code>Bar</code> object, so it thinks you are declaring the existence of a <em>function</em> called <code>x</code> that returns a <code>Foo</code> and that takes as a single parameter of type &#8220;non-member function that takes nothing and returns a <code>Bar</code>.&#8221;</p>

<p>Now here&#8217;s the sad part. In fact it&#8217;s pathetic. Some mindless drone out there is going to skip that last paragraph, then they&#8217;re going to impose a bizarre, incorrect, irrelevant, and just plain <em>stupid</em> coding standard that says something like, &#8220;Never create temporaries using a default constructor&#8221; or &#8220;Always use <code>=</code> in all initializations&#8221; or something else equally inane. If that&#8217;s you, please fire yourself before you do any more damage. Those who don&#8217;t <em>understand the problem</em> shouldn&#8217;t tell others how to solve it. Harumph.</p>

<p>(That was mostly tongue in cheek. But there&#8217;s a grain of truth in it. The real problem is that people tend to worship consistency, and they tend to extrapolate from the obscure to the common. That&#8217;s not wise.)</p>

<h3 id="explicit-ctors">What is the purpose of the <code>explicit</code> keyword?</h3>

<p>The <code>explicit</code> keyword is an optional decoration for constructors and conversion operators to tell the compiler that a certain constructor or conversion operator may <em>not</em> be used to implicitly cast an expression to its class type.</p>

<p>For example, without the <code>explicit</code> keyword the following code is valid:</p>

<pre><code>class Foo {
public:
  Foo(int x);
  operator int();
};

class Bar {
public:
  Bar(double x);
  operator double();
};

void yourCode()
{
  Foo a = 42;         // Okay: calls Foo::Foo(int) passing 42 as an argument
  Foo b(42);          // Okay: calls Foo::Foo(int) passing 42 as an argument
  Foo c = Foo(42);    // Okay: calls Foo::Foo(int) passing 42 as an argument
  Foo d = (Foo)42;    // Okay: calls Foo::Foo(int) passing 42 as an argument
  int e = d;          // Okay: calls Foo::operator int()

  Bar x = 3.14;       // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  Bar y(3.14);        // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  Bar z = Bar(3.14);  // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  Bar w = (Bar)3.14;  // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  double v = w;       // Okay: calls Bar::operator double()
}
</code></pre>

<p>But sometimes you want to prevent this sort of implicit promotion or implicit type conversion. For example, if <code>Foo</code> is really an array-like container and 42 is the initial size, you might want to let your users say, <code>Foo x(42);</code> or perhaps <code>Foo x = Foo(42);</code>, but not just <code>Foo x = 42;</code>. If that&#8217;s the case, you should use the <code>explicit</code> keyword:</p>

<pre><code>class Foo {
public:
  explicit Foo(int x);
  explicit operator int();
};

class Bar {
public:
  explicit Bar(double x);
  explicit operator double();
};

void yourCode()
{
  Foo a = 42;           // Compile-time error: can't convert 42 to an object of type Foo
  Foo b(42);            // Okay: calls Foo::Foo(int) passing 42 as an argument
  Foo c = Foo(42);      // Okay: calls Foo::Foo(int) passing 42 as an argument
  Foo d = (Foo)42;      // Okay: calls Foo::Foo(int) passing 42 as an argument
  int e = d;            // Compile-time error: can't convert d to an integer
  int f = int(d);       // Okay: calls Foo::operator int()

  Bar x = 3.14;         // Compile-time error: can't convert 3.14 to an object of type Bar
  Bar y(3.14);          // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  Bar z = Bar(3.14);    // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  Bar w = (Bar)3.14;    // Okay: calls Bar::Bar(double) passing 3.14 as an argument
  double v = w;         // Compile-time error: can't convert w to a double
  double u = double(w); // Okay: calls Bar::operator double()
}
</code></pre>

<p>You can mix <code>explicit</code> and non-<code>explicit</code> constructors and conversion operators in the same class. For example, this class has an <code>explicit</code> constructor taking a <code>bool</code> but a non-<code>explicit</code> constructor taking a <code>double</code>, and can be implicitly converted to double, but only explicitly converted to bool:</p>

<pre><code>#include &lt;iostream&gt;

class Foo {
public:
  Foo(double x)            { std::cout &lt;&lt; "Foo(double)\n"; }
  explicit Foo(bool x)     { std::cout &lt;&lt; "Foo(bool)\n"; }
  operator double()        { std::cout &lt;&lt; "operator double()\n"; }
  explicit operator bool() { std::cout &lt;&lt; "operator bool()\n"; }
};

void yourCode()
{
  Foo a = true;       // Okay: implicitly promotes true to (double)1.0, then calls Foo::Foo(double)
  Foo b = Foo(true);  // Okay: explicitly calls Foo::Foo(bool)
  double c = b;       // Okay: implicitly calls Foo::operator double()
  bool d = b;         // Okay: calls Foo::operator double() and implicitly converts to bool
  if(b) {}            // Okay, explicitly calls Foo::operator bool()
}
</code></pre>

<p>The above code will print the following:</p>

<pre><code>Foo(double)
Foo(bool)
operator double()
operator double()
operator bool()
</code></pre>

<p>Variable <code>a</code> is initialized using the <code>Foo(double)</code> constructor because <code>Foo(bool)</code> cannot be used in an implicit cast, but <code>true</code> can be interpreted as a <code>(double)true</code>, that is, as <code>1.0</code>, and implicitly cast to <code>Foo</code> using <code>Foo::Foo(double)</code>. This may or may not be what you intended, but this is what happens.</p>

<h3 id="ctor-work-right">Why doesn&#8217;t my constructor work right?</h3>

<p>This is a question that comes in many forms. Such as:</p>

<ul>
<li>Why does the compiler copy my objects when I don&#8217;t want it to?</li>
<li>How do I turn off copying?</li>
<li>How do I stop implicit conversions?</li>
<li>How did my int turn into a complex number?</li>
</ul>

<p>By default a class is given a copy constructor and a copy assignment that copy all elements, and a move constructor and a move assignment that move all elements. For example:</p>

<pre><code>    struct Point {
        int x,y;
        Point(int xx = 0, int yy = 0) :x(xx), y(yy) { }
    };

    Point p1(1,2);
    Point p2 = p1;  
</code></pre>

<p>Here we get <code>p2.x==p1.x</code> and <code>p2.y==p1.y</code>. That&#8217;s often exactly what you want (and essential for C compatibility), but consider:</p>

<pre><code>    class Handle {
    private:
        string name;
        X* p;
    public:
        Handle(string n)
            :name(n), p(0) { /* acquire X called "name" and let p point to it */ }
        ~Handle() { delete p; /* release X called "name" */ }
        // ...
    };

    void f(const string&amp; hh)
    {
        Handle h1(hh);
        Handle h2 = h1; // leads to disaster!
        // ...
    }
</code></pre>

<p>Here, the default copy gives us <code>h2.name==h1.name</code> and <code>h2.p==h1.p</code>. This leads to disaster: when we exit <code>f()</code> the destructors for <code>h1</code> and <code>h2</code> are invoked and the object pointed to by <code>h1.p</code> and <code>h2.p</code> is deleted twice.</p>

<p>How do we avoid this? The simplest solution is to mark the operations that copy as deleted:</p>

<pre><code>    class Handle {
    private:
        string name;
        X* p;

        Handle(const Handle&amp;) = delete;   // prevent copying
        Handle&amp; operator=(const Handle&amp;) = delete;
    public:
        Handle(string n)
            :name(n), p(0) { /* acquire the X called "name" and let p point to it */ }
        ~Handle() { delete p; /* release X called "name" */ }
        // ...
    };

    void f(const string&amp; hh)
    {
        Handle h1(hh);
        Handle h2 = h1; // error (reported by compiler)
        // ...
    }
</code></pre>

<p>If we need to copy or move, we can of course define the proper initializers and assignments to provide the desired semantics.</p>

<p>Now return to <code>Point</code>. For <code>Point</code> the default copy semantics is fine, the problem is the constructor:</p>

<pre><code>    struct Point {
        int x,y;
        Point(int xx = 0, int yy = 0) :x(xx), y(yy) { }
    };

    void f(Point);

    void g()
    {
        Point orig;  // create orig with the default value (0,0)
        Point p1(2); // create p1 with the default y-coordinate 0
        f(2);        // calls Point(2,0);
    }
</code></pre>

<p>People provide default arguments to get the convenience used for <code>orig</code> and <code>p1</code>. Then, some are surprised by the conversion of <code>2</code> to <code>Point(2,0)</code> in the call of <code>f()</code>.  This constructor defines a conversion. By default that&#8217;s an implicit conversion. To require such a conversion to be explicit, declare the constructor <code>explicit</code>:</p>

<pre><code>    struct Point {
        int x,y;
        explicit Point(int xx = 0, int yy = 0) :x(xx), y(yy) { }
    };

    void f(Point);

    void g()
    {
        Point orig;          // create orig with the default value (0,0)
        Point p1(2);         // create p1 with the default y-coordinate 0
                             // that's an explicit call of the constructor
        f(2);                // error (attempted implicit conversion)
        Point p2 = 2;        // error (attempted implicit conversion)
        Point p3 = Point(2); // ok (explicit conversion)
    }
</code></pre>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance — Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance — virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance — Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance — Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance — What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance — private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance — Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/ctors",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/ctors",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/ctors by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
</html>
<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/dtors by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="e66b150e06c70a5284bb5c71a7259e47b37e428c" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="de08ee7aa12800e36eda6074bc683fdf3cf59283" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="e956788c848755ef7c24de3c68074dbd24bd53ac" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        dtors
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="dtors.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    dtors
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=dtors" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="dtors">Destructors</h2>

<h3 id="overview-dtors">What&#8217;s the deal with destructors?</h3>

<p>A destructor gives an object its last rites.</p>

<p>Destructors are used to release any resources allocated by the object. E.g., <code>class</code> <code>Lock</code> might lock a semaphore, and
the destructor will release that semaphore. The most common example is when the constructor uses <code>new</code>, and the
destructor uses <code>delete</code>.</p>

<p>Destructors are a &#8220;prepare to die&#8221; member function. They are often abbreviated &#8220;dtor&#8221;.</p>

<h3 id="order-dtors-for-locals">What&#8217;s the order that local objects are destructed?</h3>

<p>In reverse order of construction: First constructed, last destructed.</p>

<p>In the following example, <code>b</code>&#8217;s destructor will be executed first, then <code>a</code>&#8217;s destructor:</p>

<pre><code>void userCode()
{
  Fred a;
  Fred b;
  // ...
}
</code></pre>

<h3 id="order-dtors-for-arrays">What&#8217;s the order that objects in an array are destructed?</h3>

<p>In reverse order of construction: First constructed, last destructed.</p>

<p>In the following example, the order for destructors will be <code>a[9]</code>, <code>a[8]</code>, &#8230;, <code>a[1]</code>, <code>a[0]</code>:</p>

<pre><code>void userCode()
{
  Fred a[10];
  // ...
}
</code></pre>

<h3 id="cant-overload-dtors">Can I overload the destructor for my class?</h3>

<p>No.</p>

<p>You can have only one destructor for a class <code>Fred</code>. It&#8217;s always called <code>Fred::~Fred()</code>. It never takes any parameters,
and it never returns anything.</p>

<p>You can&#8217;t pass parameters to the destructor anyway, since you <a href="dtors.html#dont-call-dtor-on-local" title="FAQ: Should I explicitly call a destructor on a local variable?">never explicitly call a
destructor</a> (well, <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?"><em>almost</em> never</a>).</p>

<h3 id="dont-call-dtor-on-local">Should I explicitly call a destructor on a local variable?</h3>

<p>No!</p>

<p>The destructor will get called <em>again</em> at the close <code>}</code> of the block in which the local was created. This is a guarantee
of the language; it happens automagically; there&#8217;s no way to stop it from happening. But you can get <em>really</em> bad
results from calling a destructor on the same object a second time! Bang! You&#8217;re dead!</p>

<h3 id="dont-call-dtor-on-local-really">What if I want a local to &#8220;die&#8221; before the close <code>}</code> of the scope in which it was created? Can I call a destructor on a local if I <em>really</em> want to?</h3>

<p>No! [For context, please read <a href="dtors.html#dont-call-dtor-on-local" title="FAQ: Should I explicitly call a destructor on a local variable?">the previous FAQ</a>&#93;.</p>

<p>Suppose the (desirable) side effect of destructing a local <code>File</code> object is to close the <code>File</code>. Now suppose you have an
object <code>f</code> of a class <code>File</code> and you want <code>File</code> <code>f</code> to be closed before the end of the scope (i.e., the <code>}</code>) of the
scope of object <code>f</code>:</p>

<pre><code>void someCode()
{
  File f;
  // ...code that should execute when f is still open...
  ← We want the side-effect of f's destructor here!
  // ...code that should execute after f is closed...
}
</code></pre>

<p>There is a <a href="dtors.html#artificial-block-to-control-lifetimes" title="FAQ: Okay, okay, already; I won't explicitly call the destructor of a local; but how do I handle the situation from the previous FAQ?">simple solution to this problem</a>. But in the mean time, remember:
<a href="dtors.html#dont-call-dtor-on-local" title="FAQ: Should I explicitly call a destructor on a local variable?"><em>Do not explicitly call the destructor!</em></a></p>

<h3 id="artificial-block-to-control-lifetimes">Okay, okay, already; I won&#8217;t explicitly call the destructor of a local; but how do I handle the situation from the previous FAQ?</h3>

<p>[For context, please read <a href="dtors.html#dont-call-dtor-on-local-really" title="FAQ: What if I want a local to 'die' before the close } of the scope in which it was created? Can I call a destructor on a local if I really want to?">the previous FAQ</a>&#93;.</p>

<p>Simply wrap the extent of the lifetime of the local in an artificial block <code>{...}</code>:</p>

<pre><code>void someCode()
{
  {
    File f;
    // ...code that should execute when f is still open...
  }
  ↑ // f's destructor will automagically be called here!

  // ...code that should execute after f is closed...
}
</code></pre>

<h3 id="dtor-like-method-to-control-lifetimes">What if I can&#8217;t wrap the local in an artificial block?</h3>

<p>Most of the time, you can limit the lifetime of a local by <a href="dtors.html#artificial-block-to-control-lifetimes" title="FAQ: Okay, okay, already; I won't explicitly call the destructor of a local; but how do I handle the situation from the previous FAQ?">wrapping the local in an artificial block
(<code>{...}</code>)</a>. But if for some reason you can&#8217;t do that, add a member function that
has a similar effect as the destructor. But <em>do not call the destructor itself!</em></p>

<p>For example, in the case of <code>class</code> <code>File</code>, you might add a <code>close()</code> method. Typically the destructor will simply call
this <code>close()</code> method. Note that the <code>close()</code> method will need to mark the <code>File</code> object so a subsequent call won&#8217;t
re-close an already-closed <code>File</code>. E.g., it might set the <code>fileHandle_</code> data member to some nonsensical value such as
-1, and it might check at the beginning to see if the <code>fileHandle_</code> is already equal to -1:</p>

<pre><code>class File {
public:
  void close();
  ~File();
  // ...
private:
  int fileHandle_;   // fileHandle_ &gt;= 0 if/only-if it's open
};

File::~File()
{
  close();
}

void File::close()
{
  if (fileHandle_ &gt;= 0) {
    // ...code that calls the OS to close the file...
    fileHandle_ = -1;
  }
}
</code></pre>

<p>Note that the other <code>File</code> methods may also need to check if the <code>fileHandle_</code> is -1 (i.e., check if the <code>File</code> is
closed).</p>

<p>Note also that any constructors that don&#8217;t actually open a file should set <code>fileHandle_</code> to -1.</p>

<h3 id="dont-call-dtor-on-obj-allocd-via-new">But can I explicitly call a destructor if I&#8217;ve allocated my object with <code>new</code>?</h3>

<p>Probably not.</p>

<p>Unless you used <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement <code>new</code></a>, you should simply <code>delete</code> the object rather than explicitly calling
the destructor. For example, suppose you allocated the object via a typical <code>new</code> expression:</p>

<pre><code>Fred* p = new Fred();
</code></pre>

<p>Then the destructor <code>Fred::~Fred()</code> will automagically get called when you <code>delete</code> it via:</p>

<pre><code>delete p;  // Automagically calls p-&gt;~Fred()
</code></pre>

<p>You should <em>not</em> explicitly call the destructor, since doing so won&#8217;t release the memory that was allocated for the
<code>Fred</code> object itself. Remember: <a href="freestore-mgmt.html#two-steps-of-delete" title="FAQ: What are the two steps that happen when I say delete p?"><code>delete p</code> does two things</a>: it calls the destructor and it
deallocates the memory.</p>

<h3 id="placement-new">What is &#8220;placement <code>new</code>&#8221; and why would I use it?</h3>

<p>There are many uses of placement <code>new</code>. The simplest use is to place an object at a particular location in memory. This
is done by supplying the place as a pointer parameter to the <code>new</code> part of a <code>new</code> expression:</p>

<pre><code>#include &lt;new&gt;        // Must #include this to use "placement new"
#include "Fred.h"     // Declaration of class Fred

void someCode()
{
  char memory[sizeof(Fred)];     // Line #1
  void* place = memory;          // Line #2

  Fred* f = new(place) Fred();   // Line #3 (see "DANGER" below)
  // The pointers f and place will be equal

  // ...
}
</code></pre>

<p>Line #1 creates an array of <code>sizeof(Fred)</code> bytes of memory, which is big enough to hold a <code>Fred</code> object. Line #2 creates
a pointer <code>place</code> that points to the first byte of this memory (experienced C programmers will note that this step was
unnecessary; it&#8217;s there only to make the code more obvious). Line #3 essentially just calls the constructor
<code>Fred::Fred()</code>. The <code>this</code> pointer in the <code>Fred</code> constructor will be equal to <code>place</code>. The returned pointer <code>f</code> will
therefore be equal to <code>place</code>.</p>

<p><em>ADVICE:</em> Don&#8217;t use this &#8220;placement <code>new</code>&#8221; syntax unless you have to. Use it only when you really care that an object
is placed at a particular location in memory. For example, when your hardware has a memory-mapped I/O timer device, and
you want to place a <code>Clock</code> object at that memory location.</p>

<p><em>DANGER:</em> You are taking <em>sole</em> responsibility that the pointer you pass to the &#8220;placement <code>new</code>&#8221; <code>operator</code> points to
a region of memory that is big enough and is properly aligned for the object type that you&#8217;re creating. Neither the
compiler nor the run-time system make any attempt to check whether you did this right. If your <code>Fred</code> class needs to be
aligned on a 4 byte boundary but you supplied a location that isn&#8217;t properly aligned, you can have a serious disaster on
your hands (if you don&#8217;t know what &#8220;alignment&#8221; means, <em>please</em> don&#8217;t use the placement <code>new</code> syntax). You have been
warned.</p>

<p>You are also solely responsible for destructing the placed object. This is done by explicitly calling the destructor:</p>

<pre><code>void someCode()
{
  char memory[sizeof(Fred)];
  void* p = memory;
  Fred* f = new(p) Fred();
  // ...
  f-&gt;~Fred();   // Explicitly call the destructor for the placed object
}
</code></pre>

<p>This is about the only time you ever explicitly call a destructor.</p>

<p>Note: there is <a href="dtors.html#memory-pools" title="FAQ: Is there a way to force new to allocate memory from a specific memory area?">a much cleaner but more sophisticated</a> way of handling the destruction / deletion
situation.</p>

<h3 id="placement-delete">Is there a placement <code>delete</code>?</h3>

<p>No, but if you need one you can write your own.</p>

<p>Consider placement <code>new</code> used to place objects in a set of arenas:</p>

<pre><code>        class Arena {
        public:
                void* allocate(size_t);
                void deallocate(void*);
                // ...
        };

        void* operator new(size_t sz, Arena&amp; a)
        {
                return a.allocate(sz);
        }

        Arena a1(some arguments);
        Arena a2(some arguments);
</code></pre>

<p>Given that, we can write</p>

<pre><code>        X* p1 = new(a1) X;
        Y* p2 = new(a1) Y;
        Z* p3 = new(a2) Z;
        // ...
</code></pre>

<p>But how can we later delete those objects correctly? The reason that there is no built-in &#8220;placement <code>delete</code>&#8221; to match placement <code>new</code> is that there is no general way of assuring that it would be used correctly. Nothing in the C++ type system allows us to deduce that <code>p1</code> points to an object allocated in <code>Arena a1</code>. A pointer to any <code>X</code> allocated anywhere can be assigned to <code>p1</code>.</p>

<p>However, sometimes the programmer does know, and there is a way:</p>

<pre><code>        template&lt;class T&gt; void destroy(T* p, Arena&amp; a)
        {
                if (p) {
                        p-&gt;~T();        // explicit destructor call
                        a.deallocate(p);
                }
        }
</code></pre>

<p>Now, we can write:</p>

<pre><code>        destroy(p1,a1);
        destroy(p2,a2);
        destroy(p3,a3);
</code></pre>

<p>If an <code>Arena</code> keeps track of what objects it holds, you can even write <code>destroy()</code> to defend itself against mistakes.</p>

<p>It is also possible to define matching <code>operator new()</code> and <code>operator delete()</code> pairs for a class hierarchy <a href="http://stroustrup.com/3rd.html">TC++PL(SE)</a> 15.6. See also <a href="http://stroustrup.com/dne.html">D&amp;E</a> 10.4 and TC++PL(SE) 19.4.5.</p>

<h3 id="calling-member-dtors">When I write a destructor, do I need to explicitly call the destructors for my member objects?</h3>

<p>No. You never need to explicitly call a destructor (except with <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement <code>new</code></a>).</p>

<p>A class&#8217;s destructor (whether or not you explicitly define one) <em>automagically</em> invokes the destructors for member
objects. They are destroyed in the reverse order they appear within the declaration for the class.</p>

<pre><code>class Member {
public:
  ~Member();
  // ...
};

class Fred {
public:
  ~Fred();
  // ...
private:
  Member x_;
  Member y_;
  Member z_;
};

Fred::~Fred()
{
  // Compiler automagically calls z_.~Member()
  // Compiler automagically calls y_.~Member()
  // Compiler automagically calls x_.~Member()
}
</code></pre>

<h3 id="calling-base-dtor">When I write a derived class&#8217;s destructor, do I need to explicitly call the destructor for my base class?</h3>

<p>No. You never need to explicitly call a destructor (except with <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement <code>new</code></a>).</p>

<p>A derived class&#8217;s destructor (whether or not you explicitly define one) <em>automagically</em> invokes the destructors for base
class subobjects. Base classes are destructed after member objects. In the event of multiple inheritance, direct base
classes are destructed in the reverse order of their appearance in the inheritance list.</p>

<pre><code>class Member {
public:
  ~Member();
  // ...
};

class Base {
public:
  virtual ~Base();     // A virtual destructor
  // ...
};

class Derived : public Base {
public:
  ~Derived();
  // ...
private:
  Member x_;
};

Derived::~Derived()
{
  // Compiler automagically calls x_.~Member()
  // Compiler automagically calls Base::~Base()
}
</code></pre>

<p>Note: Order dependencies with <code>virtual</code> inheritance are trickier. If you are relying on order dependencies in a
<code>virtual</code> inheritance hierarchy, you&#8217;ll need a lot more information than is in this FAQ.</p>

<h3 id="exceptions-in-dtor">Should my destructor throw an exception when it detects a problem?</h3>

<p>Beware!!! See <a href="exceptions.html#dtors-shouldnt-throw" title="FAQ: How can I handle a destructor that fails?">this FAQ</a> for details.</p>

<h3 id="memory-pools">Is there a way to force <code>new</code> to allocate memory from a specific memory area?</h3>

<p>Yes. The good news is that these &#8220;memory pools&#8221; are useful in a number of situations. The bad news is that I&#8217;ll have to
drag you through the mire of how it works before we discuss all the uses. But if you don&#8217;t know about memory pools, it
might be worthwhile to slog through this FAQ &#8212; you might learn something useful!</p>

<p>First of all, recall that a memory allocator is simply supposed to return uninitialized bits of memory; it is not
supposed to produce &#8220;objects.&#8221; In particular, the memory allocator is not supposed to set the virtual-pointer or any
other part of the object, as that is the job of the constructor which runs after the memory allocator. Starting with a
simple memory allocator function, <code>allocate()</code>, you would use <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement <code>new</code></a> to construct an object in
that memory. In other words, the following is morally equivalent to <code>new Foo()</code>:</p>

<pre><code>void* raw = allocate(sizeof(Foo));  // line 1
Foo* p = new(raw) Foo();            // line 2
</code></pre>

<p>Assuming you&#8217;ve used <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">placement <code>new</code></a> and have survived the above two lines of code, the next step is to
turn your memory allocator into an object. This kind of object is called a &#8220;memory pool&#8221; or a &#8220;memory arena.&#8221; This lets
your users have more than one &#8220;pool&#8221; or &#8220;arena&#8221; from which memory will be allocated. Each of these memory pool objects
will allocate a big chunk of memory using some specific system call (e.g., shared memory, persistent memory, stack
memory, etc.; see below), and will dole it out in little chunks as needed. Your memory-pool class might look something
like this:</p>

<pre><code>class Pool {
public:
  void* alloc(size_t nbytes);
  void dealloc(void* p);
private:
  // ...data members used in your pool object...
};

void* Pool::alloc(size_t nbytes)
{
  // ...your algorithm goes here...
}

void Pool::dealloc(void* p)
{
  // ...your algorithm goes here...
}
</code></pre>

<p>Now one of your users might have a <code>Pool</code> called <code>pool</code>, from which they could allocate objects like this:</p>

<pre><code>Pool pool;
// ...
void* raw = pool.alloc(sizeof(Foo));
Foo* p = new(raw) Foo();
</code></pre>

<p>Or simply:</p>

<pre><code>Foo* p = new(pool.alloc(sizeof(Foo))) Foo();
</code></pre>

<p>The reason it&#8217;s good to turn <code>Pool</code> into a class is because it lets users create <em>N</em> different pools of memory rather
than having one massive pool shared by all users. That allows users to do lots of funky things. For example, if they
have a chunk of the system that allocates memory like crazy then goes away, they could allocate all their memory from a
<code>Pool</code>, then not even bother doing any <code>delete</code>s on the little pieces: just deallocate the entire pool at once. Or they
could set up a &#8220;shared memory&#8221; area (where the operating system specifically provides memory that is shared between
multiple processes) and have the pool dole out chunks of shared memory rather than process-local memory. Another
angle: many systems support a non-standard function often called <code>alloca()</code> which allocates a block of memory from the
stack rather than the heap. Naturally this block of memory automatically goes away when the function returns,
eliminating the need for explicit <code>delete</code>s. Someone could use <code>alloca()</code> to give the <code>Pool</code> its big chunk of memory,
then all the little pieces allocated from that <code>Pool</code> act like they&#8217;re local: they automatically vanish when the
function returns. Of course the destructors don&#8217;t get called in some of these cases, and if the destructors do something
nontrivial you won&#8217;t be able to use these techniques, but in cases where the destructor merely deallocates memory, these
sorts of techniques can be useful.</p>

<p>Assuming you survived the 6 or 8 lines of code needed to wrap your allocate function as a method of a <code>Pool</code> class, the
next step is to change the syntax for allocating objects. The goal is to change from the rather clunky syntax
<code>new(pool.alloc(sizeof(Foo)))</code> <code>Foo()</code> to the <a href="coding-standards.html#bizarre-syntax" title="FAQ: Should I use 'unusual' syntax?">simpler syntax</a> <code>new(pool)</code> <code>Foo()</code>. To make this happen,
you need to add the following two lines of code just below the definition of your <code>Pool</code> class:</p>

<pre><code>inline void* operator new(size_t nbytes, Pool&amp; pool)
{
  return pool.alloc(nbytes);
}
</code></pre>

<p>Now when the compiler sees <code>new(pool) Foo()</code>, it calls the above <code>operator new</code> and passes <code>sizeof(Foo)</code> and <code>pool</code> as
parameters, and the only function that ends up using the funky <code>pool.alloc(nbytes)</code> method is your own <code>operator new</code>.</p>

<p>Now to the issue of how to destruct/deallocate the <code>Foo</code> objects. Recall that <a href="dtors.html#placement-new" title="FAQ: What is 'placement new' and why would I use it?">the brute force approach sometimes used
with placement <code>new</code></a> is to explicitly call the destructor then explicitly deallocate the memory:</p>

<pre><code>void sample(Pool&amp; pool)
{
  Foo* p = new(pool) Foo();
  // ...
  p-&gt;~Foo();        // explicitly call dtor
  pool.dealloc(p);  // explicitly release the memory
}
</code></pre>

<p>This has several problems, all of which are fixable:</p>

<ol>
<li>The memory will leak if <code>Foo::Foo()</code> throws an exception.</li>
<li>The destruction/deallocation syntax is different from what most programmers are used to, so they&#8217;ll probably screw
it up.</li>
<li>Users must somehow remember which pool goes with which object. Since the code that allocates is often in a different
function from the code that deallocates, programmers will have to pass around two pointers (a <code>Foo*</code> and a <code>Pool*</code>),
which gets ugly fast (example, what if they had an array of <code>Foo</code>s each of which potentially came from a different
<code>Pool</code>; ugh).</li>
</ol>

<p>We will fix them in the above order.</p>

<p><em>Problem #1: plugging the memory leak.</em> When you use the &#8220;normal&#8221; new operator, e.g., <code>Foo* p = new Foo()</code>, the
compiler generates some special code to handle the case when the constructor throws an exception. The actual code
generated by the compiler is functionally similar to this:</p>

<pre><code>// This is functionally what happens with Foo* p = new Foo()

Foo* p;

// don't catch exceptions thrown by the allocator itself
void* raw = operator new(sizeof(Foo));

// catch any exceptions thrown by the ctor
try {
  p = new(raw) Foo();  // call the ctor with raw as this
}
catch (...) {
  // oops, ctor threw an exception
  operator delete(raw);
  throw;  // rethrow the ctor's exception
}
</code></pre>

<p>The point is that the compiler deallocates the memory if the ctor throws an exception. But in the case of the &#8220;new with
parameter&#8221; syntax (commonly called &#8220;placement <code>new</code>&#8221;), the compiler won&#8217;t know what to do if the exception occurs so by
default it does nothing:</p>

<pre><code>// This is functionally what happens with Foo* p = new(pool) Foo():

void* raw = operator new(sizeof(Foo), pool);
// the above function simply returns "pool.alloc(sizeof(Foo))"

Foo* p = new(raw) Foo();
// if the above line "throws", pool.dealloc(raw) is NOT called
</code></pre>

<p>So the goal is to force the compiler to do something similar to what it does with the global <code>new</code> operator. Fortunately
it&#8217;s simple: when the compiler sees <code>new(pool) Foo()</code>, it looks for a corresponding <code>operator delete</code>. If it finds one,
it does the equivalent of wrapping the ctor call in a <code>try</code> block as shown above. So we would simply provide an
<code>operator delete</code> with the following signature (be careful to get this right; if the second parameter has a different
type from the second parameter of the <code>operator new(size_t, Pool&amp;)</code>, the compiler doesn&#8217;t complain; it simply bypasses
the <code>try</code> block when your users say <code>new(pool) Foo()</code>):</p>

<pre><code>void operator delete(void* p, Pool&amp; pool)
{
  pool.dealloc(p);
}
</code></pre>

<p>After this, the compiler will automatically wrap the ctor calls of your <code>new</code> expressions in a <code>try</code> block:</p>

<pre><code>// This is functionally what happens with Foo* p = new(pool) Foo()

Foo* p;

// don't catch exceptions thrown by the allocator itself
void* raw = operator new(sizeof(Foo), pool);
// the above simply returns "pool.alloc(sizeof(Foo))"

// catch any exceptions thrown by the ctor
try {
  p = new(raw) Foo();  // call the ctor with raw as this
}
catch (...) {
  // oops, ctor threw an exception
  operator delete(raw, pool);  // that's the magical line!!
  throw;  // rethrow the ctor's exception
}
</code></pre>

<p>In other words, the one-liner function <code>operator delete(void* p, Pool&amp; pool)</code> causes the compiler to automagically plug
the memory leak. Of course that function can be, but doesn&#8217;t have to be, <code>inline</code>.</p>

<p><em>Problems #2 (&#8220;ugly therefore error prone&#8221;) and #3 (&#8220;users must manually associate pool-pointers with the object that
allocated them, which is error prone&#8221;)</em> are solved simultaneously with an additional 10-20 lines of code in one place.
In other words, we add 10-20 lines of code in <em>one</em> place (your <code>Pool</code> header file) and simplify an arbitrarily large
number of other places (every piece of code that <em>uses</em> your <code>Pool</code> class).</p>

<p>The idea is to implicitly associate a <code>Pool*</code> with <em>every</em> allocation. The <code>Pool*</code> associated with the global allocator
would be <code>NULL</code>, but at least conceptually you could say <em>every</em> allocation has an associated <code>Pool*</code>. Then you replace
the global <code>operator delete</code> so it looks up the associated <code>Pool*</code>, and if non-<code>NULL</code>, calls that <code>Pool</code>&#8217;s deallocate
function. For example, <a href="freestore-mgmt.html#mixing-malloc-and-delete" title="FAQ: Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?">if(!)</a> the normal deallocator used <code>free()</code>, the replacment for the
global <code>operator delete</code> would look something like this:</p>

<pre><code>void operator delete(void* p)
{
  if (p != NULL) {
    Pool* pool = /* somehow get the associated 'Pool*' */;
    if (pool == NULL)
      free(p);
    else
      pool-&gt;dealloc(p);
  }
}
</code></pre>

<p>If you&#8217;re <a href="freestore-mgmt.html#mixing-malloc-and-delete" title="FAQ: Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?">not sure if the normal deallocator was <code>free()</code></a>, the easiest approach is also
replace the global <code>operator new</code> with something that uses <code>malloc()</code>. The replacement for the global <code>operator new</code>
would look something like this (note: this definition ignores a few details such as the <code>new_handler</code> loop and the
<code>throw std::bad_alloc()</code> that happens if we run out of memory):</p>

<pre><code>void* operator new(size_t nbytes)
{
  if (nbytes == 0)
    nbytes = 1;  // so all alloc's get a distinct address
  void* raw = malloc(nbytes);
  // ...somehow associate the NULL 'Pool*' with 'raw'...
  return raw;
}
</code></pre>

<p>The only remaining problem is to associate a <code>Pool*</code> with an allocation. One approach, used in at least one commercial
product, is to use a <code>std::map&lt;void*,Pool*&gt;</code>. In other words, build a look-up table whose keys are the
allocation-pointer and whose values are the associated <code>Pool*</code>. For reasons I&#8217;ll describe in a moment, it is essential
that you insert a key/value pair into the map <em>only</em> in <code>operator new(size_t,Pool&amp;)</code>. In particular, you must not insert
a key/value pair from the global <code>operator new</code> (e.g., you must not say, <code>poolMap[p] = NULL</code> in the global
<code>operator new</code>). Reason: doing that would create a nasty chicken-and-egg problem &#8212; since <code>std::map</code> probably uses
the global <code>operator new</code>, it ends up inserting a new entry every time inserts a new entry, leading to infinite
recursion &#8212; bang you&#8217;re dead.</p>

<p>Even though this technique requires a <code>std::map</code> look-up for each deallocation, it seems to have acceptable
performance, at least in many cases.</p>

<p>Another approach that is faster but might use more memory and is a little trickier is to prepend a <code>Pool*</code> just before
<em>all</em> allocations. For example, if <code>nbytes</code> was 24, meaning the caller was asking to allocate 24 bytes, we would
allocate 28 (or 32 if you think the machine requires 8-byte alignment for things like <code>double</code>s and/or <code>long long</code>s),
stuff the <code>Pool*</code> into the first 4 bytes, and return the pointer 4 (or 8) bytes from the beginning of what you
allocated. Then your global <code>operator delete</code> backs off the 4 (or 8) bytes, finds the <code>Pool*</code>, and if <code>NULL</code>, uses
<code>free()</code> otherwise calls <code>pool-&gt;dealloc()</code>. The parameter passed to <code>free()</code> and <code>pool-&gt;dealloc()</code> would be the pointer
4 (or 8) bytes to the left of the original parameter, <code>p</code>. If(!) you decide on 4 byte alignment, your code would look
something like this (although as before, the following <code>operator new</code> code elides the usual out-of-memory handlers):</p>

<pre><code>void* operator new(size_t nbytes)
{
  if (nbytes == 0)
    nbytes = 1;                    // so all alloc's get a distinct address
  void* ans = malloc(nbytes + 4);  // overallocate by 4 bytes
  *(Pool**)ans = NULL;             // use NULL in the global new
  return (char*)ans + 4;           // don't let users see the Pool*
}

void* operator new(size_t nbytes, Pool&amp; pool)
{
  if (nbytes == 0)
    nbytes = 1;                    // so all alloc's get a distinct address
  void* ans = pool.alloc(nbytes + 4); // overallocate by 4 bytes
  *(Pool**)ans = &amp;pool;            // put the Pool* here
  return (char*)ans + 4;           // don't let users see the Pool*
}

void operator delete(void* p)
{
  if (p != NULL) {
    p = (char*)p - 4;              // back off to the Pool*
    Pool* pool = *(Pool**)p;
    if (pool == NULL)
      free(p);                     // note: 4 bytes left of the original p
    else
      pool-&gt;dealloc(p);            // note: 4 bytes left of the original p
  }
}
</code></pre>

<p>Naturally the last few paragraphs of this FAQ are viable only when you are allowed to change the global <code>operator new</code>
and <code>operator delete</code>. If you are not allowed to change these global functions, the first three quarters of this FAQ is
still applicable.</p>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance — Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance — virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance — Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance — Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance — What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance — private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance — Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/dtors",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/dtors",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/dtors by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
</html>
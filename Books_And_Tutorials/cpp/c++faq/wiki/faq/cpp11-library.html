<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/cpp11-library by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="8cdcadc27aa34deaa908bfb544cb0fdbea04c94d" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="88721d6f7f5cdce173c214941b379fa0290dc9f7" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="10701e55a14be24cce38a5f4c4b7e695b5134394" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        cpp11 library
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="cpp11-library.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    cpp11 library
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=cpp11%20library" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="cpp11-library">C++11 Standard Library Extensions &#8212; General Libraries</h2>

<h3 id="unique-ptr"><code>unique_ptr</code></h3>

<p><code>unique_ptr</code> (defined in <code>&lt;memory&gt;</code>) provides a semantics of strict ownership:</p>

<ul>
<li>owns the object it holds a pointer to </li>
<li>is not CopyConstructible, nor CopyAssignable, however it is MoveConstructible and MoveAssignable. </li>
<li>stores a pointer to an object and deletes that object using the associated deleter when it is itself destroyed (such as when leaving block scope (6.7)). </li>
</ul>

<p>The uses of <code>unique_ptr</code> include:</p>

<ul>
<li>providing exception safety for dynamically allocated memory</li>
<li>passing ownership of dynamically allocated memory to a function</li>
<li>returning dynamically allocated memory from a function</li>
<li>storing pointers in containers </li>
</ul>

<p><code>unique_ptr</code> is <em>almost</em> exactly as efficient as using a raw pointer, but with safe ownership semantics. It&#8217;s &#8220;what <a href="freestore-mgmt.html#auto-ptr" title="FAQ: What is an auto_ptr and why isn't there an auto_array?"><code>auto_ptr</code></a> should have been&#8221; (but that we couldn&#8217;t write in C++98).</p>

<p><code>unique_ptr</code> is a move-only type, and so relies critically on <a href="cpp11-language.html#rval" title="FAQ: Rvalue references and move semantics">rvalue references and move semantics</a>.</p>

<p>Here is a conventional 20th-century piece of exception unsafe code:</p>

<pre><code>    X* f()
    {
        X* p = new X;
        // do something - maybe throw an exception
        return p;
    }
</code></pre>

<p>A solution is to hold the pointer to the object on the free store in a <code>unique_ptr</code>:</p>

<pre><code>    X* f()
    {
        unique_ptr&lt;X&gt; p(new X);     // or {new X} but not = new X
        // do something -- maybe throw an exception
        return p.release();
    }
</code></pre>

<p>Now, if an exception is thrown, the <code>unique_ptr</code> will (implicitly) destroy the object pointed to. That&#8217;s basic <a href="exceptions.html#finally" title="FAQ: Why doesn't C++ provide a finally construct?">RAII</a>. However, unless we really need to return a built-in pointer, we can do even better by returning a <code>unique_ptr</code>:</p>

<pre><code>    unique_ptr&lt;X&gt; f()
    {
        unique_ptr&lt;X&gt; p(new X);     // or {new X} but not = new X
        // do something -- maybe throw an exception
        return p;   // the ownership is transferred out of f()
    }
</code></pre>

<p>We can use this <code>f</code> like this:</p>

<pre><code>    void g()
    {
        unique_ptr&lt;X&gt; q = f();       // move using move constructor
        q-&gt;memfct(2);                // use q
        X x = *q;                    // copy the object pointed to
        // ...
    }   // q and the object it owns is destroyed on exit
</code></pre>

<p>The <code>unique_ptr</code> has &#8220;move semantics&#8221; so the initialization of <code>q</code> with the rvalue that is the result of the call <code>f()</code> simply transfers ownership into <code>q</code>.</p>

<p>One of the uses of <code>unique_ptr</code> is as a pointer in a container that owns its heap-allocated objects, where in the past we might have used a built-in pointer except for exception safety problems (and to guarantee destruction of the pointed to elements):</p>

<pre><code>    vector&lt;unique_ptr&lt;string&gt;&gt; vs { new string{"Doug"}, new string{"Adams"} };
</code></pre>

<p><code>unique_ptr</code> is represented by a simple built-in pointer and the overhead of using one compared to a built-in pointer are miniscule. In particular, <code>unique_ptr</code> does not offer any form of dynamic checking.</p>

<p>See also:</p>

<ul>
<li>the C++ draft section 20.7.10 </li>
<li>Howard E. Hinnant: unique_ptr Emulation for C++03 Compilers. </li>
</ul>

<h3 id="shared-ptr"><code>shared_ptr</code></h3>

<p>A <code>shared_ptr</code> is used to represent shared ownership; that is, when two pieces of code need access to some data but neither has exclusive ownership (in the sense of being responsible for destroying the object). A <code>shared_ptr</code> is a reference counted pointer where the object pointed to is deleted when the use count goes to zero. Here is a highly artificial example:</p>

<pre><code>    void test()
    {
        shared_ptr&lt;int&gt; p1(new int);    // count is 1
        {
            shared_ptr&lt;int&gt; p2(p1); // count is 2
            {
                shared_ptr&lt;int&gt; p3(p1); // count is 3
            }   // count goes back down to 2
        } // count goes back down to 1
    }   // here the count goes to 0 and the int is deleted.
</code></pre>

<p>A more realistic example would be be pointers to nodes in a general graph where someone wanting to remove a pointer to a node wouldn&#8217;t know if anyone else held a pointer to that node. If a node can hold resources that require an action by a destructor (e.g. a file handle so that a file needs to be closed when the node is deleted). You could consider <code>shared_ptr</code> to be for what you might consider plugging in a garbage collector for, except that maybe you don&#8217;t have enough garbage for that to be economical, your execution environment doesn&#8217;t allow that, or the resource managed is not just memory (e.g. that file handle) so that you need release to be deterministic when the last user goes away instead of done lazily at some nondeterminstic time, and ordered so that the object&#8217;s destructor can safely use other heap objects. For example:</p>

<pre><code>    struct Node {   // note: a Node may be pointed to from several other nodes.
        shared_ptr&lt;Node&gt; left;
        shared_ptr&lt;Node&gt; right;
        File_handle f;
        // ...
    };
</code></pre>

<p>Here <code>Node</code>&#8217;s destructor (the implicitly generated destructor will do fine) deletes its sub-nodes; that is, <code>left</code> and <code>right</code>&#8217;s destructors are invoked. When this node is destroyed, since <code>left</code> is a <code>shared_ptr</code>, the <code>Node</code> pointed to (if any) is <code>delete</code>d if <code>left</code> was the last pointer to it; <code>right</code> is handled similarly and <code>f</code>&#8217;s destructor does whatever is required for <code>f</code>.</p>

<p>Note that you should not use a <code>shared_ptr</code> just to pass a pointer from one owner to another; that&#8217;s what <code>unique_ptr</code> is for and <code>unique_ptr</code> does that cheaper and better. If you have been using counted pointers as return values from factory functions and the like, consider upgrading to <code>unique_ptr</code> rather than <code>shared_ptr</code>.</p>

<p>Please don&#8217;t thoughtlessly replace pointers with <code>shared_ptr</code>s in an attempt to prevent memory leaks; <code>shared_ptr</code>s are not a panacea nor are they without costs:</p>

<ul>
<li>a circular linked structure of <code>shared_ptr</code>s will cause a memory leak (you&#8217;ll need some logical complication to break the circle, e.g. using a <code>weak_ptr</code>), </li>
<li>&#8220;shared ownership objects&#8221; tend to stay &#8220;live&#8221; for longer than scoped objects (thus causing higher average resource usage), </li>
<li>heavy manipulation of shared pointers themselves (such as transferring ownership around frequently, though this is an antipattern) can be expensive in a multi-threaded environment because of the need to avoid data races on the use count, </li>
<li>the algorithms/logic for the update of any shared object is easier to get wrong than for an object that&#8217;s not shared. </li>
</ul>

<p>A <code>shared_ptr</code> represents shared ownership but shared ownership isn&#8217;t always ideal: By default, it is better if an object has a definite owner and a definite, predictable lifespan. Prefer the following in order: stack or member lifetime (stack variables or by-value member variables); heap allocation with <code>unique_ptr</code> unique ownership; and heap allocation via <code>make_shared</code> with shared ownership.</p>

<p>See also:</p>

<ul>
<li>the C++ draft: Shared_ptr (20.7.13.3) </li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/">GotW #89: Smart Pointers</a>.</li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/05/30/gotw-90-solution-factories/">GotW #90: Factories</a>.</li>
<li>Herb Sutter: <a href="http://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/">GotW #91: Smart Pointer Parameters</a>.</li>
</ul>

<h3 id="weak-ptr"><code>weak_ptr</code></h3>

<p><code>weak_ptr</code>s are for <em>shared observation</em> just as <code>shared_ptr</code>s are for <em>shared ownership.</em> <code>weak_ptr</code>s are commonly known to be what you need to break cycles in data structures managed using <code>shared_ptr</code>s, but more generally it is better to think of a <code>weak_ptr</code> as a pointer to something that</p>

<ol>
<li>you need access to (only) if it exists, and </li>
<li>may get deleted (by someone else), and </li>
<li>must have its destructor called after its last use (usually to delete anon-memory resource) </li>
</ol>

<p>Consider an implementation of the old &#8220;asteroid game&#8221;. All asteroids are owned by &#8220;the game&#8221; but each asteroids must keep track of neighboring asteroids and handle collisions. A collision typically leads to the destruction of one or more asteroids. Each asteroid must keep a list of other asteroids in its neighborhood. Note that being on such a neighbor list should not keep an astroid &#8220;alive&#8221; (so a <code>shared_ptr</code> would be inappropriate). On the other hand, an asteroid must not be destroyed while another asteroid is looking at it (e.g. to calculate the effect of a collision). And obviously, an asteroid&#8217;s destructor must be called to release resources (such as a connection to the graphics system). What we need is a list of asteroids that might still be intact and a way of &#8220;getting hold of one if it exists&#8221; for a while. A <code>weak_ptr</code> does just that:</p>

<pre><code>    void owner()
    {
        // ...
        vector&lt;shared_ptr&lt;Asteroid&gt;&gt; va(100);
        for (int i=0; i&lt;va.size(); ++i) {
            // ... calculate neighbors for new asteroid ...
            va[i].reset(new Asteroid(weak_ptr&lt;Asteroid&gt;(va[neighbor]));
            launch(i);
        }
        // ...
    }
</code></pre>

<p><code>reset()</code> is the function to make a <code>shared_ptr</code> refer to a new object.</p>

<p>Obviously, this example code radically simplified &#8220;the owner&#8221; and gave each new <code>Asteroid</code> just one neighbor. The key is that we give the <code>Asteroid</code> a <code>weak_ptr</code> to that neighbor. The owner keeps a <code>shared_ptr</code> to represent the ownership that&#8217;s shared whenever an <code>Asteroid</code> is looking (but not otherwise). The collision calculation for an <code>Asteroid</code> will look something like this:</p>

<pre><code>    void collision(weak_ptr&lt;Asteroid&gt; p)
    {
        if (auto q = p.lock()) {    // p.lock returns a shared_ptr to p's object
            // ... that Asteroid still existed: calculate ...
        }
        else {
            // ... oops: that Asteroid has already been destroyed: just forget about it (delete the weak_ptr to it ...
        }
    }
</code></pre>

<p>Note that even if the owner decides to shut down the game and deletes all <code>Asteroid</code>s (by destroying the <code>shared_ptr</code>s representing ownership), every <code>Asteroid</code> that is in the middle of calculating a collision still finishes correctly because after the <code>p.lock()</code> it holds a <code>shared_ptr</code> that will ensure the <code>Asteroid</code> stays alive for at least as long as <code>collision</code> is using it via that <code>shared_ptr</code>.</p>

<p>You should expect to find <code>weak_ptr</code> use much rarer than &#8220;plain&#8221; <code>shared_ptr</code> use, and both of those to be rarer than <code>unique_ptr</code> which should be most popular of all as it represents a simpler (and more efficient) notion of ownership and (therefore) allows better local reasoning.</p>

<p>See also:</p>

<ul>
<li>the C++ draft: weak_ptr (20.7.13.3) </li>
</ul>

<h3 id="gc-abi">Garbage collection ABI</h3>

<p>Garbage collection (automatic recycling of unreferenced regions of memory) is optional in C++; that is, a garbage collector is not a compulsory part of an implementation. However, C++11 provides a definition of what a GC can do if one is used and an ABI (Application Binary Interface) to help control its actions.</p>

<p>The rules for pointers and lifetimes are expressed in terms of &#8220;safely derived pointer&#8221; (3.7.4.3); roughly: &#8220;pointer to something allocated by new or to a sub-object thereof.&#8221; Here are some examples of &#8220;not safely derived pointers&#8221; aka &#8220;disguised pointers&#8221; aka <strong>what not to do</strong> in a program you want to be considered well behaved and comprehensible to ordinary mortals:</p>

<ul>
<li>Make a pointer point &#8220;elsewhere&#8221; for a while </li>
</ul>

<pre><code>    int* p = new int;
    p+=10;
    // ... collector may run here ...
    p-=10;
    *p = 10;    // can we be sure that the int is still there? 
</code></pre>

<ul>
<li>Hide the pointer in an <code>int</code> </li>
</ul>

<pre><code>    int* p = new int;
    int x = reinterpret_cast&lt;int&gt;(p);   // non-portable
    p=0;
    // ... collector may run here ...
    p = reinterpret_cast&lt;int*&gt;(x);
    *p = 10;    // can we be sure that the int is still there?
</code></pre>

<ul>
<li>There are many more and even nastier tricks. Think I/O, think &#8220;scattering the bits around in different words&#8221;, &#8230; </li>
</ul>

<p>There are legitimate reasons to disguise pointers (e.g. the xor trick in exceptionally memory-constrained applications), but not as many as some programmers think.</p>

<p>A programmer can specify where there are no pointers to be found (e.g. inside a JPEG image) and what memory can&#8217;t be reclaimed even if the collector can&#8217;t find a pointer into it:</p>

<pre><code>    void declare_reachable(void* p);    // the region of memory starting at p
                        // (and allocated by some allocator
                        // operation which remembers its size)
                        // must not be collected
    template&lt;class T&gt; T* undeclare_reachable(T* p);

    void declare_no_pointers(char* p, size_t n);       // p[0..n] holds no pointers
    void undeclare_no_pointers(char* p, size_t n);
</code></pre>

<p>A programmer can inquire which rules for pointer safety and reclamation is in force:</p>

<pre><code>    enum class pointer_safety {relaxed, preferred, strict };
    pointer_safety get_pointer_safety();
</code></pre>

<p>3.7.4.3[4]: If a pointer value that is not a safely-derived pointer value is dereferenced or deallocated, and the referenced complete object is of dynamic storage duration and has not previously been declared reachable (20.7.13.7), the behavior is undefined.</p>

<ul>
<li><em>relaxed:</em> safely-derived and not safely-derived pointers are treated equivalently; like C and C++98, but that was not my intent - I wanted to allow GC if a user didn&#8217;t keep a valid pointer around for an object. </li>
<li><em>preferred:</em> like relaxed; but a garbage collector may be running as a leak detector and/or detector of dereferences of &#8220;bad pointers&#8221; </li>
<li><em>strict:</em> safely-derived and not safely-derived pointers may be treated differently, i.e. a garbage collector may be running and will ignore pointers that aren&#8217;t safely derived </li>
</ul>

<p>There is no standard way of saying which alternative you prefer. Considered that a &#8220;quality of implementation&#8221; and a &#8220;programming environment&#8221; issue.</p>

<p>See also:</p>

<ul>
<li>the C++ draft 3.7.4.3 </li>
<li>the C++ draft 20.7.13.7 </li>
<li>Hans Boehm&#8217;s <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">GC page</a></li>
<li>Hans Boehm&#8217;s <a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">Discussion of Conservative GC</a> </li>
<li>N2527: Hans-J. Boehm and Mike Spertus: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2527.html">Minimal Support for Garbage Collection and Reachability-Based Leak Detection (revised)</a> (final proposal)</li>
<li>Michael Spertus and Hans J. Boehm: <a href="http://portal.acm.org/citation.cfm?doid=1542431.1542437">The Status of Garbage Collection in C++0X</a>. ACM ISMM&#8217;09. </li>
</ul>

<h3 id="tuple"><code>tuple</code></h3>

<p>The standard library <code>tuple</code> (an N-tuple) is a ordered sequence of <code>N</code> values where <code>N</code> can be a constant from <code>0</code> to a large implementation-defined value, defined in <code>&lt;tuple&gt;</code>. You can think of a <code>tuple</code> as an unnamed struct with members of the specified element types. In particular, the elements of a <code>tuple</code> are stored compactly; a <code>tuple</code> is not a linked structure.</p>

<p>The element types of a <code>tuple</code> can explicitly specified or be deduced (using <code>make_tuple()</code>) and the elements can be access by (zero-based) index using <code>get()</code>:</p>

<pre><code>    tuple&lt;string,int&gt; t2("Kylling",123);

    auto t = make_tuple(string("Herring"),10, 1.23);    // t will be of type tuple&lt;string,int,double&gt;
    string s = get&lt;0&gt;(t);
    int x = get&lt;1&gt;(t);
    double d = get&lt;2&gt;(t);
</code></pre>

<p>Tuples are used (directly of indirectly) whenever we want a heterogeneous list of elements at compile time but do not want to define a named class to hold them. For example, <code>tuple</code> is used internally in <a href="cpp11-library.html#std-function" title="FAQ: function and bind"><code>std::function</code> and <code>std::bind</code></a> to hold arguments.</p>

<p>The most frequently useful <code>tuple</code> is the 2-tuple; that is, a <code>pair</code>. However, <code>pair</code> is directly supported in the standard library through <code>std::pair</code> (20.3.3 Pairs). A <code>pair</code> can be used to initialize a <code>tuple</code>, but the opposite isn&#8217;t the case.</p>

<p>The comparison operators (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>) are defined for tuples of comparable element types.</p>

<p>See also:</p>

<ul>
<li>Standard: 20.5.2 Class template <code>tuple</code></li>
<li>[N2087==06-0157] Douglas Gregor: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2087.pdf">A Brief Introduction to Variadic Templates</a>. </li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/libs/tuple/doc/tuple_users_guide.html">Boost::tuple</a></li>
</ul>

<h3 id="type-traits">Type traits</h3>

<p>See:</p>

<ul>
<li>[N2984==09-0174] B. Dawes, D. Kr√ºgler, A. Meredith: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2984.htm">Additional Type Traits for C++0x (Revision 1)</a>. </li>
</ul>

<h3 id="std-function"><code>function</code> and <code>bind</code></h3>

<p>Note: <code>function</code> is long-term useful. However, <code>bind</code> is almost entirely superseded by C++14 lambdas with generalized lambda capture, but it has a few advantages if your compiler supports only C++11 lambdas and can be more compact in basic cases.</p>

<p>The <code>bind</code> and <code>function</code> standard function objects are defined in <code>&lt;functional&gt;</code> (together with a lot of other function objects); they are used to handle functions and function arguments. <code>bind</code> is used to take a function (or a function object or anything you can invoke using the <code>(a,b,c)</code> syntax) and produce a function object with one or more of the arguments of the argument function &#8220;bound&#8221; or rearranged. For example:</p>

<pre><code>    int f(int,char,double);

    auto ff = bind(f,_1,'c',1.2);   // deduce return type
    int x = ff(7);          // f(7,'c',1.2);

    // equivalent with lambdas
    auto ff2 = [](int i){ f(i,'c',1.2); };  // deduce return type
    int x2 = ff2(7);            // f(7,'c',1.2);
</code></pre>

<p>This binding of arguments is usually called &#8220;Currying.&#8221; The <code>_1</code> is a placeholder object indicating where the first argument of <code>ff</code> is to go when <code>f</code> is called through <code>ff</code>. The first argument is called <code>_1</code>, the second <code>_2</code>, and so on. For example:</p>

<pre><code>    int f(int,char,double);

    auto frev = bind(f,_3,_2,_1);   // reverse argument order
    int x = frev(1.2,'c',7);    // f(7,'c',1.2);

    // equivalent with lambdas
    auto frev2 = [](double d, char c, int i){ bind(f,i,c,d); }; // reverse argument order
    int x2 = frev2(1.2,'c',7);  // f(7,'c',1.2);
</code></pre>

<p>Note how <code>auto</code> saves us from having to specify the type of the result of <code>bind</code>.</p>

<p>If the function to be called is overloaded, it is not possible to just bind arguments. Instead, we have to explicitly state which version of an overloaded function we want to bind:</p>

<pre><code>    int g(int);
    double g(double);   // g() is overloaded

    auto g1 = bind(g,_1);               // error: which g()?
    auto g2 = bind((double(*)(double))g,_1);    // ok (but ugly)

    // equivalent with C++11 lambdas, which handle this naturally
    auto g3 = [](double d){ g(d); };    // ok in C++11

    // both shorter and more powerful with C++14 lambdas
    auto g4 = [](auto x){ g(x); };  // ok in C++14, and gives full access to the overload set
</code></pre>

<p><code>bind()</code> comes in two variants: the one shown above and a &#8220;legacy&#8221; version where you explicitly specify the return type:</p>

<pre><code>    auto f2 = bind&lt;int&gt;(f,7,'c',_1);    // explicit return type
    int x = f2(1.2);            // f(7,'c',1.2);
</code></pre>

<p>This second version was necessary in C++98 and is widely used because the first (and for a user simplest) version cannot be implemented in C++98.</p>

<p><code>function</code> is a type that can hold a value of just about anything you can invoke using the <code>(a,b,c)</code> syntax, including allowing conversions on the parameters and the return type, making it a very flexible facility indeed while preserving strict type-safety. In particular, the result of <code>bind</code> can be assigned to a <code>function</code>. <code>function</code> is very simple to use. For example:</p>

<pre><code>    function&lt;float (int x, int y)&gt; f;   // make a function object

    struct int_div {            // take something you can call using ()
        float operator()(int x, int y) const { return ((float)x)/y; };
    };

    f = int_div();              // assign
    cout &lt;&lt; f(5, 3) &lt;&lt; endl;        // call through the function object
    std::accumulate(b,e,1,f);       // passes beautifully
</code></pre>

<p>Member functions can be treated as free functions with an extra &#8220;explicit <code>this</code>&#8221; argument:</p>

<pre><code>    struct X {
        int foo(int);
    };

    function&lt;int (X*, int)&gt; f;
    f = &amp;X::foo;        // pointer to member

    X x;
    int v = f(&amp;x, 5);   // call X::foo() for x with 5
    function&lt;int (int)&gt; ff = std::bind(f,&amp;x,_1);    // first argument for f is &amp;x
    v=ff(5);        // call x.foo(5)
</code></pre>

<p><code>function</code>s are useful for callbacks, for passing operations as argument, etc. <code>function</code> can be seen as a replacement for the C++98 standard library function objects <code>mem_fun_t</code>, <code>pointer_to_unary_function</code>, etc. Similarly, <code>bind()</code> can be seen as a replacement for <code>bind1st()</code> and <code>bind2nd()</code>.</p>

<p>See also:</p>

<ul>
<li>Standard: 20.7.12 Function template bind, 20.7.16.2 Class template function </li>
<li>Herb Sutter: <a href="http://www.drdobbs.com/generalized-function-pointers/184403746">Generalized Function Pointers</a>. August 2003. </li>
<li>Douglas Gregor: <a href="http://www.boost.org/doc/libs/1_55_0/doc/html/function.html">Boost.Function</a>. </li>
<li><a href="http://www.boost.org/doc/libs/1_55_0/libs/bind/bind.html">Boost::bind</a></li>
</ul>

<h3 id="std-regex">Regular Expressions</h3>

<p>To be written.</p>

<p>In the meantime, see:</p>

<ul>
<li><a href="http://msdn.microsoft.com/en-us/library/bb982382.aspx">Microsoft <regex> documentation</a>.</li>
</ul>

<h3 id="std-duration">Time utilities</h3>

<p>We often want to time things or to do things dependent on timing. For example, the standard-library <a href="cpp11-library-concurrency.html#std-mutex" title="FAQ: Mutual exclusion">mutexes</a> and <a href="cpp11-library-concurrency.html#std-lock" title="FAQ: Locks">locks</a> provide the option for a <a href="cpp11-library-concurrency.html#std-threads" title="FAQ: Threads">thread</a> to wait for a period of time (a <code>duration</code>) or to wait until a given point in time (a <code>time_point</code>).</p>

<p>If you want to know the current <code>time_point</code>, you can call <code>now()</code> for one of three clocks: <code>system_clock</code>, <code>steady_clock</code>, and <code>high_resolution_clock</code>. For example:</p>

<pre><code>    steady_clock::time_point t = steady_clock::now();
    // do something
    steady_clock::duration d = steady_clock::now() - t;
    // something took d time units
</code></pre>

<p>A clock returns a <code>time_point</code>, and a <code>duration</code> is the difference between two <code>time_point</code>s from the same clock. As usual, if you are not interested in details, <code>auto</code> is your friend:</p>

<pre><code>    auto t = steady_clock::now();
    // do something
    auto d = steady_clock::now() - t;
    // something took d time units
</code></pre>

<p>The time facilities here are intended to efficiently support uses deep in the system; they do not provide convenience facilities to help you maintain your social calendar. In fact, the time facilities originated with the stringent needs for high-energy physics. To be able to express all time scales (such as centuries and picoseconds), avoid confusion about units, typos, and rounding errors, <code>duration</code>s and <code>time_point</code>s are expressed using a compile-time rational number package. A duration has two parts: a numeric clock &#8220;tick&#8221; and something (a &#8220;period&#8221;) that says what a tick means (is it a second or a millisecond?); the period is part of a <code>duration</code>&#8217;s type. The following table from the standard header <code>&lt;ratio&gt;</code>, defining the periods of the SI system (also known as MKS or metric system) might give you an idea of the scope of use:</p>

<pre><code>    // convenience SI typedefs:
    typedef ratio&lt;1, 1000000000000000000000000&gt; yocto;  // conditionally supported
    typedef ratio&lt;1,    1000000000000000000000&gt; zepto;  // conditionally supported
    typedef ratio&lt;1,       1000000000000000000&gt; atto;
    typedef ratio&lt;1,          1000000000000000&gt; femto;
    typedef ratio&lt;1,             1000000000000&gt; pico;
    typedef ratio&lt;1,                1000000000&gt; nano;
    typedef ratio&lt;1,                   1000000&gt; micro;
    typedef ratio&lt;1,                      1000&gt; milli;
    typedef ratio&lt;1,                       100&gt; centi;
    typedef ratio&lt;1,                        10&gt; deci;
    typedef ratio&lt;                       10, 1&gt; deca;
    typedef ratio&lt;                      100, 1&gt; hecto;
    typedef ratio&lt;                     1000, 1&gt; kilo;
    typedef ratio&lt;                  1000000, 1&gt; mega;   
    typedef ratio&lt;               1000000000, 1&gt; giga;
    typedef ratio&lt;            1000000000000, 1&gt; tera;
    typedef ratio&lt;         1000000000000000, 1&gt; peta;
    typedef ratio&lt;      1000000000000000000, 1&gt; exa;    
    typedef ratio&lt;   1000000000000000000000, 1&gt; zetta;  // conditionally supported
    typedef ratio&lt;1000000000000000000000000, 1&gt; yotta;  // conditionally supported
</code></pre>

<p>The compile time rational numbers provide the usual arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>) and comparison (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) operators for whatever combinations <code>duration</code>s and <code>time_point</code>s makes sense (e.g. you can&#8217;t add two <code>time_point</code>s). These operations are also checked for overflow and divide by zero. Since this is a compile-time facility, don&#8217;t worry about run-time performance. In addition you can use <code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, and <code>/=</code> on <code>duration</code>s and <code>tp+=d</code> and <code>tp-=d</code> for a <code>time_point tp</code> and a <code>duration d</code>.</p>

<p>Here are some examples of values using standard duration types as defined in <code>&lt;chrono&gt;</code>:</p>

<pre><code>    microseconds mms = 12345;
    milliseconds ms = 123;
    seconds s = 10;
    minutes m = 30;
    hours h = 34;

    auto x = std::chrono::hours(3);         // being explicit about namespaces
    auto x = hours(2)+minutes(35)+seconds(9);   // assuming suitable "using"
</code></pre>

<p>You cannot initialize a <code>duration</code> to a fraction. For example, don&#8217;t try 2.5 seconds; instead use 2500 milliseconds. This is because a because a duration is interpreted as a number of &#8220;ticks.&#8221; Each tick represents one unit of the duration&#8217;s &#8220;period,&#8221; such as <code>milli</code> and <code>kilo</code> as defined above. The default unit is seconds; that is, for a duration with a period of 1 a tick is interpreted as a second. We can be explicit about the representation of a <code>duration</code>:</p>

<pre><code>    duration&lt;long&gt; d0 = 5;          // seconds (by default)
    duration&lt;long,kilo&gt; d1 = 99;        // kiloseconds!
    duration&lt;long,ratio&lt;1000,1&gt;&gt; d2 = 100;  // d1 and d2 have the same type ("kilo" means "*1000")
</code></pre>

<p>If we actually want to do something with a <code>duration</code>, such as writing it out, we have to give a unit, such as minutes or microseconds. For example:</p>

<pre><code>    auto t = steady_clock::now();
    // do something
    nanoseconds d = steady_clock::now() - t;    // we want the result in nanoseconds
    cout &lt;&lt; "something took " &lt;&lt; d &lt;&lt; "nanoseconds\n";
</code></pre>

<p>Alternatively, we could convert the <code>duration</code> to a floating point number (to get rounding):</p>

<pre><code>    auto t = steady_clock::now();
    // do something
    auto d = steady_clock::now() - t;
    cout &lt;&lt; "something took " &lt;&lt; duration_cast&lt;double&gt;(d).count() &lt;&lt; "seconds\n";
</code></pre>

<p>The <code>count()</code> is the number of &#8220;ticks.&#8221;&#8220;</p>

<p>See also:</p>

<ul>
<li>Standard: 20.9 Time utilities [time] </li>
<li>Howard E. Hinnant, Walter E. Brown, Jeff Garland, and Marc Paterno: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">A Foundation to Sleep On</a>. N2661=08-0171. Including &#8220;A Brief History of Time&#8221; (With apologies to Stephen Hawking). </li>
</ul>

<h3 id="std-random">Random number generation</h3>

<p>Random numbers are useful in many contexts, such as testing, games, simulation, and security. The diversity of application areas is reflected in the wide selection of random number generation utilities provided by the standard library. A random number generator consists of two parts: (1) an engine that produces a sequence of random or pseudo-random values, and (2) a distribution that maps those values to a mathematical distribution in a range. Examples of distributions are <code>uniform_int_distribution</code> (where all integers produced are equally likely) and <code>normal_distribution</code> (&#8220;the bell curve&#8221;), each for some specified range. For example:</p>

<pre><code>    uniform_int_distribution&lt;int&gt; one_to_six {1,6};  // distribution that maps to the ints 1..6
    default_random_engine re {};                     // the default engine
</code></pre>

<p>To get a random number, you call a distribution with an engine:</p>

<pre><code>    int x = one_to_six(re); // x becomes a value in [1:6]
</code></pre>

<p>To avoid passing the engine in every call, we could bind that argument to get a function object that&#8217;s callable without arguments:</p>

<pre><code>    auto dice {bind(one_to_six,re)};   // make a generator

    int x = dice(); // roll the dice: x becomes a value in [1:6]
</code></pre>

<p>(Thanks to its uncompromising attention to generality and performance, one expert deemed the standard-library random number component &#8220;what every random number library wants to be when it grows up.)</p>

<p>What if we just want something simple to use like:</p>

<pre><code>    int rand_int(int low, int high);    // generate a random number from a uniform distribution in [low:high]
</code></pre>

<p>So, how could we get that? We have to put something like <code>dice()</code> inside <code>rand_int()</code>:</p>

<pre><code>    int rand_int(int low, int high)
    {
        static default_random_engine re {};
        using Dist = uniform_int_distribution&lt;int&gt;;
        static Dist uid {};
        return uid(re, Dist::param_type{low,high});
    }
</code></pre>

<p>While providing that definition needs a bit of expertise, calling <code>rand_int()</code> is manageable in even the first week of a C++ course.</p>

<p>Just to show a non-trivial example, here is a program that generates and prints a normal distribution&#8217;s histogram:</p>

<pre><code>    default_random_engine re;   // the default engine
    normal_distribution&lt;int&gt; nd(31 /* mean */, 8 /* sigma */);

    auto norm = std::bind(nd, re);

    vector&lt;int&gt; mn(64);

    int main()
    {
        for (int i = 0; i&lt;1200; ++i) ++mn[round(norm())]; // generate

        for (int i = 0; i&lt;mn.size(); ++i) {
            cout &lt;&lt; i &lt;&lt; '\t';
            for (int j=0; j&lt;mn[i]; ++j) cout &lt;&lt; '*';
            cout &lt;&lt; '\n';
        }
    }
</code></pre>

<p>The result of one execution was:</p>

<pre><code>0   
1   
2   
3   
4   *
5   
6   
7   
8   
9   *
10  ***
11  ***
12  ***
13  *****
14  *******
15  ****
16  **********
17  ***********
18  ****************
19  *******************
20  *******************
21  **************************
22  **********************************
23  **********************************************
24  ********************************************
25  *****************************************
26  *********************************************
27  *********************************************************
28  ***************************************************
29  ******************************************************************
30  **********************************************
31  *********************************************************************
32  **********************************************
33  *************************************************************
34  **************************************************************
35  ***************************************
36  ***********************************************
37  **********************************************
38  *********************************************
39  ********************************
40  ********************************************
41  ***********************
42  **************************
43  ******************************
44  *****************
45  *************
46  *********
47  ********
48  *****
49  *****
50  ****
51  ***
52  ***
53  **
54  *
55  *
56  
57  *
58  
59  
60  
61
62
63
</code></pre>

<p>See also:</p>

<ul>
<li>Standard 26.5: Random number generation </li>
<li>Walter E. Brown: <a href="../../files/papers/n3551.pdf">Random Number Generation in C++11</a> &#8211; note, normally committee papers are not tutorials, and it&#8217;s not often you get an excellent tutorial written by a world-class expert who is also the designer of the library &#8211; strongly recommended as a go-to source of information about <code>&lt;random&gt;</code></li>
</ul>

<h3 id="scoped-allocator">Scoped allocators</h3>

<p>For compactness of container objects and for simplicity, C++98 did not require containers to support allocators with state: Allocator objects need not be stored in container objects. This is still the default in C++11, but it is possible to use an allocator with state, say an allocator that holds a pointer to an arena from which to allocate. For example:</p>

<pre><code>template&lt;class T&gt; class Simple_alloc {  // C++98 style
    // no data
    // usual allocator stuff
};

class Arena {
    void* p;
    int s;
public:
    Arena(void* pp, int ss);
    // allocate from p[0..ss-1]
};

template&lt;class T&gt; struct My_alloc {
    Arena&amp; a;
    My_alloc(Arena&amp; aa) : a(aa) { }
    // usual allocator stuff
};

Arena my_arena1(new char[100000],100000);
Arena my_arena2(new char[1000000],1000000);

vector&lt;int&gt; v0; // allocate using default allocator

vector&lt;int,My_alloc&lt;int&gt;&gt; v1(My_alloc&lt;int&gt;{my_arena1}); // allocate from my_arena1

vector&lt;int,My_alloc&lt;int&gt;&gt; v2(My_alloc&lt;int&gt;{my_arena2}); // allocate from my_arena2

vector&lt;int,Simple_alloc&lt;int&gt;&gt; v3;   // allocate using Simple_alloc
</code></pre>

<p>Typically, the verbosity would be alleviated by the use of <code>typedef</code>s.</p>

<p>It is not guaranteed that the default allocator and <code>Simple_alloc</code> take up no space in a <code>vector</code> object, but a bit of elegant template metaprogramming in the library implementation can ensure that. So, using an allocator type imposes a space overhead only if its objects actually has state (like <code>My_alloc</code>).</p>

<p>A rather sneaky problem can occur when using containers and user-defined allocators: Should an element be in the same allocation area as its container? For example, if you use <code>Your_alloc</code> for <code>Your_string</code> to allocate its elements and someone else uses <code>My_alloc</code> to allocate elements of <code>My_vector</code>, then which allocator should be used for <code>string</code> elements in <code>My_vector&lt;Your_alloc&gt;&gt;</code>? The solution is the ability to tell a container which allocator to pass to elements. For example, assuming that there is an allocator <code>My_alloc</code> and you want a <code>vector&lt;string&gt;</code> that uses <code>My_alloc</code> for both the <code>vector</code> element and <code>string</code> element allocations, first, you must make a version of string that accepts <code>My_alloc</code> objects:</p>

<pre><code>using xstring = basic_string&lt;char, char_traits&lt;char&gt;, My_alloc&lt;char&gt;&gt;;  // a string with my allocator
</code></pre>

<p>Then, you must make a version of <code>vector</code> that accepts those strings, accepts a <code>My_alloc</code> object, and passes that object on to the string:</p>

<pre><code>using svec = vector&lt;xstring,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;&gt;;   
</code></pre>

<p>Finally, we can make an allocator of type <code>My_alloc&lt;xstring&gt;</code>:</p>

<pre><code>svec v(svec::allocator_type(My_alloc&lt;xstring&gt;{my_arena1}));
</code></pre>

<p>Now <code>svec</code> is a <code>vector</code> of strings using <code>My_alloc</code> to allocate memory for strings. What&#8217;s new is that the standard library &#8220;adaptor&#8221; (&#8220;wrapper type&#8221;) <code>scoped_allocator_adaptor</code> is used to indicate that string also should use <code>My_alloc</code>. Note that the adaptor can (trivially) convert <code>My_alloc&lt;xstring&gt;</code> to the <code>My_alloc&lt;char&gt;</code> that string needs.</p>

<p>So, we have four alternatives:</p>

<pre><code>// vector and string use their own (the default) allocator:
using svec0 = vector&lt;string&gt;;
svec0 v0;

// vector (only) uses My_alloc and string uses its own (the default) allocator:
using svec1 = vector&lt;string,My_alloc&lt;string&gt;&gt;;
svec1 v1(My_alloc&lt;string&gt;{my_arena1});

// vector and string use My_alloc (as above):
using xstring = basic_string&lt;char, char_traits&lt;char&gt;, My_alloc&lt;char&gt;&gt;;
using svec2 = vector&lt;xstring,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;&gt;;
svec2 v2(scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;{my_arena1});

// vector uses My_alloc and string uses My_string_alloc:
using xstring2 = basic_string&lt;char, char_traits&lt;char&gt;, My_string_alloc&lt;char&gt;&gt;;
using svec3 = vector&lt;xstring2,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;, My_string_alloc&lt;char&gt;&gt;&gt;;  
svec3 v3(scoped_allocator_adaptor&lt;My_alloc&lt;xstring2&gt;, My_string_alloc&lt;char&gt;&gt;{my_arena1,my_string_arena}); 
</code></pre>

<p>Obviously, the first variant, <code>svec0</code>, will be by far the most common, but for systems with serious memory-related performance constraints, the other versions (especially <code>svec2</code>) can be important. A few <code>typedef</code>s would make that code a bit more readable, but it is good it is not something you have to write every day. The <code>scoped_allocator_adaptor2</code> is a variant of <code>scoped_allocator_adaptor</code> for the case where the two non-default allocators differ.</p>

<p>See also:</p>

<ul>
<li>Standard: 20.8.5 Scoped allocator adaptor [allocator.adaptor] </li>
<li>Pablo Halpern: <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2554.pdf">The Scoped Allocator Model (Rev 2)</a>. N2554=08-0064. </li>
</ul>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance ‚Äî Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance ‚Äî virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance ‚Äî Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance ‚Äî Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance ‚Äî What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance ‚Äî private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance ‚Äî Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/cpp11-library",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/cpp11-library",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/cpp11-library by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:43 GMT -->
</html>
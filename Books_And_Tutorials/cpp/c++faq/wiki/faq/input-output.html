<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/input-output by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="519f3f5a3a60b5d9eacb2950eb41c4d0dba38abc" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="5b376478dee9fc2556dc18dc3115dac3adb39d6c" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="0d6eb4bc97772af89f7bf2f14100975c65473abe" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        input output
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="input-output.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    input output
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=input%20output" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="input-output">Input/output via <code>&lt;iostream&gt;</code> and <code>&lt;cstdio&gt;</code></h2>

<h3 id="iostream-vs-stdio">Why should I use <code>&lt;iostream&gt;</code> instead of the traditional <code>&lt;cstdio&gt;</code>?</h3>

<p>Increase type safety, reduce errors, allow extensibility, and provide inheritability.</p>

<p><code>printf()</code> is arguably not broken, and <code>scanf()</code> is perhaps livable despite being error prone, however both are limited
with respect to what C++ I/O can do. C++ I/O (using <code>&lt;&lt;</code> and <code>&gt;&gt;</code>) is, relative to C (using <code>printf()</code> and
<code>scanf()</code>):</p>

<ul>
<li><em>More type-safe:</em> With <code>&lt;iostream&gt;</code>, the type of object being I/O&#8217;d is known statically by the compiler. In
contrast, <code>&lt;cstdio&gt;</code> uses <code>"%"</code> fields to figure out the types dynamically.</li>
<li><em>Less error prone:</em> With <code>&lt;iostream&gt;</code>, there are no redundant <code>"%"</code> tokens that have to be consistent with the
actual objects being I/O&#8217;d. Removing redundancy removes a class of errors.</li>
<li><em>Extensible:</em> The C++ <code>&lt;iostream&gt;</code> mechanism allows new user-defined types to be I/O&#8217;d without breaking existing
code. Imagine the chaos if everyone was simultaneously adding new incompatible <code>"%"</code> fields to <code>printf()</code> and
<code>scanf()</code>?!</li>
<li><em>Inheritable:</em> The C++ <code>&lt;iostream&gt;</code> mechanism is built from real classes such as <code>std::ostream</code> and
<code>std::istream</code>. Unlike <code>&lt;cstdio&gt;</code>&#8217;s <code>FILE*</code>, these are real classes and hence inheritable. This means you can have
other user-defined things that look and act like streams, yet that do whatever strange and wonderful things you
want. You automatically get to use the zillions of lines of I/O code written by users you don&#8217;t even know, and they
don&#8217;t need to know about your &#8220;extended stream&#8221; class.</li>
</ul>

<h3 id="stream-input-failure">Why does my program go into an infinite loop when someone enters an invalid input character?</h3>

<p>For example, suppose you have the following code that reads integers from <code>std::cin</code>:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
  std::cout &lt;&lt; "Enter numbers separated by whitespace (use -1 to quit): ";
  int i = 0;
  while (i != -1) {
    std::cin &gt;&gt; i;        // BAD FORM — See comments below
    std::cout &lt;&lt; "You entered " &lt;&lt; i &lt;&lt; '\n';
  }
  // ...
}
</code></pre>

<p>The problem with this code is that it lacks any checking to see if someone entered an invalid input character. In
particular, if someone enters something that doesn&#8217;t look like an integer (such as an &#8216;x&#8217;), the stream <code>std::cin</code> goes
into a &#8220;failed state,&#8221; and all subsequent input attempts return immediately without doing anything. In other words, the
program enters an infinite loop; if <code>42</code> was the last number that was successfully read, the program will print the
message <code>You entered 42</code> over and over.</p>

<p>An easy way to check for invalid input is to move the input request from the body of the <code>while</code> loop into the
control-expression of the <code>while</code> loop. E.g.,</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
  std::cout &lt;&lt; "Enter a number, or -1 to quit: ";
  int i = 0;
  while (std::cin &gt;&gt; i) {    // GOOD FORM
    if (i == -1) break;
    std::cout &lt;&lt; "You entered " &lt;&lt; i &lt;&lt; '\n';
  }
  // ...
}
</code></pre>

<p>This will cause the while loop to exit either when you hit end-of-file, or when you enter a bad integer, or when you
enter <code>-1</code>.</p>

<p>(Naturally you can eliminate the <code>break</code> by changing the <code>while</code> loop expression from <code>while (std::cin &gt;&gt; i)</code> to
<code>while ((std::cin &gt;&gt; i) &amp;&amp; (i != -1))</code>, but that&#8217;s not really the point of this FAQ since this FAQ has to do with
iostreams rather than generic structured programming guidelines.)</p>

<h3 id="istream-and-ignore">How can I get <code>std::cin</code> to skip invalid input characters?</h3>

<p>Use <code>std::cin.clear()</code> and <code>std::cin.ignore()</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int main()
{
  int age = 0;

  while ((std::cout &lt;&lt; "How old are you? ")
         &amp;&amp; !(std::cin &gt;&gt; age)) {
    std::cout &lt;&lt; "That's not a number; ";
    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
  }

  std::cout &lt;&lt; "You are " &lt;&lt; age &lt;&lt; " years old\n";
  // ...
}
</code></pre>

<p>Of course you can also print the error message when the input is out of range. For example, if you wanted the <code>age</code> to
be between 1 and 200, you could change the <code>while</code> loop to:</p>

<pre><code>  // ...
  while ((std::cout &lt;&lt; "How old are you? ")
         &amp;&amp; (!(std::cin &gt;&gt; age) || age &lt; 1 || age &gt; 200)) {
    std::cout &lt;&lt; "That's not a number between 1 and 200; ";
    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
  }
  // ...
</code></pre>

<p>Here&#8217;s a sample run:</p>

<pre><code>How old are you? foo
That's not a number between 1 and 200; How old are you? bar
That's not a number between 1 and 200; How old are you? -3
That's not a number between 1 and 200; How old are you? 0
That's not a number between 1 and 200; How old are you? 201
That's not a number between 1 and 200; How old are you? 2
You are 2 years old
</code></pre>

<h3 id="istream-and-while">How does that funky <code>while (std::cin &gt;&gt; foo)</code> syntax work?</h3>

<p>See the <a href="input-output.html#stream-input-failure" title="FAQ: Why does my program go into an infinite loop when someone enters an invalid input character?">previous FAQ</a> for an example of the &#8220;funky <code>while (std::cin &gt;&gt; foo)</code> syntax.&#8221;</p>

<p>The expression <code>(std::cin &gt;&gt; foo)</code> calls the appropriate <code>operator&gt;&gt;</code> (for example, it calls the <code>operator&gt;&gt;</code> that takes
an <code>std::istream</code> on the left and, if <code>foo</code> is of type <code>int</code>, an <code>int&amp;</code> on the right). The <code>std::istream</code> <code>operator&gt;&gt;</code>
functions return their left argument by convention, which in this case means it will return <code>std::cin</code>. Next the
compiler notices that the returned <code>std::istream</code> is in a boolean context, so it converts that <code>std::istream</code> into a
boolean.</p>

<p>To convert an <code>std::istream</code> into a boolean, the compiler calls a member function called
<code>std::istream::operator void*()</code>. This returns a <code>void*</code> pointer, which is in turn converted to a boolean (<code>NULL</code>
becomes <code>false</code>, any other pointer becomes <code>true</code>). So in this case the compiler generates a call to
<code>std::cin.operator void*()</code>, just as if you had casted it explicitly such as <code>(void*) std::cin</code>.</p>

<p>The <code>operator void*()</code> cast operator returns some non-<code>NULL</code> pointer if the stream is in a good state, or <code>NULL</code> if
it&#8217;s in a failed state. For example, if you read one too many times (e.g., if you&#8217;re already at end-of-file), or if
the actual info on the input stream isn&#8217;t valid for the type of <code>foo</code> (e.g., if <code>foo</code> is an <code>int</code> and the data is an &#8216;x&#8217;
character), the stream will go into a failed state and the cast operator will return <code>NULL</code>.</p>

<p>The reason <code>operator&gt;&gt;</code> doesn&#8217;t simply return a <code>bool</code> (or <code>void*</code>) indicating whether it succeeded or failed is to
support the &#8220;cascading&#8221; syntax:</p>

<pre><code>  std::cin &gt;&gt; foo &gt;&gt; bar;
</code></pre>

<p>The <code>operator&gt;&gt;</code> is left-associative, which means the above is parsed as:</p>

<pre><code>  (std::cin &gt;&gt; foo) &gt;&gt; bar;
</code></pre>

<p>In other words, if we replace <code>operator&gt;&gt;</code> with a normal function name such as <code>readFrom()</code>, this becomes the
expression:</p>

<pre><code>  readFrom( readFrom(std::cin, foo), bar);
</code></pre>

<p>As always, we begin evaluating at the innermost expression. Because of the left-associativity of <code>operator&gt;&gt;</code>, this
happens to be the left-most expression, <code>std::cin &gt;&gt; foo</code>. This expression returns <code>std::cin</code> (more precisely, it
returns a reference to its left-hand argument) to the next expression. The next expression also returns (a reference
to) <code>std::cin</code>, but this second reference is ignored since it&#8217;s the outermost expression in this &#8220;expression statement.&#8221;</p>

<h3 id="istream-and-eof">Why does my input seem to process past the end of file?</h3>

<p>Because the eof state may not get set until after a read is attempted past the end of file. That is, reading the last
byte from a file might not set the eof state. E.g., suppose the input stream is mapped to a keyboard &#8212; in that case
it&#8217;s not even theoretically possible for the C++ library to predict whether or not the character that the user just
typed will be the last character.</p>

<p>For example, the following code might have an off-by-one error with the count <code>i</code>:</p>

<pre><code>int i = 0;
while (! std::cin.eof()) {   // WRONG! (not reliable)
  std::cin &gt;&gt; x;
  ++i;
  // Work with x ...
}
</code></pre>

<p>What you really need is:</p>

<pre><code>int i = 0;
while (std::cin &gt;&gt; x) {      // RIGHT! (reliable)
  ++i;
  // Work with x ...
}
</code></pre>

<h3 id="istreams-remember-bad-state">Why is my program ignoring my input request after the first iteration?</h3>

<p>Because the numerical extractor leaves non-digits behind in the input buffer.</p>

<p>If your code looks like this:</p>

<pre><code>char name[1000];
int age;

for (;;) {
  std::cout &lt;&lt; "Name: ";
  std::cin &gt;&gt; name;
  std::cout &lt;&lt; "Age: ";
  std::cin &gt;&gt; age;
}
</code></pre>

<p>What you really want is:</p>

<pre><code>for (;;) {
  std::cout &lt;&lt; "Name: ";
  std::cin &gt;&gt; name;
  std::cout &lt;&lt; "Age: ";
  std::cin &gt;&gt; age;
  std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
}
</code></pre>

<p>Of course you might want to change the <code>for (;;)</code> statement to <code>while (std::cin)</code>, but don&#8217;t confuse that with skipping
the non-numeric characters at the end of the loop via the line: <code>std::cin.ignore(...);</code>.</p>

<h3 id="endl-vs-slash-n">Should I end my output lines with <code>std::endl</code> or <code>'\n'</code>?</h3>

<p>Using <code>std::endl</code> flushes the output buffer after sending a <code>'\n'</code>, which means <code>std::endl</code> is more expensive in
performance. Obviously if you need to flush the buffer after sending a <code>'\n'</code>, then use <code>std::endl</code>; but if you don&#8217;t
need to flush the buffer, the code will run faster if you use <code>'\n'</code>.</p>

<p>This code simply outputs a <code>'\n'</code>:</p>

<pre><code>void f()
{
  std::cout &lt;&lt; /*...stuff...*/ &lt;&lt; '\n';
}
</code></pre>

<p>This code outputs a <code>'\n'</code>, then flushes the output buffer:</p>

<pre><code>void g()
{
  std::cout &lt;&lt; /*...stuff...*/ &lt;&lt; std::endl;
}
</code></pre>

<p>This code simply flushes the output buffer:</p>

<pre><code>void h()
{
  std::cout &lt;&lt; /*...stuff...*/ &lt;&lt; std::flush;
}
</code></pre>

<p>Note: all three of the above examples require <code>#include &lt;iostream&gt;</code></p>

<h3 id="output-operator">How can I provide printing for my <code>class</code> <code>Fred</code>?</h3>

<p>Use <a href="operator-overloading.html" title="Section: Operator Overloading"><code>operator</code> overloading</a> to provide a <a href="friends.html" title="Section: Friends"><code>friend</code></a> left-shift operator, <code>operator&lt;&lt;</code>.</p>

<pre><code>#include &lt;iostream&gt;

class Fred {
public:
  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Fred&amp; fred);
  // ...
private:
  int i_;    // Just for illustration
};

std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Fred&amp; fred)
{
  return o &lt;&lt; fred.i_;
}

int main()
{
  Fred f;
  std::cout &lt;&lt; "My Fred object: " &lt;&lt; f &lt;&lt; "\n";
  // ...
}
</code></pre>

<p>We use a non-member function (a <a href="friends.html" title="Section: Friends"><code>friend</code></a> in this case) since the <code>Fred</code> object is the right-hand operand of
the <code>&lt;&lt;</code> operator. If the <code>Fred</code> object was supposed to be on the left hand side of the <code>&lt;&lt;</code> (that is,
<code>myFred &lt;&lt; std::cout</code> rather than <code>std::cout &lt;&lt; myFred</code>), we could have used a member function named <code>operator&lt;&lt;</code>.</p>

<p>Note that <code>operator&lt;&lt;</code> returns the stream. This is so the output operations can be <a href="input-output.html#istream-and-while" title="FAQ: How does that funky while (std::cin >> foo) syntax work?">cascaded</a>.</p>

<h3 id="output-operator-via-friends">But shouldn&#8217;t I always use a <code>printOn()</code> method rather than a <code>friend</code> function?</h3>

<p>No.</p>

<p>The usual reason people want to <em>always</em> use a <code>printOn()</code> method rather than a <code>friend</code> function is because they
wrongly believe that friends violate encapsulation and/or that friends are evil. These beliefs are naive and wrong:
when used properly, <a href="friends.html#friends-and-encap" title="FAQ: Do friends violate encapsulation?">friends can actually enhance encapsulation</a>.</p>

<p>This is not to say that the <code>printOn()</code> method approach is <em>never</em> useful. For example, it is useful when <a href="input-output.html#virtual-friend-fns" title="FAQ: How can I provide printing for an entire hierarchy of classes?">providing
printing for an entire hierarchy of classes</a>. But if you use a <code>printOn()</code> method, it should
normally be <code>protected</code>, not <code>public</code>.</p>

<p>For completeness, here is &#8220;the <code>printOn()</code> method approach.&#8221; The idea is to have a member function, often called
<code>printOn()</code>, that does the actual printing, then have <code>operator&lt;&lt;</code> call that <code>printOn()</code> method. When it is done
<em>wrongly</em>, the <code>printOn()</code> method is <code>public</code> so <code>operator&lt;&lt;</code> doesn&#8217;t have to be a <code>friend</code> &#8212; it can be a simple
top-level function that is neither a <code>friend</code> nor a member of the class. Here&#8217;s some sample code:</p>

<pre><code>#include &lt;iostream&gt;

class Fred {
public:
  void printOn(std::ostream&amp; o) const;
  // ...
};

// operator&lt;&lt; can be declared as a non-friend [NOT recommended!]
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Fred&amp; fred);

// The actual printing is done inside the printOn() method [NOT recommended!]
void Fred::printOn(std::ostream&amp; o) const
{
  // ...
}

// operator&lt;&lt; calls printOn() [NOT recommended!]
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Fred&amp; fred)
{
  fred.printOn(o);
  return o;
}
</code></pre>

<p>People wrongly assume that this reduces maintenance cost &#8220;since it avoids having a friend function.&#8221; This is a wrong
assumption because:</p>

<ol>
<li><strong>The member-called-by-top-level-function approach has <em>zero</em> benefit in terms of maintenance cost.</strong> Let&#8217;s say
it takes <em>N</em> lines of code to do the actual printing. In the case of a <code>friend</code> function, those <em>N</em> lines of code
will have direct access to the class&#8217;s <code>private</code>/<code>protected</code> parts, which means whenever someone changes the class&#8217;s
<code>private</code>/<code>protected</code> parts, those <em>N</em> lines of code will need to be scanned and possibly modified, which increases
the maintenance cost. However using the <code>printOn()</code> method doesn&#8217;t change this at all: we still have <em>N</em> lines of
code that have direct access to the class&#8217;s <code>private</code>/<code>protected</code> parts. Thus moving the code from a <code>friend</code>
function into a member function does <em>not</em> reduce the maintenance cost <em>at all</em>. Zero reduction. No benefit in
maintenance cost. (If anything it&#8217;s a bit worse with the <code>printOn()</code> method since you now have <em>more</em> lines of code
to maintain since you have an extra function that you didn&#8217;t have before.)</li>
<li><strong>The member-called-by-top-level-function approach makes the class harder to use, particularly by programmers
who are not also class designers.</strong> The approach exposes a <code>public</code> method that programmers are not supposed to
call. When a programmer reads the <code>public</code> methods of the class, they&#8217;ll see two ways to do the same thing. The
documentation would need to say something like, &#8220;This does exactly the same as that, but don&#8217;t use this; instead use
that.&#8221; And the average programmer will say, &#8220;Huh? Why make the method <code>public</code> if I&#8217;m not supposed to use it?&#8221; In
reality the only reason the <code>printOn()</code> method is <code>public</code> is to avoid granting friendship status to <code>operator&lt;&lt;</code>,
and that is a notion that is somewhere between subtle and incomprehensible to a programmer who simply wants to use
the class.</li>
</ol>

<p>Net: the member-called-by-top-level-function approach has a cost but no benefit. Therefore it is, in general, a
bad idea.</p>

<p>Note: if the <code>printOn()</code> method is <code>protected</code> or <code>private</code>, the second objection doesn&#8217;t apply. There are cases when
that approach is reasonable, such as when <a href="input-output.html#virtual-friend-fns" title="FAQ: How can I provide printing for an entire hierarchy of classes?">providing printing for an entire hierarchy of classes</a>.
Note also that when the <code>printOn()</code> method is non-<code>public</code>, <code>operator&lt;&lt;</code> needs to be a <code>friend</code>.</p>

<h3 id="input-operator">How can I provide input for my <code>class</code> <code>Fred</code>?</h3>

<p>Use <a href="operator-overloading.html" title="Section: Operator Overloading"><code>operator</code> overloading</a> to provide a <a href="friends.html" title="Section: Friends"><code>friend</code></a> right-shift operator, <code>operator&gt;&gt;</code>.
This is similar to the <a href="input-output.html#output-operator" title="FAQ: How can I provide printing for my class Fred?">output operator</a>, except the parameter doesn&#8217;t have a
<a href="const-correctness.html" title="Section: Const Correctness"><code>const</code></a>: &#8220;<code>Fred&amp;</code>&#8221; rather than &#8220;<code>const Fred&amp;</code>&#8221;.</p>

<pre><code>#include &lt;iostream&gt;

class Fred {
public:
  friend std::istream&amp; operator&gt;&gt; (std::istream&amp; i, Fred&amp; fred);
  // ...
private:
  int i_;    // Just for illustration
};

std::istream&amp; operator&gt;&gt; (std::istream&amp; i, Fred&amp; fred)
{
  return i &gt;&gt; fred.i_;
}

int main()
{
  Fred f;
  std::cout &lt;&lt; "Enter a Fred object: ";
  std::cin &gt;&gt; f;
  // ...
}
</code></pre>

<p>Note that <code>operator&gt;&gt;</code> returns the stream. This is so the input operations can be <a href="input-output.html#istream-and-while" title="FAQ: How does that funky while (std::cin >> foo) syntax work?">cascaded and/or used in a <code>while</code>
loop or <code>if</code> statement</a>.</p>

<h3 id="virtual-friend-fns">How can I provide printing for an entire hierarchy of classes?</h3>

<p>Provide a <a href="friends.html" title="Section: Friends"><code>friend</code></a> <a href="input-output.html#output-operator" title="FAQ: How can I provide printing for my class Fred?"><code>operator&lt;&lt;</code></a> that calls a <code>protected</code> <a href="virtual-functions.html" title="Section: Inheritance — virtual functions"><code>virtual</code></a>
function:</p>

<pre><code>class Base {
public:
  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Base&amp; b);
  // ...
protected:
  virtual void printOn(std::ostream&amp; o) const = 0;  // Or plain virtual; see below
};

inline std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Base&amp; b)
{
  b.printOn(o);
  return o;
}

class Derived : public Base {
public:
  // ...
protected:
  virtual void printOn(std::ostream&amp; o) const;
};

void Derived::printOn(std::ostream&amp; o) const
{
  // ...
}
</code></pre>

<p>The end result is that <code>operator&lt;&lt;</code> <em>acts</em> as if it were dynamically bound, even though it&#8217;s a <a href="friends.html" title="Section: Friends"><code>friend</code></a>
function. This is called the Virtual Friend Function Idiom.</p>

<p>Note that derived classes override <code>printOn(std::ostream&amp;)</code> <code>const</code>. In particular, they do <em>not</em> provide their own
<code>operator&lt;&lt;</code>.</p>

<p>As to whether <code>Base::printOn()</code> is <a href="abcs.html#pure-virtual-fns" title="FAQ: What is a 'pure virtual' member function?">plain virtual or pure virtual</a>, consider making it a plain virtual
(without the &#8220;<code>= 0</code>&#8221;) if you can implement that function with code that would otherwise be repeated in two or more
derived classes. However if <code>Base</code> is a <a href="abcs.html#abc-defn" title="FAQ: What is an ABC?">ABC</a> with little or no member data, you might not be able to provide
a meaningful definition for <code>Base::printOn()</code> and you should make it pure virtual. If you&#8217;re not sure, make it pure
virtual, at least until you get a better handle on the derived classes.</p>

<h3 id="binary-mode-for-iostreams">How can I open a stream in binary mode?</h3>

<p>Use <code>std::ios::binary</code>.</p>

<p>Some operating systems differentiate between <em>text</em> and <em>binary</em> modes. In text mode, end-of-line sequences and
possibly other things are translated; in binary mode, they are not. For example, in text mode under Windows, <code>"\r\n"</code> is
translated into <code>"\n"</code> on input, and the reverse on output.</p>

<p>To read a file in binary mode, use something like this:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;

void readBinaryFile(const std::string&amp; filename)
{
  std::ifstream input(filename.c_str(), std::ios::in | std::ios::binary);
  char c;
  while (input.get(c)) {
    // ...do something with c here...
  }
}
</code></pre>

<p>Note: <code>input &gt;&gt; c</code> discards leading whitespace, so you won&#8217;t normally use that when reading binary files.</p>

<h3 id="binary-mode-for-cin-cout">How can I &#8220;reopen&#8221; <code>std::cin</code> and <code>std::cout</code> in binary mode?</h3>

<p>This is implementation dependent. Check with your compiler&#8217;s documentation.</p>

<p>For example, suppose you want to do <a href="input-output.html#binary-mode-for-iostreams" title="FAQ: How can I open a stream in binary mode?">binary I/O</a> using <code>std::cin</code> and <code>std::cout</code>.</p>

<p>Unfortunately there is no standard way to cause <code>std::cin</code>, <code>std::cout</code>, and/or <code>std::cerr</code> to be opened in binary mode.
Closing the streams and attempting to reopen them in binary mode might have unexpected or undesirable results.</p>

<p>On systems <a href="input-output.html#binary-mode-for-iostreams" title="FAQ: How can I open a stream in binary mode?">where it makes a difference</a>, the implementation might provide a way to make them
binary streams, but you would have to <a href="misc-environmental-issues.html#os-specific-faqs" title="FAQ: Where can I get OS-specific questions answered (e.g., BC++, Windows, etc)?">check the implementation specifics</a> to find out.</p>

<h3 id="serialization-xref-file">How can I write/read objects of my class to/from a data file?</h3>

<p>Read the section on <a href="serialization.html" title="Section: Serialization and Unserialization">object serialization</a>.</p>

<h3 id="serialization-xref-communication">How can I send objects of my class to another computer (e.g., via a socket, TCP/IP, FTP, email, a wireless link, etc.)?</h3>

<p>Read the section on <a href="serialization.html" title="Section: Serialization and Unserialization">object serialization</a>.</p>

<h3 id="backslashes-in-filenames">Why can&#8217;t I open a file in a different directory such as <code>"..\test.dat"</code>?</h3>

<p>Because <code>"\t"</code> is a tab character.</p>

<p>You should use forward slashes in your filenames, even on operating systems that use backslashes (DOS, Windows, OS/2,
etc.). For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main()
{
  #if 1
    std::ifstream file("../test.dat");  // RIGHT!
  #else
    std::ifstream file("..\test.dat");  // WRONG!
  #endif

  // ...
}
</code></pre>

<p>Remember, the backslash (<code>"\"</code>) is used in string literals to create special characters: <code>"\n"</code> is a newline, <code>"\b"</code> is
a backspace, and <code>"\t"</code> is a tab, <code>"\a"</code> is an &#8220;alert&#8221;, <code>"\v"</code> is a vertical-tab, etc. Therefore the file name
<code>"\version\next\alpha\beta\test.dat"</code> is interpreted as a bunch of very funny characters. To be safe, use
<code>"/version/next/alpha/beta/test.dat"</code> instead, even on systems that use a <code>"\"</code> as the directory separator. This is
because the library routines on these operating systems handle <code>"/"</code> and <code>"\"</code> interchangeably.</p>

<p>Of course you <em>could</em> use <code>"\\version\\next\\alpha\\beta\\test.dat"</code>, but that might hurt you (there&#8217;s a non-zero
chance you&#8217;ll forget one of the <code>"\"</code>s, a rather subtle bug since most people don&#8217;t notice it) and it can&#8217;t help you
(there&#8217;s no benefit for using <code>"\\"</code> over <code>"/"</code>). Besides <code>"/"</code> is more portable since it works on all flavors of Unix,
Plan 9, Inferno, all Windows, OS/2, etc., but <code>"\\"</code> works only on a subset of that list. So <code>"\\"</code> costs you something
and gains you nothing: use <code>"/"</code> instead.</p>

<h3 id="kbhit">How can I tell (if a key, which key) was pressed before the user presses the ENTER key?</h3>

<p>This is not a standard C++ feature &#8212; C++ doesn&#8217;t even require your system to <em>have a keyboard!</em>. That means every
operating system and vendor does it somewhat differently.</p>

<p>Please read the documentation that came with your compiler for details on your particular installation.</p>

<p>(By the way, the process on UNIX typically has two steps: first <a href="http://www.faqs.org/faqs/unix-faq/programmer/faq/">set the terminal to single-character
mode</a>, then use either <code>select()</code> or <code>poll()</code> to test if a key was
pressed. You might be able to adapt <a href="http://www.pwilson.net/kbhit.html">this code</a>.)</p>

<h3 id="turn-off-tty-echo">How can I make it so keys pressed by users are not echoed on the screen?</h3>

<p>This is not a standard C++ feature &#8212; C++ doesn&#8217;t even require your system to have a keyboard or a screen. That
means every operating system and vendor does it somewhat differently.</p>

<p>Please read the documentation that came with your compiler for details on your particular installation.</p>

<h3 id="move-cursor-on-screen">How can I move the cursor around on the screen?</h3>

<p>This is not a standard C++ feature &#8212; C++ doesn&#8217;t even require your system to have a screen. That means every
operating system and vendor does it somewhat differently.</p>

<p>Please read the documentation that came with your compiler for details on your particular installation.</p>

<h3 id="clear-screen">How can I clear the screen? Is there something like <code>clrscr()</code>?</h3>

<p>This is not a standard C++ feature &#8212; C++ doesn&#8217;t even require your system to have a screen. That means every
operating system and vendor does it somewhat differently.</p>

<p>Please read the documentation that came with your compiler for details on your particular installation.</p>

<h3 id="change-screen-colors">How can I change the colors on the screen?</h3>

<p>This is not a standard C++ feature &#8212; C++ doesn&#8217;t even require your system to have a screen. That means every
operating system and vendor does it somewhat differently.</p>

<p>Please read the documentation that came with your compiler for details on your particular installation.</p>

<h3 id="print-char-or-ptr-as-number">How can I print a <code>char</code> as a number? How can I print a <code>char*</code> so the output shows the pointer&#8217;s numeric value?</h3>

<p>Cast it.</p>

<p>C++ streams do what most programmers expect when printing a <code>char</code>. If you print a character, it prints as the actual
character, not the numeric value of the character:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void f()
{
  char c = 'x';
  std::string s = "Now is";
  const char* t = "the time";
  std::cout &lt;&lt; c;     // Prints a character, in this case, x
  std::cout &lt;&lt; 'y';   // Prints a character, in this case, y
  std::cout &lt;&lt; s[2];  // Prints a character, in this case, w
  std::cout &lt;&lt; t[2];  // Prints a character, in this case, e
}
</code></pre>

<p>C++ streams also do the right thing when printing a <code>char*</code>: it prints the string, which must be terminated by
<code>'\0'</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void f()
{
  const char* s = "xyz";
  std::cout &lt;&lt; s;     // Prints the string, in this case, xyz
  std::cout &lt;&lt; "pqr"; // Prints the string, in this case, pqr
}
</code></pre>

<p>These seem obvious only because they are intuitive, but in fact there is some pretty wonderful functionality going on in
there. C++ streams interpret the values of your chars into actual human readable symbols according to your current
locale, plus they know that if you give them a character-pointer, you probably meant to print the C-like string. The
only problem is when you do <em>not</em> want the code to behave this way.</p>

<p>Imagine you have a structure that stores peoples&#8217; age as an <code>unsigned char</code>. If you wanted to print that structure, it
would not make much sense to say that a person&#8217;s is <code>'A'</code>. Or if for some reason you wanted to print the address of that
age variable, the stream would start at that address and would interpret every subsequent byte (bytes of your struct or
class or even of the stack!) as a character, stopping finally when it reaches the first byte containing <code>'\0'</code>.</p>

<pre><code>// Variable 'age' stores the person's age
unsigned char age = 65;

// Our goal here is to print the person's age:
std::cout &lt;&lt; age;   // Whoops! Prints 'A', not the numeric age

// Our next goal is to print the age variable's location, that is, its address:
std::cout &lt;&lt; &amp;age;  // Whoops! Prints garbage, and might crash
</code></pre>

<p>This is <em>not</em> what was desired. The simplest, and usually recommended, solution is to cast the <code>char</code> or <code>char*</code> to a
type your compiler does not interpret as characters, respectively an <code>int</code> or a <code>void*</code>:</p>

<pre><code>// Variable 'age' stores the person's age
unsigned char age = 65;

// Our goal here is to print the person's age:
std::cout &lt;&lt; static_cast&lt;unsigned&gt;(age);      // Good: prints 65

// Our next goal is to print the age variable's location, that is, its address:
std::cout &lt;&lt; static_cast&lt;const void*&gt;(&amp;age);  // Good: prints the variable's address
</code></pre>

<p>That works great for explicitly specified types, such as <code>unsigned char</code> shown above. But if you are creating a
template, where the type <code>unsigned char</code> above is simply known as some numeric type <code>T</code>, you don&#8217;t want to assume the
proper numeric type is <code>unsigned</code> or anything else. In this case, you want to convert your <code>T</code> object to the <em>proper</em>
numeric type, whatever that is.</p>

<p>For example, your type <code>T</code> might be anything from <code>char</code> to <code>int</code> to <code>long</code> or <code>long long</code> (if your compiler supports
that already). Or your type <code>T</code> might even be an abstract numeric class that does not even provide a cast to any
built-in integer (think <code>safe_integer</code>, <code>ranged_integer</code> or <code>big_num</code> classes, for example).</p>

<p>One way to handle this is through traits or template specialization, but there is a much simpler solution that works for
<code>char</code> types without jeopardizing these other types. So long as type <code>T</code> provides a unary <code>+</code> operator with ordinary
semantics[&#42;footnote], which is provided for all built-in numeric types, everything will work fine:</p>

<pre><code>template &lt;typename T&gt;
void my_super_function(T x)
{
  // ...
  std::cout &lt;&lt; +x &lt;&lt; '\n';  // promotes x to a type printable as a number, regardless of type
  // ...
}
</code></pre>

<p>Works like magic. The worst you have to worry about now is that it might be a bit cryptic to other developers. If you
are thinking to yourself, &#8220;Self, I should probably create a function called <code>promote_to_printable_integer_type()</code> to
make my code self-documenting.&#8221; Unfortunately, C++ <em>currently</em> lacks Type Inference, so writing such a function would
require code so complex it would probably bring more bugs than the (potential) ones you would prevent. So short term,
the best solution is to just bite the bullet, use <code>operator+</code> and comment your code.</p>

<p>When your organization gets access to C++11, you can start enjoying the convenience of type inference:</p>

<pre><code>template &lt;typename T&gt;
auto promote_to_printable_integer_type(T i) -&gt; decltype(+i)
{
  return +i;
}
</code></pre>

<p>Without going into detail, the return type is &#8220;the same type as the type of +i&#8221;. It might look weird, but like most
generic templates, what counts is the ease of <em>use</em>, not the beauty of the template definition itself. Here is a sample
use:</p>

<pre><code>void f()
{
  unsigned char age = 65;
  std::cout &lt;&lt; promote_to_printable_integer_type(age);  // Prints 65
}

template &lt;typename T&gt;
void g(T x)
{
  // ...
  std::cout &lt;&lt; promote_to_printable_integer_type(x);  // Works for any T that provides unary +
  // ...
}
</code></pre>

<p>This answer will be updated due to C++11 type inference. Watch this space for updates in the near future!!</p>

<p>[&#42;footnote] If you are defining a class that represents a number, to provide a unary <code>+</code> operator with canonical
semantics, create an <code>operator+()</code> that simply returns <code>*this</code> either by value or by reference-to-const.</p>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance — Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance — virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance — Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance — Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance — What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance — private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance — Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/input-output",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/input-output",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/input-output by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:41 GMT -->
</html>
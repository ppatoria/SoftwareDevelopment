<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/templates by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="4074d9738c9c16767b32202ab9e3557447bcc34d" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="5389374b687952d50eb17e63d2cfdd8c4eeb507c" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="7d9452b27eb1f6cf13b830f564eea6062c935750" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        templates
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="templates.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    templates
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=templates" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="templates">Templates</h2>

<h3 id="overview-templates">What&#8217;s the idea behind templates?</h3>

<p>A template is a cookie-cutter that specifies how to cut cookies that all look pretty much the same (although the cookies can be made of various kinds of dough, they&#8217;ll all have the same basic shape). In the same way, a class template is a cookie cutter for a description of how to build a family of classes that all look basically the same, and a function template describes how to build a family of similar looking functions.</p>

<p>Class templates are often used to build type safe containers (although this only scratches the surface for how they can be used).</p>

<h3 id="class-templates">What&#8217;s the syntax / semantics for a &#8220;class template&#8221;?</h3>

<p>Consider a container <code>class</code> <code>Array</code> that acts like an array of integers:</p>

<pre><code>// This would go into a header file such as "Array.h"
class Array {
public:
  Array(int len=10)                  : len_(len), data_(new int[len]) { }
 ~Array()                            { delete[] data_; }
  int len() const                    { return len_;     }
  const int&amp; operator[](int i) const { return data_[check(i)]; }  // Subscript operators often come in pairs
  int&amp;       operator[](int i)       { return data_[check(i)]; }  // Subscript operators often come in pairs
  Array(const Array&amp;);
  Array&amp; operator= (const Array&amp;);
private:
  int  len_;
  int* data_;
  int  check(int i) const
    {
      if (i &lt; 0 || i &gt;= len_)
        throw BoundsViol("Array", i, len_);
      return i;
    }
};
</code></pre>

<p>Repeating the above over and over for Array of <code>float</code>, of <code>char</code>, of <code>std::string</code>, of Array-of-<code>std::string</code>, etc, would become tedious.  Instead, you add the <code>template&lt;typename T&gt;</code> before the class definition (the <code>T</code> can be any identifier you want, <code>T</code> is just the most commonly used one, especially in examples).  Then, instead of using <code>int</code> or <code>float</code> or <code>char</code> where referring to the data type, you use <code>T</code> instead.  Also, instead of just referring to the class as Array, it&#8217;s <code>Array&lt;T&gt;</code> when referring to the template, or <code>Array&lt;int&gt;</code>, <code>Array&lt;float&gt;</code>, etc. when referring to a specific instantiation.</p>

<pre><code>// This would go into a header file such as "Array.h"
template&lt;typename T&gt;
class Array {
public:
  Array(int len=10)                : len_(len), data_(new T[len]) { }
 ~Array()                          { delete[] data_; }
  int len() const                  { return len_;     }
  const T&amp; operator[](int i) const { return data_[check(i)]; }
  T&amp;       operator[](int i)       { return data_[check(i)]; }
  Array(const Array&lt;T&gt;&amp;);
  Array(Array&lt;T&gt;&amp;&amp;);
  Array&lt;T&gt;&amp; operator= (const Array&lt;T&gt;&amp;);
  Array&lt;T&gt;&amp; operator= (Array&lt;T&gt;&amp;&amp;);
private:
  int len_;
  T*  data_;
  int check(int i) const {
    assert(i &gt;= 0 &amp;&amp; i &lt; len_);
    return i;
  }
};
</code></pre>

<p>Just as with a normal class, you can optionally define your methods outside the class:</p>

<pre><code>template&lt;typename T&gt;
class Array {
public:
  int len() const;
  // ...
};

template&lt;typename T&gt;
inline      // See below if you want to make this non-inline
int Array&lt;T&gt;::len() const
{
  // ...
}
</code></pre>

<p>Unlike <a href="templates.html#fn-templates" title="FAQ: What's the syntax / semantics for a 'function template'?">template functions</a>, template classes (instantiations of class templates) need to be explicit about the parameters over which they are instantiating:</p>

<pre><code>int main()
{
  Array&lt;int&gt;           ai;
  Array&lt;float&gt;         af;
  Array&lt;char*&gt;         ac;
  Array&lt;std::string&gt;   as;
  Array&lt;Array&lt;int&gt;&gt;    aai;
  // ...
}
</code></pre>

<p>Note that prior to C++11, a space was required between the two <code>&gt;</code>&#8217;s in the last example. Without this space, the C++98/C++03 compiler would see a <code>&gt;&gt;</code> (right-shift) token instead of two <code>&gt;</code>&#8217;s. Aren&#8217;t you lucky that it is no longer the case in C++11?</p>

<h3 id="fn-templates">What&#8217;s the syntax / semantics for a &#8220;function template&#8221;?</h3>

<p>Consider this function that swaps its two integer arguments:</p>

<pre><code>void swap(int&amp; x, int&amp; y)
{
  int tmp = x;
  x = y;
  y = tmp;
}
</code></pre>

<p>If we also had to swap floats, longs, Strings, Sets, and FileSystems, we&#8217;d get pretty tired of coding lines that look almost identical except for the type. Mindless repetition is an ideal job for a computer, hence a function template:</p>

<pre><code>template&lt;typename T&gt;
void swap(T&amp; x, T&amp; y)
{
  T tmp = x;
  x = y;
  y = tmp;
}
</code></pre>

<p>Every time we used <code>swap()</code> with a given pair of types, the compiler will go to the above definition and will create yet another &#8220;template function&#8221; as an instantiation of the above. Unlike <a href="templates.html#class-templates" title="FAQ: What's the syntax / semantics for a 'class template'?">template classes</a>, template functions usually do not need to be explicit about the parameters over which they are instantiating.  The compiler can usually determine them automatically.  E.g.,</p>

<pre><code>int main()
{
  int         i,j;  /*...*/  swap(i,j);  // Instantiates a swap for int
  float       a,b;  /*...*/  swap(a,b);  // Instantiates a swap for float
  char        c,d;  /*...*/  swap(c,d);  // Instantiates a swap for char
  std::string s,t;  /*...*/  swap(s,t);  // Instantiates a swap for std::string
  // ...
}
</code></pre>

<p>Note: A &#8220;template function&#8221; is the instantiation of a &#8220;function template&#8221;.</p>

<p>Sometimes, you do <a href="templates.html#fn-templates-explicit-calls" title="FAQ: How do I explicitly select which version of a function template should get called?">want to be explicit about the types used</a>.</p>

<h3 id="fn-templates-explicit-calls">How do I explicitly select which version of a function template should get called?</h3>

<p>When you call a function template, the compiler tries to <em>deduce</em> the template type. Most of the time it can do that successfully, but every once in a while you may want to help the compiler deduce the right type &#8212; either because it cannot deduce the type at all, or perhaps because it would deduce the wrong type.</p>

<p>For example, you might be calling a function template that doesn&#8217;t have any parameters of its template argument types, or you might want to force the compiler to do certain promotions on the arguments before selecting the correct function template. In these cases you&#8217;ll need to explicitly tell the compiler which instantiation of the function template should be called.</p>

<p>Here is a sample function template where the template parameter <code>T</code> does not appear in the function&#8217;s parameter list. In this case the compiler <em>cannot</em> deduce the template parameter types when the function is called.</p>

<pre><code>template&lt;typename T&gt;
void f()
{
  // ...
}
</code></pre>

<p>To call this function with <code>T</code> being an <code>int</code> or a <code>std::string</code>, you could say:</p>

<pre><code>#include &lt;string&gt;

void sample()
{
  f&lt;int&gt;();          // type T will be int in this call
  f&lt;std::string&gt;();  // type T will be std::string in this call
}
</code></pre>

<p>Here is another function whose template parameters appear in the function&#8217;s list of formal parameters (that is, the compiler <em>can</em> deduce the template type from the actual arguments):</p>

<pre><code>template&lt;typename T&gt;
void g(T x)
{
  // ...
}
</code></pre>

<p>Now if you want to force the actual arguments to be promoted before the compiler deduces the template type, you can use the above technique. E.g., if you simply called <code>g(42)</code> you would get <code>g&lt;int&gt;(42)</code>, but if you wanted to pass <code>42</code> to <code>g&lt;long&gt;()</code>, you could say this: <code>g&lt;long&gt;(42)</code>. (Of course you could also promote the parameter explicitly, such as either <code>g(long(42))</code> or even <code>g(42L)</code>, but that ruins the example.)</p>

<p>Similarly if you said <code>g("xyz")</code> you&#8217;d end up calling <code>g&lt;char*&gt;(char*)</code>, but if you wanted to call the <code>std::string</code> version of <code>g&lt;&gt;()</code> you could say <code>g&lt;std::string&gt;("xyz")</code>. (Again you could also promote the argument, such as <code>g(std::string("xyz"))</code>, but that&#8217;s another story.)</p>

<p>Another time when you must specify the types is when the function takes two parameters of the same type, but you give it two different types.</p>

<pre><code>template&lt;typename T&gt;
void g(T x, T y);

int m = 0;
long n = 1;
g(m, n);
</code></pre>

<p>Since <code>m</code> and <code>n</code> have different types, the compiler can&#8217;t deduce what type to use for <code>T</code>, so you have to tell it what to use:</p>

<pre><code>template&lt;typename T&gt;
void g(T x, T y);

int m = 0;
long n = 1;
g&lt;int&gt;(m, n);
</code></pre>

<h3 id="param-types">What is a &#8220;parameterized type&#8221;?</h3>

<p>Another way to say, &#8220;class templates.&#8221;</p>

<p>A parameterized type is a type that is parameterized over another type or some value. <code>List&lt;int&gt;</code> is a type (<code>List</code>)
parameterized over another type (<code>int</code>).</p>

<h3 id="genericity">What is &#8220;genericity&#8221;?</h3>

<p>Yet another way to say, &#8220;class templates.&#8221;</p>

<p>Not to be confused with &#8220;generality&#8221; (which just means avoiding solutions which are overly specific), &#8220;genericity&#8221; means
class templates.</p>

<h3 id="template-specialization">My template function does something special when the template type <code>T</code> is <code>int</code> or <code>std::string</code>; how do I write my template so it uses the special code when <code>T</code> is one of those specific types?</h3>

<p>Before showing how to do this, let&#8217;s make sure you&#8217;re not shooting yourself in the foot. Does the function&#8217;s behavior
<em>appear</em> different to your users? In other words, is the <em>observable behavior</em> different in some substantive way? If so,
you&#8217;re probably shooting yourself in the foot and you will probably confuse your users &#8212; you&#8217;re probably better off
using different functions with different names &#8212; don&#8217;t use templates, don&#8217;t use overloading. For example, if the code
for <code>int</code> inserts something into a container and sorts the result, but the code for <code>std::string</code> removes something from
a container and does not sort the result, those two functions ought not to be an overloaded pair &#8212; their <em>observable
behavior</em> is different so they ought to have different names.</p>

<p>However if the function&#8217;s observable behavior is consistent for all the <code>T</code> types with the differences limited to
implementation details, then you can proceed. Let&#8217;s proceed with an example of this (conceptual only; not C++):</p>

<pre><code>template&lt;typename T&gt;
void foo(const T&amp; x)
{
  switch (typeof(T)) {  // Conceptual only; not C++
    case int:
      // ...implementation details when T is int
      break;

    case std::string:
      // ...implementation details when T is std::string
      break;

    default:
      // ...implementation details when T is neither int nor std::string
      break;
  }
}
</code></pre>

<p>One way to implement the above is via template specialization. Instead of a <code>switch</code>-statement, you end up breaking up
the code into separate functions. The first function is the <code>default</code> case &#8212; the code to be used when <code>T</code> is anything
other than <code>int</code> or <code>std::string</code>:</p>

<pre><code>template&lt;typename T&gt;
void foo(const T&amp; x)
{
  // ...implementation details when T is neither int nor std::string
}
</code></pre>

<p>Next are the two specializations, first for the <code>int</code> case&#8230;</p>

<pre><code>template&lt;&gt;
void foo&lt;int&gt;(const int&amp; x)
{
  // ...implementation details when T is int
}
</code></pre>

<p>&#8230;and next for the <code>std::string</code> case&#8230;</p>

<pre><code>template&lt;&gt;
void foo&lt;std::string&gt;(const std::string&amp; x)
{
  // ...implementation details when T is std::string
}
</code></pre>

<p>That&#8217;s it; you&#8217;re done. The compiler will automagically select the correct specialization when it sees which <code>T</code> you are
using.</p>

<h3 id="template-specialization-example">Huh? Can you provide an example of template specialization that doesn&#8217;t use <code>foo</code> and <code>bar</code>?</h3>

<p>Yes.</p>

<p>One of several ways I personally use <a href="templates.html#template-specialization" title="FAQ: My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">template specialization</a> is for stringification. I
usually use a template to <a href="misc-technical-issues.html#convert-num-to-string" title="FAQ: How do I convert a value (a number, for example) to a std::string?">stringify various objects of various types</a>, but I often need to
specialize the code for stringifying certain specific types. For instance, when stringifying <code>bool</code>s I prefer <code>"true"</code>
and <code>"false"</code> over <code>"1"</code> and <code>"0"</code> so I use <code>std::boolalpha</code> when <code>T</code> is <code>bool</code>. Also I often prefer floating point
output to contain all the digits (so I can see very small differences, etc.) so I use <code>std::setprecision</code> when <code>T</code> is a
floating point type. The end result usually looks something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;limits&gt;

template&lt;typename T&gt; inline std::string stringify(const T&amp; x)
{
  std::ostringstream out;
  out &lt;&lt; x;
  return out.str();
}

template&lt;&gt; inline std::string stringify&lt;bool&gt;(const bool&amp; x)
{
  std::ostringstream out;
  out &lt;&lt; std::boolalpha &lt;&lt; x;
  return out.str();
}

template&lt;&gt; inline std::string stringify&lt;double&gt;(const double&amp; x)
{
  const int sigdigits = std::numeric_limits&lt;double&gt;::digits10;
  // or perhaps std::numeric_limits&lt;double&gt;::max_digits10 if that is available on your compiler
  std::ostringstream out;
  out &lt;&lt; std::setprecision(sigdigits) &lt;&lt; x;
  return out.str();
}

template&lt;&gt; inline std::string stringify&lt;float&gt;(const float&amp; x)
{
  const int sigdigits = std::numeric_limits&lt;float&gt;::digits10;
  // or perhaps std::numeric_limits&lt;float&gt;::max_digits10 if that is available on your compiler
  std::ostringstream out;
  out &lt;&lt; std::setprecision(sigdigits) &lt;&lt; x;
  return out.str();
}

template&lt;&gt; inline std::string stringify&lt;long double&gt;(const long double&amp; x)
{
  const int sigdigits = std::numeric_limits&lt;long double&gt;::digits10;
  // or perhaps std::numeric_limits&lt;long_double&gt;::max_digits10 if that is available on your compiler
  std::ostringstream out;
  out &lt;&lt; std::setprecision(sigdigits) &lt;&lt; x;
  return out.str();
}
</code></pre>

<p>Conceptually they all do the same thing: stringify the parameter. That means the <em>observable behavior</em> is consistent,
therefore the specializations do not confuse callers. However the details for implementing that observable behavior is
slightly different for <code>bool</code> and floating point types, so template specialization is a good approach.</p>

<h3 id="template-specialization-piecemeal">But most of the code in my template function is the same; is there some way to get the benefits of template specialization without duplicating all that source code?</h3>

<p>Yes.</p>

<p>For example, suppose your template function has a bunch of common code along with a relatively small amount of
<code>T</code>-specific code (conceptual only; not C++):</p>

<pre><code>template&lt;typename T&gt;
void foo(const T&amp; x)
{
  // ... common code that works for all T types ...

  switch (typeof(T)) {  // Conceptual only; not C++
    case int:
      // ... small amount of code used only when T is int ...
      break;

    case std::string:
      // ... small amount of code used only when T is std::string ...
      break;

    default:
      // ... small amount of code used when T is neither int nor std::string ...
      break;
  }

  // ... more common code that works for all T types ...
}
</code></pre>

<p>If you blindly applied the advice from <a href="templates.html#template-specialization" title="FAQ: My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">the FAQ on template specialization</a>, you would end up
duplicating all that code before and after the pseudo-switch statement. The way to get the best of both worlds &#8212; to
get the benefits of <code>T</code>-specific pieces without duplicating the entire function, is to extract the pseudo-switch
statement portion into a separate function <code>foo_part()</code>, and <a href="templates.html#template-specialization" title="FAQ: My template function does something special when the template type T is int or std::string; how do I write my template so it uses the special code when T is one of those specific types?">use template specialization</a> on
that separate function:</p>

<pre><code>template&lt;typename T&gt; inline void foo_part(const T&amp; x)
{
  // ... small amount of code used when T is neither int nor std::string ...
}

template&lt;&gt; inline void foo_part&lt;int&gt;(const int&amp; x)
{
  // ... small amount of code used only when T is int ...
}

template&lt;&gt; inline void foo_part&lt;std::string&gt;(const std::string&amp; x)
{
  // ... small amount of code used only when T is std::string ...
}
</code></pre>

<p>The main <code>foo()</code> function would be a simple template &#8212; no specializations. Note that the pseudo-switch statement has
been replaced by a call to <code>foo_part()</code>:</p>

<pre><code>template&lt;typename T&gt;
void foo(const T&amp; x)
{
  // ... common code that works for all T types ...

  foo_part(x);

  // ... more common code that works for all T types ...
}
</code></pre>

<p>As you can see, the body of <code>foo()</code> now doesn&#8217;t mention any particular <code>T</code>. It all gets figured out automatically. The
compiler generates <code>foo</code> for you based on type <code>T</code>, and will generate the correctly typed <code>foo_part</code> function based on
the actual compile-time known type of the <code>x</code> argument. Proper specializations of <code>foo_part</code> will be instantiated.</p>

<h3 id="template-specialization-speed">All those templates and template specializations must slow down my program, right?</h3>

<p>Wrong.</p>

<p>This is a quality-of-implementation issue so your results may vary. However there is usually no slow-down at all. If
anything, the templates might affect the speed of compilation slightly, but once the types are resolved by the compiler
at compile-time, it will typically generate code that is just as fast as with non-template functions, including
inline-expanding appropriate functions, etc.</p>

<h3 id="templates-vs-overloading">So templates are overloading, right?</h3>

<p>Yes and no.</p>

<p>Function templates participate in name resolution for overloaded functions, but the rules are different. For a template
to be considered in overload resolution, the type has to match exactly. If the types do not match exactly, the
conversions are not considered and the template is simply dropped from the set of viable functions. That&#8217;s what is known
as &#8220;SFINAE&#8221; &#8212; Substitution Failure Is Not An Error. Example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

template&lt;typename T&gt; void foo(T* x)
{ std::cout &lt;&lt; "foo&lt;" &lt;&lt; typeid(T).name() &lt;&lt; "&gt;(T*)\n"; }

void foo(int x)
{ std::cout &lt;&lt; "foo(int)\n"; }

void foo(double x)
{ std::cout &lt;&lt; "foo(double)\n"; }

int main()
{
    foo(42);        // matches foo(int) exactly
    foo(42.0);      // matches foo(double) exactly
    foo("abcdef");  // matches foo&lt;T&gt;(T*) with T = char
    return 0;
}
</code></pre>

<p>In this example, <code>foo&lt;T&gt;</code> cannot be considered for the first or the second call to <code>foo</code> in the body of <code>main</code> because
neither 42 nor 42.0 gives the compiler any information to deduce <code>T</code>. The third call, however, includes <code>foo&lt;T&gt;</code> with
<code>T</code> = <code>char</code> and it wins.</p>

<h3 id="templates-defn-vs-decl">Why can&#8217;t I separate the definition of my templates class from its declaration and put it inside a .cpp file?</h3>

<p>If all you want to know is <em>how</em> to fix this situation, read the <a href="templates.html#separate-template-fn-defn-from-decl" title="FAQ: How can I avoid linker errors with my template functions?">next</a>
<a href="templates.html#separate-template-fn-defn-from-decl-export-keyword" title="FAQ: How does the C++ keyword export help with template linker errors?">two</a> FAQs. But in order to understand <em>why</em> things are the way they
are, first accept these facts:</p>

<ol>
<li>A template is not a class or a function. A template is a &#8220;pattern&#8221; that the compiler uses to generate a family of
<a href="templates.html#class-templates" title="FAQ: What's the syntax / semantics for a 'class template'?">classes</a> or <a href="templates.html#fn-templates" title="FAQ: What's the syntax / semantics for a 'function template'?">functions</a>.</li>
<li>In order for the compiler to generate the code, it must see both the template definition (not just declaration) and
the specific types/whatever used to &#8220;fill in&#8221; the template. For example, if you&#8217;re trying to use a <code>Foo&lt;int&gt;</code>, the
compiler must see both the <code>Foo</code> template and the fact that you&#8217;re trying to make a specific <code>Foo&lt;int&gt;</code>.</li>
<li>Your compiler probably doesn&#8217;t remember the details of one <code>.cpp</code> file while it is compiling another <code>.cpp</code> file. It
<em>could</em>, but most do not and if you are reading this FAQ, it almost definitely does not. BTW this is called the
&#8220;separate compilation model.&#8221;</li>
</ol>

<p>Now based on those facts, here&#8217;s an example that shows why things are the way they are. Suppose you have a template
<code>Foo</code> defined like this:</p>

<pre><code>template&lt;typename T&gt;
class Foo {
public:
  Foo();
  void someMethod(T x);
private:
  T x;
};
</code></pre>

<p>Along with similar definitions for the member functions:</p>

<pre><code>template&lt;typename T&gt;
Foo&lt;T&gt;::Foo()
{
  // ...
}

template&lt;typename T&gt;
void Foo&lt;T&gt;::someMethod(T x)
{
  // ...
}
</code></pre>

<p>Now suppose you have some code in file <code>Bar.cpp</code> that uses <code>Foo&lt;int&gt;</code>:</p>

<pre><code>// Bar.cpp

void blah_blah_blah()
{
  // ...
  Foo&lt;int&gt; f;
  f.someMethod(5);
  // ...
}
</code></pre>

<p>Clearly somebody somewhere is going to have to use the &#8220;pattern&#8221; for the constructor definition and for the
<code>someMethod()</code> definition and instantiate those when <code>T</code> is actually <code>int</code>. But if you had put the definition of the
constructor and <code>someMethod()</code> into file <code>Foo.cpp</code>, the compiler would see the template code when it compiled <code>Foo.cpp</code>
and it would see <code>Foo&lt;int&gt;</code> when it compiled <code>Bar.cpp</code>, but there would never be a time when it saw both the template
code and <code>Foo&lt;int&gt;</code>. So by rule #2 above, it could never generate the code for <code>Foo&lt;int&gt;::someMethod()</code>.</p>

<p><em>A note to the experts:</em> I have obviously made several simplifications above. This was intentional so please don&#8217;t
complain too loudly. If you know the difference between a <code>.cpp</code> file and a compilation unit, the difference between a
class template and a template class, and the fact that templates really aren&#8217;t just glorified macros, then don&#8217;t
complain: this particular question/answer wasn&#8217;t aimed at you to begin with. I simplified things so newbies would &#8220;get
it,&#8221; even if doing so offends some experts.</p>

<p><em>Reminder:</em> Read the <a href="templates.html#separate-template-fn-defn-from-decl" title="FAQ: How can I avoid linker errors with my template functions?">next</a>
<a href="templates.html#separate-template-fn-defn-from-decl-export-keyword" title="FAQ: How does the C++ keyword export help with template linker errors?">two</a> FAQs for some solutions to this problem.</p>

<h3 id="separate-template-fn-defn-from-decl">How can I avoid linker errors with my template functions?</h3>

<p>This answer will be updated due to C++11 <code>extern template</code>. Watch this space for updates in the near future!!</p>

<p>Tell your C++ compiler which instantiations to make while it is compiling your template function&#8217;s .cpp file.</p>

<p>As an example, consider the header file <code>foo.h</code> which contains the following template function declaration:</p>

<pre><code>// File "foo.h"
template&lt;typename T&gt;
extern void foo();
</code></pre>

<p>Now suppose file <code>foo.cpp</code> actually defines that template function:</p>

<pre><code>// File "foo.cpp"
#include &lt;iostream&gt;
#include "foo.h"

template&lt;typename T&gt;
void foo()
{
  std::cout &lt;&lt; "Here I am!\n";
}
</code></pre>

<p>Suppose file <code>main.cpp</code> uses this template function by calling <code>foo&lt;int&gt;()</code>:</p>

<pre><code>// File "main.cpp"
#include "foo.h"

int main()
{
  foo&lt;int&gt;();
  // ...
}
</code></pre>

<p>If you compile and (try to) link these two .cpp files, most compilers will generate linker errors. There are two
solutions for this. The first solution is to physically move the definition of the template function into the .h file,
even if it is not an <code>inline</code> function. This solution may (or may not!) cause significant code bloat, meaning your
executable size may increase dramatically (or, if your compiler is smart enough, may not; try it and see).</p>

<p>The other solution is to leave the definition of the template function in the .cpp file and simply add the line
<code>template void foo&lt;int&gt;();</code> to that file:</p>

<pre><code>// File "foo.cpp"
#include &lt;iostream&gt;
#include "foo.h"

template&lt;typename T&gt; void foo()
{
  std::cout &lt;&lt; "Here I am!\n";
}

template void foo&lt;int&gt;();
</code></pre>

<p>If you can&#8217;t modify <code>foo.cpp</code>, simply create a new .cpp file such as <code>foo-impl.cpp</code> as follows:</p>

<pre><code>// File "foo-impl.cpp"
#include "foo.cpp"

template void foo&lt;int&gt;();
</code></pre>

<p>Notice that <code>foo-impl.cpp</code> <code>#include</code>s a .cpp file, not a .h file. If that&#8217;s confusing, click your heels twice, think of
Kansas, and repeat after me, &#8220;I will do it anyway even though it&#8217;s confusing.&#8221; You can trust me on this one. But if you
don&#8217;t trust me or are simply curious, <a href="templates.html#templates-defn-vs-decl" title="FAQ: Why can't I separate the definition of my templates class from its declaration and put it inside a .cpp file?">the rationale is given earlier</a>.</p>

<h3 id="separate-template-fn-defn-from-decl-export-keyword">How does the C++ keyword <code>export</code> help with template linker errors?</h3>

<p>This answer will be updated due to C++11 <code>extern template</code>. Watch this space for updates in the near future!!</p>

<p>The C++ keyword <code>export</code> was originally designed to eliminate the need to <a href="templates.html#separate-template-fn-defn-from-decl" title="FAQ: How can I avoid linker errors with my template functions?">include a template definition</a> (either by providing the definition in the header file or by including the implementation file). However, only a few compilers ever supported this capability, such as <a href="http://www.comeaucomputing.com/tryitout">Comeau C++</a> and <a href="http://docs.sun.com/source/816-2460/Program_Org.html#pgfId-780">Sun Studio</a>, and the general consensus was that it was not worth the trouble.</p>

<p>Because of that, in the C++11 standard, the <code>export</code> feature has been removed from the language.  It remains a reserved word but it no longer has any meaning.</p>

<p>If you are working with a compiler that supports the <code>export</code> keyword, it will probably continue to support the keyword via some sort of compiler option or extension until its users migrate away from it. If you already have code that uses <code>export</code>, you can use a fairly simple discipline to allow your code to easily migrate if/when your compiler stops
supporting it entirely. Just define your template header-files like this:</p>

<pre><code>// File Foo.h

#ifdef USE_EXPORT_KEYWORD
export
#endif
template&lt;typename T&gt;
class Foo {
  // ...
};

#ifndef USE_EXPORT_KEYWORD
  #include "Foo.cpp"
#endif
</code></pre>

<p>And define your non-inline functions in a source-file like this:</p>

<pre><code>// File Foo.cpp

#ifdef USE_EXPORT_KEYWORD
export
#endif
template&lt;typename T&gt; ...
</code></pre>

<p>Then compile with <code>-DUSE_EXPORT_KEYWORD</code>, or whatever equivalent compiler option lets you set a preprocessor symbol like <code>USE_COMPILER_KEYWORD</code>, and if/when your compiler removes support for <code>export</code>, just remove that compiler option.</p>

<h3 id="separate-template-class-defn-from-decl">How can I avoid linker errors with my template classes?</h3>

<p>This answer will be updated due to C++11 <code>extern template</code>. Watch this space for updates in the near future!!</p>

<p>Tell your C++ compiler which instantiations to make while it is compiling your template class&#8217;s .cpp file.</p>

<p>(If you&#8217;ve already read the previous FAQ, this answer is completely symmetric with that one, so you can probably skip this answer.)</p>

<p>As an example, consider the header file <code>Foo.h</code> which contains the following template class. Note that method <code>Foo&lt;T&gt;::f()</code> is inline and methods <code>Foo&lt;T&gt;::g()</code> and <code>Foo&lt;T&gt;::h()</code> are not.</p>

<pre><code>// File "Foo.h"
template&lt;typename T&gt;
class Foo {
public:
  void f();
  void g();
  void h();
};

template&lt;typename T&gt;
inline
void Foo&lt;T&gt;::f()
{
  // ...
}
</code></pre>

<p>Now suppose file <code>Foo.cpp</code> actually defines the non-<code>inline</code> methods <code>Foo&lt;T&gt;::g()</code> and <code>Foo&lt;T&gt;::h()</code>:</p>

<pre><code>// File "Foo.cpp"
#include &lt;iostream&gt;
#include "Foo.h"

template&lt;typename T&gt;
void Foo&lt;T&gt;::g()
{
  std::cout &lt;&lt; "Foo&lt;T&gt;::g()\n";
}

template&lt;typename T&gt;
void Foo&lt;T&gt;::h()
{
  std::cout &lt;&lt; "Foo&lt;T&gt;::h()\n";
}
</code></pre>

<p>Suppose file <code>main.cpp</code> uses this template class by creating a <code>Foo&lt;int&gt;</code> and calling its methods:</p>

<pre><code>// File "main.cpp"
#include "Foo.h"

int main()
{
  Foo&lt;int&gt; x;
  x.f();
  x.g();
  x.h();
  // ...
}
</code></pre>

<p>If you compile and (try to) link these two .cpp files, most compilers will generate linker errors. There are two
solutions for this. The first solution is to physically move the definition of the template functions into the .h file,
even if they are not <code>inline</code> functions. This solution may (or may not!) cause significant code bloat, meaning your
executable size may increase dramatically (or, if your compiler is smart enough, may not; try it and see).</p>

<p>The other solution is to leave the definition of the template function in the .cpp file and simply add the line
<code>template class Foo&lt;int&gt;;</code> to that file:</p>

<pre><code>// File "Foo.cpp"
#include &lt;iostream&gt;
#include "Foo.h"

// ...definition of Foo&lt;T&gt;::f() is unchanged -- see above...
// ...definition of Foo&lt;T&gt;::g() is unchanged -- see above...

template class Foo&lt;int&gt;;
</code></pre>

<p>If you can&#8217;t modify <code>Foo.cpp</code>, simply create a new .cpp file such as <code>Foo-impl.cpp</code> as follows:</p>

<pre><code>// File "Foo-impl.cpp"
#include "Foo.cpp"

template class Foo&lt;int&gt;;
</code></pre>

<p>Notice that <code>Foo-impl.cpp</code> <code>#include</code>s a .cpp file, not a .h file. If that&#8217;s confusing, click your heels twice, think of
Kansas, and repeat after me, &#8220;I will do it anyway even though it&#8217;s confusing.&#8221; You can trust me on this one. But if you
don&#8217;t trust me or are simply curious, <a href="templates.html#templates-defn-vs-decl" title="FAQ: Why can't I separate the definition of my templates class from its declaration and put it inside a .cpp file?">the rationale is given earlier</a>.</p>

<p>If you are using <a href="http://www.comeaucomputing.com/tryitout">Comeau C++</a>, you probably want to <a href="templates.html#separate-template-fn-defn-from-decl-export-keyword" title="FAQ: How does the C++ keyword export help with template linker errors?">learn about the <code>export</code>
keyword</a>.</p>

<h3 id="template-friends">Why do I get linker errors when I use template friends?</h3>

<p>Ah, the intricacies of template friends. Here&#8217;s an example of what people often want to do:</p>

<pre><code>#include &lt;iostream&gt;

template&lt;typename T&gt;
class Foo {
public:
  Foo(const T&amp; value = T());
  friend Foo&lt;T&gt; operator+ (const Foo&lt;T&gt;&amp; lhs, const Foo&lt;T&gt;&amp; rhs);
  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Foo&lt;T&gt;&amp; x);
private:
  T value_;
};
</code></pre>

<p>Naturally the template will need to actually be <em>used</em> somewhere:</p>

<pre><code>int main()
{
  Foo&lt;int&gt; lhs(1);
  Foo&lt;int&gt; rhs(2);
  Foo&lt;int&gt; result = lhs + rhs;
  std::cout &lt;&lt; result;
  // ...
}
</code></pre>

<p>And of course the various member and friend functions will need to be defined somewhere:</p>

<pre><code>template&lt;typename T&gt;
Foo&lt;T&gt;::Foo(const T&amp; value = T())
  : value_(value)
{ }

template&lt;typename T&gt;
Foo&lt;T&gt; operator+ (const Foo&lt;T&gt;&amp; lhs, const Foo&lt;T&gt;&amp; rhs)
{ return Foo&lt;T&gt;(lhs.value_ + rhs.value_); }

template&lt;typename T&gt;
std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Foo&lt;T&gt;&amp; x)
{ return o &lt;&lt; x.value_; }
</code></pre>

<p>The snag happens when the compiler sees the <code>friend</code> lines way up in the class definition proper. At that moment it does
not yet know the <code>friend</code> functions are themselves templates; it assumes they are non-templates like this:</p>

<pre><code>Foo&lt;int&gt; operator+ (const Foo&lt;int&gt;&amp; lhs, const Foo&lt;int&gt;&amp; rhs)
{ /*...*/ }

std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Foo&lt;int&gt;&amp; x)
{ /*...*/ }
</code></pre>

<p>When you call the <code>operator+</code> or <code>operator&lt;&lt;</code> functions, this assumption causes the compiler to generate a call to the
<em>non</em>-template functions, but the linker will give you an &#8220;undefined external&#8221; error because you never actually defined
those <em>non</em>-template functions.</p>

<p>The solution is to convince the compiler <em>while it is examining the class body proper</em> that the <code>operator+</code> and
<code>operator&lt;&lt;</code> functions are themselves templates. There are several ways to do this; one simple approach is pre-declare
each template friend function <em>above</em> the definition of template class <code>Foo</code>:</p>

<pre><code>template&lt;typename T&gt; class Foo;  // pre-declare the template class itself
template&lt;typename T&gt; Foo&lt;T&gt; operator+ (const Foo&lt;T&gt;&amp; lhs, const Foo&lt;T&gt;&amp; rhs);
template&lt;typename T&gt; std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Foo&lt;T&gt;&amp; x);
</code></pre>

<p>Also you add <code>&lt;&gt;</code> in the <code>friend</code> lines, as shown:</p>

<pre><code>#include &lt;iostream&gt;

template&lt;typename T&gt;
class Foo {
public:
  Foo(const T&amp; value = T());
  friend Foo&lt;T&gt; operator+ &lt;&gt; (const Foo&lt;T&gt;&amp; lhs, const Foo&lt;T&gt;&amp; rhs);
  friend std::ostream&amp; operator&lt;&lt; &lt;&gt; (std::ostream&amp; o, const Foo&lt;T&gt;&amp; x);
private:
  T value_;
};
</code></pre>

<p>After the compiler sees that magic stuff, it will be better informed about the <code>friend</code> functions. In particular, it
will realize that the <code>friend</code> lines are referring to functions that are themselves templates. That eliminates the
confusion.</p>

<p>Another approach is to <em>define</em> the <code>friend</code> function within the class body at the same moment you declare it to be a
<code>friend</code>. For example:</p>

<pre><code>#include &lt;iostream&gt;

template&lt;typename T&gt;
class Foo {
public:
  Foo(const T&amp; value = T());

  friend Foo&lt;T&gt; operator+ (const Foo&lt;T&gt;&amp; lhs, const Foo&lt;T&gt;&amp; rhs)
  {
    // ...
  }

  friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Foo&lt;T&gt;&amp; x)
  {
    // ...
  }

private:
  T value_;
};
</code></pre>

<h3 id="constraints">Why can&#8217;t I define constraints for my template parameters?</h3>

<p>(Note: This FAQ is a bit dated and needs to be updated for <code>static_assert</code>.)</p>

<p>Well, you can, and it&#8217;s quite easy and general.</p>

<p>Consider:</p>

<pre><code>        template&lt;class Container&gt;
        void draw_all(Container&amp; c)
        {
                for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));
        }
</code></pre>

<p>If there is a type error, it will be in the resolution of the fairly complicated <code>for_each()</code> call. For example, if the element type of the container is an <code>int</code>, then we get some kind of obscure error related to the <code>for_each()</code> call (because we can&#8217;t invoke <code>Shape::draw()</code> for an <code>int</code>).</p>

<p>To catch such errors early, you can write:</p>

<pre><code>        template&lt;class Container&gt;
        void draw_all(Container&amp; c)
        {
                Shape* p = c.front(); // accept only containers of Shape*s

                for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));
        }
</code></pre>

<p>The initialization of the spurious variable <code>p</code> will trigger a comprehensible error message from most current compilers. Tricks like this are common in all languages and have to be developed for all novel constructs. In production code, you&#8217;d probably write something like:</p>

<pre><code>    template&lt;class Container&gt;
        void draw_all(Container&amp; c)
        {
                typedef typename Container::value_type T;
                Can_copy&lt;T,Shape*&gt;(); // accept containers of only Shape*s

                for_each(c.begin(),c.end(),mem_fun(&amp;Shape::draw));
        }
</code></pre>

<p>This makes it clear that you&#8217;re making an assertion. The <code>Can_copy</code> template can be defined like this:</p>

<pre><code>    template&lt;class T1, class T2&gt; struct Can_copy {
        static void constraints(T1 a, T2 b) { T2 c = a; b = a; }
        Can_copy() { void(*p)(T1,T2) = constraints; }
    };
</code></pre>

<p><code>Can_copy</code> checks (at compile time) that a <code>T1</code> can be assigned to a <code>T2</code>. <code>Can_copy&lt;T,Shape*&gt;</code> checks that <code>T</code> is a <code>Shape*</code> or a pointer to a class publicly derived from <code>Shape</code> or a type with a user-defined conversion to <code>Shape*</code>. Note that the definition is close to minimal:</p>

<ul>
<li>one line to name the constraints to be checked and the types for which to check them</li>
<li>one line to list the specific constraints checked (the <code>constraints()</code> function)</li>
<li>one line to provide a way to trigger the check (the constructor)</li>
</ul>

<p>Note also that the definition has the desirable properties that</p>

<ul>
<li>You can express constraints without declaring or copying variables, thus the writer of a constraint doesn&#8217;t have to make assumptions about how a type is initialized, whether objects can be copied, destroyed, etc. (unless, of course, those are the properties being tested by the constraint)</li>
<li>No code is generated for a constraint using current compilers</li>
<li>No macros are needed to define or use constraints</li>
</ul>

<p>Current compilers give acceptable error messages for a failed constraint, including the word &#8220;constraints&#8221; (to give the reader a clue), the name of the constraints, and the specific error that caused the failure (e.g. &#8220;cannot initialize <code>Shape*</code> by <code>double*</code>&#8221;)</p>

<p>So why is something like <code>Can_copy()</code> &#8211; or something even more elegant &#8211; not in the language? A way to specify these constraints directly is being worked on as we speak &#8211; see <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3580.pdf">Concepts Lite</a>.</p>

<p>Until then, the above the idea is very general. After all, when we write a template we have the full expressive power of C++ available. Consider:</p>

<pre><code>    template&lt;class T, class B&gt; struct Derived_from {
        static void constraints(T* p) { B* pb = p; }
        Derived_from() { void(*p)(T*) = constraints; }
    };

    template&lt;class T1, class T2&gt; struct Can_copy {
        static void constraints(T1 a, T2 b) { T2 c = a; b = a; }
        Can_copy() { void(*p)(T1,T2) = constraints; }
    };

    template&lt;class T1, class T2 = T1&gt; struct Can_compare {
        static void constraints(T1 a, T2 b) { a==b; a!=b; a&lt;b; }
        Can_compare() { void(*p)(T1,T2) = constraints; }
    };

    template&lt;class T1, class T2, class T3 = T1&gt; struct Can_multiply {
        static void constraints(T1 a, T2 b, T3 c) { c = a*b; }
        Can_multiply() { void(*p)(T1,T2,T3) = constraints; }
    };

    struct B { };
    struct D : B { };
    struct DD : D { };
    struct X { };

    int main()
    {
        Derived_from&lt;D,B&gt;();
        Derived_from&lt;DD,B&gt;();
        Derived_from&lt;X,B&gt;();
        Derived_from&lt;int,B&gt;();
        Derived_from&lt;X,int&gt;();

        Can_compare&lt;int,float&gt;();
        Can_compare&lt;X,B&gt;();
        Can_multiply&lt;int,float&gt;();
        Can_multiply&lt;int,float,double&gt;();
        Can_multiply&lt;B,X&gt;();

        Can_copy&lt;D*,B*&gt;();
        Can_copy&lt;D,B*&gt;();
        Can_copy&lt;int,B*&gt;();
    }

    // the classical "elements must derived from Mybase*" constraint:

    template&lt;class T&gt; class Container : Derived_from&lt;T,Mybase&gt; {
        // ...
    };
</code></pre>

<p>Actually, <code>Derived_from</code> doesn&#8217;t check derivation, but conversion, but that&#8217;s often a better constraint. Finding good names for constraints can be hard.</p>

<h3 id="template-error-msgs">How can any human hope to understand these overly verbose template-based error messages?</h3>

<p>Here&#8217;s a free tool that <a href="http://www.bdsoft.com/tools/stlfilt.html">transforms error messages into something more
understandable</a>. At the time of this writing, it works with the following
compilers: Comeau C++, Intel C++, CodeWarrior C++, gcc, Borland C++, Microsoft Visual C++, and EDG C++.</p>

<p>Here&#8217;s an example showing some unfiltered gcc error messages:</p>

<pre><code>rtmap.cpp: In function `int main()':
rtmap.cpp:19: invalid conversion from `int' to `
   std::_Rb_tree_node&lt;std::pair&lt;const int, double&gt; &gt;*'
rtmap.cpp:19:   initializing argument 1 of `std::_Rb_tree_iterator&lt;_Val, _Ref,
   _Ptr&gt;::_Rb_tree_iterator(std::_Rb_tree_node&lt;_Val&gt;*) [with _Val =
   std::pair&lt;const int, double&gt;, _Ref = std::pair&lt;const int, double&gt;&amp;, _Ptr =
   std::pair&lt;const int, double&gt;*]'
rtmap.cpp:20: invalid conversion from `int' to `
   std::_Rb_tree_node&lt;std::pair&lt;const int, double&gt; &gt;*'
rtmap.cpp:20:   initializing argument 1 of `std::_Rb_tree_iterator&lt;_Val, _Ref,
   _Ptr&gt;::_Rb_tree_iterator(std::_Rb_tree_node&lt;_Val&gt;*) [with _Val =
   std::pair&lt;const int, double&gt;, _Ref = std::pair&lt;const int, double&gt;&amp;, _Ptr =
   std::pair&lt;const int, double&gt;*]'
E:/GCC3/include/c++/3.2/bits/stl_tree.h: In member function `void
   std::_Rb_tree&lt;_Key, _Val, _KeyOfValue, _Compare, _Alloc&gt;::insert_unique(_II,
    _II) [with _InputIterator = int, _Key = int, _Val = std::pair&lt;const int,
   double&gt;, _KeyOfValue = std::_Select1st&lt;std::pair&lt;const int, double&gt; &gt;,
   _Compare = std::less&lt;int&gt;, _Alloc = std::allocator&lt;std::pair&lt;const int,
   double&gt; &gt;]':
E:/GCC3/include/c++/3.2/bits/stl_map.h:272:   instantiated from `void std::map&lt;_
Key, _Tp, _Compare, _Alloc&gt;::insert(_InputIterator, _InputIterator) [with _Input
Iterator = int, _Key = int, _Tp = double, _Compare = std::less&lt;int&gt;, _Alloc = st
d::allocator&lt;std::pair&lt;const int, double&gt; &gt;]'
rtmap.cpp:21:   instantiated from here
E:/GCC3/include/c++/3.2/bits/stl_tree.h:1161: invalid type argument of `unary *
   '
</code></pre>

<p>Here&#8217;s what the filtered error messages look like (note: you can configure the tool so it shows more information; this
output was generated with settings to strip things down to a minimum):</p>

<pre><code>rtmap.cpp: In function `int main()':
rtmap.cpp:19: invalid conversion from `int' to `iter'
rtmap.cpp:19:   initializing argument 1 of `iter(iter)'
rtmap.cpp:20: invalid conversion from `int' to `iter'
rtmap.cpp:20:   initializing argument 1 of `iter(iter)'
stl_tree.h: In member function `void map&lt;int,double&gt;::insert_unique(_II, _II)':
    [STL Decryptor: Suppressed 1 more STL standard header message]
rtmap.cpp:21:   instantiated from here
stl_tree.h:1161: invalid type argument of `unary *'
</code></pre>

<p>Here is the source code to generate the above example:</p>

<pre><code>#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

const int values[] = { 1,2,3,4,5 };
const int NVALS = sizeof values / sizeof (int);

int main()
{
    using namespace std;

    typedef map&lt;int, double&gt; valmap;

    valmap m;

    for (int i = 0; i &lt; NVALS; i++)
        m.insert(make_pair(values[i], pow(values[i], .5)));

    valmap::iterator it = 100;              // error
    valmap::iterator it2(100);              // error
    m.insert(1,2);                          // error

    return 0;
}
</code></pre>

<h3 id="nondependent-name-lookup-types">Why am I getting errors when my template-derived-class uses a nested type it inherits from its template-base-class?</h3>

<p>Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:</p>

<pre><code>template&lt;typename T&gt;
class B {
public:
  class Xyz { /*...*/ };  // Type nested in class B&lt;T&gt;
  typedef int Pqr;        // Type nested in class B&lt;T&gt;
};

template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
  void g()
  {
    Xyz x;  // Bad (even though some compilers erroneously (temporarily?) accept it)
    Pqr y;  // Bad (even though some compilers erroneously (temporarily?) accept it)
  }
};
</code></pre>

<p>This might hurt your head; better if you sit down.</p>

<p>Within <code>D&lt;T&gt;::g()</code>, name <code>Xyz</code> and <code>Pqr</code> do not depend on template parameter <code>T</code>, so they are known as a <em>nondependent
names</em>. On the other hand, <code>B&lt;T&gt;</code> is dependent on template parameter <code>T</code> so <code>B&lt;T&gt;</code> is called a <em>dependent name</em>.</p>

<p>Here&#8217;s the rule: the compiler does not look in dependent base classes (like <code>B&lt;T&gt;</code>) when looking up nondependent names
(like <code>Xyz</code> or <code>Pqr</code>). As a result, the compiler does not know they even exist let alone are types.</p>

<p>At this point, programmers sometimes prefix them with <code>B&lt;T&gt;::</code>, such as:</p>

<pre><code>template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
  void g()
  {
    B&lt;T&gt;::Xyz x;  // Bad (even though some compilers erroneously (temporarily?) accept it)
    B&lt;T&gt;::Pqr y;  // Bad (even though some compilers erroneously (temporarily?) accept it)
  }
};
</code></pre>

<p>Unfortunately this doesn&#8217;t work either because those names (are you ready? are you sitting down?) are not necessarily
types. &#8220;Huh?!?&#8221; you say. &#8220;Not types?!?&#8221; you exclaim. &#8220;That&#8217;s crazy; any fool can <em>SEE</em> they are types; just look!!!&#8221; you
protest. Sorry, the fact is that they might not be types. The reason is that there can be a specialization of <code>B&lt;T&gt;</code>,
say <code>B&lt;Foo&gt;</code>, where <code>B&lt;Foo&gt;::Xyz</code> is a data member, for example. Because of this potential specialization, the compiler
cannot assume that <code>B&lt;T&gt;::Xyz</code> is a type until it knows <code>T</code>. The solution is to give the compiler a hint via the
<code>typename</code> keyword:</p>

<pre><code>template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
  void g()
  {
    typename B&lt;T&gt;::Xyz x;  // Good
    typename B&lt;T&gt;::Pqr y;  // Good
  }
};
</code></pre>

<h3 id="nondependent-name-lookup-members">Why am I getting errors when my template-derived-class uses a member it inherits from its template-base-class?</h3>

<p>Perhaps surprisingly, the following code is not valid C++, even though some compilers accept it:</p>

<pre><code>template&lt;typename T&gt;
class B {
public:
  void f() { }  // Member of class B&lt;T&gt;
};

template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
  void g()
  {
    f();  // Bad (even though some compilers erroneously (temporarily?) accept it)
  }
};
</code></pre>

<p>This might hurt your head; better if you sit down.</p>

<p>Within <code>D&lt;T&gt;::g()</code>, the name <code>f</code> does not depend on template parameter <code>T</code>, so <code>f</code> is known as a <em>nondependent name</em>. On
the other hand, <code>B&lt;T&gt;</code> is dependent on template parameter <code>T</code> so <code>B&lt;T&gt;</code> is called a <em>dependent name</em>.</p>

<p>Here&#8217;s the rule: the compiler does not look in dependent base classes (like <code>B&lt;T&gt;</code>) when looking up nondependent names
(like <code>f</code>).</p>

<p>This doesn&#8217;t mean that inheritance doesn&#8217;t work. Class <code>D&lt;int&gt;</code> is still derived from class <code>B&lt;int&gt;</code>, the compiler still
lets you implicitly do the is-a conversions (e.g., <code>D&lt;int&gt;*</code> to <code>B&lt;int&gt;*</code>), dynamic binding still works when virtual
functions are invoked, etc. But there is an issue about how names are looked up.</p>

<p>Workarounds:</p>

<ul>
<li>Change the call from <code>f()</code> to <code>this-&gt;f()</code>. Since <code>this</code> is always implicitly dependent in a template, <code>this-&gt;f</code> is
dependent and the lookup is therefore deferred until the template is actually instantiated, at which point all base
classes are considered.</li>
<li>Insert <code>using B&lt;T&gt;::f;</code> just prior to calling <code>f()</code>.</li>
<li>Change the call from <code>f()</code> to <code>B&lt;T&gt;::f()</code>. Note however that this might not give you what you want if <code>f()</code> is
virtual, since it inhibits the virtual dispatch mechanism.</li>
</ul>

<h3 id="nondependent-name-lookup-silent-bug">Can the previous problem hurt me silently? Is it possible that the compiler will silently generate the wrong code?</h3>

<p>Yes.</p>

<p>Since <a href="templates.html#nondependent-name-lookup-types" title="FAQ: Why am I getting errors when my template-derived-class uses a nested type it inherits from its template-base-class?">non-dependent types</a> and <a href="templates.html#nondependent-name-lookup-members" title="FAQ: Why am I getting errors when my template-derived-class uses a member it inherits from its template-base-class?">non-dependent
members</a> are not found in the dependent template base-classes, the compiler will
search the enclosing scope, such as the enclosing namespace. This can cause it to silently(!) do the wrong thing.</p>

<p>For example:</p>

<pre><code>class Xyz { /*...*/ };  // Global ("namespace scope") type
void f() { }            // Global ("namespace scope") function

template&lt;typename T&gt;
class B {
public:
  class Xyz { /*...*/ };  // Type nested in class B&lt;T&gt;
  void f() { }            // Member of class B&lt;T&gt;
};

template&lt;typename T&gt;
class D : public B&lt;T&gt; {
public:
  void g()
  {
    Xyz x;  // Suprise: you get the global Xyz!!
    f();    // Suprise: you get the global f!!
  }
};
</code></pre>

<p>The use of <code>Xyz</code> and <code>f</code> within <code>D&lt;T&gt;::g()</code> will silently(!) resolve to the global entities rather than those inherited
from class <code>B&lt;T&gt;</code>.</p>

<p>You have been warned.</p>

<h3 id="template-of-template">How can I create a container-template that allows my users to supply the type of the underlying container that actually stores the values?</h3>

<p>First, let&#8217;s clarify the question: the goal is to create a template <code>Foo&lt;&gt;</code>, but having the template parameter-list
include some particular type of <code>std::vector&lt;T&gt;</code> or <code>std::list&lt;T&gt;</code> or some other (possibly non-standard) container to
actually store the values.</p>

<p>Here&#8217;s one way to do that:</p>

<pre><code>template&lt;typename Underlying&gt;
class Foo {
public:
  // typename value_type is the type of the values within a Foo-container
  typedef typename Underlying::value_type  value_type;

  void insert(const typename value_type&amp; x)
  {
    // ...code to insert x into data_...
  }

  // ...
private:
  Underlying data_;
};

Foo&lt;std::vector&lt;int&gt; &gt; x;
Foo&lt;std::list&lt;double&gt; &gt; y;
</code></pre>

<p>If you want to allow your users to provide you with an underlying container that does not necessarily have a
<code>value_type</code> typedef (such as some container from a third party), you could provide the value-type explicitly:</p>

<pre><code>template&lt;typename T, typename Underlying&gt;
class Foo {
public:
  // typename value_type is the type of the values within a Foo-container
  typedef T  value_type;

  void insert(const typename value_type&amp; x)
  {
    // ...code to insert x into data_...
  }

  // ...

private:
  Underlying data_;
};

Foo&lt;int, std::vector&lt;int&gt; &gt; x;
Foo&lt;double, std::list&lt;double&gt; &gt; y;
</code></pre>

<p>However you cannot (yet) provide an unspecified template as a template parameter, such as this:</p>

<pre><code>template&lt;typename T, template&lt;typename&gt; class Underlying&gt;  // Conceptual only; not C++
class Foo {
public:
  // ...
private:
  Underlying&lt;T&gt; data_;     // Conceptual only; not C++
};

Foo&lt;int, std::vector&gt; x;   // Conceptual only; not C++
Foo&lt;double, std::list&gt; y;  // Conceptual only; not C++
</code></pre>

<h3 id="template-proxies">Follow-up to previous: can I pass in the underlying structure and the element-type separately?</h3>

<p>Yes, with a &#8220;proxy&#8221; trick.</p>

<p>Here&#8217;s the problem: <code>std::vector</code> template can have, does have, more than one argument. You&#8217;re required to make them
match in the number, order, and nature &#8212; type/non-type, etc.</p>

<p>It is possible, however, to &#8220;cheat&#8221; your way out of specifying all those arguments and use the defaults. It&#8217;s called the
&#8220;proxy template&#8221; technique:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;list&gt;

template&lt;typename T&gt;
struct wrap_vector {
  typedef std::vector&lt;T&gt; type;
};

template&lt;typename T&gt;
struct wrap_list {
  typedef std::list&lt;T&gt; type;
};

template&lt;typename T, template&lt;typename&gt; class C&gt;
struct A {
  typename C&lt;T&gt;::type data;  // trick to use a proxy
};

int main()
{
  A&lt;int,wrap_vector&gt; avi;
  A&lt;double,wrap_list&gt; adl;
  // ...
}
</code></pre>

<p>You can also create a proxy if you actually have a template that takes only one argument:</p>

<pre><code>template&lt;typename T&gt;
struct wrap_my1argtemplate {
  typedef my1argtemplate&lt;T&gt; type;
};
</code></pre>

<p>The &#8220;template typedefs&#8221; proposal will allow redefining templates just like we do with types, which will make the
proxy-trick unnecessary. Until then, use something like the above.</p>

<h3 id="template-proxies-and-runtime-performance">Related: all those proxies must negatively reflect on the speed of my program. Don&#8217;t they?</h3>

<p>No.</p>

<p>They might require an extra microsecond to compile, but once all the types are resolved by the compiler, the resulting
code is just as fast as if you used them directly without any proxy templates whatsoever.</p>

<p>Not only that, there are some techniques (template meta programming or TMP) that can, under the right circumstances,
improve the efficiency of the generated code. The basic notion is to get the compiler to do more work at compile-time
so less work has to be done at runtime.</p>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance  Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance  virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance  Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance  Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance  What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance  private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance  Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/templates",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/templates",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/templates by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
</html>
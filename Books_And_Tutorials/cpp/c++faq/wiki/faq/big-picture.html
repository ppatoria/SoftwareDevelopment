<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/big-picture by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="30d4027bd626bd211ee1182143e0bf9cde47b3fc" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="2808e8e879de839648c99657e665eedef200f2b6" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="3eb565f6416b3198b3fa13b95cff6eddae2297c6" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        big picture
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="big-picture.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    big picture
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=big%20picture" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="big-picture">Big Picture Issues</h2>

<h3 id="what-is-cpp">What is C++?</h3>

<p>C++ is a general-purpose programming language with a bias towards systems programming that</p>

<ul>
<li>is <a href="c.html#c-diffs" title="FAQ: What's the difference between C++ and C?">a better C</a></li>
<li>supports <a href="big-picture.html#why-classes" title="FAQ: What's so great about classes?">data abstraction</a> (e.g., classes)</li>
<li>supports <a href="big-picture.html#why-use-oo" title="FAQ: What's the big deal with OO?">object-oriented programming</a> (e.g., inheritance)</li>
<li>supports <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">generic programming</a> (e.g., reusable generic containers and algorithms)</li>
<li>supports functional programming (e.g., template metaprogramming, lambda functions, <code>constexpr</code>)</li>
</ul>

<p>It is defined by <a href="big-picture.html#standardization" title="FAQ: Is C++ standardized?">an ISO standard</a>, offers stability over decades, and has a large and lively user community. See also <a href="http://stroustrup.com/4th.html">The C++ Programming Language</a> and <a href="http://stroustrup.com/hopl-almost-final.pdf">Evolving a language in and for the real world: C++ 1991-2006</a>.</p>

<p>See also <a href="big-picture.html#when-invented" title="FAQ: When was C++ invented?">when</a> and <a href="big-picture.html#why-invented" title="FAQ: Why was C++ invented?">why</a> C++ was invented.</p>

<h3 id="practical-language">Is C++ a practical language?</h3>

<p>Yes.</p>

<p>C++ is a practical tool. <a href="big-picture.html#imperfect-language" title="FAQ: Is C++ a perfect language?">It&#8217;s not perfect</a>, but it&#8217;s useful.</p>

<p>In the world of industrial software, C++ is viewed as a solid, mature, mainstream tool. It has widespread industry
support which makes it &#8220;good&#8221; from an <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">overall business perspective</a>.</p>

<h3 id="imperfect-language">Is C++ a perfect language?</h3>

<p>Nope.</p>

<p>C++ wasn&#8217;t designed to demonstrate what a perfect language looks like. It was designed to be a practical tool for
solving real world problems. It has a few warts, as do all practical programming tools, but the only place where it&#8217;s
appropriate to keep fiddling with something until it&#8217;s perfect is in a pure academic setting. That wasn&#8217;t C++&#8217;s goal.</p>

<h3 id="why-classes">What&#8217;s so great about classes?</h3>

<p>Classes are there to help you organize your code and to reason about your programs. You could roughly equivalently say that classes are there to help you avoid making mistakes and to help you find bugs after you do make a mistake. In this way, classes significantly help maintenance.</p>

<p>A class is the representation of an idea, a concept, in the code. An object of a class represents a particular example of the idea in the code. Without classes, a reader of the code would have to guess about the relationships among data items and functions &#8211; classes make such relationships explicit and &#8220;understood&#8221; by compilers. With classes, more of the high-level structure of your program is reflected in the code, not just in the comments.</p>

<p>A well-designed class presents a clean and simple interface to its users, hiding its representation and saving its users from having to know about that representation. If the representation shouldn&#8217;t be hidden &#8211; say, because users should be able to change any data member any way they like &#8211; you can think of that class as &#8220;just a plain old data structure&#8221;; for example:</p>

<pre><code>struct Pair {
    Pair(const string&amp; n, const string&amp; v) : name(n), value(v) { }
    string name, value;
};
</code></pre>

<p>Note that even data structures can benefit from auxiliary functions, such as constructors. 
When designing a class, it is often useful to consider what&#8217;s true for every object of the class and at all times. Such a property is called an invariant. For example, the invariant of a <code>vector</code> could be that (a) its representation consists of a pointer to a number of elements and (b) that number of elements is stored in an integer. It is the job of every constructor to establish the class invariant, so that every member function can rely on it. Every member function must leave the invariant valid upon exit. This kind of thinking is particularly useful for classes that manage resources such as locks, sockets, and files. For example, a file handle class will have the invariant that it holds a pointer to an open file. The file handle constructor opens the file. Destructors free resources acquired by constructors. For example, the destructor for a file handle closes the file opened by the constructor:</p>

<pre><code>class File_handle {
public:
    File_handle(const char* n, const char* rw)
        { f = fopen(n,rw); if (f==nullptr) throw Open_failure(n); }
    ~File_handle() { fclose(f); } // destructor
    // ...
private:
    FILE* f;
};
</code></pre>

<p>If you haven&#8217;t programmed with classes, you will find parts of this explanation obscure and you&#8217;ll underestimate the usefulness of classes. Look for examples. Like all good textbooks, <a href="http://www.stroustrup.com/4th.html">TC++PL</a> has lots of examples; for example, see <a href="http://www.stroustrup.com/tour2.pdf">A Tour of the Standard Library</a>. Most modern C++ libraries consist (among other things) of classes and a library tutorial is one of the best places to look for examples of useful classes.</p>

<h3 id="why-use-oo">What&#8217;s the big deal with OO?</h3>

<p>Object-oriented techniques using classes and virtual functions are an important way to develop large, complex software applications and systems. So are <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">generic programming techniques using templates</a>. Both are important ways to express polymorphism &#8211; at run time and at compile time, respectively. And they work great together in C++.</p>

<p>There are lots of definitions of &#8220;object oriented&#8221;, &#8220;object-oriented programming&#8221;, and &#8220;object-oriented programming languages&#8221;. For a longish explanation of what Stroustrup thinks of as &#8220;object oriented&#8221;, read <a href="http://www.stroustrup.com/oopsla.pdf">Why C++ isn&#8217;t just an object-oriented programming language</a>. That said, object-oriented programming is a style of programming originating with Simula (about 40 years ago!) relying on encapsulation, inheritance, and polymorphism. In the context of C++ (and of many other languages with their roots in Simula), it means programming using class hierarchies and virtual functions to allow manipulation of objects of a variety of types through well-defined interfaces and to allow a program to be extended incrementally through derivation.</p>

<p>See <a href="big-picture.html#why-classes" title="FAQ: What's so great about classes?">whats so great about classes</a> for an idea about what&#8217;s great about &#8220;plain classes&#8221;. The point about arranging classes into a class hierarchy is to express hierarchical relationships among classes and to use those relationships to simplify code.</p>

<p>To really understand OOP, look for some examples. For example, you might have two (or more) device drivers with a common interface:</p>

<pre><code>class Driver {  // common driver interface
public:
    virtual int read(char* p, int n) = 0; // read max n characters from device to p
                                          // return the number of characters read
    virtual bool reset() = 0;             // reset device
    virtual Status check() = 0;           // read status
};
</code></pre>

<p>This <code>Driver</code> is simply an interface. It is defined with no data members and a set of pure virtual functions. A <code>Driver</code> can be used through this interface and many different kinds of drivers can implement this interface:</p>

<pre><code>class Driver1 : public Driver { // a driver
public:
    Driver1(Register);          // constructor
    int read(char*, int n) override;    
    bool reset() override;
    Status check() override;
private:
    // implementation details, including representation
};

class Driver2 : public Driver { // another driver
public:
    Driver2(Register);
    int read(char*, int n) override;    
    bool reset() override;
    Status check() override;
private:
    // implementation details, including representation
};
</code></pre>

<p>Note that these drivers hold data (state) and objects of them can be created. They implement the functions defined in <code>Driver</code>. We can imagine a driver being used like this:</p>

<pre><code>void f(Driver&amp; d)               // use driver
{
    Status old_status = d.check();  
    // ...
    d.reset();
    char buf[512];
    int x = d.read(buf,512);
    // ...
}
</code></pre>

<p>The key point here is that <code>f()</code> doesn&#8217;t need to know which kind of driver it uses; all it needs to know is that it is passed a <code>Driver</code>; that is, an interface to many different kinds of drivers. We could invoke <code>f()</code> like this:</p>

<pre><code>void g()
{
    Driver1 d1(Register(0xf00));  // create a Driver1 for device
                                  // with device register at address 0xf00

    Driver2 d2(Register(0xa00));  // create a Driver2 for device
                                  // with device register at address 0xa00
    // ...
    int dev;
    cin &gt;&gt; dev;

    if (dev==1) 
        f(d1);  // use d1
    else
        f(d2);  // use d2
    // ...
}
</code></pre>

<p>Note that when <code>f()</code> uses a <code>Driver</code> the right kind of operations are implicitly chosen at run time. For example, when <code>f()</code> is passed <code>d1</code>, <code>d.read()</code> uses <code>Driver1::read()</code>, whereas when <code>f()</code> is passed <code>d2</code>, <code>d.read()</code> uses <code>Driver2::read()</code>. This is sometimes called run-time dispatch or dynamic dispatch. In this case there is no way that <code>f()</code> could know the kind of device it is called with because we choose it based on an input.</p>

<p>Please note that object-oriented programming is not a panacea. &#8220;OOP&#8221; does not simply mean &#8220;good&#8221; &#8211; if there are no inherent hierarchical relationships among the fundamental concepts in your problem then no amount of hierarchy and virtual functions will improve your code. The strength of OOP is that there are many problems that can be usefully expressed using class hierarchies &#8211; the main weakness of OOP is that too many people try to force too many problems into a hierarchical mold. Not every program should be object-oriented. As alternatives, consider <a href="big-picture.html#why-classes" title="FAQ: What's so great about classes?">plain classes</a>, <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">generic programming</a>, and free-standing functions (as in math, C, and Fortran).</p>

<p>If you&#8217;re still wondering &#8220;why OO?&#8221;, consider also business reasons:</p>

<p>The software industry is succeeding at automating many of life&#8217;s functions that used to be manual. In addition, software is
improving the flexibility of devices that were previously automated, for example, transforming the internal
implementation of many previously existing devices from mechanical to software (clocks, automobile ignition systems,
etc.) or from being controlled by electrical circuitry to software (TVs, kitchen appliances, etc.). And, of course,
software is integrated into every aspect of our daily business lives &#8212; originally software was limited to Accounting
and Finance, but it is now embedded in Operations, Marketing, Sales, and Management &#8212; software is nearly everywhere.</p>

<p>This incredible success has constantly stressed the ability of the software development organizations to keep up. As an
industry, software development has continuously failed to meet the demands for large, complex software systems. Yes,
this failure is actually due to the success of software&#8217;s ability to bring perceived value &#8212; it is actually caused
because demand is greater than our ability to satisfy that demand. And while it is possible for us software people to
sit around and pat ourselves on the back for that demand, innovators and thought leaders in this and every other
discipline are marked by one undeniable characteristic: they/we are not satisfied. As an industry, we must do better. A
<em>lot</em> better. Uber better.</p>

<p>Our past successes have propelled users to ask for more. We created a market hunger that Structured Analysis, Design and
Programming techniques have not been able to satisfy. This required us to create a better paradigm. Several, in fact.</p>

<p>C++ supports OO programming. C++ can also be used as a traditional, imperative programming language (&#8220;as a better
C&#8221;) or using the <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">generic programming approach</a>. Naturally each of these approaches has its pros and
cons; don&#8217;t expect the benefits of one technique while using another. (Most common case of misunderstanding: don&#8217;t
expect to get the benefits of object-oriented programming if you&#8217;re using C++ as a better C.)</p>

<p>C++ also supports <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">the generic programming approach</a>. And most recently C++ is starting to support
(as opposed to merely allow) the functional programming approach. The best programmers are able to decide which approach
fits best in which situation, rather than trying to shove a single approach (&#8220;my favorite approach&#8221;) at every problem
everywhere in every industry irrespective of the business context or the sponsor&#8217;s goals.</p>

<p>Most importantly, sometimes the best solution is achieved by using a combination of features from Object-Oriented, Generic and Functional programming styles, whereas trying to restrict oneself to one particular approach may lead to a suboptimal solution.</p>

<h3 id="generic-paradigm">What&#8217;s the big deal with generic programming?</h3>

<p>Generic programming techniques using templates are an important way to develop large, complex software applications and systems. So are <a href="big-picture.html#why-use-oo" title="FAQ: What's the big deal with OO?">object oriented techniques</a>. Both are important ways to express polymorphism &#8211; at compile time and at run time, respectively. And they work great together in C++.</p>

<p>C++ supports generic programming. Generic programming is a way of developing software that maximizes code reuse in a
way that does not sacrifice performance. (The &#8220;performance&#8221; part isn&#8217;t strictly necessary, but it is highly desirable.)</p>

<p>Generic programming is programming based on parameterization: You can parameterize a type with another (such as a <code>vector</code> with its element types) and an algorithm with another (such as a sort function with a comparison function). The aim of generic programming is to generalize a useful algorithm or data structure to its most general and useful form. For example, a <code>vector</code> of integers is fine and so is a function that finds the largest value in a <code>vector</code> of integers. However, a better generic find function will be able to find an element in a <code>vector</code> of any type or better still in any sequence of elements described with a pair of iterators:</p>

<pre><code>auto p = find(begin(vs), end(vs), "Grail"s); // vector&lt;string&gt; vs; p is vector&lt;string&gt;::iterator 

auto q = find(begin(vi), end(vi), 42);       // vector&lt;int&gt; vi;    q is vector&lt;int&gt;::iterator 

auto r = find(begin(ld), end(ld), 1.2);      // list&lt;double&gt; ld;   r is list&lt;double&gt;::iterator 

auto s = find(begin(ar), end(ar), 10);       // int ar[10];        s is int *
</code></pre>

<p>These examples are from the STL (the containers and algorithms part of the ISO C++ standard library); for a brief introduction, see <a href="http://www.stroustrup.com/tour2.pdf">A Tour of the Standard Library</a> from <a href="http://www.stroustrup.com/3rd.html">TC++PL</a>.</p>

<p>Generic programming is in some ways more flexible than object-oriented programming. In particular, it does not depend on hierarchies. For example, there is no hierarchical relationship between an <code>int</code> and a <code>string</code>. Generic programming is generally more structured than OOP; in fact, a common term used to describe generic programming is &#8220;parametric polymorphism&#8221;, with &#8220;ad hoc polymorphism&#8221; being the corresponding term for object-oriented programming. In the context of C++, generic programming resolves all names at compile time; it does not involve dynamic (run-time) dispatch. This has led generic programming to become dominant in areas where run-time performance is important.</p>

<p>Please note that generic programming is not a panacea. There are many parts of a program that need no parameterization and many examples where run-time dispatch (OOP) is more approriate.</p>

<p>Generic components are pretty easy to use, at least if they&#8217;re designed well, and they tend to hide a lot of complexity.
The other interesting feature is that they tend to make your code faster, particularly if you use them more. This
creates a pleasant non-tradeoff: when you use the components to do the nasty work for you, your code gets smaller and
simpler, you have less chance of introducing errors, and your code will often run faster.</p>

<p>Most developers are not cut out to create these generic components, but most can use them. Fortunately generic components are, um, generic, so your organization does not often need to create a lot of them. There
are many off-the-shelf libraries of generic components. <a href="class-libraries.html#stl" title="FAQ: What is the 'STL'?">STL</a> is one such library. <a href="http://www.boost.org/">Boost</a>
has a bunch more. <!-- There are many. --></p>

<h3 id="multiparadigm-programming">What is multiparadigm programming?</h3>

<p>In short: The same as just &#8220;programming,&#8221; using different features (notably OO and generic styles) in combination as needed.</p>

<p>Back when having OO and generic programming in the same language was still new, &#8220;multiparadigm programming&#8221; was originally a fancy way of saying &#8220;programming using more than one programming style, each to its best effect.&#8221; For example, using object-oriented programming when run-time resolution between different object types is required and generic programming when static type safety and run-time performance is at a premium. Naturally, the main strength of multiparadigm programming is in programs where more than one paradigm (programming style) is used, so that it would be hard to get the same effect by composing a system out of parts written in languages supporting different paradigms. The most compelling cases for multiparadigm programming are found where techniques from different paradigms are used in close collaboration to write code that is more elegant and more maintainable than would be possible within a single paradigm. A simple example is the traversal of a statically typed container of objects of a polymorphic type:</p>

<pre><code>void draw_all(vector&lt;Shape*&gt;&amp; vs)   // draw each element of a standard vector
{
    for_each(vs.begin(),vs.end(),[](Shape* p){ p-&gt;draw(); });
}
</code></pre>

<p>Here, <code>Shape</code> will be an abstract base class defining the interface to a hierarchy of geometric shapes. This example easily generalizes to any standard library container:</p>

<pre><code>template&lt;class C&gt;
void draw_all(C&amp; cs)    // draw each element of a standard container
{
    for_each(cs.begin(),cs.end(),[](Shape* p){ p-&gt;draw(); });
}
</code></pre>

<p>Is this OOP, GP, functional, or conventional structured programming? All of the above: It&#8217;s a function template (GP) with a procedural body (conventional structured) that uses a generic algorithm (GP again) and a lambda (functional) that takes a pointer to a base class and invokes a virtual function (OO). The key point is that this is all just &#8220;programming.&#8221;</p>

<p>So today instead of &#8220;multiparadigm programming&#8221; we should simply say &#8220;programming.&#8221; It&#8217;s all programming, just using the right language features together in combination as usual.</p>

<h3 id="lang-comparisons">Is C++ better than Java? (or C#, C, Objective-C, JavaScript, Ruby, Perl, PHP, Haskell, FORTRAN, Pascal, Ada, Smalltalk, or any other language?)</h3>

<p>Stop. This question generates much <em>much</em> more heat than light. Please read the following before posting some variant of
this question.</p>

<p>In 99% of the cases, programming language selection is <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">dominated by business considerations</a>, <em>not</em>
by technical considerations. Things that <em>really</em> end up mattering are things like availability of a programming
environment for the development machine, availability of runtime environment(s) for the deployment machine(s),
licensing/legal issues of the runtime and/or development environments, availability of trained developers, availability
of consulting services, and corporate culture/politics. These business considerations generally play a much greater role
than compile time performance, runtime performance, static vs. dynamic typing, static vs. dynamic binding, etc.</p>

<p>Those who ignore the (dominant!) business criteria when evaluating programming language tradeoffs expose themselves to
criticism for having poor judgment. Be technical, but don&#8217;t be a techie weenie. <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">Business issues really do dominate
technical issues</a>, and those who don&#8217;t realize that is destined to make decisions that have terrible
business consequences &#8212; they are dangerous to their employer.</p>

<p>The most widely circulated comparisons tend to be those written by proponents of some language, Z, to prove that Z is better that other languages. Given its wide use, C++ is often top of the list of languages that the proponents of Z wants to prove inferior. Often, such papers are &#8220;published&#8221; or distributed by a company that sells Z as part of a marketing campaign. Surprisingly, many seem to take an unreviewed paper written by people working for a company selling Z &#8220;proving&#8221; that Z is best seriously. One problem is that there are always grains of truth in such comparisons. After all, no language is better than every other in all possible ways. C++ certainly isn&#8217;t perfect, but selective truth can be most seductive and occasionally completely misleading. When looking at a language comparison consider who wrote it, consider carefully if the descriptions are factual and fair, and also if the comparison criteria are themselves fair for all languages considered. This is not easy.</p>

<p>Stroustrup refuses to compare C++ to other languages for these reasons given in <a href="http://stroustrup.com/dne.html">The Design and Evolution of C++</a>:</p>

<blockquote>
  <p>&#8220;Several reviewers asked me to compare C++ to other languages. This I have decided against doing. Thereby, I have reaffirmed a long-standing and strongly held view: Language comparisons are rarely meaningful and even less often fair. A good comparison of major programming languages requires more effort than most people are willing to spend, experience in a wide range of application areas, a rigid maintenance of a detached and impartial point of view, and a sense of fairness. I do not have the time, and as the designer of C++, my impartiality would never be fully credible.</p>
  
  <p>I also worry about a phenomenon I have repeatedly observed in honest attempts at language comparisons. The authors try hard to be impartial, but are hopelessly biased by focusing on a single application, a single style of programming, or a single culture among programmers. Worse, when one language is significantly better known than others, a subtle shift in perspective occurs: Flaws in the well-known language are deemed minor and simple workarounds are presented, whereas similar flaws in other languages are deemed fundamental. Often, the workarounds commonly used in the less-well-known languages are simply unknown to the people doing the comparison or deemed unsatisfactory because they would be unworkable in the more familiar language.</p>
  
  <p>Similarly, information about the well-known language tends to be completely up-to-date, whereas for the less-known language, the authors rely on several-year-old information. For languages that are worth comparing, a comparison of language X as defined three years ago vs. language Y as it appears in the latest experimental implementation is neither fair nor informative. Thus, I restrict my comments about languages other than C++ to generalities and to very specific comments.&#8221;</p>
</blockquote>

<p>That said, C++ is considered to be the best choice in programming language for a wide variety of people and applications.</p>

<h3 id="why-so-big">Why is C++ so big?</h3>

<p>C++ is not a tiny language designed to be a minimal language for teaching, but neither are the languages people most often compare it to, such as C, Java, C#. They too are huge compared to say, Pascal as Dr. Wirth originally defined it &#8211; for good reasons. The programming world is far more complex today than it was 30 years ago, and modern programming languages reflect that.</p>

<p>C++ isn&#8217;t as big as some people imagine. By word count, the size of the <em>language</em> specifications (excluding standard libraries) for C++, C#, and Java are currently within a few percentage points of each other. This reflects that they are general-purpose mainstream languages that have grown similar features &#8211; <code>auto</code>/<code>var</code> type deduction, range <code>for</code> loops, lambda functions, various levels of support for generic programming, and so on. It also reflects what design theorists call &#8220;essential complexity in the problem domain&#8221; &#8211; the complexity in the real world and that a serious language has to expose, everything from fundamental OS differences to calling C++ libraries.</p>

<p>In some cases C++ directly supports (i.e., in the language) what some other languages support through libraries, so the language part will be relatively larger. On the other hand, if you want to write a &#8220;typical modern application&#8221;, you need to consider operating system interfaces, GUI, databases, web interfaces, etc. the sum of language features, libraries, and programming conventions and standards that you must become familiar with dwarf the programming language. Here, C++&#8217;s size can be an advantage as far as it better supports good libraries.</p>

<p>Finally, the days where a novice programmer can know all of a language are gone, at least for the languages in widespread industrial use. Few people know &#8220;all of C&#8221; or &#8220;all of Java&#8221; either and none of those are novices. It follows that nobody should have to apologize for the fact that novices do not know all of C++. What you must do - in any language &#8211; is to pick a subset, get working writing code, and gradually learn more of the language, its libraries, and its tools. For my suggestion on how beginners can approach C++, see <a href="http://stroustrup.com/programming.html">Programming: Principles and Practice using C++</a>.</p>

<h3 id="who-uses-cpp">Who uses C++?</h3>

<p><a href="http://www.stroustrup.com/applications.html">Lots and</a> <a href="http://www.lextrait.com/vincent/implementations.html">lots of</a> companies and government sites. Lots. And if you&#8217;re using a compiler or runtime of another language, such as Java, chances are good that it too is implemented in C++.</p>

<p>There are too many C++ users to effectively count them, but the number is in the millions. C++ is supported by all major vendors. The large number of developers (and therefore the large amount of available support infrastructure including vendors,
tools, training, etc.) is one of several <a href="big-picture.html#overview-cpp" title="FAQ: What are some features of C++ from a business perspective?">critical features of C++</a>.</p>

<p>During 1980-1991, the number of users doubled every seven and a half months (see <a href="http://stroustrup.com/dne.html">The Design and Evolution of C++</a>). The current growth rate is steady and positive. IDC&#8217;s 2001 estimate of the number of C++ programmers was &#8220;about 3 million&#8221;; their 2004 number was &#8220;more than 3 million.&#8221;  That seems plausible and indicates a continued growth. Especially since about 2010 there is a renewed growth in C++ as both mobile and datacenter applications value &#8220;performance per Watt&#8221; as a new mainstream metric.</p>

<h3 id="time-to-learn">How long does it take to learn C++?</h3>

<p>That depends on what you mean by &#8220;learning.&#8221; If you are a C programmer you can learn enough C++ to make you more effective at C-style programming in a day.</p>

<p>The book <a href="http://www.stroustrup.com/programming.html">Programming: Principles and Practice using C++</a> has been used to get thousands of freshmen (1st year students) through the fundamentals of C++ and the programming techniques it supports (notably object-oriented programming and generic programming) in a semester.</p>

<p>On the other hand, if you want to be fully comfortable with all the major C++ language constructs, with data abstraction, Object-Oriented programming, generic programming, Object-Oriented design, etc., you can easily spend a year or two &#8211; if you aren&#8217;t already acquainted with those techniques (say, from Java or C#).</p>

<p>Is that then the time it takes to learn C++? Maybe, but then again, that is the timescale we have to consider to become better designers and programmers. If a dramatic change of the way we work and think about building systems isn&#8217;t our aim, then why bother to learn a new language? Compared to the time required to learn to play the piano well or to become fluent in a foreign (natural) language, learning a new and different programming language and programming style is easy.</p>

<p>For more observations about learning C++ see <a href="http://www.stroustrup.com/dne.html">D&amp;E</a> or <a href="http://www.stroustrup.com/learn.html">a note Bjarne Stroustrup wrote some time ago</a>.</p>

<p>Companies successfully teach standard industry &#8220;short courses,&#8221; where a university semester course is compressed into
one 40 hour work week. But regardless of where you get your training, make sure the courses have a hands-on element,
since most people learn best when they have projects to help the concepts &#8220;gel.&#8221; But even if they have the <em>best</em>
training, they&#8217;re not ready yet.</p>

<p>It takes 6-12 months to become broadly proficient in C++, especially if you haven&#8217;t done OO or generic programming before. It takes less time for developers who have easy access to a &#8220;local&#8221; body of
experts, more if there isn&#8217;t a &#8220;good&#8221; general purpose C++ class library available. To become one of these experts who
can mentor others takes around 3 years.</p>

<p>Some people never make it. You don&#8217;t have a chance unless you are teachable and have personal drive. As a bare minimum
on &#8220;teachability,&#8221; you have to be able to admit when you&#8217;ve been wrong. As a bare minimum on &#8220;drive,&#8221; you must be
willing to put in some extra hours. Remember: it&#8217;s a <em>lot</em> easier to learn some new facts than it is to change your
paradigm, i.e., to change the <em>way</em> you think; to change your notion of goodness; to change your mental models.</p>

<p>Two things you <em>should</em> do:</p>

<ul>
<li>Get your people two books: one <a href="how-to-learn-cpp.html#legality-books" title="FAQ: What are some best-of-breed C++ legality guides?">to tell them what is legal</a>, another <a href="how-to-learn-cpp.html#morality-books" title="FAQ: What are some best-of-breed C++ morality guides?">to tell them what is
moral</a></li>
<li>Consider bringing in <a href="how-to-learn-cpp.html#mentoring" title="FAQ: What is mentoring?">a &#8220;mentor&#8221;</a></li>
</ul>

<p>Two things you <em>should not</em> do:</p>

<ul>
<li><a href="how-to-learn-cpp.html#learning-c-not-a-prereq" title="FAQ: Should I learn C before I learn OO/C++?">You should <em>not</em> bother having your people trained in C as a stepping-stone to learning
OO/C++</a></li>
<li><a href="how-to-learn-cpp.html#learning-objective-c-not-a-prereq" title="FAQ: Should I learn Objective-C before I learn OO/C++?">You should <em>not</em> bother having your people trained in Objective-C as a stepping-stone to learning
OO/C++</a></li>
</ul>

<h3 id="improve-programs">What&#8217;s the best way to improve my C++ programs?</h3>

<p>That depends on how you use it. Most people underestimate abstract classes and templates. Conversely, most people seriously overuse casts and macros. Have a look at one of Stroustrup&#8217;s <a href="http://stroustrup.com/papers.html">papers</a> or <a href="http://stroustrup.com/books.html">books</a> for ideas. One way of thinking of abstract classes and templates is as interfaces that allow a more clean and logical presentation of services than is easy to provide through functions or single-rooted class hierarchies. See other sections of this FAQ for some specific examples and ideas.</p>

<h3 id="which-language">Does it matter which programming language I use?</h3>

<p>Yes, but don&#8217;t expect miracles. Some people seem to believe that a programming language can or at least should solve most of their problems with system building. They are condemned to search forever for the perfect programming language and become repeatedly disappointed. Others dismiss programming languages as unimportant &#8220;implementation details&#8221; and put their money into development processes and design methods. They are condemned to program in COBOL, C, and proprietary design languages forever. A good language &#8211; such as C++ &#8211; can do a lot for a designer and a programmer, as long as its strengths and limitations are clearly understood and respected.</p>

<h3 id="overview-cpp">What are some features of C++ from a business perspective?</h3>

<p>Here are a few features of OO/C++ from a <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">business perspective</a>:</p>

<ul>
<li>C++ has a <a href="big-picture.html#who-uses-cpp" title="FAQ: Who uses C++?">huge installed base</a>, which means you&#8217;ll have <a href="big-picture.html#lang-comparisons" title="FAQ: Is C++ better than Java? (or Visual Basic, C, Objective-C, FORTRAN, Pascal, Ada, Smalltalk, or any other language?)">multi-vendor support for tools,
environments, consulting services, etc.</a>, plus you&#8217;ll have a very valuable line-item on your
resumé</li>
<li>C++ lets developers provide <a href="classes-and-objects.html#good-interfaces" title="FAQ: When is an interface 'good'?">simplified interfaces</a> to software chunks, which improves the
defect-rate when those chunks are (re)used</li>
<li>C++ lets you exploit developer&#8217;s intuition through <a href="operator-overloading.html#op-ov-benefits" title="FAQ: What are the benefits of operator overloading?">operator overloading</a>, which reduces the
learning curve for (re)users</li>
<li>C++ <a href="classes-and-objects.html#encapsulation" title="FAQ: What is encapsulation?">localizes access</a> to a software chunk, which reduces the cost of changes.</li>
<li>C++ reduces the <a href="classes-and-objects.html#safety-vs-usability" title="FAQ: How does C++ help with the tradeoff of safety vs. usability?">safety-<em>vs.</em>-usability tradeoff</a>, which improves the cost of (re)using a
chunk of software.</li>
<li>C++ reduces the <a href="inline-functions.html#safety-vs-speed" title="FAQ: How can inline functions help with the tradeoff of safety vs. speed?">safety-<em>vs.</em>-speed tradeoff</a>, which improves defect rates without degrading
performance.</li>
<li>C++ gives you <a href="big-picture.html#virt-is-central-to-oo" title="FAQ: Are virtual functions (dynamic binding) central to OO/C++?">inheritance and dynamic binding</a> which let <a href="big-picture.html#old-code-can-call-new-code" title="FAQ: I'm from Missouri. Can you give me a simple reason why virtual functions (dynamic binding) make a big difference?">old code call new
code</a>, making it possible to quickly extend/adapt your software to hit narrow market
windows.</li>
</ul>

<h3 id="virt-is-central-to-oo">Are <code>virtual</code> functions (dynamic binding) central to OO/C++?</h3>

<p>Yes and no! OO-style dynamic polymorphism, which you get by calling virtual functions, is one of the two major ways C++ offers to achieve polymorphism, and the one you should use for things that can&#8217;t be known at compile time. The other is generic-programming-style static polymorphism, which you get by using templates, and you should often use for things that <em>are</em> known at compile time. They&#8217;re two great tastes that taste great together.</p>

<p>Without <a href="virtual-functions.html" title="Section: Inheritance — virtual functions">virtual functions</a>, C++ wouldn&#8217;t be object-oriented. <a href="operator-overloading.html" title="Section: Operator Overloading">Operator
overloading</a> and non-<code>virtual</code> member functions are great, but they are, after all, just
syntactic sugar for the more typical C notion of passing a pointer to a <code>struct</code> to a function. The <a href="class-libraries.html#stl" title="FAQ: What is the 'STL'?">standard
library</a> contains numerous templates that illustrate &#8220;generic programming&#8221; techniques, which are also great, but
<code>virtual</code> functions are still at the heart of object-oriented programming using C++.</p>

<p>From a <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">business perspective</a>, there is very little reason to switch from straight C to C++
without <code>virtual</code> functions (for now we&#8217;ll ignore generic programming and <a href="class-libraries.html#stl" title="FAQ: What is the 'STL'?">the standard library</a>). Technical people
often think that there is a large difference between C and non-OO C++, but without OO, the difference usually isn&#8217;t
enough to justify the cost of training developers, new tools, etc. In other words, if I were to advise a manager
regarding whether to switch from C to non-OO C++ (i.e., to switch languages but not paradigms), I&#8217;d probably
discourage him or her unless there were compelling tool-oriented reasons. From a <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">business
perspective</a>, OO can help make systems extensible and adaptable, but just the syntax of C++
classes without OO may not even reduce the maintenance cost, and it surely adds to the training cost significantly.</p>

<p>Bottom line: C++ without <code>virtual</code> is not OO. Programming with classes but without dynamic binding is called &#8220;object
based,&#8221; but not &#8220;object oriented.&#8221; Throwing out <code>virtual</code> functions is the same as throwing out OO. All you have left is
object-based programming, similar to the original Ada language (the updated Ada language, by the way, supports true OO
rather than just object-based programming).</p>

<p>Note: you don&#8217;t need <code>virtual</code> functions for <a href="big-picture.html#generic-paradigm" title="FAQ: What's the big deal with generic programming?">generic programming</a>. Among other things, this means
you can&#8217;t tell which paradigm you&#8217;ve used simply by counting the number of <code>virtual</code> functions you have.</p>

<h3 id="old-code-can-call-new-code">I&#8217;m from Missouri. Can you give me a simple reason why <code>virtual</code> functions (dynamic binding, dynamic polymorphism) and templates (static polymorphism) make a big difference?</h3>

<p>They can improve reuse by letting <em>old</em> code call <em>new</em> code provided at run time (virtual functions) or compile time (templates).</p>

<p>Before OO and generic programming came along, reuse was accomplished by having new code call old code. For example, a programmer might write
some code that called some reusable code such as <code>printf()</code>.</p>

<p>With OO and generic programming, reuse can also be accomplished by having <em>old</em> code call <em>new</em> code. For example, a programmer might write some
code that is called by a framework that was written by their great, great grandfather. There&#8217;s no need to change
great-great-grandpa&#8217;s code. In fact, for dynamic binding with virtual functions, it doesn&#8217;t even need to be recompiled. Even if all you have left is the object
file and the source code that great-great-grandpa wrote was lost 25 years ago, that ancient object file will call the
new extension without anything falling apart.</p>

<p><em>That</em> is extensibility, and <em>that</em> is OO and generic programming for powerful reusable abstraction.</p>

<h3 id="back-compat-with-c">Is C++ backward compatible with ANSI/ISO C?</h3>

<p>Almost. See also <a href="c.html#is-c-a-subset" title="FAQ: Is C a subset of C++?">is C a subset of C++</a>.</p>

<p>C++ is as close as possible to compatible with C, but no closer. In practice, the major difference is that C++
requires prototypes, and that <code>f()</code> declares a function that takes no parameters (in C, a function declared using <code>f()</code>
can be passed an arbitrary number of parameters of arbitrary types).</p>

<p>There are some very subtle differences as well, like <code>sizeof('x')</code> is equal to <code>sizeof(char)</code> in C++ but is equal to
<code>sizeof(int)</code> in C. Also, C++ puts structure &#8220;tags&#8221; in the same namespace as other names, whereas C requires an
explicit <code>struct</code> (e.g., the <code>typedef struct Fred Fred;</code> technique still works, but is redundant in C++).</p>

<h3 id="why-compat-with-c">Why is C++ (almost) compatible with C?</h3>

<p>When Stroustrup invented C++, he wanted C++ to be compatible with a complete language with sufficient performance and flexibility for even the most demanding systems programming. He &#8220;had a perfect dread of producing yet-another pretty language with unintentional limitations.&#8221; See Section 2.7 of <a href="http://stroustrup.com/dne.html">The Design and Evolution of C++</a> for historical details.</p>

<p>At the time, Stroustrup considered C the best systems programming language available. That was not as obvious then (1979) as it later became, but Stroustrup had experts such as <a href="http://netlib.bell-labs.com/who/dmr">Dennis Ritchie</a>, Steve Johnson, <a href="http://www.fraserresearch.org/agf.html">Sandy Fraser</a>, Greg Chesson, <a href="http://www.cs.dartmouth.edu/~doug">Doug McIlroy</a>, and <a href="http://www.cs.princeton.edu/~bwk/">Brian Kernighan</a> down the corridor from whom he could learn and get feedback. Without their help and advice, and without C, C++ would have been stillborn.</p>

<p>Contrary to repeated rumors, Stroustrup was never told that he had to use C; nor was he ever told not to use C. In fact, the first C++ manual grew from troff source of the C manual contributed by Dennis Ritchie. Many new languages were designed at Bell labs; in &#8220;Research&#8221; at least, there were no rules enforcing language bigotry.</p>

<h3 id="when-invented">When was C++ invented?</h3>

<p>Bjarne Stroustrup started work on what became C++ in 1979. The initial version was called &#8220;C with Classes&#8221;. The first version of C++ was used internally in AT&amp;T in August 1983. The name &#8220;C++&#8221; was used late that year. The first commercial implementation was released October 1985 at the same time as the publication of <a href="http://stroustrup.com/1st.html">the first edition of The C++ Programming Language</a>. Templates and exception handling were included later in the 1980&#8217;s and documented in <a href="http://stroustrup.com/arm.html">The Annotated C++ Reference Manual</a> and <a href="http://stroustrup.com/2nd.html">The C++ Programming Language (2nd Edition)</a>.</p>

<p>The current definition of C++ is <a href="../../std/the-standard.html">the ISO C++ Standard</a> and is described in <a href="http://stroustrup.com/4th.html">The C++ Programming Language (4th Edition)</a>.</p>

<p>You can find a more complete timeline and more detailed explanations in <a href="http://stroustrup.com/dne.html">The Design and Evolution of C++</a> and <a href="http://stroustrup.com/hopl2.pdf">A History of C++: 1979-1991</a>.</p>

<h3 id="why-invented">Why was C++ invented?</h3>

<p>Stroustrup  wanted to write efficient systems programs in the styles encouraged by Simula67. To do that, he added facilities for better type checking, data abstraction, and object-oriented programming to C. The more general aim was to design a language in which developers could write programs that were both efficient and elegant. Many languages force you to choose between those two alternatives.</p>

<p>The specific tasks that caused Stroustrup to start designing and implementing C++ (initially called &#8220;C with Classes&#8221;) had to do with distributing operating system facilities across a network.</p>

<p>You can find more detailed explanations in <a href="http://stroustrup.com/dne.html">The Design and Evolution of C++</a>. See also <a href="http://stroustrup.com/hopl2.pdf">A History of C++: 1979-1991</a> and <a href="http://stroustrup.com/hopl-almost-final.pdf">Evolving a language in and for the real world: C++ 1991-2006</a>.</p>

<h3 id="why-name">Where did the name C++ come from?</h3>

<p>In Chapter 3 of <a href="http://stroustrup.com/dne.html">D&amp;E</a>, Stroustrup wrote:</p>

<blockquote>
  <p>I picked C++ because it was short, had nice interpretations, and wasn&#8217;t of the form &#8220;adjective C.&#8221;</p>
</blockquote>

<p>In C, <code>++</code> can, depending on context, be read as &#8220;next,&#8221; &#8220;successor,&#8221; or &#8220;increment,&#8221; though it is always pronounced &#8220;plus plus.&#8221; The name C++ and its runner up ++C are fertile sources for jokes and puns &#8211; almost all of which were known and appreciated before the name was chosen. The name C++ was suggested by Rick Mascitti. It was first used in December of 1983 when it was edited into the final copies of [Stroustrup,1984] and [Stroustrup,1984c].</p>

<p>In chapter 1 of <a href="http://stroustrup.com/3rd.html">TC++PL</a>, Stroustrup wrote:</p>

<blockquote>
  <p>The name C++ (pronounced &#8220;see plus plus&#8221;) was coined by Rick Mascitti in the summer of 1983. The name signifies the evolutionary nature of the changes from C; &#8220;<code>++</code>&#8221; is the C increment operator. The slightly shorter name &#8220;C+&#8221; is a syntax error; it has also been used as the name of an unrelated language. Connoisseurs of C semantics find C++ inferior to ++C. The language is not called D, because it is an extension of C, and it does not attempt to remedy problems by removing features. For yet another interpretation of the name C++, see the appendix of [Orwell,1949].</p>
</blockquote>

<p>The &#8220;C&#8221; in C++ has a long history. Naturally, it is the name of the language Dennis Ritchie designed. C&#8217;s immediate ancestor was an interpreted descendant of BCPL called B designed by Ken Thompson. BCPL was designed and implemented by Martin Richards from Cambridge University while visiting MIT in the other Cambridge. BCPL in turn was Basic CPL, where CPL is the name of a rather large (for its time) and elegant programming language developed jointly by the universities of Cambridge and London. Before the London people joined the project &#8220;C&#8221; stood for Cambridge. Later, &#8220;C&#8221; officially stood for Combined. Unofficially, &#8220;C&#8221; stood for Christopher because Christopher Strachey was the main power behind CPL.</p>

<h3 id="unsafe-code">Why does C++ allow unsafe code?</h3>

<p>That is, why does C++ support operations that can be used to violate the rules of static (compile-time) type safety?</p>

<ul>
<li>to access hardware directly (e.g. to treat an integer as a pointer to (address of) a device register) </li>
<li>to achieve optimal run-time and space performance (e.g. unchecked access to elements of an array and unchecked access to an object through a pointer) </li>
<li>to be compatible with C </li>
</ul>

<p>That said, it is a good idea to avoid unsafe code like the plague whenever you don&#8217;t actually need one of those three features:</p>

<ul>
<li>don&#8217;t use casts </li>
<li>keep C-style <code>[]</code> arrays out of interfaces (hide them in the innards of high-performance functions and classes where they are needed and write the rest of the program using proper <code>string</code>s, <code>vector</code>s, etc.) </li>
<li>avoid <code>void*</code> (keep them inside low-level functions and data structures if you really need them and present type safe interfaces, usually templates, to your users) </li>
<li>avoid <code>union</code>s</li>
<li>if you have any doubts about the validity of a pointer, use a smart pointer instead</li>
<li>don&#8217;t use &#8220;naked&#8221; <code>new</code> and <code>delete</code> (use containers, resource handles, etc., instead) </li>
<li>don&#8217;t use <code>...</code>-style variadic functions (&#8220;<code>printf</code> style&#8221;) </li>
<li><a href="style-and-techniques.html#why-not-macros" title="FAQ: So, what's wrong with using macros?">avoid macros</a> except for <code>#include</code> guards </li>
</ul>

<p>Almost all C++ code can follow these simple rules. Please don&#8217;t be confused by the fact that you cannot follow these rules if you write C code or C-style code in C++.</p>

<h3 id="undefined">Why are some things left undefined in C++?</h3>

<p>Because machines differ and because C left many things undefined. For details, including definitions of the terms &#8220;undefined&#8221;, &#8220;unspecified&#8221;, &#8220;implementation defined&#8221;, and &#8220;well-formed&#8221;; see the ISO C++ standard. Note that the meaning of those terms differ from their definition of the ISO C standard and from some common usage. You can get wonderfully confused discussions when people don&#8217;t realize that not everybody shares definitions.</p>

<p>This is a correct, if unsatisfactory, answer. Like C, C++ is meant to exploit hardware directly and efficiently. This implies that C++ must deal with hardware entities such as bits, bytes, words, addresses, integer computations, and floating-point computations the way they are on a given machine, rather than how we might like them to be. Note that many &#8220;things&#8221; that people refer to as &#8220;undefined&#8221; are in fact &#8220;implementation defined&#8221;, so that we can write perfectly specified code as long as we know which machine we are running on. Sizes of integers and the rounding behavior of floating-point computations fall into that category.</p>

<p>Consider what is probably the the best known and most infamous example of undefined behavior:</p>

<pre><code>    int a[10];
    a[100] = 0; // range error
    int* p = a;
    // ...
    p[100] = 0; // range error (unless we gave p a better value before that assignment)
</code></pre>

<p>The C++ (and C) notion of array and pointer are direct representations of a machine&#8217;s notion of memory and addresses, provided with no overhead. The primitive operations on pointers map directly onto machine instructions. In particular, no range checking is done. Doing range checking would impose a cost in terms of run time and code size. C was designed to outcompete assembly code for operating systems tasks, so that was a necessary decision. Also, C &#8211; unlike C++ &#8211; has no reasonable way of reporting a violation had a compiler decided to generate code to detect it: There are no exceptions in C. C++ followed C for reasons of compatibility and because C++ also compete directly with assembler (in OS, embedded systems, and some numeric computation areas). If you want range checking, use a suitable checked class (<code>vector</code>, smart pointer, <code>string</code>, etc.). A good compiler could catch the range error for <code>a[100]</code> at compile time, catching the one for <code>p[100]</code> is far more difficult, and in general it is impossible to catch every range error at compile time.</p>

<p>Other examples of undefined behavior stems from the compilation model. A compiler cannot detect an inconsistent definition of an object or a function in separately-compiled translation units. For example:</p>

<pre><code>    // file1.c:
    struct S { int x,y; };
    int f(struct S* p) { return p-&gt;x; }

    // file2.c:
    struct S { int y,x; }
    int main()
    {
        struct S s;
        s.x = 1;
        int x = f(&amp;s);  // x!=s.x !!
        return 2;
    }
</code></pre>

<p>Compiling <code>file1.c</code> and <code>file2.c</code> and linking the results into the same program is illegal in both C and C++. A linker could catch the inconsistent definition of <code>S</code>, but is not obliged to do so (and most don&#8217;t). In many cases, it can be quite difficult to catch inconsistencies between separately compiled translation units. Consistent use of header files helps minimize such problems and there are some signs that linkers are improving. Note that C++ linkers do catch almost all errors related to inconsistently declared functions.</p>

<p>Finally, we have the apparently unnecessary and rather annoying undefined behavior of individual expressions. For example:</p>

<pre><code>    void out1() { cout &lt;&lt; 1; }
    void out2() { cout &lt;&lt; 2; }

    int main()
    {
        int i = 10;
        int j = ++i + i++;  // value of j unspecified
        f(out1(),out2());   // prints 12 or 21
    }
</code></pre>

<p>The value of <code>j</code> is unspecified to allow compilers to produce optimal code. It is claimed that the difference between what can be produced giving the compiler this freedom and requiring &#8220;ordinary left-to-right evaluation&#8221; can be significant. Leading experts are unconvinced, but with innumerable compilers &#8220;out there&#8221; taking advantage of the freedom and some people passionately defending that freedom, a change would be difficult and could take decades to penetrate to the distant corners of the C and C++ worlds. It is disappointing that not all compilers warn against code such as <code>++i+i++</code>. Similarly, the order of evaluation of arguments is unspecified.</p>

<p>There is a sentiment that too many &#8220;things&#8221; are left undefined, unspecified, implementation-defined, etc. To address this, the ISO C++ committee has created Study Group 12 to review and recommend wide-ranging tightening-up to reduce undefined, unspecified, and implementation-defined behavior.</p>

<h3 id="portability">Why is portability considered so important?</h3>

<p>Successful software is long-lived; life-spans of decades are not uncommon. A good application/program often outlives the hardware it was designed for, the operating system it was written for, the data base system it initially used, etc. Often, a good piece of software outlives the companies that supplied the basic technologies used to build it.</p>

<p>Often a successful application/program have customers/users who prefer a variety of platforms. The set of desirable platforms change as the user population changes. Being tied to a single platform or single vendor, limits the application/program&#8217;s potential use.</p>

<p>Obviously, complete platform independence is incompatible with the ability to use all platform specific facilities. However, you can often approximate platform independence for an application by accessing platform facilities through a &#8220;thin interface&#8221; representing the application&#8217;s view of its environment as a library.</p>

<h3 id="standardization">Is C++ standardized?</h3>

<p>Yes.</p>

<p>The C++ standard was finalized and adopted by ISO (International Organization for Standardization) as well as several
national standards organizations such as INCITS (the U.S. National Committee for Information Technology Standards), BSI (the British Standards
Institute), DIN (the German national standards organization). The ISO standard was finalized and adopted by unanimous
vote in November 1997, with minor updates in 2003 and now significant and valuable updates in 2011. Another set of updates is expected to be published in 2014.</p>

<p>The U.S. C++ committee is called &#8220;PL22.16&#8221;. The ISO C++ standards group is called &#8220;WG21&#8221;. The major players in the
C++ standards process have included just about everyone: representatives from Australia, Canada, Denmark, Finland, France,
Germany, Ireland, Japan, the Netherlands, New Zealand, Sweden, the UK, and the USA, along with representatives from
about a hundred companies and many interested individuals. Major players have included AT&amp;T, Ericsson, Digital, Borland,
Hewlett Packard, IBM, Intel, Mentor Graphics, Microsoft, NVidia, Silicon Graphics, Sun Microsystems, and Siemens.</p>

<p>For further information see <a href="../../std.html">the ISO C++ standardization pages</a>, including but not limited to</p>

<ul>
<li><a href="../../std/the-committee.html">the committee page</a></li>
<li><a href="../../std/meetings-and-participation.html">the meetings and participation page</a></li>
<li><a href="../../std/iso-iec-jtc1-procedures.html">the ISO/IEC JTC1 procedures summary</a></li>
</ul>

<h3 id="standardization-committee">Who is on the standardization committee?</h3>

<p>See also <a href="../../std/the-committee.html">the committee page</a>.</p>

<p>The committee consists of a large number of people (about 200) out of whom about 100 turn up at the week-long meetings two or three times a year. In addition there are national standards groups and meetings in several countries. Most members contribute either by attending meetings, by taking part in email discussions, or by submitting papers for committee consideration. Most members have friends and colleagues who help them. From day #1, the committee has had members from many countries and at every meeting people from half a dozen to a dozen countries attend. The final votes are done by about 20 national standards bodies. Thus, the ISO C++ standardization is a fairly massive effort, not a small coherent group of people working to create a perfect language for &#8220;people just like themselves.&#8221; The standard is what this group of volunteers can agree on as being the best they can produce that all can live with.</p>

<p>Naturally, many (but not all) of these volunteers have day jobs focused on C++: They include compiler writers, tool builders, library writers, application builders, researchers, book authors, consultants, test-suite builders, and more.</p>

<p>Here is a very-partial list of some major organizations involved: Adobe, Apple, Boost, Bloomberg, EDG, Google, HP, IBM, Intel, Microsoft, Oracle, Red Hat.</p>

<p>Here is a short list of names of members who you may have encountered in the literature or on the web: Dave Abrahams, Matt Austern, Pete Becker, Hans Boehm, Steve Clamage, Lawrence Crowl, Beman Dawes, Francis Glassborow, Doug Gregor, Pablo Halpern, Howard Hinnant, Jaakko Jarvi, John Lakos, Alisdair Meredith, Jens Maurer, Jason Merrill, Sean Parent, P.J. Plauger, Tom Plum, Gabriel Dos Reis, Bjarne Stroustrup, Herb Sutter, David Vandevoorde, Michael Wong. Apologies to the 200+ current and past members that we couldn&#8217;t list. Also, please note the author lists on the various papers: a standard is written by (many) individuals, not by an anonymous committee.</p>

<p>You can get a better impression of the breath and depth of expertise involved by examining the authors listed in the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">WG21 papers archive</a>, but please remember there are major contributors to the standards effort who do not write a lot.</p>

<h3 id="copy-of-standard">Where can I get a copy of the C++ standard?</h3>

<p>See <a href="../../std/the-standard.html">isocpp.org&#8217;s The Standard page</a>.</p>

<h3 id="cpp98-to-cpp03">What is the difference between C++98 and C++03?</h3>

<p>From a programmer&#8217;s view there is none. The C++03 revision of the standard was a bug fix release for implementers to ensure greater consistency and portability. In particular, tutorial and reference material describing C++98 and C++03 can be used interchangeably by all except compiler writers and standards gurus.</p>

<h3 id="cpp98-to-cpp0x">What is the difference between C++98 and C++0x?</h3>

<p>The same as <a href="big-picture.html#cpp98-to-cpp11" title="FAQ: What is the difference between C++98 and C++11?">the difference between C++98 and C++11</a>, because C++0x ended up being C++11. The <code>x</code> C++0x went hexadecimal; we have C++0xB. :)</p>

<h3 id="cpp98-to-cpp11">What is the difference between C++98 and C++11?</h3>

<p>See <a href="cpp11.html" title="Section: C++11 Overview">what&#8217;s new in C++11</a>.</p>

<p>Note that the C++ language will remain stable because compatibility is always a major concern. The committee tries hard not to break your (standard conforming) code. Except for some corner cases you&#8217;re unlikely to notice, all valid C++98 code is valid C++11 and C++14 code.</p>

<h3 id="cpp11-to-cpp14">What is the difference between C++11 and C++14?</h3>

<p>See <a href="cpp14.html" title="Section: C++14 Overview">what&#8217;s new in C++14</a>.</p>

<p>Note that the C++ language will remain stable because compatibility is always a major concern. The committee tries hard not to break your (standard conforming) code. Except for some corner cases you&#8217;re unlikely to notice, all valid C++98 code is valid C++14 code.</p>

<h3 id="interview-questions">What are some &#8220;interview questions&#8221; I could ask that would let me know if candidates really know their stuff?</h3>

<p>This answer is primarily for non-technical managers and HR folks who are trying to do a good job at interviewing C++
candidates. If you&#8217;re a C++ programmer about to be interviewed, and if you&#8217;re lurking in this FAQ hoping to know the
questions they&#8217;ll ask you ahead of time so you can avoid having to <em>really</em> learn C++, shame on you: spend your time
becoming technically competent and you won&#8217;t have to try to &#8220;cheat&#8221; your way through life!</p>

<p>Back to the non-technical manager / HR person: obviously you are eminently qualified to judge whether a candidate is a
good &#8220;fit&#8221; with your company&#8217;s culture. However there are enough charlatans, wannabes, and posers out there that you
really need to team up with someone who is technically competent in order to make sure the candidate has the right level
of technical skill. A lot of companies have been burned by hiring nice but incompetent duds &#8212; people who were
incompetent in spite of the fact that they knew the answers to a few obscure questions. The only way to smoke out the
posers and wannabes is to get someone in with you who can ask penetrating technical questions. You have no hope
whatsoever of doing that yourself. Even if I gave you a bunch of &#8220;tricky questions,&#8221; they wouldn&#8217;t smoke out the bad
guys.</p>

<p>Your technical sidekick might not be (and often isn&#8217;t) qualified to judge the candidate on personality or soft skills,
so please don&#8217;t abdicate your role as the final arbiter in the decision making process. But please don&#8217;t think you can
ask a half dozen C++ questions and have the slightest clue if the candidate <em>really</em> knows what they&#8217;re talking about
from a technical perspective.</p>

<p>Having said all that, <em>if</em> you&#8217;re technical enough to read the C++ FAQ, you can dig up a lot of good interview
questions here. The FAQ has a <em>lot</em> of goodies that will separate the wheat from the chaff. The FAQ focuses on what
programmers should do, as opposed to merely what the compiler will let them do. There are things that can be done in
C++ but shouldn&#8217;t be done. The FAQ helps people separate those two.</p>

<h3 id="defn-evil">What does the FAQ mean by &#8220;such and such is <em>evil</em>&#8221;?</h3>

<p>It means <em>such and such</em> is something you should avoid most of the time, but <em>not</em> something you should avoid <em>all</em> the
time. For example, you will end up using these &#8220;evil&#8221; things whenever they are &#8220;the least evil of the evil
alternatives.&#8221; It&#8217;s a joke, okay? Don&#8217;t take it too seriously.</p>

<p>The real purpose of the term (<em>&#8220;Ah ha,&#8221;</em> I hear you saying, <em>&#8220;there really <strong>is</strong> a hidden motive!&#8221;</em>; you&#8217;re right:
there is) is to shake new C++ programmers free from some of their old thinking. For example, C programmers who are new
to C++ often use pointers, arrays and/or <code>#define</code> more than they should. The FAQ lists those as &#8220;evil&#8221; to give new
C++ programmers a vigorous (and droll!) shove in the right direction. The goal of farcical things like &#8220;pointers are
evil&#8221; is to convince new C++ programmers that C++ really isn&#8217;t &#8220;just like C except for those silly <code>//</code> comments.&#8221;</p>

<p>Now let&#8217;s get real here. I&#8217;m not suggesting macros or arrays or pointers are right up there with murder or kidnapping.
Well, maybe pointers. (Just kidding!) So don&#8217;t get all hyper about the word &#8220;evil&#8221;: it&#8217;s supposed to sound a little
outrageous. And don&#8217;t look for a technically precise definition of exactly when something is or isn&#8217;t &#8220;evil&#8221;: there
isn&#8217;t one.</p>

<p>Items labeled as &#8220;evil&#8221; (macros, arrays, pointers, etc.) aren&#8217;t <em>always</em> bad in <em>all</em> situations. When they are the
&#8220;least bad&#8221; of the alternatives, <a href="big-picture.html#use-evil-things-sometimes" title="FAQ: Will I sometimes use any so-called 'evil' constructs?">use them</a>!</p>

<h3 id="use-evil-things-sometimes">Will I sometimes use any so-called &#8220;evil&#8221; constructs?</h3>

<p>Of <em>course</em> you will!</p>

<p>One size does not fit all. Stop. Right now, take out a fine-point marker and write on the inside of your glasses:
<em>Software Development <strong>Is</strong> Decision Making</em>. &#8220;Think&#8221; is not a four-letter word. There are very few &#8220;never&#8230;&#8221; and
&#8220;always&#8230;&#8221; rules in software &#8212; rules that you can apply without thinking &#8212; rules that always work in all situations
in all markets &#8212; one-size-fits-all rules.</p>

<p>In plain English, you <em>will</em> have to make decisions, and the quality of your decisions <em>will</em> affect the <a href="big-picture.html#biz-dominates-tech" title="FAQ: Is it important to know the technical definition of 'good OO'? Of 'good class design'?">business
value</a> of your software. Software development is <em>not</em> mostly about slavishly following rules; it is
a matter of thinking and making tradeoffs and choosing. And sometimes you will have to choose between a bunch of bad
options. When that happens, the best you can hope for is to choose the <em>least bad</em> of the alternatives, the lesser of
the &#8220;evils.&#8221;</p>

<p>You <em>will</em> occasionally use approaches and techniques labeled as &#8220;evil.&#8221; If that makes you uncomfortable, mentally
change the word &#8220;evil&#8221; to &#8220;frequently undesirable&#8221; (but don&#8217;t quit your day job to become an author:
<a href="http://www.dictionary.com/search?q=milquetoast" title="milquetoast: A very timid, unassertive, spineless person,
especially one who is easily dominated or intimidated.">milquetoast</a> terms like that put people to sleep :-)</p>

<h3 id="biz-dominates-tech">Is it important to know the technical definition of &#8220;good OO&#8221;? Of &#8220;good class design&#8221;?</h3>

<p>You might not like this, but the short answer is, &#8220;No.&#8221; (With the caveat that this answer is directed to practitioners,
not theoreticians.)</p>

<p>Mature software designers evaluate situations based on business criteria (time, money and risk) in addition to technical
criteria like whether something is or is not &#8220;good OO&#8221; or &#8220;good class design.&#8221; This is a lot harder since it involves
business issues (schedule, skill of the people, finding out where the company wants to go so we know where to design
flexibility into the software, willingness to factor in the likelihood of future changes - changes that are likely
rather than merely theoretically possible, etc.) in addition to technical issues. However it results in decisions that
are a <em>lot</em> more likely to bring good business results.</p>

<p>As a developer, you have a fiduciary responsibility to your employer to invest only in ways that have a reasonable
expectation for a return on that investment. If you don&#8217;t ask the business questions <em>in addition to</em> the technical
questions, you will make decisions that have random and unpredictable business consequences.</p>

<p>Like it or not, what that means in practice is that you&#8217;re probably better off leaving terms like &#8220;good class design&#8221;
and &#8220;good OO&#8221; undefined. In fact I believe precise, pure-technical definitions of those terms can be dangerous and can
cost companies money, ultimately perhaps even costing people their jobs. That sounds bizarre, but there&#8217;s a really good
reason: if these terms are defined in precise, pure-technical terms, well-meaning developers tend to ignore business
considerations in their desire to fulfill these pure-technical definitions of &#8220;good.&#8221;</p>

<p><em>Any</em> purely technical definition of &#8220;good,&#8221; such as &#8220;good OO&#8221; or &#8220;good design&#8221; or anything else that can be evaluated
without regard to schedule, business objectives (so we know where to invest), expected future changes, corporate culture
with respect to a willingness to invest in the future, skill levels of the team that will be doing the maintenance,
etc., is dangerous. It is dangerous because it deceives programmers into thinking they are making &#8220;right&#8221; decisions when
in reality they <em>might</em> be making decisions that have <em>terrible</em> consequences. Or those decisions might not have
terrible business consequences, but that&#8217;s the point: when you ignore business considerations while making decisions,
the business consequences will be random and somewhat unpredicatable. That&#8217;s bad.</p>

<p>It is a simple fact that business issues dominate technical issues, and any definition of &#8220;good&#8221; that fails to
acknowledge that fact is bad.</p>

<h3 id="faq-moniker-not-acronym">What should I tell people who complain that the word &#8220;FAQ&#8221; is misleading, that it emphasizes the questions rather than the answers, and that we should all start using a different acronym?</h3>

<p>Tell them to grow up.</p>

<p>Some people want to change the word &#8220;FAQ&#8221; to a different acronym, such as something emphasizing the answers rather than
the questions. However a word or phrase is defined by its usage. Multitudes of people already understand &#8220;FAQ&#8221; as a word
in its own right. Think of it as a moniker for an idea rather than an acronym. As a word, &#8220;FAQ&#8221; already means a list of
common questions <em>and</em> answers.</p>

<p>Do not take this as an encouragement to use words sloppily. Quite the opposite. The point is that clear communication
involves using words that everybody already understands. Getting into a contest over whether we should change the word
&#8220;FAQ&#8221; is silly and a waste of time. It would be one thing if the word wasn&#8217;t already well known, but it no longer makes
sense after so many people already understand it.</p>

<p>An (imperfect) analogy: the character <code>'\n'</code> is almost universally known as the linefeed character, yet very few
programmers today work with computers equipped with a teletype that actually does a &#8220;line feed.&#8221; Nobody cares anymore;
it&#8217;s a linefeed character; get over it. And <code>'\r'</code> is the carriage return, even though your computer might not have a
carriage that returns. Live with it.</p>

<p>Another (imperfect) analogy is <a href="exceptions.html#mindset-for-proper-use-of-eh" title="FAQ: Exception handling seems to make my life more difficult; that must mean exception handling itself is bad; clearly I'm not the problem, right??">RAII</a>. Thanks to the excellent work of <a href="mailto:(NOSPAM)ark(AT)research(DOT)att(DOT)com">Andy
Koenig</a>, <a href="http://www.research.att.com/~bs/glossary.html#Gresource-acquisition-is-initialization">Bjarne
Stroustrup</a>, and others, the name
&#8220;RAII&#8221; has become very widely known in the C++ community. &#8220;RAII&#8221; represents a <a href="exceptions.html#mindset-for-proper-use-of-eh" title="FAQ: Exception handling seems to make my life more difficult; that must mean exception handling itself is bad; clearly I'm not the problem, right??">very valuable
concept</a> and you ought to <a href="exceptions.html#too-many-trycatch-blocks" title="FAQ: I have too many try blocks; what can I do about it?">use it regularly</a>. <em>However</em>, if you
dissect &#8220;RAII&#8221; as an acronym, and if you look (too?) closely at the words making up that acronym, you will realize that
the words are not a perfect match for the concept. Who cares?!? The concept is what&#8217;s important; &#8220;RAII&#8221; is merely a
moniker used as a handle for that concept.</p>

<blockquote>
  <p>Details: If you dissect the words of the RAII acronym (Resource Acquisition Is Initialization), you will think RAII
  is about acquiring resources during initialization. However the power of RAII comes not from tying <em>acquisition</em> to
  <em>initialization</em>, but from tying <em>reclamation</em> to <em>destruction</em>. A more precise acronym might be RRID (Resource
  Reclamation Is Destruction), perhaps DIRR (Destruction Is Resource Reclamation), but since so many people already
  understand RAII, using it properly is far more important than complaining about the term. RAII is a moniker for an
  idea; its precision as an acronym is secondary.</p>
  
  <p>(What&#8217;s <em>really</em> important in acronyms is how cool they sound. Clearly &#8220;RRID&#8221; and &#8220;DIRR&#8221; are therefore better! Just
  kidding.)</p>
</blockquote>

<p>So treat the word &#8220;FAQ&#8221; as a moniker that already has a well established, well known meaning. A word is defined by its
usage.</p>

<h3 id="please-send-material">How can I help make the C++ FAQ even better??!??</h3>

<p>Please <a href="mailto:faq-discussion@isocpp.org" title="Email the FAQ Editors">send material</a> with suggestions, or even that you want to volunteer to be approved as a FAQ maintainer to make contributions yourself as you have time. Qualified volunteers are appreciated.</p>

<p>If you want to help, here are some specifics:</p>

<ol>
<li><p>Don&#8217;t expect to get paid.</p>

<p>This is a non-paying labor of love &#8212; for me, and, if you choose to help, for you.</p>

<p>Giving back is A Good Thing. Technology has been good to me, and I expect it&#8217;s been good to you.</p></li>
<li><p>A worked-out solution (FAQ-like question + answer) will get integrated more quickly than a one-liner suggestion
for someone else to write up.</p>

<ul>
<li><code>"Editors, here is a new question + answer on ...."</code> ← <em>Preferred!</em></li>
<li><code>"Editors, YOU should write a new question + answer on ...."</code> ← <em>Will take longer!</em></li>
</ul>

<p>We will try (and always have have tried) to get to the latter, though we have only so much time.</p></li>
<li><p>Don&#8217;t worry if you suck at writing. Send your ideas anyway. We will gladly wordsmith what you send, both to make
it &#8220;fit&#8221; with the rest of the FAQ and to make it easy for you.</p>

<p>So send in your suggestions, even if you&#8217;re not confident in your writing ability!!</p></li>
<li><p>Dead external links. Sigh. There are too many of them. If you find one, it would be <em>very</em> helpful (to the entire
C++ community!!) if you&#8217;d send the correct, updated URL.</p>

<p>Obviously we appreciate any help, even if the only thing you tell us is that the link is dead. However if you do
that, be advised that the link will merely be removed &#8212; it probably won&#8217;t get corrected.</p></li>
</ol>

<p>Remember: you&#8217;re helping the entire world-wide C++ community.</p>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance — Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance — virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance — Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance — Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance — What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance — private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance — Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/big-picture",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/big-picture",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/big-picture by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:40 GMT -->
</html>
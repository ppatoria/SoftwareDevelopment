<!doctype html>
<html lang="en">
  
<!-- Mirrored from isocpp.org/wiki/faq/pointers-to-members by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <title>
            Standard C++
    </title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link href="../../favicon.ico" rel="shortcut icon" />
    <link rel="apple-touch-icon" href="apple-touch-icon-57.html" />
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72.html" />
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114.html" />
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144.html" />
    
    <link href="../../indexe9db.html?css=stylesheets/prettify" rel="stylesheet" media="all" type="text/css" />
    <script type="text/javascript" src="../../../cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
    
    <link href="../../index6bd3.html?css=stylesheets/screen" rel="stylesheet" media="all" type="text/css" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <script src="../../mint/index3298.html?js" type="text/javascript"></script>
    
    <script type="text/javascript" src="../../../use.typekit.com/kml7swa.js"></script>
    <script type="text/javascript">try{Typekit.load();}catch(e){}</script>
    
  </head>
  
  <body class="hide-sidebar">
    <div id="root">
    
      <div id="crown">
        <a id="sidebar-toggle" href="#sidebar">Show sidebar &raquo;</a>
        <ul class="user">
                          <li><a href="../../member/login.html">Sign In</a></li>
          <li><a href="../../member/register.html">Register</a></li>
                </ul>
      </div>

      <header id="top" role="banner">
        <div class="container">
          <h1>
            <a href="../../index.html"><img src="../../images/uploads/logo-sun.jpg" alt="Standard C++" /></a>
          </h1>
          <nav role="navigation">
            <ul id="nav-sub">
<li class="first"><a href="../../get-started.html">Get Started!</a></li>
<li><a href="../../tour.html">Tour</a></li>
<li><a href="../../faq.html">C++ Super-FAQ</a></li>
<li><a href="../../blog.html">Blog</a></li>
<li><a href="../../forums.html">Forums</a></li>
<li><a href="../../std.html">Standardization</a></li>
<li class="last"><a href="../../about.html">About</a></li>
</ul>
          </nav>
          <form action="https://isocpp.org/search/google">
            <input type="text" name="q" id="q" maxlength="100" value="" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          <!--
          <form method="post" action="https://isocpp.org/"  >
<div class='hiddenFields'>
<input type="hidden" name="ACT" value="6" />
<input type="hidden" name="XID" value="4fb16123ed402bdc112dab749d4c7914aa9da3f5" />
<input type="hidden" name="RES" value="" />
<input type="hidden" name="meta" value="zYMKgX58Zs8+1aclN9tC7heLzqeMS/BIDf2KWaqfUPy9IuEVYHdFD1dlGh34VWoTLfYfqx2VVNOeAsrIgIvvoFDyH5RKx1rRrjSIJmrlV4WTNhwE+/Onu3ISLsbzAk2awqSU6A+hVvt+f/zJn30d7+qnYdsX9iFLWu40TELdyhIN7OvZg7LuJknFB0gZ7nQTklJ/9coWuk9SURbQpuERR2hTSI2C5xLtlwfiI61PqkKwyrlOKG6XDMBSEtvAIHOCp+adyiqHkYhNSPC8wgrdUEXu/O1ACVY3yqa/hYv3qY5COcgp3UflhKiNqQvGfAikDLrb28Jq5FJxzSTO4kcq1kRWnkMAIa+DJDX1Ri9lxnSoesPEDjJwSIcqjcXXIxh1l0qg2xNSdmuOrE+KB+C8x3zG6M/Rmrrfc9CHMGWIs3c=" />
<input type="hidden" name="site_id" value="1" />
</div>


            <input type="text" name="keywords" id="keywords" maxlength="100" value="M50o93H7pQ09L8X1t49cHY01Z5j4TT91fGfr" class="textbox" />
            <input type="submit" value="Search" class="button" />
          </form>
          -->
        </div>
      </header>

      <div id="content" class="hide-sidebar" role="main">
        <div class="container">
    
      <div id="sidebar">
              <section>
              <header>Features</header>
            <div class="sidebar-section-content prettify">
        <p style="text-align: center;">
	&nbsp;</p>
<p>
	<a href="https://github.com/cplusplus/draft"><img alt="" src="../../images/uploads/github.png" style="width: 90px; height: 48px; margin-right: 5px; margin-left: 5px; float: right;" /></a><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf"><strong>Working Draft</strong> of the next&nbsp;standard</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/status.html">Current ISO C++ status</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="../../std/meetings-and-participation/upcoming-meetings.html">Upcoming ISO C++ meetings</a></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://en.cppreference.com/w/cpp/compiler_support">Compiler conformance status</a></p>
      </div>
    </section>
  
  
  
        <nav>
          <section>
            <header>
              Navigation
            </header>
            <ul>
              <li><a href="../faq.html">FAQ Home</a></li>
              <li><a href="../../themes/wiki_themes/isocpp/rss/faq-revisions-rss.php" class="icon rss">FAQ RSS Feed</a></li>
              <li><a href="editinfo.html">FAQ Help</a></li>
                          </ul>
          </section>
        
        
          <section>
            <header>
              Search this Wiki
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Search_results">
              <input type="hidden" name="XID" value="f7f04771fdc7a2fc1e11fb7cd7e1c92068598323" />
              <input type="text" class="input" name="keywords" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
          
          <section>
            <header>
              Go to Page
            </header>
            <form method="post" action="https://isocpp.org/wiki/faq/Special:Find_page">
              <input type="hidden" name="XID" value="6f27303a4725361179e2e25486b5cb19e0f12ccd" />
              <input type="text" class="input" name="title" size="20" value="" maxlength="80" /><input type="submit" class="submit" value="Go" />
            </form>
          </section>
        </nav>
          
      <section>
              <header>Upcoming Events</header>
            <div class="sidebar-section-content prettify">
        <p>
	<a href="http://cppcon.org/" style="line-height: 1;"><strong>CppCon 2015</strong></a></p>
<p>
	<span style="line-height: 1;">Sep 19-20 (boot camp)</span></p>
<p>
	<span style="line-height: 1;">Sep 20-25 (conference)</span></p>
<p>
	<span style="line-height: 1;">Bellevue, WA, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<span style="line-height: 1;"><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4544.htm"><strong>ISO C++ Fall Meeting</strong></a> <a href="../../files/papers/n4545.html">(agenda)</a></span></p>
<p>
	Oct 19-24,&nbsp;<span style="line-height: 1;">Kona, HI, USA</span></p>
<p>
	&nbsp;</p>
<p>
	<a href="http://meetingcpp.com/index.php/meetingcpp-2015.html"><strong>Meeting C++ 2015</strong></a></p>
<p>
	Dec 4-5, Berlin, Germany</p>
<p>
	&nbsp;</p>
      </div>
    </section>
  
      <section>
            <div class="sidebar-section-content prettify">
        <div class="twitter-container">
	<a class="twitter-timeline" data-dnt="true" data-widget-id="344512921423998976" href="https://twitter.com/isocpp">Tweets by @isocpp</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script></div>
      </div>
    </section>
  
      </div>

      <div id="mainbar">
        <header>
          <div class="breadcrumbs">

            <a href="../faq.html">Wiki Home</a>
            <span class="breadcrumbspacer">&nbsp;&nbsp;&gt;&nbsp;&nbsp;</span>

                        pointers to members
            
          </div>
          
          <div class="wiki-page-actions">
                    <a href="pointers-to-members.html">View</a>
                              </div>
          
          <h2>
                    
          
                    
                    pointers to members
                    </h2>

          <div class="save-to-reader wiki">
            <div class="title">Save to:</div>
            <a href="http://www.instapaper.com/hello2?url={url}&amp;title=pointers%20to%20members" class="icon instapaper">Instapaper</a>
            <a href="http://getpocket.com/create?url={url}&amp;action=save&amp;k=3aNp2F20Aao4bvW884g224eUfud1nfI0" class="icon pocket">Pocket</a>
            <a href="#" class="icon readability">Readability</a>
            <div class="rdbWrapper" data-show-read="1" data-show-send-to-kindle="1" data-show-print="1" data-show-email="1" data-orientation="0" data-version="1" data-bg-color="#ffffff"></div><script type="text/javascript">(function() {var s = document.getElementsByTagName("script")[0],rdb = document.createElement("script"); rdb.type = "text/javascript"; rdb.async = true; rdb.src = document.location.protocol + "//www.readability.com/embed.js"; s.parentNode.insertBefore(rdb, s); })();</script>
          </div>
          
        </header>

        <article>

          <!-- Begin Main Content of Page -->

          
          

          <div id="wiki-content">

          

          <div class="prettify">


<h2 id="pointers-to-members">Pointers to Member Functions</h2>

<h3 id="fnptr-vs-memfnptr-types">Is the type of &#8220;pointer-to-member-function&#8221; different from &#8220;pointer-to-function&#8221;?</h3>

<p>Yep.</p>

<p>Consider the following function:</p>

<pre><code>int f(char a, float b);
</code></pre>

<p>The type of this function is different depending on whether it is an ordinary function or a non-<code>static</code> member
function of some class:</p>

<ul>
<li>Its type is &#8220;<code>int (*)(char,float)</code>&#8221; if an ordinary function</li>
<li>Its type is &#8220;<code>int (Fred::*)(char,float)</code>&#8221; if a non-<code>static</code> member function of <code>class</code> <code>Fred</code></li>
</ul>

<p>Note: if it&#8217;s a <code>static</code> member function of <code>class</code> <code>Fred</code>, its type is the same as if it were an ordinary function:
&#8220;<code>int (*)(char,float)</code>&#8221;.</p>

<h3 id="memfnptr-vs-fnptr">How do I pass a pointer-to-member-function to a signal handler, X event callback, system call that starts a thread/task, etc?</h3>

<p>Don&#8217;t.</p>

<p>Because a member function is meaningless without an object to invoke it on, you can&#8217;t do this directly (if The X Window
System was rewritten in C++, it would probably pass references to <em>objects</em> around, not just pointers to functions;
naturally the objects would embody the required function and probably a whole lot more).</p>

<p>As a patch for existing software, use a top-level (non-member) function as a wrapper which takes an object obtained
through some other technique. Depending on the routine you&#8217;re calling, this &#8220;other technique&#8221; might be trivial or might
require a little work on your part. The system call that starts a thread, for example, might require you to pass a
function pointer along with a <code>void*</code>, so you can pass the object pointer in the <code>void*</code>. Many real-time operating
systems do something similar for the function that starts a new task. Worst case you could store the object pointer in a
global variable; this might be required for Unix signal handlers (but globals are, in general, undesired). In any case,
the top-level function would call the desired member function on the object.</p>

<p>Here&#8217;s an example of the worst case (using a global). Suppose you want to call <code>Fred::memberFn()</code> on interrupt:</p>

<pre><code>class Fred {
public:
  void memberFn();
  static void staticMemberFn();  // A static member function can usually handle it
  // ...
};

// Wrapper function uses a global to remember the object:
Fred* object_which_will_handle_signal;

void Fred_memberFn_wrapper()
{
  object_which_will_handle_signal-&gt;memberFn();
}

int main()
{
  /* signal(SIGINT, Fred::memberFn); */   // Can NOT do this
  signal(SIGINT, Fred_memberFn_wrapper);  // Okay
  signal(SIGINT, Fred::staticMemberFn);   // Okay usually; see below
  // ...
}
</code></pre>

<p>Note: <code>static</code> member functions do not require an actual object to be invoked, so
pointers-to-<code>static</code>-member-functions are <em>usually</em> type-compatible with regular pointers-to-functions. However,
although it probably works on most compilers, it actually would have to be an <code>extern "C"</code> non-member function to be
correct, since &#8220;C linkage&#8221; doesn&#8217;t only cover things like name mangling, but also calling conventions, which might be
different between C and C++.</p>

<h3 id="memfnptr-vs-fnptr-more">Why do I keep getting compile errors (type mismatch) when I try to use a member function as an interrupt service routine?</h3>

<p>This is a special case of the previous two questions, therefore read the previous two answers first.</p>

<p>Non-<code>static</code> member functions have a hidden parameter that corresponds to the <code>this</code> pointer. The <code>this</code> pointer points
to the instance data for the object. The interrupt hardware/firmware in the system is not capable of providing the
<code>this</code> pointer argument. You must use &#8220;normal&#8221; functions (non class members) or <code>static</code> member functions as interrupt
service routines.</p>

<p>One possible solution is to use a <code>static</code> member as the interrupt service routine and have that function look somewhere
to find the instance/member pair that should be called on interrupt. Thus the effect is that a member function is
invoked on an interrupt, but for technical reasons you need to call an intermediate function first.</p>

<h3 id="addr-of-memfn">Why am I having trouble taking the address of a C++ function?</h3>

<p>Short answer: if you&#8217;re trying to store it into (or pass it as) a pointer-to-function, then that&#8217;s the problem &#8212;
this is a corollary to the previous FAQ.</p>

<p>Long answer: In C++, member functions have an implicit parameter which points to the object (the <code>this</code> pointer
inside the member function). Normal C functions can be thought of as having a different calling convention from member
functions, so the types of their pointers (pointer-to-member-function vs pointer-to-function) are different and
incompatible. C++ introduces a new type of pointer, called a pointer-to-member, which can be invoked only by
providing an object.</p>

<p>NOTE: do <em>not</em> attempt to &#8220;cast&#8221; a pointer-to-member-function into a pointer-to-function; the result is undefined
and probably disastrous. E.g., a pointer-to-member-function is <em>not</em> required to contain the machine address of the
appropriate function. As was said in the last example, if you have a pointer to a regular C function, use either a
top-level (non-member) function, or a <code>static</code> (class) member function.</p>

<h3 id="typedef-for-ptr-to-memfn">How can I avoid syntax errors when creating pointers to members?</h3>

<p>Use a <code>typedef</code>.</p>

<p>Yea, right, I know: <em>you</em> are different. You are <em>smart</em>. You can do this stuff without a <code>typedef</code>. Sigh. I have
received many emails from people who, like you, refused to take the simple advice of this FAQ. They wasted hours and
hours of their time, when 10 seconds worth of <code>typedef</code>s would have simplified their lives. Plus, face it, you are not
writing code that only you can read; you are hopefully writing your code that others will also be able to read &#8212; when
they&#8217;re tired &#8212; when they have their own deadlines and their own challenges. So why intentionally make life harder on
yourself and on others? Be smart: use a <code>typedef</code>.</p>

<p>Here&#8217;s a sample class:</p>

<pre><code>class Fred {
public:
  int f(char x, float y);
  int g(char x, float y);
  int h(char x, float y);
  int i(char x, float y);
  // ...
};
</code></pre>

<p>The typedef is trivial:</p>

<pre><code>typedef  int (Fred::*FredMemFn)(char x, float y);  // Please do this!
</code></pre>

<p>That&#8217;s it! <code>FredMemFn</code> is the type name, and a pointer of that type points to any member of <code>Fred</code> that takes
<code>(char,float)</code>, such as <code>Fred</code>&#8217;s <code>f</code>, <code>g</code>, <code>h</code> and <code>i</code>.</p>

<p>It&#8217;s then <em>trivial</em> to declare a member-function pointer:</p>

<pre><code>int main()
{
  FredMemFn p = &amp;Fred::f;
  // ...
}
</code></pre>

<p>And it&#8217;s also <em>trivial</em> to declare functions that receive member-function pointers:</p>

<pre><code>void userCode(FredMemFn p)
{ /*...*/ }
</code></pre>

<p>And it&#8217;s also <em>trivial</em> to declare functions that return member-function pointers:</p>

<pre><code>FredMemFn userCode()
{ /*...*/ }
</code></pre>

<p>So please, use a <code>typedef</code>. Either that or <em>do not send me email</em> about the problems you have with your member-function
pointers!</p>

<h3 id="macro-for-ptr-to-memfn">How can I avoid syntax errors when calling a member function using a pointer-to-member-function?</h3>

<p>Use a <code>#define</code> macro.</p>

<p>Please.</p>

<p>Pretty please.</p>

<p>I get way too many emails from confused people who refused to take this advice. It&#8217;s so simple. I know, you don&#8217;t <em>need</em>
a macro, and the expert you talked to can do it without a macro, but please don&#8217;t let your ego get in the way of what&#8217;s
important: money. Other programmers will need to read / maintain your code. Yes, I know: you are smarter than everyone
else; fine. And you are awesome; fine. But don&#8217;t add unnecessary complexity to your code. Reduce maintenance cost by,
<a href="inline-functions.html#inline-vs-macros" title="FAQ: Why should I use inline functions instead of plain old #define macros?">paradoxically</a>, using a <code>#define</code> macro in this particular case.</p>

<p>(<a href="inline-functions.html#inline-vs-macros" title="FAQ: Why should I use inline functions instead of plain old #define macros?">Normally I dislike <code>#define</code> macros</a>, but <a href="big-picture.html#use-evil-things-sometimes" title="FAQ: Will I sometimes use any so-called 'evil' constructs?">you should use them with pointers to
members</a> because they improve the readability and writability of that sort of code.)</p>

<p>The macro is trivial:</p>

<pre><code>#define CALL_MEMBER_FN(object,ptrToMember)  ((object).*(ptrToMember))
</code></pre>

<p>Using the macro is also trivial. Note: <code>FredMemFn</code> is <a href="pointers-to-members.html#typedef-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when creating pointers to members?">a <code>typedef</code> for a pointer-to-member
type</a>:</p>

<pre><code>void userCode(Fred&amp; fred, FredMemFn p)  // Use a typedef for pointer-to-member types
{
  int ans = CALL_MEMBER_FN(fred,p)('x', 3.14);
  // Would normally be: int ans = (fred.*p)('x', 3.14);

  // ...
}
</code></pre>

<p>The reason this macro is a good idea is because member function invocations are often a <em>lot</em> more complex than the
simple example just given. The difference in readability and writability is significant.
<a href="news:comp.lang.c++"><code>comp.lang.c++</code></a> has had to endure hundreds and hundreds of postings from confused programmers who
couldn&#8217;t quite get the syntax right. Almost all these errors would have vanished had they used the above macro.</p>

<p>Note: <code>#define</code> macros are <a href="big-picture.html#defn-evil" title="FAQ: What does the FAQ mean by 'such and such is evil'?">evil</a> in 4 different ways: <a href="inline-functions.html#inline-vs-macros" title="FAQ: Why should I use inline functions instead of plain old #define macros?">evil#1</a>,
<a href="misc-technical-issues.html#macros-with-if" title="FAQ: What should be done with macros that contain if?">evil#2</a>, <a href="misc-technical-issues.html#macros-with-multi-stmts" title="FAQ: What should be done with macros that have multiple lines?">evil#3</a>, and <a href="misc-technical-issues.html#macros-with-token-pasting" title="FAQ: What should be done with macros that need to paste two tokens together?">evil#4</a>. But they&#8217;re <a href="big-picture.html#use-evil-things-sometimes" title="FAQ: Will I sometimes use any so-called 'evil' constructs?">still
useful sometimes</a>. But you should still feel a vague sense of shame after using them.</p>

<h3 id="array-memfnptrs">How do I create and use an array of pointer-to-member-function?</h3>

<p>Use <em>both</em> the <code>typedef</code> <em>and</em> the <code>#define</code> macro <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">described earlier</a>, and you&#8217;re 90% done.</p>

<p><strong>Step 1:</strong> create a <code>typedef</code>:</p>

<pre><code>class Fred {
public:
  int f(char x, float y);
  int g(char x, float y);
  int h(char x, float y);
  int i(char x, float y);
  // ...
};

// FredMemFn points to a member of Fred that takes (char,float)
typedef  int (Fred::*FredMemFn)(char x, float y);
</code></pre>

<p><strong>Step 2:</strong> create a <code>#define</code> macro:</p>

<pre><code>#define CALL_MEMBER_FN(object,ptrToMember)  ((object).*(ptrToMember))
</code></pre>

<p>Now your array of pointers-to-member-functions is straightforward:</p>

<pre><code>FredMemFn a[] = { &amp;Fred::f, &amp;Fred::g, &amp;Fred::h, &amp;Fred::i };
</code></pre>

<p>And your usage of one of the member function pointers is also straightforward:</p>

<pre><code>void userCode(Fred&amp; fred, int memFnNum)
{
  // Assume memFnNum is between 0 and 3 inclusive:
  CALL_MEMBER_FN(fred, a[memFnNum]) ('x', 3.14);
}
</code></pre>

<p>Note: <code>#define</code> macros are <a href="big-picture.html#defn-evil" title="FAQ: What does the FAQ mean by 'such and such is evil'?">evil</a> in 4 different ways: <a href="inline-functions.html#inline-vs-macros" title="FAQ: Why should I use inline functions instead of plain old #define macros?">evil#1</a>,
<a href="misc-technical-issues.html#macros-with-if" title="FAQ: What should be done with macros that contain if?">evil#2</a>, <a href="misc-technical-issues.html#macros-with-multi-stmts" title="FAQ: What should be done with macros that have multiple lines?">evil#3</a>, and <a href="misc-technical-issues.html#macros-with-token-pasting" title="FAQ: What should be done with macros that need to paste two tokens together?">evil#4</a>. But they&#8217;re still
useful sometimes. Feel ashamed, feel guilty, but when an evil construct like a macro improves your software, <a href="big-picture.html#use-evil-things-sometimes" title="FAQ: Will I sometimes use any so-called 'evil' constructs?">use
it</a>.</p>

<h3 id="memfnptr-to-const-memfn">How do I declare a pointer-to-member-function that points to a <code>const</code> member function?</h3>

<p>Short answer: add a <code>const</code> to the right of the <code>)</code> <a href="pointers-to-members.html#typedef-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when creating pointers to members?">when you use a <code>typedef</code> to declare the member-function-pointer
type</a>.</p>

<p>For example, suppose you want a pointer-to-member-function that points at <code>Fred::f</code>, <code>Fred::g</code> or <code>Fred::h</code>:</p>

<pre><code>class Fred {
public:
  int f(int i) const;
  int g(int i) const;
  int h(int j) const;
  // ...
};
</code></pre>

<p>Then <a href="pointers-to-members.html#typedef-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when creating pointers to members?">when you use a <code>typedef</code> to declare the member-function-pointer type</a>, it should look
like this:</p>

<pre><code>// FredMemFn points to a const member-function of Fred that takes (int)
typedef  int (Fred::*FredMemFn)(int) const;
                                     ↑↑↑↑↑ // Points only to member functions decorated with const
</code></pre>

<p>That&#8217;s it!</p>

<p>Then you can declare/pass/return member-function pointers just like normal:</p>

<pre><code>void foo(FredMemFn p)  // Pass a member-function pointer
{ /*...*/ }

FredMemFn bar()        // Return a member-function pointer
{ /*...*/ }

void baz()
{
  FredMemFn p = &amp;Fred::f;  // Declare a member-function pointer
  FredMemFn a[10];         // Declare an array of member-function pointers
  // ...
}
</code></pre>

<h3 id="dotstar-vs-arrowstar">What is the difference between the <code>.*</code> and <code>-&gt;*</code> operators?</h3>

<p>You won&#8217;t need to understand this if you <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">use a macro for member-function-pointer calls</a>. Oh
yea, <em>please</em> <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">use a macro in this case</a>. And did I mention that you should <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">use a macro in this
case</a>??!?</p>

<p>But if you really want to avoid the macro, sigh, groan, okay, here it is: use <code>.*</code> when the left-hand argument is a
reference to an object, and <code>-&gt;*</code> when it is a pointer to an object.</p>

<p>For example:</p>

<pre><code>class Fred { /*...*/ };

typedef  int (Fred::*FredMemFn)(int i, double d);  // use a typedef!!! please!!!

void sample(Fred x, Fred&amp; y, Fred* z, FredMemFn func)
{
  x.*func(42, 3.14);
  y.*func(42, 3.14);
  z-&gt;*func(42, 3.14);
}
</code></pre>

<p><em>BUT</em> please consider <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">using a macro instead</a>:</p>

<pre><code>void sample(Fred x, Fred&amp; y, Fred* z, FredMemFn func)
{
  CALL_MEMBER_FN(x,func)(42, 3.14);
  CALL_MEMBER_FN(y,func)(42, 3.14);
  CALL_MEMBER_FN(*z,func)(42, 3.14);
}
</code></pre>

<p>As discussed <a href="pointers-to-members.html#macro-for-ptr-to-memfn" title="FAQ: How can I avoid syntax errors when calling a member function using a pointer-to-member-function?">earlier</a>, real-world invocations are often much more complicated than the simple
ones here, so using a macro will typically improve your code&#8217;s writability and readability.</p>

<h3 id="cant-cvt-memfnptr-to-voidptr">Can I convert a pointer-to-member-function to a <code>void*</code>?</h3>

<p>No!</p>

<pre><code>class Fred {
public:
  int f(char x, float y);
  int g(char x, float y);
  int h(char x, float y);
  int i(char x, float y);
  // ...
};

// FredMemFn points to a member of Fred that takes (char,float)
typedef  int (Fred::*FredMemFn)(char x, float y);

#define CALL_MEMBER_FN(object,ptrToMember)  ((object).*(ptrToMember))

int callit(Fred&amp; o, FredMemFn p, char x, float y)
{
  return CALL_MEMBER_FN(o,p)(x, y);
}

int main()
{
  FredMemFn p = &amp;Fred::f;
  void* p2 = (void*)p;                  // ← illegal!!
  Fred o;
  callit(o, p, 'x', 3.14f);             // okay
  callit(o, FredMemFn(p2), 'x', 3.14f); // might fail!!
  // ...
}
</code></pre>

<p>Technical details: pointers to member functions and pointers to data are not necessarily represented in the same way. A
pointer to a member function might be a data structure rather than a single pointer. Think about it: if it&#8217;s pointing
at a virtual function, it might not actually be pointing at a statically resolvable pile of code, so it might not even
be a normal address &#8212; it might be a different data structure of some sort.</p>

<p><em>Please</em> do not email me if the above <em>seems to work</em> on your particular version of your particular compiler on your
particular operating system. I don&#8217;t care. It&#8217;s illegal, period.</p>

<h3 id="cant-cvt-fnptr-to-voidptr">Can I convert a pointer-to-function to a <code>void*</code>?</h3>

<p>No!</p>

<pre><code>int f(char x, float y);
int g(char x, float y);

typedef int(*FunctPtr)(char,float);

int callit(FunctPtr p, char x, float y)
{
  return p(x, y);
}

int main()
{
  FunctPtr p = f;
  void* p2 = (void*)p;              // ← illegal!!
  callit(p, 'x', 3.14f);            // okay
  callit(FunctPtr(p2), 'x', 3.14f); // might fail!!
  // ...
}
</code></pre>

<p>Technical details: <code>void*</code> pointers are pointers to data, and function pointers point to functions. The language does
not require functions and data to be in the same address space, so, by way of <em>example</em> and <em>not limitation</em>, on
architectures that have them in different address spaces, the two different pointer types will not be comparable.</p>

<p><em>Please</em> do not email me if the above <em>seems to work</em> on your particular version of your particular compiler on your
particular operating system. I don&#8217;t care. It&#8217;s illegal, period.</p>

<h3 id="functionoids-teaser">I need something like function-pointers, but with more flexibility and/or thread-safety; is there another way?</h3>

<p>Use a functionoid.</p>

<h3 id="functionoids">What the heck is a functionoid, and why would I use one?</h3>

<p>Functionoids are functions on steroids. Functionoids are strictly more powerful than functions, and that extra power
solves some (not all) of the challenges typically faced when you use function-pointers.</p>

<p>Let&#8217;s work an example showing a traditional use of function-pointers, then we&#8217;ll translate that example into
functionoids. The traditional function-pointer idea is to have a bunch of compatible functions:</p>

<pre><code>int funct1( /*...params...*/ ) { /*...code...*/ }
int funct2( /*...params...*/ ) { /*...code...*/ }
int funct3( /*...params...*/ ) { /*...code...*/ }
</code></pre>

<p>Then you access those by function-pointers:</p>

<pre><code>typedef int(*FunctPtr)( /*...params...*/ );

void myCode(FunctPtr f)
{
  // ...
  f( /*...args-go-here...*/ );
  // ...
}
</code></pre>

<p>Sometimes people create an array of these function-pointers:</p>

<pre><code>FunctPtr array[10];
array[0] = funct1;
array[1] = funct1;
array[2] = funct3;
array[3] = funct2;
// ...
</code></pre>

<p>In which case they call the function by accessing the array:</p>

<pre><code>array[i]( /*...args-go-here...*/ );
</code></pre>

<p>With functionoids, you first create a base class with a pure-virtual method:</p>

<pre><code>class Funct {
public:
  virtual int doit(int x) = 0;
  virtual ~Funct() = 0;
};

inline Funct::~Funct() { }  // defined even though it's pure virtual; it's faster this way; trust me
</code></pre>

<p>Then instead of three functions, you create three derived classes:</p>

<pre><code>class Funct1 : public Funct {
public:
  virtual int doit(int x) { /*...code from funct1...*/ }
};

class Funct2 : public Funct {
public:
  virtual int doit(int x) { /*...code from funct2...*/ }
};

class Funct3 : public Funct {
public:
  virtual int doit(int x) { /*...code from funct3...*/ }
};
</code></pre>

<p>Then instead of passing a function-pointer, you pass a <code>Funct*</code>. I&#8217;ll create a <code>typedef</code> called <code>FunctPtr</code> merely to
make the rest of the code similar to the old-fashioned approach:</p>

<pre><code>typedef Funct* FunctPtr;

void myCode(FunctPtr f)
{
  // ...
  f-&gt;doit( /*...args-go-here...*/ );
  // ...
}
</code></pre>

<p>You can create an array of them in almost the same way:</p>

<pre><code>FunctPtr array[10];
array[0] = new Funct1( /*...ctor-args...*/ );
array[1] = new Funct1( /*...ctor-args...*/ );
array[2] = new Funct3( /*...ctor-args...*/ );
array[3] = new Funct2( /*...ctor-args...*/ );
// ...
</code></pre>

<p>This gives us the first hint about where functionoids are strictly more powerful than function-pointers: the fact that
the functionoid approach has arguments you can pass to the ctors (shown above as <em>&#8230;ctor-args&#8230;</em>) whereas the
function-pointers version does not. Think of a functionoid object as a freeze-dried function-call (emphasis on the
word <em>call</em>). Unlike a pointer to a function, a functionoid is (conceptually) a pointer to a <em>partially called</em>
function. Imagine for the moment a technology that lets you pass some-but-not-all arguments to a function, then lets
you freeze-dry that (partially completed) call. Pretend that technology gives you back some sort of magic pointer to
that freeze-dried partially-completed function-call. Then later you pass the <em>remaining</em> args using that pointer, and
the system magically takes your original args (that were freeze-dried), combines them with any local variables that the
function calculated prior to being freeze-dried, combines all that with the newly passed args, and continues the
function&#8217;s execution where it left off when it was freeze-dried. That might sound like science fiction, but it&#8217;s
conceptually what functionoids let you do. <em>Plus</em> they let you repeatedly &#8220;complete&#8221; that freeze-dried function-call
with various different &#8220;remaining parameters,&#8221; as often as you like. <em>Plus</em> they allow (not require) you to change the
freeze-dried state when it gets called, meaning functionoids can remember information from one call to the next.</p>

<p>Let&#8217;s get our feet back on the ground and we&#8217;ll work a couple of examples to explain what all that mumbo jumbo really
means.</p>

<p>Suppose the original functions (in the old-fashioned function-pointer style) took slightly different parameters.</p>

<pre><code>int funct1(int x, float y)
{ /*...code...*/ }

int funct2(int x, const std::string&amp; y, int z)
{ /*...code...*/ }

int funct3(int x, const std::vector&lt;double&gt;&amp; y)
{ /*...code...*/ }
</code></pre>

<p>When the parameters are different, the old-fashioned function-pointers approach is difficult to use, since the caller
doesn&#8217;t know which parameters to pass (the caller merely has a pointer to the function, not the function&#8217;s <em>name</em> or,
when the parameters are different, the number and types of its parameters) (do <em>not</em> write me an email about this; yes
you can do it, but you have to stand on your head and do messy things; but do <em>not</em> write me about it &#8212; use
functionoids instead).</p>

<p>With functionoids, the situation is, at least sometimes, much better. Since a functionoid can be thought of as a
freeze-dried function <em>call</em>, just take the un-common args, such as the ones I&#8217;ve called <code>y</code> and/or <code>z</code>, and make them
args to the corresponding ctors. You may also pass the common args (in this case the <code>int</code> called <code>x</code>) to the ctor, but
you don&#8217;t have to &#8212; you have the option of passing it/them to the pure virtual <code>doit()</code> method instead. I&#8217;ll assume
you want to pass <code>x</code> into <code>doit()</code> and <code>y</code> and/or <code>z</code> into the ctors:</p>

<pre><code>class Funct {
public:
  virtual int doit(int x) = 0;
};
</code></pre>

<p>Then instead of three functions, you create three derived classes:</p>

<pre><code>class Funct1 : public Funct {
public:
  Funct1(float y) : y_(y) { }
  virtual int doit(int x) { /*...code from funct1...*/ }
private:
  float y_;
};

class Funct2 : public Funct {
public:
  Funct2(const std::string&amp; y, int z) : y_(y), z_(z) { }
  virtual int doit(int x) { /*...code from funct2...*/ }
private:
  std::string y_;
  int z_;
};

class Funct3 : public Funct {
public:
  Funct3(const std::vector&lt;double&gt;&amp; y) : y_(y) { }
  virtual int doit(int x) { /*...code from funct3...*/ }
private:
  std::vector&lt;double&gt; y_;
};
</code></pre>

<p>Now you see that the ctor&#8217;s parameters get freeze-dried into the functionoid when you create the array of
functionoids:</p>

<pre><code>FunctPtr array[10];

array[0] = new Funct1(3.14f);

array[1] = new Funct1(2.18f);

std::vector&lt;double&gt; bottlesOfBeerOnTheWall;
bottlesOfBeerOnTheWall.push_back(100);
bottlesOfBeerOnTheWall.push_back(99);
// ...
bottlesOfBeerOnTheWall.push_back(1);
array[2] = new Funct3(bottlesOfBeerOnTheWall);

array[3] = new Funct2("my string", 42);

// ...
</code></pre>

<p>So when the user invokes the <code>doit()</code> on one of these functionoids, he supplies the &#8220;remaining&#8221; args, and the call
conceptually combines the original args passed to the ctor with those passed into the <code>doit()</code> method:</p>

<pre><code>array[i]-&gt;doit(12);
</code></pre>

<p>As I&#8217;ve already hinted, one of the benefits of functionoids is that you can have several instances of, say, <code>Funct1</code> in
your array, and those instances can have different parameters freeze-dried into them. For example, <code>array[0]</code> and
<code>array[1]</code> are both of type <code>Funct1</code>, but the behavior of <code>array[0]-&gt;doit(12)</code> will be different from the behavior of
<code>array[1]-&gt;doit(12)</code> since the behavior will depend on both the 12 that was passed to <code>doit()</code> <em>and</em> the args passed to
the ctors.</p>

<p>Another benefit of functionoids is apparent if we change the example from an array of functionoids to a local
functionoid. To set the stage, let&#8217;s go back to the old-fashioned function-pointer approach, and imagine that you&#8217;re
trying to pass a comparison-function to a <code>sort()</code> or <code>binarySearch()</code> routine. The <code>sort()</code> or <code>binarySearch()</code>
routine is called <code>childRoutine()</code> and the comparison function-pointer type is called <code>FunctPtr</code>:</p>

<pre><code>void childRoutine(FunctPtr f)
{
  // ...
  f( /*...args...*/ );
  // ...
}
</code></pre>

<p>Then different callers would pass different function-pointers depending on what they thought was best:</p>

<pre><code>void myCaller()
{
  // ...
  childRoutine(funct1);
  // ...
}

void yourCaller()
{
  // ...
  childRoutine(funct3);
  // ...
}
</code></pre>

<p>We can easily translate this example into one using functionoids:</p>

<pre><code>void childRoutine(Funct&amp; f)
{
  // ...
  f.doit( /*...args...*/ );
  // ...
}

void myCaller()
{
  // ...
  Funct1 funct( /*...ctor-args...*/ );
  childRoutine(funct);
  // ...
}

void yourCaller()
{
  // ...
  Funct3 funct( /*...ctor-args...*/ );
  childRoutine(funct);
  // ...
}
</code></pre>

<p>Given this example as a backdrop, we can see two benefits of functionoids over function-pointers. The &#8220;ctor args&#8221;
benefit described above, plus the fact that functionoids can maintain state between calls <em>in a thread-safe manner</em>.
With plain function-pointers, people normally maintain state between calls via static data. However static data is not
intrinsically thread-safe &#8212; static data is shared between all threads. The functionoid approach provides you with
something that is <em>intrinsically</em> thread-safe since the code ends up with thread-local data. The implementation is
trivial: change the old-fashioned static datum to an instance data member inside the functionoid&#8217;s <code>this</code> object, and
poof, the data is not only thread-local, but it is even safe with recursive calls: each call to <code>yourCaller()</code> will
have its own distinct <code>Funct3</code> object with its own distinct instance data.</p>

<p>Note that we&#8217;ve gained something without losing anything. If you <em>want</em> thread-global data, functionoids can give you
that too: just change it from an instance data member inside the functionoid&#8217;s <code>this</code> object to a static data member
within the functionoid&#8217;s class, or even to a local-scope static data. You&#8217;d be no better off than with
function-pointers, but you wouldn&#8217;t be worse off either.</p>

<p>The functionoid approach gives you a third option which is not available with the old-fashioned approach: the
functionoid lets callers decide whether <em>they</em> want thread-local or thread-global data. They&#8217;d be responsible to use
locks in cases where they wanted thread-global data, but at least they&#8217;d have the choice. It&#8217;s easy:</p>

<pre><code>void callerWithThreadLocalData()
{
  // ...
  Funct1 funct( /*...declare ctor args here...*/ );
  childRoutine(funct);
  // ...
}

void callerWithThreadGlobalData()
{
  // ...
  static Funct1 funct( /*...declare ctor args here...*/ );  // The static is the only difference
  childRoutine(funct);
  // ...
}
</code></pre>

<p>Functionoids don&#8217;t solve every problem encountered when making flexible software, but they are strictly more powerful
than function-pointers and they are worth at least evaluating. In fact you can easily prove that functionoids don&#8217;t
lose any power over function-pointers, since you can imagine that the old-fashioned approach of function-pointers is
equivalent to having a global(!) functionoid object. Since you can always make a global functionoid object, you haven&#8217;t
lost any ground. QED.</p>

<h3 id="functionoids2">Can you make functionoids faster than normal function calls?</h3>

<p>Yes.</p>

<p>If you have a small functionoid, and in the real world that&#8217;s rather common, the cost of the function-call can be high
compared to the cost of the work done by the functionoid. In <a href="pointers-to-members.html#functionoids" title="FAQ: What the heck is a functionoid, and why would I use one?">the previous FAQ</a>, functionoids were
implemented using <a href="virtual-functions.html" title="Section: Inheritance — virtual functions">virtual functions</a> and will typically cost you a function-call. An alternate
approach uses <a href="templates.html" title="Section: Templates">templates</a>.</p>

<p>The following example is similar in spirit to the one in <a href="pointers-to-members.html#functionoids" title="FAQ: What the heck is a functionoid, and why would I use one?">the previous FAQ</a>. I have renamed <code>doit()</code> to
<code>operator()()</code> to improve the caller code&#8217;s readability and to allow someone to pass a regular function-pointer:</p>

<pre><code>class Funct1 {
public:
  Funct1(float y) : y_(y) { }
  int operator()(int x) { /*...code from funct1...*/ }
private:
  float y_;
};

class Funct2 {
public:
  Funct2(const std::string&amp; y, int z) : y_(y), z_(z) { }
  int operator()(int x) { /*...code from funct2...*/ }
private:
  std::string y_;
  int z_;
};

class Funct3 {
public:
  Funct3(const std::vector&lt;double&gt;&amp; y) : y_(y) { }
  int operator()(int x) { /*...code from funct3...*/ }
private:
  std::vector&lt;double&gt; y_;
};
</code></pre>

<p>The difference between this approach and the one in <a href="pointers-to-members.html#functionoids" title="FAQ: What the heck is a functionoid, and why would I use one?">the previous FAQ</a> is that the fuctionoid gets &#8220;bound&#8221;
to the caller at compile-time rather than at run-time. Think of it as passing in a parameter: if you know at
compile-time the kind of functionoid you ultimately want to pass in, then you can use the above technique, and you can,
<a href="inline-functions.html#inline-and-perf" title="FAQ: Do inline functions improve performance?">at least in typical cases</a>, get a speed benefit from having the compiler
<a href="inline-functions.html" title="Section: Inline Functions">inline-expand</a> the functionoid code within the caller. Here is an example:</p>

<pre><code>template &lt;typename FunctObj&gt;
void myCode(FunctObj f)
{
  // ...
  f( /*...args-go-here...*/ );
  // ...
}
</code></pre>

<p>When the compiler compiles the above, it <a href="inline-functions.html#overview-inline-fns" title="FAQ: What's the deal with inline functions?">might</a> inline-expand the call which
<a href="inline-functions.html#inline-and-perf" title="FAQ: Do inline functions improve performance?">might</a> improve performance.</p>

<p>Here is one way to call the above:</p>

<pre><code>void blah()
{
  // ...
  Funct2 x("functionoids are powerful", 42);
  myCode(x);
  // ...
}
</code></pre>

<p>Aside: as was hinted at in the first paragraph above, you may also pass in the names of normal functions (though you
might incur the cost of the function call when the caller uses these):</p>

<pre><code>void myNormalFunction(int x);

void blah()
{
  // ...
  myCode(myNormalFunction);
  // ...
}
</code></pre>

<h3 id="functor-vs-functionoid">What&#8217;s the difference between a functionoid and a functor?</h3>

<p>A functionoid is an object that has one major method. It&#8217;s basically the OO extension of a C-like function such as
printf(). One would use a functionoid whenever the function has more than one entry point (i.e., more than one &#8220;method&#8221;)
and/or needs to maintain state between calls in a thread-safe manner (the C-style approach to maintaining state
between calls is to add a local &#8220;static&#8221; variable to the function, but that is horribly unsafe in a multi-threaded
environment).</p>

<p>A functor is a special case of a functionoid: it is a functionoid whose method is the &#8220;function-call operator,&#8221;
operator()(). Since it overloads the function-call operator, code can call its major method using the same syntax they
would for a function call. E.g., if &#8220;foo&#8221; is a functor, to call the &#8220;operator()()&#8221; method on the &#8220;foo&#8221; object one would
say &#8220;foo()&#8221;. The benefit of this is in templates, since then the template can have a template parameter that will be
used as a function, and this parameter can be either the name of a function or a functor-object. There is a performance
advantage of it being a functor object since the &#8220;operator()()&#8221; method can be inlined (whereas if you pass the address
of a function it must, necessarily, be non-inlined).</p>

<p>This is very useful for things like the &#8220;comparison&#8221; function on sorted containers. In C, the comparison function is
always passed by pointer (e.g., see the signature to &#8220;qsort()&#8221;), but in C++ the parameter can come in either as a
pointer to function OR as the name of a functor-object, and the result is that sorted containers in C++ can be, in
some cases, a lot faster (and never slower) than the equivalent in C.</p>

<p>Since Java has nothing similar to templates, it must use dynamic binding for all this stuff, and dynamic binding of
necessity means a function call. Normally not a big deal, but in C++ we want to enable extremely high performance
code. That is, C++ has a &#8220;pay for it only if you use it&#8221; philosophy, which means the language must never arbitrarily
impose any overhead over what the physical machine is capable of performing (of course a programmer may, optionally, use
techniques such as dynamic binding that will, in general, impose some overhead in exchange for flexibility or some other
&#8220;ility&#8221;, but it&#8217;s up to the designer and programmer to decide whether they want the benefits (and costs) of such
constructs).</p>

<!--
File: id-defns

Defines IDs for each FAQ and section.

Rule:
  FAQ editors should always use these IDs for every internal cross-reference within the FAQ.
  Always use indirect links ('[description][id-of-target]')  when linking to the FAQ from within the FAQ.
  Never  use  direct  links ('[description](url-of-target)') when linking to the FAQ from within the FAQ.

Reason:
  The FAQ is a living document -- we will split/join sections and move FAQs between sections.
  Those changes result in changes to the URL of the moved FAQs, which breaks all direct links -- many changes.
  However using indirect links means we need only change one thing in one place: this id-defns file.

Caveat:
  This rule applies only to internal cross-reference links, not to links to resources outside the FAQ.
  E.g., if you are making a link from FAQ 'x' to FAQ 'y', then you should always use FAQ 'y's link-ID.
  However if you are making a link from FAQ 'x' to some resource outside the FAQ, you have two choices:
  You can use a direct link to the external resource's URL ('[description](url-of-external-resource)'),
  or you can add the external resource to this file then link indirectly ('[description][id-of-external-resource]').
  Typically you would do the latter only when the FAQ contains more than one link to that external resource.
-->

<p><!-- special resources -->
<!-- /wiki/faq/index = 'C++ FAQ' -->
<!-- /wiki/faq/big-picture = 'Big Picture Issues' -->
<!-- /wiki/faq/classes-and-objects = 'Classes and Objects' -->
<!-- /wiki/faq/references = 'References' -->
<!-- /wiki/faq/inline-functions = 'Inline Functions' -->
<!-- /wiki/faq/ctors = 'Constructors' -->
<!-- /wiki/faq/dtors = 'Destructors' -->
<!-- /wiki/faq/assignment-operators = 'Assignment Operators' -->
<!-- /wiki/faq/operator-overloading = 'Operator Overloading' -->
<!-- /wiki/faq/friends = 'Friends' -->
<!-- /wiki/faq/input-output = 'Input/output via <iostream> and <cstdio>' -->
<!-- /wiki/faq/freestore-mgmt = 'Memory Management' -->
<!-- /wiki/faq/exceptions = 'Exceptions and Error Handling' -->
<!-- /wiki/faq/const-correctness = 'Const Correctness' -->
<!-- /wiki/faq/big3 = 'The Big Three' -->
<!-- /wiki/faq/basics-of-inheritance = 'Inheritance — Basics' -->
<!-- /wiki/faq/virtual-functions = 'Inheritance — virtual functions' -->
<!-- /wiki/faq/proper-inheritance = 'Inheritance — Proper Inheritance and Substitutability' -->
<!-- /wiki/faq/abcs = 'Inheritance — Abstract Base Classes (ABCs)' -->
<!-- /wiki/faq/strange-inheritance = 'Inheritance — What your mother never told you' -->
<!-- /wiki/faq/private-inheritance = 'Inheritance — private and protected inheritance' -->
<!-- /wiki/faq/multiple-inheritance = 'Inheritance — Multiple and Virtual Inheritance' -->
<!-- /wiki/faq/intrinsic-types = 'Built-in / Intrinsic / Primitive Data Types' -->
<!-- /wiki/faq/coding-standards = 'Coding Standards' -->
<!-- /wiki/faq/how-to-learn-cpp = 'Learning C++' -->
<!-- /wiki/faq/newbie = 'Newbie Questions & Answers' -->
<!-- /wiki/faq/objective-c = 'Learning C++ if you already know Objective-C' -->
<!-- /wiki/faq/c = 'Learning C++ if you already know C' -->
<!-- /wiki/faq/csharp-java = 'Learning C++ if you already know C# or Java' -->
<!-- /wiki/faq/myths = 'Myths and Urban Legends About C++' -->
<!-- /wiki/faq/value-vs-ref-semantics = 'Reference and Value Semantics' -->
<!-- /wiki/faq/mixing-c-and-cpp = 'How to mix C and C++' -->
<!-- /wiki/faq/pointers-to-members = 'Pointers to Member Functions' -->
<!-- /wiki/faq/containers = 'Container Classes' -->
<!-- /wiki/faq/templates = 'Templates' -->
<!-- /wiki/faq/serialization = 'Serialization and Unserialization' -->
<!-- /wiki/faq/class-libraries = 'Class Libraries' -->
<!-- /wiki/faq/compiler-dependencies = 'Compiler Dependencies' -->
<!-- /wiki/faq/misc-technical-issues = 'Miscellaneous Technical Issues' -->
<!-- /wiki/faq/misc-environmental-issues = 'Miscellaneous Environmental Issues' -->
<!-- /wiki/faq/style-and-techniques = 'Miscellaneous Style Issues' -->
<!-- /wiki/faq/user-groups-worldwide = 'User Groups Worldwide' -->
<!-- /wiki/faq/cpp11 = 'C++11 Overview' -->
<!-- /wiki/faq/cpp11-language = 'C++11 Language Extensions --- General Features' -->
<!-- /wiki/faq/cpp11-language-classes = 'C++11 Language Extensions -- Classes' -->
<!-- /wiki/faq/cpp11-language-concurrency = 'C++11 Language Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-language-misc = 'C++11 Language Extensions --- Miscellaneous Language Features' -->
<!-- /wiki/faq/cpp11-language-templates = 'C++11 Language Extensions -- Templates' -->
<!-- /wiki/faq/cpp11-language-types = 'C++11 Language Extensions --- Other Types' -->
<!-- /wiki/faq/cpp11-library = 'C++11 Library Extensions --- General Libraries' -->
<!-- /wiki/faq/cpp11-library-concurrency = 'C++11 Standard Library Extensions --- Concurrency' -->
<!-- /wiki/faq/cpp11-library-stl = 'C++11 Standard Library Extensions --- Containers and Algorithms' -->
<!-- /wiki/faq/cpp0x-concepts-history = 'C++0x Concepts --- Historical FAQs' -->
<!-- /wiki/faq/cpp14 = 'C++14 Overview' -->
<!-- /wiki/faq/cpp14-language = 'C++14 Language Extensions' -->
<!-- /wiki/faq/cpp14-library = 'C++14 Library Extensions' -->
<!-- /wiki/faq/wg21 = 'WG21 Members' -->
<!-- /wiki/faq/subject-index = 'Subject Index' --></p>

<!-- BEGIN 'Category' Namespace Stuff -->


<!-- END 'Category' Namespace Stuff -->


<!-- BEGIN Categories for Page -->


<!-- END Categories for Page -->


</div>


          </div>

        </article>

      </div>
      
<div id="popup-suggest" class="wiki-popup">
  <p>Please <a href="../../member/login.html">Login</a> to submit a recommendation.</p>
  <p>If you don&rsquo;t have an account, you can <a href="../../member/register.html">register for free.</a></p>
</div>

        </div>
        
        <div id="root-footer"></div>
      </div>
    </div>

    <footer id="bottom" role="contentinfo">
      <div class="container">
        &copy; <a href="../../home/terms-of-use.html">Copyright</a> 2015 Standard C++ Foundation. 
        All rights reserved. 
        <ul id="nav-sub">
<li class="first"><a href="../../home/terms-of-use.html">Terms of Use</a></li>
<li class="last"><a href="../../home/privacy-policy.html">Privacy Policy</a></li>
</ul>
      </div>
    </footer>

    <script src="../../../ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../javascript/jquery.html"><\/script>')</script>
    <script src="../../../ajax.googleapis.com/ajax/libs/jqueryui/1.10.1/jquery-ui.min.js"></script>
    <script>window.jQuery.ui || document.write('<script src="../../javascript/jquery-ui.html"><\/script>')</script>
    
    <script type="text/javascript" charset="utf-8" src="../../index97fd.html?ACT=comment_editor"></script>
    <script type="text/javascript">
	        					$(document).ready(function() {
									$("*[id^=likee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/pointers-to-members",
	   										data: "likee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#dislikee_"+c+id).replaceWith("<span>"+$("#dislikee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())+1);
	 									$("#likeeCount_"+c+id).html(parseInt($("#likeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
									
									$("*[id^=dislikee_]").click(function(){
										var ids = $(this).attr("id").split("_");
										if (ids[1]=="c"){
											id=ids[2];
											c="c_";
											isCom="true";
										} else {
											id=ids[1];
											c="";
											isCom="false";
										}
										$.ajax({
	   										type: "POST",
	   										url: "/wiki/faq/pointers-to-members",
	   										data: "dislikee=true&entry_id="+id+"&isCom="+isCom,
	   										success: function(msg){
	     										//alert( "Data Saved: " + msg );
	   										}
	 									});
	 									
	 									$(this).replaceWith("<strong>"+$(this).html()+"</strong>");
	 									$("#likee_"+c+id).replaceWith("<span>"+$("#likee_"+c+id).html()+"</span>");
	 									$("#scoreeCount_"+c+id).html(parseInt($("#scoreeCount_"+c+id).html())-1);
	 									$("#dislikeeCount_"+c+id).html(parseInt($("#dislikeeCount_"+c+id).html())+1);
	 									$("#likeeReplace_"+c+id).replaceWith("");
	 									$("#likeeShow_"+c+id).replaceWith($("#likeeShow_"+c+id).html());
									});
								
								});	
	        			  </script>
    
    <script type="text/javascript" src="../../js/isocpp.min.js"></script>
    
    <script type="text/javascript" src="../../js/magnific.min.js"></script>
    <script type="text/javascript" src="../../js/qtip.min.js"></script>
    <script type="text/javascript" src="../../themes/wiki_themes/isocpp/javascript/wiki57ff.js?v=20140115"></script>
    
    <script type="text/javascript">
      $("#top nav a").each(function() {
        var aSeg1 = $(this).attr("href").replace("http://", "").replace("https:///", "").split("../../index.html")[1];
        if (aSeg1 == "wiki") {$(this).parent().addClass("here");}
      });
    </script>

  </body>

<!-- Mirrored from isocpp.org/wiki/faq/pointers-to-members by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 01 Aug 2015 12:41:42 GMT -->
</html>
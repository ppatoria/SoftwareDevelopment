<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/boost/operators.hpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:10:41 GMT -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<title>boost/operators.hpp - 1.54.0</title>  <link rel="icon" href="http://www.boost.org/favicon.ico" type="image/ico" />
  <link rel="stylesheet" type="text/css" href="http://www.boost.org/style-v2/section-doc.css" />
  <!--[if IE 7]> <style type="text/css"> body { behavior: url(/style-v2/csshover3.htc); } </style> <![endif]-->

</head>

<body>
  <div id="heading">
    <div class="heading-inner">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
  <a href="http://www.boost.org/">
  <img src="http://www.boost.org/gfx/space.png" alt= "Boost C++ Libraries" class="heading-logo" />
  <span class="heading-boost">Boost</span>
  <span class="heading-cpplibraries">C++ Libraries</span>
  </a></h1>

  <p class="heading-quote">
  <q>...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.</q> <span class="heading-attribution">&mdash; <a href=
  "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
  "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
  Alexandrescu</a>, <a href=
  "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
  Coding Standards</a></span></p>
</div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33761719-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </div>

  <div id="body">
    <div id="body-inner">
      <div id="content">
        <div class="section" id="docs">
          <div class="section-0">
            <div class="section-body">
              <h3>boost/operators.hpp</h3>
<pre>
//  Boost operators.hpp header file  ----------------------------------------//

//  (C) Copyright David Abrahams, Jeremy Siek, Daryle Walker 1999-2001.
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)

//  See <a href="http://www.boost.org/libs/utility/operators.htm">http://www.boost.org/libs/utility/operators.htm</a> for documentation.

//  Revision History
//  16 Dec 10 Limit warning suppression for 4284 to older versions of VC++
//            (Matthew Bradbury, fixes #4432)
//  07 Aug 08 Added &quot;euclidean&quot; spelling. (Daniel Frey)
//  03 Apr 08 Make sure &quot;convertible to bool&quot; is sufficient
//            for T::operator&lt;, etc. (Daniel Frey)
//  24 May 07 Changed empty_base to depend on T, see
//            <a href="http://svn.boost.org/trac/boost/ticket/979">http://svn.boost.org/trac/boost/ticket/979</a>
//  21 Oct 02 Modified implementation of operators to allow compilers with a
//            correct named return value optimization (NRVO) to produce optimal
//            code.  (Daniel Frey)
//  02 Dec 01 Bug fixed in random_access_iteratable.  (Helmut Zeisel)
//  28 Sep 01 Factored out iterator operator groups.  (Daryle Walker)
//  27 Aug 01 'left' form for non commutative operators added;
//            additional classes for groups of related operators added;
//            workaround for empty base class optimization
//            bug of GCC 3.0 (Helmut Zeisel)
//  25 Jun 01 output_iterator_helper changes: removed default template 
//            parameters, added support for self-proxying, additional 
//            documentation and tests (Aleksey Gurtovoy)
//  29 May 01 Added operator classes for &lt;&lt; and &gt;&gt;.  Added input and output
//            iterator helper classes.  Added classes to connect equality and
//            relational operators.  Added classes for groups of related
//            operators.  Reimplemented example operator and iterator helper
//            classes in terms of the new groups.  (Daryle Walker, with help
//            from Alexy Gurtovoy)
//  11 Feb 01 Fixed bugs in the iterator helpers which prevented explicitly
//            supplied arguments from actually being used (Dave Abrahams)
//  04 Jul 00 Fixed NO_OPERATORS_IN_NAMESPACE bugs, major cleanup and
//            refactoring of compiler workarounds, additional documentation
//            (Alexy Gurtovoy and Mark Rodgers with some help and prompting from
//            Dave Abrahams) 
//  28 Jun 00 General cleanup and integration of bugfixes from Mark Rodgers and
//            Jeremy Siek (Dave Abrahams)
//  20 Jun 00 Changes to accommodate Borland C++Builder 4 and Borland C++ 5.5
//            (Mark Rodgers)
//  20 Jun 00 Minor fixes to the prior revision (Aleksey Gurtovoy)
//  10 Jun 00 Support for the base class chaining technique was added
//            (Aleksey Gurtovoy). See documentation and the comments below 
//            for the details. 
//  12 Dec 99 Initial version with iterator operators (Jeremy Siek)
//  18 Nov 99 Change name &quot;divideable&quot; to &quot;dividable&quot;, remove unnecessary
//            specializations of dividable, subtractable, modable (Ed Brey) 
//  17 Nov 99 Add comments (Beman Dawes)
//            Remove unnecessary specialization of operators&lt;&gt; (Ed Brey)
//  15 Nov 99 Fix less_than_comparable&lt;T,U&gt; second operand type for first two
//            operators.(Beman Dawes)
//  12 Nov 99 Add operators templates (Ed Brey)
//  11 Nov 99 Add single template parameter version for compilers without
//            partial specialization (Beman Dawes)
//  10 Nov 99 Initial version

// 10 Jun 00:
// An additional optional template parameter was added to most of 
// operator templates to support the base class chaining technique (see 
// documentation for the details). Unfortunately, a straightforward
// implementation of this change would have broken compatibility with the
// previous version of the library by making it impossible to use the same
// template name (e.g. 'addable') for both the 1- and 2-argument versions of
// an operator template. This implementation solves the backward-compatibility
// issue at the cost of some simplicity.
//
// One of the complications is an existence of special auxiliary class template
// 'is_chained_base&lt;&gt;' (see 'detail' namespace below), which is used
// to determine whether its template parameter is a library's operator template
// or not. You have to specialize 'is_chained_base&lt;&gt;' for each new 
// operator template you add to the library.
//
// However, most of the non-trivial implementation details are hidden behind 
// several local macros defined below, and as soon as you understand them,
// you understand the whole library implementation. 

#ifndef BOOST_OPERATORS_HPP
#define BOOST_OPERATORS_HPP

#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/config.hpp">boost/config.hpp</a>&gt;
#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/iterator.hpp">boost/iterator.hpp</a>&gt;
#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/detail/workaround.hpp">boost/detail/workaround.hpp</a>&gt;

#if defined(__sgi) &amp;&amp; !defined(__GNUC__)
#   pragma set woff 1234
#endif

#if BOOST_WORKAROUND(BOOST_MSVC, &lt; 1600)
#   pragma warning( disable : 4284 ) // complaint about return type of 
#endif                               // operator-&gt; not begin a UDT

namespace boost {
namespace detail {

template &lt;typename T&gt; class empty_base {

// Helmut Zeisel, empty base class optimization bug with GCC 3.0.0
#if defined(__GNUC__) &amp;&amp; __GNUC__==3 &amp;&amp; __GNUC_MINOR__==0 &amp;&amp; __GNU_PATCHLEVEL__==0
  bool dummy; 
#endif

};

} // namespace detail
} // namespace boost

// In this section we supply the xxxx1 and xxxx2 forms of the operator
// templates, which are explicitly targeted at the 1-type-argument and
// 2-type-argument operator forms, respectively. Some compilers get confused
// when inline friend functions are overloaded in namespaces other than the
// global namespace. When BOOST_NO_OPERATORS_IN_NAMESPACE is defined, all of
// these templates must go in the global namespace.

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
namespace boost
{
#endif

//  Basic operator classes (contributed by Dave Abrahams) ------------------//

//  Note that friend functions defined in a class are implicitly inline.
//  See the C++ std, 11.4 [class.friend] paragraph 5

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct less_than_comparable2 : B
{
     friend bool operator&lt;=(const T&amp; x, const U&amp; y) { return !static_cast&lt;bool&gt;(x &gt; y); }
     friend bool operator&gt;=(const T&amp; x, const U&amp; y) { return !static_cast&lt;bool&gt;(x &lt; y); }
     friend bool operator&gt;(const U&amp; x, const T&amp; y)  { return y &lt; x; }
     friend bool operator&lt;(const U&amp; x, const T&amp; y)  { return y &gt; x; }
     friend bool operator&lt;=(const U&amp; x, const T&amp; y) { return !static_cast&lt;bool&gt;(y &lt; x); }
     friend bool operator&gt;=(const U&amp; x, const T&amp; y) { return !static_cast&lt;bool&gt;(y &gt; x); }
};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct less_than_comparable1 : B
{
     friend bool operator&gt;(const T&amp; x, const T&amp; y)  { return y &lt; x; }
     friend bool operator&lt;=(const T&amp; x, const T&amp; y) { return !static_cast&lt;bool&gt;(y &lt; x); }
     friend bool operator&gt;=(const T&amp; x, const T&amp; y) { return !static_cast&lt;bool&gt;(x &lt; y); }
};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct equality_comparable2 : B
{
     friend bool operator==(const U&amp; y, const T&amp; x) { return x == y; }
     friend bool operator!=(const U&amp; y, const T&amp; x) { return !static_cast&lt;bool&gt;(x == y); }
     friend bool operator!=(const T&amp; y, const U&amp; x) { return !static_cast&lt;bool&gt;(y == x); }
};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct equality_comparable1 : B
{
     friend bool operator!=(const T&amp; x, const T&amp; y) { return !static_cast&lt;bool&gt;(x == y); }
};

// A macro which produces &quot;name_2left&quot; from &quot;name&quot;.
#define BOOST_OPERATOR2_LEFT(name) name##2##_##left

//  NRVO-friendly implementation (contributed by Daniel Frey) ---------------//

#if defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

// This is the optimal implementation for ISO/ANSI C++,
// but it requires the compiler to implement the NRVO.
// If the compiler has no NRVO, this is the best symmetric
// implementation available.

#define BOOST_BINARY_OPERATOR_COMMUTATIVE( NAME, OP )                         \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;        \
struct NAME##2 : B                                                            \
{                                                                             \
  friend T operator OP( const T&amp; lhs, const U&amp; rhs )                          \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                              \
  friend T operator OP( const U&amp; lhs, const T&amp; rhs )                          \
    { T nrv( rhs ); nrv OP##= lhs; return nrv; }                              \
};                                                                            \
                                                                              \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;                 \
struct NAME##1 : B                                                            \
{                                                                             \
  friend T operator OP( const T&amp; lhs, const T&amp; rhs )                          \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                              \
};

#define BOOST_BINARY_OPERATOR_NON_COMMUTATIVE( NAME, OP )               \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;  \
struct NAME##2 : B                                                      \
{                                                                       \
  friend T operator OP( const T&amp; lhs, const U&amp; rhs )                    \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                        \
};                                                                      \
                                                                        \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;  \
struct BOOST_OPERATOR2_LEFT(NAME) : B                                   \
{                                                                       \
  friend T operator OP( const U&amp; lhs, const T&amp; rhs )                    \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                        \
};                                                                      \
                                                                        \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;           \
struct NAME##1 : B                                                      \
{                                                                       \
  friend T operator OP( const T&amp; lhs, const T&amp; rhs )                    \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                        \
};

#else // defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

// For compilers without NRVO the following code is optimal, but not
// symmetric!  Note that the implementation of
// BOOST_OPERATOR2_LEFT(NAME) only looks cool, but doesn't provide
// optimization opportunities to the compiler :)

#define BOOST_BINARY_OPERATOR_COMMUTATIVE( NAME, OP )                   \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;  \
struct NAME##2 : B                                                      \
{                                                                       \
  friend T operator OP( T lhs, const U&amp; rhs ) { return lhs OP##= rhs; } \
  friend T operator OP( const U&amp; lhs, T rhs ) { return rhs OP##= lhs; } \
};                                                                      \
                                                                        \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;           \
struct NAME##1 : B                                                      \
{                                                                       \
  friend T operator OP( T lhs, const T&amp; rhs ) { return lhs OP##= rhs; } \
};

#define BOOST_BINARY_OPERATOR_NON_COMMUTATIVE( NAME, OP )               \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;  \
struct NAME##2 : B                                                      \
{                                                                       \
  friend T operator OP( T lhs, const U&amp; rhs ) { return lhs OP##= rhs; } \
};                                                                      \
                                                                        \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;  \
struct BOOST_OPERATOR2_LEFT(NAME) : B                                   \
{                                                                       \
  friend T operator OP( const U&amp; lhs, const T&amp; rhs )                    \
    { return T( lhs ) OP##= rhs; }                                      \
};                                                                      \
                                                                        \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;           \
struct NAME##1 : B                                                      \
{                                                                       \
  friend T operator OP( T lhs, const T&amp; rhs ) { return lhs OP##= rhs; } \
};

#endif // defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

BOOST_BINARY_OPERATOR_COMMUTATIVE( multipliable, * )
BOOST_BINARY_OPERATOR_COMMUTATIVE( addable, + )
BOOST_BINARY_OPERATOR_NON_COMMUTATIVE( subtractable, - )
BOOST_BINARY_OPERATOR_NON_COMMUTATIVE( dividable, / )
BOOST_BINARY_OPERATOR_NON_COMMUTATIVE( modable, % )
BOOST_BINARY_OPERATOR_COMMUTATIVE( xorable, ^ )
BOOST_BINARY_OPERATOR_COMMUTATIVE( andable, &amp; )
BOOST_BINARY_OPERATOR_COMMUTATIVE( orable, | )

#undef BOOST_BINARY_OPERATOR_COMMUTATIVE
#undef BOOST_BINARY_OPERATOR_NON_COMMUTATIVE
#undef BOOST_OPERATOR2_LEFT

//  incrementable and decrementable contributed by Jeremy Siek

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct incrementable : B
{
  friend T operator++(T&amp; x, int)
  {
    incrementable_type nrv(x);
    ++x;
    return nrv;
  }
private: // The use of this typedef works around a Borland bug
  typedef T incrementable_type;
};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct decrementable : B
{
  friend T operator--(T&amp; x, int)
  {
    decrementable_type nrv(x);
    --x;
    return nrv;
  }
private: // The use of this typedef works around a Borland bug
  typedef T decrementable_type;
};

//  Iterator operator classes (contributed by Jeremy Siek) ------------------//

template &lt;class T, class P, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct dereferenceable : B
{
  P operator-&gt;() const
  { 
    return &amp;*static_cast&lt;const T&amp;&gt;(*this); 
  }
};

template &lt;class T, class I, class R, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct indexable : B
{
  R operator[](I n) const
  {
    return *(static_cast&lt;const T&amp;&gt;(*this) + n);
  }
};

//  More operator classes (contributed by Daryle Walker) --------------------//
//  (NRVO-friendly implementation contributed by Daniel Frey) ---------------//

#if defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

#define BOOST_BINARY_OPERATOR( NAME, OP )                                     \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;        \
struct NAME##2 : B                                                            \
{                                                                             \
  friend T operator OP( const T&amp; lhs, const U&amp; rhs )                          \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                              \
};                                                                            \
                                                                              \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;                 \
struct NAME##1 : B                                                            \
{                                                                             \
  friend T operator OP( const T&amp; lhs, const T&amp; rhs )                          \
    { T nrv( lhs ); nrv OP##= rhs; return nrv; }                              \
};

#else // defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

#define BOOST_BINARY_OPERATOR( NAME, OP )                                     \
template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;        \
struct NAME##2 : B                                                            \
{                                                                             \
  friend T operator OP( T lhs, const U&amp; rhs ) { return lhs OP##= rhs; }       \
};                                                                            \
                                                                              \
template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;                 \
struct NAME##1 : B                                                            \
{                                                                             \
  friend T operator OP( T lhs, const T&amp; rhs ) { return lhs OP##= rhs; }       \
};

#endif // defined(BOOST_HAS_NRVO) || defined(BOOST_FORCE_SYMMETRIC_OPERATORS)

BOOST_BINARY_OPERATOR( left_shiftable, &lt;&lt; )
BOOST_BINARY_OPERATOR( right_shiftable, &gt;&gt; )

#undef BOOST_BINARY_OPERATOR

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct equivalent2 : B
{
  friend bool operator==(const T&amp; x, const U&amp; y)
  {
    return !static_cast&lt;bool&gt;(x &lt; y) &amp;&amp; !static_cast&lt;bool&gt;(x &gt; y);
  }
};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct equivalent1 : B
{
  friend bool operator==(const T&amp;x, const T&amp;y)
  {
    return !static_cast&lt;bool&gt;(x &lt; y) &amp;&amp; !static_cast&lt;bool&gt;(y &lt; x);
  }
};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct partially_ordered2 : B
{
  friend bool operator&lt;=(const T&amp; x, const U&amp; y)
    { return static_cast&lt;bool&gt;(x &lt; y) || static_cast&lt;bool&gt;(x == y); }
  friend bool operator&gt;=(const T&amp; x, const U&amp; y)
    { return static_cast&lt;bool&gt;(x &gt; y) || static_cast&lt;bool&gt;(x == y); }
  friend bool operator&gt;(const U&amp; x, const T&amp; y)
    { return y &lt; x; }
  friend bool operator&lt;(const U&amp; x, const T&amp; y)
    { return y &gt; x; }
  friend bool operator&lt;=(const U&amp; x, const T&amp; y)
    { return static_cast&lt;bool&gt;(y &gt; x) || static_cast&lt;bool&gt;(y == x); }
  friend bool operator&gt;=(const U&amp; x, const T&amp; y)
    { return static_cast&lt;bool&gt;(y &lt; x) || static_cast&lt;bool&gt;(y == x); }
};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct partially_ordered1 : B
{
  friend bool operator&gt;(const T&amp; x, const T&amp; y)
    { return y &lt; x; }
  friend bool operator&lt;=(const T&amp; x, const T&amp; y)
    { return static_cast&lt;bool&gt;(x &lt; y) || static_cast&lt;bool&gt;(x == y); }
  friend bool operator&gt;=(const T&amp; x, const T&amp; y)
    { return static_cast&lt;bool&gt;(y &lt; x) || static_cast&lt;bool&gt;(x == y); }
};

//  Combined operator classes (contributed by Daryle Walker) ----------------//

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct totally_ordered2
    : less_than_comparable2&lt;T, U
    , equality_comparable2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct totally_ordered1
    : less_than_comparable1&lt;T
    , equality_comparable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct additive2
    : addable2&lt;T, U
    , subtractable2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct additive1
    : addable1&lt;T
    , subtractable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct multiplicative2
    : multipliable2&lt;T, U
    , dividable2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct multiplicative1
    : multipliable1&lt;T
    , dividable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct integer_multiplicative2
    : multiplicative2&lt;T, U
    , modable2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct integer_multiplicative1
    : multiplicative1&lt;T
    , modable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct arithmetic2
    : additive2&lt;T, U
    , multiplicative2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct arithmetic1
    : additive1&lt;T
    , multiplicative1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct integer_arithmetic2
    : additive2&lt;T, U
    , integer_multiplicative2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct integer_arithmetic1
    : additive1&lt;T
    , integer_multiplicative1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct bitwise2
    : xorable2&lt;T, U
    , andable2&lt;T, U
    , orable2&lt;T, U, B
      &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct bitwise1
    : xorable1&lt;T
    , andable1&lt;T
    , orable1&lt;T, B
      &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct unit_steppable
    : incrementable&lt;T
    , decrementable&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct shiftable2
    : left_shiftable2&lt;T, U
    , right_shiftable2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct shiftable1
    : left_shiftable1&lt;T
    , right_shiftable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ring_operators2
    : additive2&lt;T, U
    , subtractable2_left&lt;T, U
    , multipliable2&lt;T, U, B
      &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ring_operators1
    : additive1&lt;T
    , multipliable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_ring_operators2
    : ring_operators2&lt;T, U
    , totally_ordered2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_ring_operators1
    : ring_operators1&lt;T
    , totally_ordered1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct field_operators2
    : ring_operators2&lt;T, U
    , dividable2&lt;T, U
    , dividable2_left&lt;T, U, B
      &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct field_operators1
    : ring_operators1&lt;T
    , dividable1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_field_operators2
    : field_operators2&lt;T, U
    , totally_ordered2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_field_operators1
    : field_operators1&lt;T
    , totally_ordered1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct euclidian_ring_operators2
    : ring_operators2&lt;T, U
    , dividable2&lt;T, U
    , dividable2_left&lt;T, U
    , modable2&lt;T, U
    , modable2_left&lt;T, U, B
      &gt; &gt; &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct euclidian_ring_operators1
    : ring_operators1&lt;T
    , dividable1&lt;T
    , modable1&lt;T, B
      &gt; &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_euclidian_ring_operators2
    : totally_ordered2&lt;T, U
    , euclidian_ring_operators2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_euclidian_ring_operators1
    : totally_ordered1&lt;T
    , euclidian_ring_operators1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct euclidean_ring_operators2
    : ring_operators2&lt;T, U
    , dividable2&lt;T, U
    , dividable2_left&lt;T, U
    , modable2&lt;T, U
    , modable2_left&lt;T, U, B
      &gt; &gt; &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct euclidean_ring_operators1
    : ring_operators1&lt;T
    , dividable1&lt;T
    , modable1&lt;T, B
      &gt; &gt; &gt; {};

template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_euclidean_ring_operators2
    : totally_ordered2&lt;T, U
    , euclidean_ring_operators2&lt;T, U, B
      &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct ordered_euclidean_ring_operators1
    : totally_ordered1&lt;T
    , euclidean_ring_operators1&lt;T, B
      &gt; &gt; {};

template &lt;class T, class P, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct input_iteratable
    : equality_comparable1&lt;T
    , incrementable&lt;T
    , dereferenceable&lt;T, P, B
      &gt; &gt; &gt; {};

template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct output_iteratable
    : incrementable&lt;T, B
      &gt; {};

template &lt;class T, class P, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct forward_iteratable
    : input_iteratable&lt;T, P, B
      &gt; {};

template &lt;class T, class P, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct bidirectional_iteratable
    : forward_iteratable&lt;T, P
    , decrementable&lt;T, B
      &gt; &gt; {};

//  To avoid repeated derivation from equality_comparable,
//  which is an indirect base class of bidirectional_iterable,
//  random_access_iteratable must not be derived from totally_ordered1
//  but from less_than_comparable1 only. (Helmut Zeisel, 02-Dec-2001)
template &lt;class T, class P, class D, class R, class B = ::boost::detail::empty_base&lt;T&gt; &gt;
struct random_access_iteratable
    : bidirectional_iteratable&lt;T, P
    , less_than_comparable1&lt;T
    , additive2&lt;T, D
    , indexable&lt;T, D, R, B
      &gt; &gt; &gt; &gt; {};

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE
} // namespace boost
#endif // BOOST_NO_OPERATORS_IN_NAMESPACE


// BOOST_IMPORT_TEMPLATE1 .. BOOST_IMPORT_TEMPLATE4 -
//
// When BOOST_NO_OPERATORS_IN_NAMESPACE is defined we need a way to import an
// operator template into the boost namespace. BOOST_IMPORT_TEMPLATE1 is used
// for one-argument forms of operator templates; BOOST_IMPORT_TEMPLATE2 for
// two-argument forms. Note that these macros expect to be invoked from within
// boost.

#ifndef BOOST_NO_OPERATORS_IN_NAMESPACE

  // The template is already in boost so we have nothing to do.
# define BOOST_IMPORT_TEMPLATE4(template_name)
# define BOOST_IMPORT_TEMPLATE3(template_name)
# define BOOST_IMPORT_TEMPLATE2(template_name)
# define BOOST_IMPORT_TEMPLATE1(template_name)

#else // BOOST_NO_OPERATORS_IN_NAMESPACE

#  ifndef BOOST_NO_USING_TEMPLATE

     // Bring the names in with a using-declaration
     // to avoid stressing the compiler.
#    define BOOST_IMPORT_TEMPLATE4(template_name) using ::template_name;
#    define BOOST_IMPORT_TEMPLATE3(template_name) using ::template_name;
#    define BOOST_IMPORT_TEMPLATE2(template_name) using ::template_name;
#    define BOOST_IMPORT_TEMPLATE1(template_name) using ::template_name;

#  else

     // Otherwise, because a Borland C++ 5.5 bug prevents a using declaration
     // from working, we are forced to use inheritance for that compiler.
#    define BOOST_IMPORT_TEMPLATE4(template_name)                                             \
     template &lt;class T, class U, class V, class W, class B = ::boost::detail::empty_base&lt;T&gt; &gt; \
     struct template_name : ::template_name&lt;T, U, V, W, B&gt; {};

#    define BOOST_IMPORT_TEMPLATE3(template_name)                                    \
     template &lt;class T, class U, class V, class B = ::boost::detail::empty_base&lt;T&gt; &gt; \
     struct template_name : ::template_name&lt;T, U, V, B&gt; {};

#    define BOOST_IMPORT_TEMPLATE2(template_name)                           \
     template &lt;class T, class U, class B = ::boost::detail::empty_base&lt;T&gt; &gt; \
     struct template_name : ::template_name&lt;T, U, B&gt; {};

#    define BOOST_IMPORT_TEMPLATE1(template_name)                  \
     template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt; \
     struct template_name : ::template_name&lt;T, B&gt; {};

#  endif // BOOST_NO_USING_TEMPLATE

#endif // BOOST_NO_OPERATORS_IN_NAMESPACE

//
// Here's where we put it all together, defining the xxxx forms of the templates
// in namespace boost. We also define specializations of is_chained_base&lt;&gt; for
// the xxxx, xxxx1, and xxxx2 templates, importing them into boost:: as
// necessary.
//
#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

// is_chained_base&lt;&gt; - a traits class used to distinguish whether an operator
// template argument is being used for base class chaining, or is specifying a
// 2nd argument type.

namespace boost {
// A type parameter is used instead of a plain bool because Borland's compiler
// didn't cope well with the more obvious non-type template parameter.
namespace detail {
  struct true_t {};
  struct false_t {};
} // namespace detail

// Unspecialized version assumes that most types are not being used for base
// class chaining. We specialize for the operator templates defined in this
// library.
template&lt;class T&gt; struct is_chained_base {
  typedef ::boost::detail::false_t value;
};

} // namespace boost

// Import a 4-type-argument operator template into boost (if necessary) and
// provide a specialization of 'is_chained_base&lt;&gt;' for it.
# define BOOST_OPERATOR_TEMPLATE4(template_name4)                     \
  BOOST_IMPORT_TEMPLATE4(template_name4)                              \
  template&lt;class T, class U, class V, class W, class B&gt;               \
  struct is_chained_base&lt; ::boost::template_name4&lt;T, U, V, W, B&gt; &gt; {  \
    typedef ::boost::detail::true_t value;                            \
  };

// Import a 3-type-argument operator template into boost (if necessary) and
// provide a specialization of 'is_chained_base&lt;&gt;' for it.
# define BOOST_OPERATOR_TEMPLATE3(template_name3)                     \
  BOOST_IMPORT_TEMPLATE3(template_name3)                              \
  template&lt;class T, class U, class V, class B&gt;                        \
  struct is_chained_base&lt; ::boost::template_name3&lt;T, U, V, B&gt; &gt; {     \
    typedef ::boost::detail::true_t value;                            \
  };

// Import a 2-type-argument operator template into boost (if necessary) and
// provide a specialization of 'is_chained_base&lt;&gt;' for it.
# define BOOST_OPERATOR_TEMPLATE2(template_name2)                  \
  BOOST_IMPORT_TEMPLATE2(template_name2)                           \
  template&lt;class T, class U, class B&gt;                              \
  struct is_chained_base&lt; ::boost::template_name2&lt;T, U, B&gt; &gt; {     \
    typedef ::boost::detail::true_t value;                         \
  };

// Import a 1-type-argument operator template into boost (if necessary) and
// provide a specialization of 'is_chained_base&lt;&gt;' for it.
# define BOOST_OPERATOR_TEMPLATE1(template_name1)                  \
  BOOST_IMPORT_TEMPLATE1(template_name1)                           \
  template&lt;class T, class B&gt;                                       \
  struct is_chained_base&lt; ::boost::template_name1&lt;T, B&gt; &gt; {        \
    typedef ::boost::detail::true_t value;                         \
  };

// BOOST_OPERATOR_TEMPLATE(template_name) defines template_name&lt;&gt; such that it
// can be used for specifying both 1-argument and 2-argument forms. Requires the
// existence of two previously defined class templates named '&lt;template_name&gt;1'
// and '&lt;template_name&gt;2' which must implement the corresponding 1- and 2-
// argument forms.
//
// The template type parameter O == is_chained_base&lt;U&gt;::value is used to
// distinguish whether the 2nd argument to &lt;template_name&gt; is being used for
// base class chaining from another boost operator template or is describing a
// 2nd operand type. O == true_t only when U is actually an another operator
// template from the library. Partial specialization is used to select an
// implementation in terms of either '&lt;template_name&gt;1' or '&lt;template_name&gt;2'.
//

# define BOOST_OPERATOR_TEMPLATE(template_name)                    \
template &lt;class T                                                  \
         ,class U = T                                              \
         ,class B = ::boost::detail::empty_base&lt;T&gt;                 \
         ,class O = typename is_chained_base&lt;U&gt;::value             \
         &gt;                                                         \
struct template_name : template_name##2&lt;T, U, B&gt; {};               \
                                                                   \
template&lt;class T, class U, class B&gt;                                \
struct template_name&lt;T, U, B, ::boost::detail::true_t&gt;             \
  : template_name##1&lt;T, U&gt; {};                                     \
                                                                   \
template &lt;class T, class B&gt;                                        \
struct template_name&lt;T, T, B, ::boost::detail::false_t&gt;            \
  : template_name##1&lt;T, B&gt; {};                                     \
                                                                   \
template&lt;class T, class U, class B, class O&gt;                       \
struct is_chained_base&lt; ::boost::template_name&lt;T, U, B, O&gt; &gt; {     \
  typedef ::boost::detail::true_t value;                           \
};                                                                 \
                                                                   \
BOOST_OPERATOR_TEMPLATE2(template_name##2)                         \
BOOST_OPERATOR_TEMPLATE1(template_name##1)


#else // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

#  define BOOST_OPERATOR_TEMPLATE4(template_name4) \
        BOOST_IMPORT_TEMPLATE4(template_name4)
#  define BOOST_OPERATOR_TEMPLATE3(template_name3) \
        BOOST_IMPORT_TEMPLATE3(template_name3)
#  define BOOST_OPERATOR_TEMPLATE2(template_name2) \
        BOOST_IMPORT_TEMPLATE2(template_name2)
#  define BOOST_OPERATOR_TEMPLATE1(template_name1) \
        BOOST_IMPORT_TEMPLATE1(template_name1)

   // In this case we can only assume that template_name&lt;&gt; is equivalent to the
   // more commonly needed template_name1&lt;&gt; form.
#  define BOOST_OPERATOR_TEMPLATE(template_name)                   \
   template &lt;class T, class B = ::boost::detail::empty_base&lt;T&gt; &gt;   \
   struct template_name : template_name##1&lt;T, B&gt; {};

#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION

namespace boost {
    
BOOST_OPERATOR_TEMPLATE(less_than_comparable)
BOOST_OPERATOR_TEMPLATE(equality_comparable)
BOOST_OPERATOR_TEMPLATE(multipliable)
BOOST_OPERATOR_TEMPLATE(addable)
BOOST_OPERATOR_TEMPLATE(subtractable)
BOOST_OPERATOR_TEMPLATE2(subtractable2_left)
BOOST_OPERATOR_TEMPLATE(dividable)
BOOST_OPERATOR_TEMPLATE2(dividable2_left)
BOOST_OPERATOR_TEMPLATE(modable)
BOOST_OPERATOR_TEMPLATE2(modable2_left)
BOOST_OPERATOR_TEMPLATE(xorable)
BOOST_OPERATOR_TEMPLATE(andable)
BOOST_OPERATOR_TEMPLATE(orable)

BOOST_OPERATOR_TEMPLATE1(incrementable)
BOOST_OPERATOR_TEMPLATE1(decrementable)

BOOST_OPERATOR_TEMPLATE2(dereferenceable)
BOOST_OPERATOR_TEMPLATE3(indexable)

BOOST_OPERATOR_TEMPLATE(left_shiftable)
BOOST_OPERATOR_TEMPLATE(right_shiftable)
BOOST_OPERATOR_TEMPLATE(equivalent)
BOOST_OPERATOR_TEMPLATE(partially_ordered)

BOOST_OPERATOR_TEMPLATE(totally_ordered)
BOOST_OPERATOR_TEMPLATE(additive)
BOOST_OPERATOR_TEMPLATE(multiplicative)
BOOST_OPERATOR_TEMPLATE(integer_multiplicative)
BOOST_OPERATOR_TEMPLATE(arithmetic)
BOOST_OPERATOR_TEMPLATE(integer_arithmetic)
BOOST_OPERATOR_TEMPLATE(bitwise)
BOOST_OPERATOR_TEMPLATE1(unit_steppable)
BOOST_OPERATOR_TEMPLATE(shiftable)
BOOST_OPERATOR_TEMPLATE(ring_operators)
BOOST_OPERATOR_TEMPLATE(ordered_ring_operators)
BOOST_OPERATOR_TEMPLATE(field_operators)
BOOST_OPERATOR_TEMPLATE(ordered_field_operators)
BOOST_OPERATOR_TEMPLATE(euclidian_ring_operators)
BOOST_OPERATOR_TEMPLATE(ordered_euclidian_ring_operators)
BOOST_OPERATOR_TEMPLATE(euclidean_ring_operators)
BOOST_OPERATOR_TEMPLATE(ordered_euclidean_ring_operators)
BOOST_OPERATOR_TEMPLATE2(input_iteratable)
BOOST_OPERATOR_TEMPLATE1(output_iteratable)
BOOST_OPERATOR_TEMPLATE2(forward_iteratable)
BOOST_OPERATOR_TEMPLATE2(bidirectional_iteratable)
BOOST_OPERATOR_TEMPLATE4(random_access_iteratable)

#undef BOOST_OPERATOR_TEMPLATE
#undef BOOST_OPERATOR_TEMPLATE4
#undef BOOST_OPERATOR_TEMPLATE3
#undef BOOST_OPERATOR_TEMPLATE2
#undef BOOST_OPERATOR_TEMPLATE1
#undef BOOST_IMPORT_TEMPLATE1
#undef BOOST_IMPORT_TEMPLATE2
#undef BOOST_IMPORT_TEMPLATE3
#undef BOOST_IMPORT_TEMPLATE4

// The following 'operators' classes can only be used portably if the derived class
// declares ALL of the required member operators.
template &lt;class T, class U&gt;
struct operators2
    : totally_ordered2&lt;T,U
    , integer_arithmetic2&lt;T,U
    , bitwise2&lt;T,U
      &gt; &gt; &gt; {};

#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION
template &lt;class T, class U = T&gt;
struct operators : operators2&lt;T, U&gt; {};

template &lt;class T&gt; struct operators&lt;T, T&gt;
#else
template &lt;class T&gt; struct operators
#endif
    : totally_ordered&lt;T
    , integer_arithmetic&lt;T
    , bitwise&lt;T
    , unit_steppable&lt;T
      &gt; &gt; &gt; &gt; {};

//  Iterator helper classes (contributed by Jeremy Siek) -------------------//
//  (Input and output iterator helpers contributed by Daryle Walker) -------//
//  (Changed to use combined operator classes by Daryle Walker) ------------//
template &lt;class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V const *,
          class R = V const &amp;&gt;
struct input_iterator_helper
  : input_iteratable&lt;T, P
  , boost::iterator&lt;std::input_iterator_tag, V, D, P, R
    &gt; &gt; {};

template&lt;class T&gt;
struct output_iterator_helper
  : output_iteratable&lt;T
  , boost::iterator&lt;std::output_iterator_tag, void, void, void, void
  &gt; &gt;
{
  T&amp; operator*()  { return static_cast&lt;T&amp;&gt;(*this); }
  T&amp; operator++() { return static_cast&lt;T&amp;&gt;(*this); }
};

template &lt;class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&amp;&gt;
struct forward_iterator_helper
  : forward_iteratable&lt;T, P
  , boost::iterator&lt;std::forward_iterator_tag, V, D, P, R
    &gt; &gt; {};

template &lt;class T,
          class V,
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&amp;&gt;
struct bidirectional_iterator_helper
  : bidirectional_iteratable&lt;T, P
  , boost::iterator&lt;std::bidirectional_iterator_tag, V, D, P, R
    &gt; &gt; {};

template &lt;class T,
          class V, 
          class D = std::ptrdiff_t,
          class P = V*,
          class R = V&amp;&gt;
struct random_access_iterator_helper
  : random_access_iteratable&lt;T, P, D, R
  , boost::iterator&lt;std::random_access_iterator_tag, V, D, P, R
    &gt; &gt;
{
  friend D requires_difference_operator(const T&amp; x, const T&amp; y) {
    return x - y;
  }
}; // random_access_iterator_helper

} // namespace boost

#if defined(__sgi) &amp;&amp; !defined(__GNUC__)
#pragma reset woff 1234
#endif

#endif // BOOST_OPERATORS_HPP
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="clear"></div>
    </div>
  </div>

  <div id="footer">
    <div id="footer-left">
      <div id="revised">
        <p>Revised $Date: 2010-09-26 09:11:52 -0400 (Sun, 26 Sep 2010) $</p>
      </div>

      <div id="copyright">
        <p>Copyright Beman Dawes, David Abrahams, 1998-2005.</p>

        <p>Copyright Rene Rivera 2004-2008.</p>
      </div>  <div id="license">
    <p>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt" class=
    "internal">Boost Software License, Version 1.0</a>.</p>
  </div>
    </div>

    <div id="footer-right">
        <div id="banners">
    <p id="banner-xhtml"><a href="http://validator.w3.org/check?uri=referer"
    class="external">XHTML 1.0</a></p>

    <p id="banner-css"><a href=
    "http://jigsaw.w3.org/css-validator/check/referer" class=
    "external">CSS</a></p>

    <p id="banner-osi"><a href=
    "http://www.opensource.org/docs/definition.php" class="external">OSI
    Certified</a></p>
  </div>
    </div>

    <div class="clear"></div>
  </div>
</body>

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/boost/operators.hpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:10:41 GMT -->
</html>
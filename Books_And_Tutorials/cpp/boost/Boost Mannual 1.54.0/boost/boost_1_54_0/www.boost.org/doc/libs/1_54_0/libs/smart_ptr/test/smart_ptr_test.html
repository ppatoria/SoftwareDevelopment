<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/libs/smart_ptr/test/smart_ptr_test.cpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:10:49 GMT -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<title>libs/smart_ptr/test/smart_ptr_test.cpp - 1.54.0</title>  <link rel="icon" href="http://www.boost.org/favicon.ico" type="image/ico" />
  <link rel="stylesheet" type="text/css" href="http://www.boost.org/style-v2/section-doc.css" />
  <!--[if IE 7]> <style type="text/css"> body { behavior: url(/style-v2/csshover3.htc); } </style> <![endif]-->

</head>

<body>
  <div id="heading">
    <div class="heading-inner">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
  <a href="http://www.boost.org/">
  <img src="http://www.boost.org/gfx/space.png" alt= "Boost C++ Libraries" class="heading-logo" />
  <span class="heading-boost">Boost</span>
  <span class="heading-cpplibraries">C++ Libraries</span>
  </a></h1>

  <p class="heading-quote">
  <q>...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.</q> <span class="heading-attribution">&mdash; <a href=
  "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
  "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
  Alexandrescu</a>, <a href=
  "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
  Coding Standards</a></span></p>
</div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33761719-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </div>

  <div id="body">
    <div id="body-inner">
      <div id="content">
        <div class="section" id="docs">
          <div class="section-0">
            <div class="section-body">
              <h3>libs/smart_ptr/test/smart_ptr_test.cpp</h3>
<pre>
//  smart pointer test program  ----------------------------------------------//

//  Copyright Beman Dawes 1998, 1999.  Distributed under the Boost
//  Software License, Version 1.0. (See accompanying file
//  LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)

//  See <a href="http://www.boost.org/libs/smart_ptr">http://www.boost.org/libs/smart_ptr</a> for documentation.

//  Revision History
//  24 May 01  use Boost test library for error detection, reporting, add tests
//             for operations on incomplete types (Beman Dawes) 
//  29 Nov 99  added std::swap and associative container tests (Darin Adler)
//  25 Sep 99  added swap tests
//  20 Jul 99  header name changed to .hpp
//  20 Apr 99  additional error tests added.

#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/config.hpp">boost/config.hpp</a>&gt;

#if defined(BOOST_MSVC)

# pragma warning(disable: 4786)  // identifier truncated in debug info
# pragma warning(disable: 4710)  // function not inlined
# pragma warning(disable: 4711)  // function selected for automatic inline expansion
# pragma warning(disable: 4514)  // unreferenced inline removed

#if (BOOST_MSVC &gt;= 1310)
# pragma warning(disable: 4675)  // resolved overload found with Koenig lookup
#endif

#endif

#ifdef __BORLANDC__
# pragma warn -8092 // template argument passed to 'find' is not an iterator
#endif

#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/smart_ptr.hpp">boost/smart_ptr.hpp</a>&gt;

#include &lt;<a href="http://www.boost.org/doc/libs/1_54_0/boost/detail/lightweight_test.hpp">boost/detail/lightweight_test.hpp</a>&gt;

#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string.h&gt;

class Incomplete;

Incomplete * get_ptr(  boost::shared_ptr&lt;Incomplete&gt;&amp; incomplete )
{
  return incomplete.get();
}

template&lt;class T&gt;
void ck( const T* v1, T v2 ) { BOOST_TEST( *v1 == v2 ); }

namespace {
  int UDT_use_count;  // independent of pointer maintained counts
  }

//  user defined type  -------------------------------------------------------//

class UDT {
  long value_;
 public:
  explicit UDT( long value=0 ) : value_(value) { ++UDT_use_count; }
  ~UDT() {
    --UDT_use_count;
    std::cout &lt;&lt; &quot;UDT with value &quot; &lt;&lt; value_ &lt;&lt; &quot; being destroyed\n&quot;;
    }
  long value() const { return value_; }
  void value( long v ) { value_ = v;; }
  };  // UDT

//  tests on incomplete types  -----------------------------------------------//

//  Certain smart pointer operations are specified to work on incomplete types,
//  and some uses depend upon this feature.  These tests verify compilation
//  only - the functions aren't actually invoked.

class Incomplete;

Incomplete * check_incomplete( boost::scoped_ptr&lt;Incomplete&gt;&amp; incomplete )
{
  return incomplete.get();
}

Incomplete * check_incomplete( boost::shared_ptr&lt;Incomplete&gt;&amp; incomplete,
                               boost::shared_ptr&lt;Incomplete&gt;&amp; i2 )
{
  incomplete.swap(i2);
  std::cout &lt;&lt; incomplete.use_count() &lt;&lt; ' ' &lt;&lt; incomplete.unique() &lt;&lt; '\n';
  return incomplete.get();
}

//  This isn't a very systematic test; it just hits some of the basics.

void test()
{
    BOOST_TEST( UDT_use_count == 0 );  // reality check

    //  test scoped_ptr with a built-in type
    long * lp = new long;
    boost::scoped_ptr&lt;long&gt; sp ( lp );
    BOOST_TEST( sp.get() == lp );
    BOOST_TEST( lp == sp.get() );
    BOOST_TEST( &amp;*sp == lp );

    *sp = 1234568901L;
    BOOST_TEST( *sp == 1234568901L );
    BOOST_TEST( *lp == 1234568901L );
    ck( static_cast&lt;long*&gt;(sp.get()), 1234568901L );
    ck( lp, *sp );

    sp.reset();
    BOOST_TEST( sp.get() == 0 );

    //  test scoped_ptr with a user defined type
    boost::scoped_ptr&lt;UDT&gt; udt_sp ( new UDT( 999888777 ) );
    BOOST_TEST( udt_sp-&gt;value() == 999888777 );
    udt_sp.reset();
    udt_sp.reset( new UDT( 111222333 ) );
    BOOST_TEST( udt_sp-&gt;value() == 111222333 );
    udt_sp.reset( new UDT( 333222111 ) );
    BOOST_TEST( udt_sp-&gt;value() == 333222111 );

    //  test scoped_array with a build-in type
    char * sap = new char [ 100 ];
    boost::scoped_array&lt;char&gt; sa ( sap );
    BOOST_TEST( sa.get() == sap );
    BOOST_TEST( sap == sa.get() );

    strcpy( sa.get(), &quot;Hot Dog with mustard and relish&quot; );
    BOOST_TEST( strcmp( sa.get(), &quot;Hot Dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( strcmp( sap, &quot;Hot Dog with mustard and relish&quot; ) == 0 );

    BOOST_TEST( sa[0] == 'H' );
    BOOST_TEST( sa[30] == 'h' );

    sa[0] = 'N';
    sa[4] = 'd';
    BOOST_TEST( strcmp( sap, &quot;Not dog with mustard and relish&quot; ) == 0 );

    sa.reset();
    BOOST_TEST( sa.get() == 0 );

    //  test shared_ptr with a built-in type
    int * ip = new int;
    boost::shared_ptr&lt;int&gt; cp ( ip );
    BOOST_TEST( ip == cp.get() );
    BOOST_TEST( cp.use_count() == 1 );

    *cp = 54321;
    BOOST_TEST( *cp == 54321 );
    BOOST_TEST( *ip == 54321 );
    ck( static_cast&lt;int*&gt;(cp.get()), 54321 );
    ck( static_cast&lt;int*&gt;(ip), *cp );

    boost::shared_ptr&lt;int&gt; cp2 ( cp );
    BOOST_TEST( ip == cp2.get() );
    BOOST_TEST( cp.use_count() == 2 );
    BOOST_TEST( cp2.use_count() == 2 );

    BOOST_TEST( *cp == 54321 );
    BOOST_TEST( *cp2 == 54321 );
    ck( static_cast&lt;int*&gt;(cp2.get()), 54321 );
    ck( static_cast&lt;int*&gt;(ip), *cp2 );

    boost::shared_ptr&lt;int&gt; cp3 ( cp );
    BOOST_TEST( cp.use_count() == 3 );
    BOOST_TEST( cp2.use_count() == 3 );
    BOOST_TEST( cp3.use_count() == 3 );
    cp.reset();
    BOOST_TEST( cp2.use_count() == 2 );
    BOOST_TEST( cp3.use_count() == 2 );
    cp.reset( new int );
    *cp =  98765;
    BOOST_TEST( *cp == 98765 );
    *cp3 = 87654;
    BOOST_TEST( *cp3 == 87654 );
    BOOST_TEST( *cp2 == 87654 );
    cp.swap( cp3 );
    BOOST_TEST( *cp == 87654 );
    BOOST_TEST( *cp2 == 87654 );
    BOOST_TEST( *cp3 == 98765 );
    cp.swap( cp3 );
    BOOST_TEST( *cp == 98765 );
    BOOST_TEST( *cp2 == 87654 );
    BOOST_TEST( *cp3 == 87654 );
    cp2 = cp2;
    BOOST_TEST( cp2.use_count() == 2 );
    BOOST_TEST( *cp2 == 87654 );
    cp = cp2;
    BOOST_TEST( cp2.use_count() == 3 );
    BOOST_TEST( *cp2 == 87654 );
    BOOST_TEST( cp.use_count() == 3 );
    BOOST_TEST( *cp == 87654 );

#if defined( BOOST_NO_ARGUMENT_DEPENDENT_LOOKUP )
    using boost::swap;
#endif

    boost::shared_ptr&lt;int&gt; cp4;
    swap( cp2, cp4 );
    BOOST_TEST( cp4.use_count() == 3 );
    BOOST_TEST( *cp4 == 87654 );
    BOOST_TEST( cp2.get() == 0 );

    std::set&lt; boost::shared_ptr&lt;int&gt; &gt; scp;
    scp.insert(cp4);
    BOOST_TEST( scp.find(cp4) != scp.end() );
    BOOST_TEST( scp.find(cp4) == scp.find( boost::shared_ptr&lt;int&gt;(cp4) ) );

    //  test shared_array with a built-in type
    char * cap = new char [ 100 ];
    boost::shared_array&lt;char&gt; ca ( cap );
    BOOST_TEST( ca.get() == cap );
    BOOST_TEST( cap == ca.get() );
    BOOST_TEST( &amp;ca[0] == cap );

    strcpy( ca.get(), &quot;Hot Dog with mustard and relish&quot; );
    BOOST_TEST( strcmp( ca.get(), &quot;Hot Dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( strcmp( cap, &quot;Hot Dog with mustard and relish&quot; ) == 0 );

    BOOST_TEST( ca[0] == 'H' );
    BOOST_TEST( ca[30] == 'h' );

    boost::shared_array&lt;char&gt; ca2 ( ca );
    boost::shared_array&lt;char&gt; ca3 ( ca2 );

    ca[0] = 'N';
    ca[4] = 'd';
    BOOST_TEST( strcmp( ca.get(), &quot;Not dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( strcmp( ca2.get(), &quot;Not dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( strcmp( ca3.get(), &quot;Not dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( ca.use_count() == 3 );
    BOOST_TEST( ca2.use_count() == 3 );
    BOOST_TEST( ca3.use_count() == 3 );
    ca2.reset();
    BOOST_TEST( ca.use_count() == 2 );
    BOOST_TEST( ca3.use_count() == 2 );
    BOOST_TEST( ca2.use_count() == 0 );

    ca.reset();
    BOOST_TEST( ca.get() == 0 );

    boost::shared_array&lt;char&gt; ca4;
    swap( ca3, ca4 );
    BOOST_TEST( ca4.use_count() == 1 );
    BOOST_TEST( strcmp( ca4.get(), &quot;Not dog with mustard and relish&quot; ) == 0 );
    BOOST_TEST( ca3.get() == 0 );

    std::set&lt; boost::shared_array&lt;char&gt; &gt; sca;
    sca.insert(ca4);
    BOOST_TEST( sca.find(ca4) != sca.end() );
    BOOST_TEST( sca.find(ca4) == sca.find( boost::shared_array&lt;char&gt;(ca4) ) );

    //  test shared_array with user defined type
    boost::shared_array&lt;UDT&gt; udta ( new UDT[3] );

    udta[0].value( 111 );
    udta[1].value( 222 );
    udta[2].value( 333 );
    boost::shared_array&lt;UDT&gt; udta2 ( udta );

    BOOST_TEST( udta[0].value() == 111 );
    BOOST_TEST( udta[1].value() == 222 );
    BOOST_TEST( udta[2].value() == 333 );
    BOOST_TEST( udta2[0].value() == 111 );
    BOOST_TEST( udta2[1].value() == 222 );
    BOOST_TEST( udta2[2].value() == 333 );
    udta2.reset();
    BOOST_TEST( udta2.get() == 0 );
    BOOST_TEST( udta.use_count() == 1 );
    BOOST_TEST( udta2.use_count() == 0 );

    BOOST_TEST( UDT_use_count == 4 );  // reality check

    //  test shared_ptr with a user defined type
    UDT * up = new UDT;
    boost::shared_ptr&lt;UDT&gt; sup ( up );
    BOOST_TEST( up == sup.get() );
    BOOST_TEST( sup.use_count() == 1 );

    sup-&gt;value( 54321 ) ;
    BOOST_TEST( sup-&gt;value() == 54321 );
    BOOST_TEST( up-&gt;value() == 54321 );

    boost::shared_ptr&lt;UDT&gt; sup2;
    sup2 = sup;
    BOOST_TEST( sup2-&gt;value() == 54321 );
    BOOST_TEST( sup.use_count() == 2 );
    BOOST_TEST( sup2.use_count() == 2 );
    sup2 = sup2;
    BOOST_TEST( sup2-&gt;value() == 54321 );
    BOOST_TEST( sup.use_count() == 2 );
    BOOST_TEST( sup2.use_count() == 2 );

    std::cout &lt;&lt; &quot;OK\n&quot;;

    new char[12345]; // deliberate memory leak to verify leaks detected
}

int main()
{
    test();
    return boost::report_errors();
}
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="clear"></div>
    </div>
  </div>

  <div id="footer">
    <div id="footer-left">
      <div id="revised">
        <p>Revised $Date: 2010-09-26 09:11:52 -0400 (Sun, 26 Sep 2010) $</p>
      </div>

      <div id="copyright">
        <p>Copyright Beman Dawes, David Abrahams, 1998-2005.</p>

        <p>Copyright Rene Rivera 2004-2008.</p>
      </div>  <div id="license">
    <p>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt" class=
    "internal">Boost Software License, Version 1.0</a>.</p>
  </div>
    </div>

    <div id="footer-right">
        <div id="banners">
    <p id="banner-xhtml"><a href="http://validator.w3.org/check?uri=referer"
    class="external">XHTML 1.0</a></p>

    <p id="banner-css"><a href=
    "http://jigsaw.w3.org/css-validator/check/referer" class=
    "external">CSS</a></p>

    <p id="banner-osi"><a href=
    "http://www.opensource.org/docs/definition.php" class="external">OSI
    Certified</a></p>
  </div>
    </div>

    <div class="clear"></div>
  </div>
</body>

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/libs/smart_ptr/test/smart_ptr_test.cpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:10:49 GMT -->
</html>
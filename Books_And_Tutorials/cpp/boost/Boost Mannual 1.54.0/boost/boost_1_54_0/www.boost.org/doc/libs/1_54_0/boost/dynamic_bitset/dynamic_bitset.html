<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/boost/dynamic_bitset/dynamic_bitset.hpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:12:02 GMT -->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<title>boost/dynamic_bitset/dynamic_bitset.hpp - 1.54.0</title>  <link rel="icon" href="http://www.boost.org/favicon.ico" type="image/ico" />
  <link rel="stylesheet" type="text/css" href="http://www.boost.org/style-v2/section-doc.css" />
  <!--[if IE 7]> <style type="text/css"> body { behavior: url(/style-v2/csshover3.htc); } </style> <![endif]-->

</head>

<body>
  <div id="heading">
    <div class="heading-inner">
  <div class="heading-placard"></div>

  <h1 class="heading-title">
  <a href="http://www.boost.org/">
  <img src="http://www.boost.org/gfx/space.png" alt= "Boost C++ Libraries" class="heading-logo" />
  <span class="heading-boost">Boost</span>
  <span class="heading-cpplibraries">C++ Libraries</span>
  </a></h1>

  <p class="heading-quote">
  <q>...one of the most highly
  regarded and expertly designed C++ library projects in the
  world.</q> <span class="heading-attribution">&mdash; <a href=
  "http://www.gotw.ca/" class="external">Herb Sutter</a> and <a href=
  "http://en.wikipedia.org/wiki/Andrei_Alexandrescu" class="external">Andrei
  Alexandrescu</a>, <a href=
  "http://safari.awprofessional.com/?XmlId=0321113586" class="external">C++
  Coding Standards</a></span></p>
</div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33761719-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </div>

  <div id="body">
    <div id="body-inner">
      <div id="content">
        <div class="section" id="docs">
          <div class="section-0">
            <div class="section-body">
              <h3>boost/dynamic_bitset/dynamic_bitset.hpp</h3>
<pre>
// -----------------------------------------------------------
//
//   Copyright (c) 2001-2002 Chuck Allison and Jeremy Siek
//        Copyright (c) 2003-2006, 2008 Gennaro Prota
//
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)
//
// -----------------------------------------------------------

#ifndef BOOST_DYNAMIC_BITSET_DYNAMIC_BITSET_HPP
#define BOOST_DYNAMIC_BITSET_DYNAMIC_BITSET_HPP

#include &lt;assert.h&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;      // for CHAR_BIT

#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/dynamic_bitset/config.hpp">boost/dynamic_bitset/config.hpp</a>&quot;

#ifndef BOOST_NO_STD_LOCALE
#  include &lt;locale&gt;
#endif

#if defined(BOOST_OLD_IOSTREAMS)
#  include &lt;iostream.h&gt;
#  include &lt;ctype.h&gt; // for isspace
#else
#  include &lt;istream&gt;
#  include &lt;ostream&gt;
#endif

#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/dynamic_bitset_fwd.hpp">boost/dynamic_bitset_fwd.hpp</a>&quot;
#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/detail/dynamic_bitset.hpp">boost/detail/dynamic_bitset.hpp</a>&quot;
#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/detail/iterator.hpp">boost/detail/iterator.hpp</a>&quot; // used to implement append(Iter, Iter)
#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/static_assert.hpp">boost/static_assert.hpp</a>&quot;
#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/limits.hpp">boost/limits.hpp</a>&quot;
#include &quot;<a href="http://www.boost.org/doc/libs/1_54_0/boost/pending/lowest_bit.hpp">boost/pending/lowest_bit.hpp</a>&quot;


namespace boost {

template &lt;typename Block, typename Allocator&gt;
class dynamic_bitset
{
  // Portability note: member function templates are defined inside
  // this class definition to avoid problems with VC++. Similarly,
  // with the member functions of nested classes.
  //
  // [October 2008: the note above is mostly historical; new versions
  // of VC++ are likely able to digest a more drinking form of the
  // code; but changing it now is probably not worth the risks...]

  BOOST_STATIC_ASSERT((bool)detail::dynamic_bitset_impl::allowed_block_type&lt;Block&gt;::value);

public:
    typedef Block block_type;
    typedef Allocator allocator_type;
    typedef std::size_t size_type;
    typedef block_type block_width_type;

    BOOST_STATIC_CONSTANT(block_width_type, bits_per_block = (std::numeric_limits&lt;Block&gt;::digits));
    BOOST_STATIC_CONSTANT(size_type, npos = static_cast&lt;size_type&gt;(-1));


public:

    // A proxy class to simulate lvalues of bit type.
    //
    class reference
    {
        friend class dynamic_bitset&lt;Block, Allocator&gt;;


        // the one and only non-copy ctor
        reference(block_type &amp; b, block_type pos)
            :m_block(b),
             m_mask( (assert(pos &lt; bits_per_block),
                      block_type(1) &lt;&lt; pos )
                   )
        { }

        void operator&amp;(); // left undefined

    public:

        // copy constructor: compiler generated

        operator bool() const { return (m_block &amp; m_mask) != 0; }
        bool operator~() const { return (m_block &amp; m_mask) == 0; }

        reference&amp; flip() { do_flip(); return *this; }

        reference&amp; operator=(bool x)               { do_assign(x);   return *this; } // for b[i] = x
        reference&amp; operator=(const reference&amp; rhs) { do_assign(rhs); return *this; } // for b[i] = b[j]

        reference&amp; operator|=(bool x) { if  (x) do_set();   return *this; }
        reference&amp; operator&amp;=(bool x) { if (!x) do_reset(); return *this; }
        reference&amp; operator^=(bool x) { if  (x) do_flip();  return *this; }
        reference&amp; operator-=(bool x) { if  (x) do_reset(); return *this; }

     private:
        block_type &amp; m_block;
        const block_type m_mask;

        void do_set() { m_block |= m_mask; }
        void do_reset() { m_block &amp;= ~m_mask; }
        void do_flip() { m_block ^= m_mask; }
        void do_assign(bool x) { x? do_set() : do_reset(); }
    };

    typedef bool const_reference;

    // constructors, etc.
    explicit
    dynamic_bitset(const Allocator&amp; alloc = Allocator());

    explicit
    dynamic_bitset(size_type num_bits, unsigned long value = 0,
               const Allocator&amp; alloc = Allocator());


    // WARNING: you should avoid using this constructor.
    //
    //  A conversion from string is, in most cases, formatting,
    //  and should be performed by using operator&gt;&gt;.
    //
    // NOTE:
    //  Leave the parentheses around std::basic_string&lt;CharT, Traits, Alloc&gt;::npos.
    //  g++ 3.2 requires them and probably the standard will - see core issue 325
    // NOTE 2:
    //  split into two constructors because of bugs in MSVC 6.0sp5 with STLport

    template &lt;typename CharT, typename Traits, typename Alloc&gt;
    dynamic_bitset(const std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; s,
        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type pos,
        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type n,
        size_type num_bits = npos,
        const Allocator&amp; alloc = Allocator())

    :m_bits(alloc),
     m_num_bits(0)
    {
      init_from_string(s, pos, n, num_bits);
    }

    template &lt;typename CharT, typename Traits, typename Alloc&gt;
    explicit
    dynamic_bitset(const std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; s,
      typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type pos = 0)

    :m_bits(Allocator()),
     m_num_bits(0)
    {
      init_from_string(s, pos, (std::basic_string&lt;CharT, Traits, Alloc&gt;::npos),
                       npos);
    }

    // The first bit in *first is the least significant bit, and the
    // last bit in the block just before *last is the most significant bit.
    template &lt;typename BlockInputIterator&gt;
    dynamic_bitset(BlockInputIterator first, BlockInputIterator last,
                   const Allocator&amp; alloc = Allocator())

    :m_bits(alloc),
     m_num_bits(0)
    {
        using boost::detail::dynamic_bitset_impl::value_to_type;
        using boost::detail::dynamic_bitset_impl::is_numeric;

        const value_to_type&lt;
            is_numeric&lt;BlockInputIterator&gt;::value&gt; selector;

        dispatch_init(first, last, selector);
    }

    template &lt;typename T&gt;
    void dispatch_init(T num_bits, unsigned long value,
                       detail::dynamic_bitset_impl::value_to_type&lt;true&gt;)
    {
        init_from_unsigned_long(static_cast&lt;size_type&gt;(num_bits), value);
    }

    template &lt;typename T&gt;
    void dispatch_init(T first, T last,
                       detail::dynamic_bitset_impl::value_to_type&lt;false&gt;)
    {
        init_from_block_range(first, last);
    }

    template &lt;typename BlockIter&gt;
    void init_from_block_range(BlockIter first, BlockIter last)
    {
        assert(m_bits.size() == 0);
        m_bits.insert(m_bits.end(), first, last);
        m_num_bits = m_bits.size() * bits_per_block;
    }

    // copy constructor
    dynamic_bitset(const dynamic_bitset&amp; b);

    ~dynamic_bitset();

    void swap(dynamic_bitset&amp; b);
    dynamic_bitset&amp; operator=(const dynamic_bitset&amp; b);

    allocator_type get_allocator() const;

    // size changing operations
    void resize(size_type num_bits, bool value = false);
    void clear();
    void push_back(bool bit);
    void append(Block block);

    template &lt;typename BlockInputIterator&gt;
    void m_append(BlockInputIterator first, BlockInputIterator last, std::input_iterator_tag)
    {
        std::vector&lt;Block, Allocator&gt; v(first, last);
        m_append(v.begin(), v.end(), std::random_access_iterator_tag());
    }
    template &lt;typename BlockInputIterator&gt;
    void m_append(BlockInputIterator first, BlockInputIterator last, std::forward_iterator_tag)
    {
        assert(first != last);
        block_width_type r = count_extra_bits();
        std::size_t d = boost::detail::distance(first, last);
        m_bits.reserve(num_blocks() + d);
        if (r == 0) {
            for( ; first != last; ++first)
                m_bits.push_back(*first); // could use vector&lt;&gt;::insert()
        }
        else {
            m_highest_block() |= (*first &lt;&lt; r);
            do {
                Block b = *first &gt;&gt; (bits_per_block - r);
                ++first;
                m_bits.push_back(b | (first==last? 0 : *first &lt;&lt; r));
            } while (first != last);
        }
        m_num_bits += bits_per_block * d;
    }
    template &lt;typename BlockInputIterator&gt;
    void append(BlockInputIterator first, BlockInputIterator last) // strong guarantee
    {
        if (first != last) {
            typename detail::iterator_traits&lt;BlockInputIterator&gt;::iterator_category cat;
            m_append(first, last, cat);
        }
    }


    // bitset operations
    dynamic_bitset&amp; operator&amp;=(const dynamic_bitset&amp; b);
    dynamic_bitset&amp; operator|=(const dynamic_bitset&amp; b);
    dynamic_bitset&amp; operator^=(const dynamic_bitset&amp; b);
    dynamic_bitset&amp; operator-=(const dynamic_bitset&amp; b);
    dynamic_bitset&amp; operator&lt;&lt;=(size_type n);
    dynamic_bitset&amp; operator&gt;&gt;=(size_type n);
    dynamic_bitset operator&lt;&lt;(size_type n) const;
    dynamic_bitset operator&gt;&gt;(size_type n) const;

    // basic bit operations
    dynamic_bitset&amp; set(size_type n, bool val = true);
    dynamic_bitset&amp; set();
    dynamic_bitset&amp; reset(size_type n);
    dynamic_bitset&amp; reset();
    dynamic_bitset&amp; flip(size_type n);
    dynamic_bitset&amp; flip();
    bool test(size_type n) const;
    bool any() const;
    bool none() const;
    dynamic_bitset operator~() const;
    size_type count() const;

    // subscript
    reference operator[](size_type pos) {
        return reference(m_bits[block_index(pos)], bit_index(pos));
    }
    bool operator[](size_type pos) const { return test(pos); }

    unsigned long to_ulong() const;

    size_type size() const;
    size_type num_blocks() const;
    size_type max_size() const;
    bool empty() const;

    bool is_subset_of(const dynamic_bitset&amp; a) const;
    bool is_proper_subset_of(const dynamic_bitset&amp; a) const;
    bool intersects(const dynamic_bitset &amp; a) const;

    // lookup
    size_type find_first() const;
    size_type find_next(size_type pos) const;


#if !defined BOOST_DYNAMIC_BITSET_DONT_USE_FRIENDS
    // lexicographical comparison
    template &lt;typename B, typename A&gt;
    friend bool operator==(const dynamic_bitset&lt;B, A&gt;&amp; a,
                           const dynamic_bitset&lt;B, A&gt;&amp; b);

    template &lt;typename B, typename A&gt;
    friend bool operator&lt;(const dynamic_bitset&lt;B, A&gt;&amp; a,
                          const dynamic_bitset&lt;B, A&gt;&amp; b);


    template &lt;typename B, typename A, typename BlockOutputIterator&gt;
    friend void to_block_range(const dynamic_bitset&lt;B, A&gt;&amp; b,
                               BlockOutputIterator result);

    template &lt;typename BlockIterator, typename B, typename A&gt;
    friend void from_block_range(BlockIterator first, BlockIterator last,
                                 dynamic_bitset&lt;B, A&gt;&amp; result);


    template &lt;typename CharT, typename Traits, typename B, typename A&gt;
    friend std::basic_istream&lt;CharT, Traits&gt;&amp; operator&gt;&gt;(std::basic_istream&lt;CharT, Traits&gt;&amp; is,
                                                         dynamic_bitset&lt;B, A&gt;&amp; b);

    template &lt;typename B, typename A, typename stringT&gt;
    friend void to_string_helper(const dynamic_bitset&lt;B, A&gt; &amp; b, stringT &amp; s, bool dump_all);


#endif


private:
    BOOST_STATIC_CONSTANT(block_width_type, ulong_width = std::numeric_limits&lt;unsigned long&gt;::digits);
    typedef std::vector&lt;block_type, allocator_type&gt; buffer_type;

    void m_zero_unused_bits();
    bool m_check_invariants() const;

    size_type m_do_find_from(size_type first_block) const;

    block_width_type count_extra_bits() const { return bit_index(size()); }
    static size_type block_index(size_type pos) { return pos / bits_per_block; }
    static block_width_type bit_index(size_type pos) { return static_cast&lt;block_width_type&gt;(pos % bits_per_block); }
    static Block bit_mask(size_type pos) { return Block(1) &lt;&lt; bit_index(pos); }

    template &lt;typename CharT, typename Traits, typename Alloc&gt;
    void init_from_string(const std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; s,
        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type pos,
        typename std::basic_string&lt;CharT, Traits, Alloc&gt;::size_type n,
        size_type num_bits)
    {
        assert(pos &lt;= s.size());

        typedef typename std::basic_string&lt;CharT, Traits, Alloc&gt; StrT;
        typedef typename StrT::traits_type Tr;

        const typename StrT::size_type rlen = (std::min)(n, s.size() - pos);
        const size_type sz = ( num_bits != npos? num_bits : rlen);
        m_bits.resize(calc_num_blocks(sz));
        m_num_bits = sz;


        BOOST_DYNAMIC_BITSET_CTYPE_FACET(CharT, fac, std::locale());
        const CharT one = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '1');

        const size_type m = num_bits &lt; rlen ? num_bits : rlen;
        typename StrT::size_type i = 0;
        for( ; i &lt; m; ++i) {

            const CharT c = s[(pos + m - 1) - i];

            assert( Tr::eq(c, one)
                    || Tr::eq(c, BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '0')) );

            if (Tr::eq(c, one))
                set(i);

        }

    }

    void init_from_unsigned_long(size_type num_bits,
                                 unsigned long value/*,
                                 const Allocator&amp; alloc*/)
    {

        assert(m_bits.size() == 0);

        m_bits.resize(calc_num_blocks(num_bits));
        m_num_bits = num_bits;

        typedef unsigned long num_type;
        typedef boost::detail::dynamic_bitset_impl
            ::shifter&lt;num_type, bits_per_block, ulong_width&gt; shifter;

        //if (num_bits == 0)
        //    return;

        // zero out all bits at pos &gt;= num_bits, if any;
        // note that: num_bits == 0 implies value == 0
        if (num_bits &lt; static_cast&lt;size_type&gt;(ulong_width)) {
            const num_type mask = (num_type(1) &lt;&lt; num_bits) - 1;
            value &amp;= mask;
        }

        typename buffer_type::iterator it = m_bits.begin();
        for( ; value; shifter::left_shift(value), ++it) {
            *it = static_cast&lt;block_type&gt;(value);
        }

    }



BOOST_DYNAMIC_BITSET_PRIVATE:

    bool m_unchecked_test(size_type pos) const;
    static size_type calc_num_blocks(size_type num_bits);

    Block&amp;        m_highest_block();
    const Block&amp;  m_highest_block() const;

    buffer_type m_bits;
    size_type   m_num_bits;


    class bit_appender;
    friend class bit_appender;
    class bit_appender {
      // helper for stream &gt;&gt;
      // Supplies to the lack of an efficient append at the less
      // significant end: bits are actually appended &quot;at left&quot; but
      // rearranged in the destructor. From the perspective of
      // client code everything works *as if* dynamic_bitset&lt;&gt; had
      // an append_at_right() function (eventually throwing the same
      // exceptions as push_back) except that the function is in fact
      // called bit_appender::do_append().
      //
      dynamic_bitset &amp; bs;
      size_type n;
      Block mask;
      Block * current;

      // not implemented
      bit_appender(const bit_appender &amp;);
      bit_appender &amp; operator=(const bit_appender &amp;);

    public:
        bit_appender(dynamic_bitset &amp; r) : bs(r), n(0), mask(0), current(0) {}
        ~bit_appender() {
            // reverse the order of blocks, shift
            // if needed, and then resize
            //
            std::reverse(bs.m_bits.begin(), bs.m_bits.end());
            const block_width_type offs = bit_index(n);
            if (offs)
                bs &gt;&gt;= (bits_per_block - offs);
            bs.resize(n); // doesn't enlarge, so can't throw
            assert(bs.m_check_invariants());
        }
        inline void do_append(bool value) {

            if (mask == 0) {
                bs.append(Block(0));
                current = &amp;bs.m_highest_block();
                mask = Block(1) &lt;&lt; (bits_per_block - 1);
            }

            if(value)
                *current |= mask;

            mask /= 2;
            ++n;
        }
        size_type get_count() const { return n; }
    };

};

#if !defined BOOST_NO_INCLASS_MEMBER_INITIALIZATION

template &lt;typename Block, typename Allocator&gt;
const typename dynamic_bitset&lt;Block, Allocator&gt;::block_width_type
dynamic_bitset&lt;Block, Allocator&gt;::bits_per_block;

template &lt;typename Block, typename Allocator&gt;
const typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::npos;

template &lt;typename Block, typename Allocator&gt;
const typename dynamic_bitset&lt;Block, Allocator&gt;::block_width_type
dynamic_bitset&lt;Block, Allocator&gt;::ulong_width;

#endif

// Global Functions:

// comparison
template &lt;typename Block, typename Allocator&gt;
bool operator!=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

template &lt;typename Block, typename Allocator&gt;
bool operator&lt;=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

template &lt;typename Block, typename Allocator&gt;
bool operator&gt;(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
               const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

template &lt;typename Block, typename Allocator&gt;
bool operator&gt;=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

// stream operators
#ifdef BOOST_OLD_IOSTREAMS
template &lt;typename Block, typename Allocator&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os,
                         const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

template &lt;typename Block, typename Allocator&gt;
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, dynamic_bitset&lt;Block,Allocator&gt;&amp; b);
#else
template &lt;typename CharT, typename Traits, typename Block, typename Allocator&gt;
std::basic_ostream&lt;CharT, Traits&gt;&amp;
operator&lt;&lt;(std::basic_ostream&lt;CharT, Traits&gt;&amp; os,
           const dynamic_bitset&lt;Block, Allocator&gt;&amp; b);

template &lt;typename CharT, typename Traits, typename Block, typename Allocator&gt;
std::basic_istream&lt;CharT, Traits&gt;&amp;
operator&gt;&gt;(std::basic_istream&lt;CharT, Traits&gt;&amp; is,
           dynamic_bitset&lt;Block, Allocator&gt;&amp; b);
#endif

// bitset operations
template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator&amp;(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator|(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator^(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator-(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b1,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);

// namespace scope swap
template&lt;typename Block, typename Allocator&gt;
void swap(dynamic_bitset&lt;Block, Allocator&gt;&amp; b1,
          dynamic_bitset&lt;Block, Allocator&gt;&amp; b2);


template &lt;typename Block, typename Allocator, typename stringT&gt;
void
to_string(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b, stringT &amp; s);

template &lt;typename Block, typename Allocator, typename BlockOutputIterator&gt;
void
to_block_range(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b,
               BlockOutputIterator result);


template &lt;typename BlockIterator, typename B, typename A&gt;
inline void
from_block_range(BlockIterator first, BlockIterator last,
                 dynamic_bitset&lt;B, A&gt;&amp; result)
{
    // PRE: distance(first, last) &lt;= numblocks()
    std::copy (first, last, result.m_bits.begin());
}

//=============================================================================
// dynamic_bitset implementation


//-----------------------------------------------------------------------------
// constructors, etc.

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;::dynamic_bitset(const Allocator&amp; alloc)
  : m_bits(alloc), m_num_bits(0)
{

}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;::
dynamic_bitset(size_type num_bits, unsigned long value, const Allocator&amp; alloc)
    : m_bits(alloc),
      m_num_bits(0)
{
    init_from_unsigned_long(num_bits, value);
}

// copy constructor
template &lt;typename Block, typename Allocator&gt;
inline dynamic_bitset&lt;Block, Allocator&gt;::
dynamic_bitset(const dynamic_bitset&amp; b)
  : m_bits(b.m_bits), m_num_bits(b.m_num_bits)
{

}

template &lt;typename Block, typename Allocator&gt;
inline dynamic_bitset&lt;Block, Allocator&gt;::
~dynamic_bitset()
{
    assert(m_check_invariants());
}

template &lt;typename Block, typename Allocator&gt;
inline void dynamic_bitset&lt;Block, Allocator&gt;::
swap(dynamic_bitset&lt;Block, Allocator&gt;&amp; b) // no throw
{
    std::swap(m_bits, b.m_bits);
    std::swap(m_num_bits, b.m_num_bits);
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp; dynamic_bitset&lt;Block, Allocator&gt;::
operator=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    m_bits = b.m_bits;
    m_num_bits = b.m_num_bits;
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
inline typename dynamic_bitset&lt;Block, Allocator&gt;::allocator_type
dynamic_bitset&lt;Block, Allocator&gt;::get_allocator() const
{
    return m_bits.get_allocator();
}

//-----------------------------------------------------------------------------
// size changing operations

template &lt;typename Block, typename Allocator&gt;
void dynamic_bitset&lt;Block, Allocator&gt;::
resize(size_type num_bits, bool value) // strong guarantee
{

  const size_type old_num_blocks = num_blocks();
  const size_type required_blocks = calc_num_blocks(num_bits);

  const block_type v = value? ~Block(0) : Block(0);

  if (required_blocks != old_num_blocks) {
    m_bits.resize(required_blocks, v); // s.g. (copy)
  }


  // At this point:
  //
  //  - if the buffer was shrunk, we have nothing more to do,
  //    except a call to m_zero_unused_bits()
  //
  //  - if it was enlarged, all the (used) bits in the new blocks have
  //    the correct value, but we have not yet touched those bits, if
  //    any, that were 'unused bits' before enlarging: if value == true,
  //    they must be set.

  if (value &amp;&amp; (num_bits &gt; m_num_bits)) {

    const block_width_type extra_bits = count_extra_bits();
    if (extra_bits) {
        assert(old_num_blocks &gt;= 1 &amp;&amp; old_num_blocks &lt;= m_bits.size());

        // Set them.
        m_bits[old_num_blocks - 1] |= (v &lt;&lt; extra_bits);
    }

  }

  m_num_bits = num_bits;
  m_zero_unused_bits();

}

template &lt;typename Block, typename Allocator&gt;
void dynamic_bitset&lt;Block, Allocator&gt;::
clear() // no throw
{
  m_bits.clear();
  m_num_bits = 0;
}


template &lt;typename Block, typename Allocator&gt;
void dynamic_bitset&lt;Block, Allocator&gt;::
push_back(bool bit)
{
  const size_type sz = size();
  resize(sz + 1);
  set(sz, bit);
}

template &lt;typename Block, typename Allocator&gt;
void dynamic_bitset&lt;Block, Allocator&gt;::
append(Block value) // strong guarantee
{
    const block_width_type r = count_extra_bits();

    if (r == 0) {
        // the buffer is empty, or all blocks are filled
        m_bits.push_back(value);
    }
    else {
        m_bits.push_back(value &gt;&gt; (bits_per_block - r));
        m_bits[m_bits.size() - 2] |= (value &lt;&lt; r); // m_bits.size() &gt;= 2
    }

    m_num_bits += bits_per_block;
    assert(m_check_invariants());

}


//-----------------------------------------------------------------------------
// bitset operations
template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::operator&amp;=(const dynamic_bitset&amp; rhs)
{
    assert(size() == rhs.size());
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        m_bits[i] &amp;= rhs.m_bits[i];
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::operator|=(const dynamic_bitset&amp; rhs)
{
    assert(size() == rhs.size());
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        m_bits[i] |= rhs.m_bits[i];
    //m_zero_unused_bits();
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::operator^=(const dynamic_bitset&amp; rhs)
{
    assert(size() == rhs.size());
    for (size_type i = 0; i &lt; this-&gt;num_blocks(); ++i)
        m_bits[i] ^= rhs.m_bits[i];
    //m_zero_unused_bits();
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::operator-=(const dynamic_bitset&amp; rhs)
{
    assert(size() == rhs.size());
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        m_bits[i] &amp;= ~rhs.m_bits[i];
    //m_zero_unused_bits();
    return *this;
}

//
// NOTE:
//  Note that the 'if (r != 0)' is crucial to avoid undefined
//  behavior when the left hand operand of &gt;&gt; isn't promoted to a
//  wider type (because rs would be too large).
//
template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::operator&lt;&lt;=(size_type n)
{
    if (n &gt;= m_num_bits)
        return reset();
    //else
    if (n &gt; 0) {

        size_type    const last = num_blocks() - 1;  // num_blocks() is &gt;= 1
        size_type    const div  = n / bits_per_block; // div is &lt;= last
        block_width_type const r = bit_index(n);
        block_type * const b    = &amp;m_bits[0];

        if (r != 0) {

            block_width_type const rs = bits_per_block - r;

            for (size_type i = last-div; i&gt;0; --i) {
                b[i+div] = (b[i] &lt;&lt; r) | (b[i-1] &gt;&gt; rs);
            }
            b[div] = b[0] &lt;&lt; r;

        }
        else {
            for (size_type i = last-div; i&gt;0; --i) {
                b[i+div] = b[i];
            }
            b[div] = b[0];
        }

        // zero out div blocks at the less significant end
        std::fill_n(b, div, static_cast&lt;block_type&gt;(0));

        // zero out any 1 bit that flowed into the unused part
        m_zero_unused_bits(); // thanks to Lester Gong

    }

    return *this;


}


//
// NOTE:
//  see the comments to operator &lt;&lt;=
//
template &lt;typename B, typename A&gt;
dynamic_bitset&lt;B, A&gt; &amp; dynamic_bitset&lt;B, A&gt;::operator&gt;&gt;=(size_type n) {
    if (n &gt;= m_num_bits) {
        return reset();
    }
    //else
    if (n&gt;0) {

        size_type  const last  = num_blocks() - 1; // num_blocks() is &gt;= 1
        size_type  const div   = n / bits_per_block;   // div is &lt;= last
        block_width_type const r     = bit_index(n);
        block_type * const b   = &amp;m_bits[0];


        if (r != 0) {

            block_width_type const ls = bits_per_block - r;

            for (size_type i = div; i &lt; last; ++i) {
                b[i-div] = (b[i] &gt;&gt; r) | (b[i+1]  &lt;&lt; ls);
            }
            // r bits go to zero
            b[last-div] = b[last] &gt;&gt; r;
        }

        else {
            for (size_type i = div; i &lt;= last; ++i) {
                b[i-div] = b[i];
            }
            // note the '&lt;=': the last iteration 'absorbs'
            // b[last-div] = b[last] &gt;&gt; 0;
        }



        // div blocks are zero filled at the most significant end
        std::fill_n(b + (num_blocks()-div), div, static_cast&lt;block_type&gt;(0));
    }

    return *this;
}


template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;::operator&lt;&lt;(size_type n) const
{
    dynamic_bitset r(*this);
    return r &lt;&lt;= n;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;::operator&gt;&gt;(size_type n) const
{
    dynamic_bitset r(*this);
    return r &gt;&gt;= n;
}


//-----------------------------------------------------------------------------
// basic bit operations

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::set(size_type pos, bool val)
{
    assert(pos &lt; m_num_bits);

    if (val)
        m_bits[block_index(pos)] |= bit_mask(pos);
    else
        reset(pos);

    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::set()
{
  std::fill(m_bits.begin(), m_bits.end(), ~Block(0));
  m_zero_unused_bits();
  return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::reset(size_type pos)
{
    assert(pos &lt; m_num_bits);
#if defined __MWERKS__ &amp;&amp; BOOST_WORKAROUND(__MWERKS__, &lt;= 0x3003) // 8.x
    // CodeWarrior 8 generates incorrect code when the &amp;=~ is compiled,
    // use the |^ variation instead.. &lt;grafik&gt;
    m_bits[block_index(pos)] |= bit_mask(pos);
    m_bits[block_index(pos)] ^= bit_mask(pos);
#else
    m_bits[block_index(pos)] &amp;= ~bit_mask(pos);
#endif
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::reset()
{
  std::fill(m_bits.begin(), m_bits.end(), Block(0));
  return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::flip(size_type pos)
{
    assert(pos &lt; m_num_bits);
    m_bits[block_index(pos)] ^= bit_mask(pos);
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;&amp;
dynamic_bitset&lt;Block, Allocator&gt;::flip()
{
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        m_bits[i] = ~m_bits[i];
    m_zero_unused_bits();
    return *this;
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::m_unchecked_test(size_type pos) const
{
    return (m_bits[block_index(pos)] &amp; bit_mask(pos)) != 0;
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::test(size_type pos) const
{
    assert(pos &lt; m_num_bits);
    return m_unchecked_test(pos);
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::any() const
{
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        if (m_bits[i])
            return true;
    return false;
}

template &lt;typename Block, typename Allocator&gt;
inline bool dynamic_bitset&lt;Block, Allocator&gt;::none() const
{
    return !any();
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;::operator~() const
{
    dynamic_bitset b(*this);
    b.flip();
    return b;
}

template &lt;typename Block, typename Allocator&gt;
typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::count() const
{
    using detail::dynamic_bitset_impl::table_width;
    using detail::dynamic_bitset_impl::access_by_bytes;
    using detail::dynamic_bitset_impl::access_by_blocks;
    using detail::dynamic_bitset_impl::value_to_type;

#if BOOST_WORKAROUND(__GNUC__, == 4) &amp;&amp; (__GNUC_MINOR__ == 3) &amp;&amp; (__GNUC_PATCHLEVEL__ == 3)
    // NOTE: Explicit qualification of &quot;bits_per_block&quot;
    //       breaks compilation on gcc 4.3.3
    enum { no_padding = bits_per_block == CHAR_BIT * sizeof(Block) };
#else
    // NOTE: Explicitly qualifying &quot;bits_per_block&quot; to workaround
    //       regressions of gcc 3.4.x
    enum { no_padding =
        dynamic_bitset&lt;Block, Allocator&gt;::bits_per_block
        == CHAR_BIT * sizeof(Block) };
#endif

    enum { enough_table_width = table_width &gt;= CHAR_BIT };

    enum { mode = (no_padding &amp;&amp; enough_table_width)
                          ? access_by_bytes
                          : access_by_blocks };

    return do_count(m_bits.begin(), num_blocks(), Block(0),
                    static_cast&lt;value_to_type&lt;(bool)mode&gt; *&gt;(0));
}


//-----------------------------------------------------------------------------
// conversions


template &lt;typename B, typename A, typename stringT&gt;
void to_string_helper(const dynamic_bitset&lt;B, A&gt; &amp; b, stringT &amp; s,
                      bool dump_all)
{
    typedef typename stringT::traits_type Tr;
    typedef typename stringT::value_type  Ch;

    BOOST_DYNAMIC_BITSET_CTYPE_FACET(Ch, fac, std::locale());
    const Ch zero = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '0');
    const Ch one  = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '1');

    // Note that this function may access (when
    // dump_all == true) bits beyond position size() - 1

    typedef typename dynamic_bitset&lt;B, A&gt;::size_type size_type;

    const size_type len = dump_all?
         dynamic_bitset&lt;B, A&gt;::bits_per_block * b.num_blocks():
         b.size();
    s.assign (len, zero);

    for (size_type i = 0; i &lt; len; ++i) {
        if (b.m_unchecked_test(i))
            Tr::assign(s[len - 1 - i], one);

    }

}


// A comment similar to the one about the constructor from
// basic_string can be done here. Thanks to James Kanze for
// making me (Gennaro) realize this important separation of
// concerns issue, as well as many things about i18n.
//
template &lt;typename Block, typename Allocator, typename stringT&gt;
inline void
to_string(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b, stringT&amp; s)
{
    to_string_helper(b, s, false);
}


// Differently from to_string this function dumps out
// every bit of the internal representation (may be
// useful for debugging purposes)
//
template &lt;typename B, typename A, typename stringT&gt;
inline void
dump_to_string(const dynamic_bitset&lt;B, A&gt;&amp; b, stringT&amp; s)
{
    to_string_helper(b, s, true /* =dump_all*/);
}

template &lt;typename Block, typename Allocator, typename BlockOutputIterator&gt;
inline void
to_block_range(const dynamic_bitset&lt;Block, Allocator&gt;&amp; b,
               BlockOutputIterator result)
{
    // note how this copies *all* bits, including the
    // unused ones in the last block (which are zero)
    std::copy(b.m_bits.begin(), b.m_bits.end(), result);
}

template &lt;typename Block, typename Allocator&gt;
unsigned long dynamic_bitset&lt;Block, Allocator&gt;::
to_ulong() const
{

  if (m_num_bits == 0)
      return 0; // convention

  // Check for overflows. This may be a performance burden on very
  // large bitsets but is required by the specification, sorry
  if (find_next(ulong_width - 1) != npos)
    throw std::overflow_error(&quot;boost::dynamic_bitset::to_ulong overflow&quot;);


  // Ok, from now on we can be sure there's no &quot;on&quot; bit
  // beyond the &quot;allowed&quot; positions
  typedef unsigned long result_type;

  const size_type maximum_size =
            (std::min)(m_num_bits, static_cast&lt;size_type&gt;(ulong_width));

  const size_type last_block = block_index( maximum_size - 1 );

  assert((last_block * bits_per_block) &lt; static_cast&lt;size_type&gt;(ulong_width));

  result_type result = 0;
  for (size_type i = 0; i &lt;= last_block; ++i) {
    const size_type offset = i * bits_per_block;
    result |= (static_cast&lt;result_type&gt;(m_bits[i]) &lt;&lt; offset);
  }

  return result;
}

template &lt;typename Block, typename Allocator&gt;
inline typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::size() const
{
    return m_num_bits;
}

template &lt;typename Block, typename Allocator&gt;
inline typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::num_blocks() const
{
    return m_bits.size();
}

template &lt;typename Block, typename Allocator&gt;
inline typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::max_size() const
{
    // Semantics of vector&lt;&gt;::max_size() aren't very clear
    // (see lib issue 197) and many library implementations
    // simply return dummy values, _unrelated_ to the underlying
    // allocator.
    //
    // Given these problems, I was tempted to not provide this
    // function at all but the user could need it if he provides
    // his own allocator.
    //

    const size_type m = detail::dynamic_bitset_impl::
                        vector_max_size_workaround(m_bits);

    return m &lt;= (size_type(-1)/bits_per_block) ?
        m * bits_per_block :
        size_type(-1);
}

template &lt;typename Block, typename Allocator&gt;
inline bool dynamic_bitset&lt;Block, Allocator&gt;::empty() const
{
  return size() == 0;
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::
is_subset_of(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a) const
{
    assert(size() == a.size());
    for (size_type i = 0; i &lt; num_blocks(); ++i)
        if (m_bits[i] &amp; ~a.m_bits[i])
            return false;
    return true;
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::
is_proper_subset_of(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a) const
{
    assert(size() == a.size());
    assert(num_blocks() == a.num_blocks());

    bool proper = false;
    for (size_type i = 0; i &lt; num_blocks(); ++i) {
        const Block &amp; bt =   m_bits[i];
        const Block &amp; ba = a.m_bits[i];

        if (bt &amp; ~ba)
            return false; // not a subset at all
        if (ba &amp; ~bt)
            proper = true;
    }
    return proper;
}

template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::intersects(const dynamic_bitset &amp; b) const
{
    size_type common_blocks = num_blocks() &lt; b.num_blocks()
                              ? num_blocks() : b.num_blocks();

    for(size_type i = 0; i &lt; common_blocks; ++i) {
        if(m_bits[i] &amp; b.m_bits[i])
            return true;
    }
    return false;
}

// --------------------------------
// lookup


// look for the first bit &quot;on&quot;, starting
// from the block with index first_block
//
template &lt;typename Block, typename Allocator&gt;
typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::m_do_find_from(size_type first_block) const
{
    size_type i = first_block;

    // skip null blocks
    while (i &lt; num_blocks() &amp;&amp; m_bits[i] == 0)
        ++i;

    if (i &gt;= num_blocks())
        return npos; // not found

    return i * bits_per_block + boost::lowest_bit(m_bits[i]);

}


template &lt;typename Block, typename Allocator&gt;
typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::find_first() const
{
    return m_do_find_from(0);
}


template &lt;typename Block, typename Allocator&gt;
typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::find_next(size_type pos) const
{

    const size_type sz = size();
    if (pos &gt;= (sz-1) || sz == 0)
        return npos;

    ++pos;

    const size_type blk = block_index(pos);
    const block_width_type ind = bit_index(pos);

    // mask out bits before pos
    const Block fore = m_bits[blk] &amp; ( ~Block(0) &lt;&lt; ind );

    return fore?
        blk * bits_per_block + lowest_bit(fore)
        :
        m_do_find_from(blk + 1);

}



//-----------------------------------------------------------------------------
// comparison

template &lt;typename Block, typename Allocator&gt;
bool operator==(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    return (a.m_num_bits == b.m_num_bits)
           &amp;&amp; (a.m_bits == b.m_bits);
}

template &lt;typename Block, typename Allocator&gt;
inline bool operator!=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                       const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    return !(a == b);
}

template &lt;typename Block, typename Allocator&gt;
bool operator&lt;(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
               const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    assert(a.size() == b.size());
    typedef typename dynamic_bitset&lt;Block, Allocator&gt;::size_type size_type;

    //if (a.size() == 0)
    //  return false;

    // Since we are storing the most significant bit
    // at pos == size() - 1, we need to do the comparisons in reverse.
    //
    for (size_type ii = a.num_blocks(); ii &gt; 0; --ii) {
      size_type i = ii-1;
      if (a.m_bits[i] &lt; b.m_bits[i])
        return true;
      else if (a.m_bits[i] &gt; b.m_bits[i])
        return false;
    }
    return false;
}

template &lt;typename Block, typename Allocator&gt;
inline bool operator&lt;=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                       const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    return !(a &gt; b);
}

template &lt;typename Block, typename Allocator&gt;
inline bool operator&gt;(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                      const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    return b &lt; a;
}

template &lt;typename Block, typename Allocator&gt;
inline bool operator&gt;=(const dynamic_bitset&lt;Block, Allocator&gt;&amp; a,
                       const dynamic_bitset&lt;Block, Allocator&gt;&amp; b)
{
    return !(a &lt; b);
}

//-----------------------------------------------------------------------------
// stream operations

#ifdef BOOST_OLD_IOSTREAMS
template &lt; typename Block, typename Alloc&gt;
std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, const dynamic_bitset&lt;Block, Alloc&gt;&amp; b)
{
    // NOTE: since this is aimed at &quot;classic&quot; iostreams, exception
    // masks on the stream are not supported. The library that
    // ships with gcc 2.95 has an exceptions() member function but
    // nothing is actually implemented; not even the class ios::failure.

    using namespace std;

    const ios::iostate ok = ios::goodbit;
    ios::iostate err = ok;

    if (os.opfx()) {

        //try
        typedef typename dynamic_bitset&lt;Block, Alloc&gt;::size_type bitsetsize_type;

        const bitsetsize_type sz = b.size();
        std::streambuf * buf = os.rdbuf();
        size_t npad = os.width() &lt;= 0  // careful: os.width() is signed (and can be &lt; 0)
            || (bitsetsize_type) os.width() &lt;= sz? 0 : os.width() - sz;

        const char fill_char = os.fill();
        const ios::fmtflags adjustfield = os.flags() &amp; ios::adjustfield;

        // if needed fill at left; pad is decresed along the way
        if (adjustfield != ios::left) {
            for (; 0 &lt; npad; --npad)
                if (fill_char != buf-&gt;sputc(fill_char)) {
                    err |= ios::failbit;
                    break;
                }
        }

        if (err == ok) {
            // output the bitset
            for (bitsetsize_type i = b.size(); 0 &lt; i; --i) {
                const char dig = b.test(i-1)? '1' : '0';
                if (EOF == buf-&gt;sputc(dig)) {
                    err |= ios::failbit;
                    break;
                }
            }
        }

        if (err == ok) {
            // if needed fill at right
            for (; 0 &lt; npad; --npad) {
                if (fill_char != buf-&gt;sputc(fill_char)) {
                    err |= ios::failbit;
                    break;
                }
            }
        }

        os.osfx();
        os.width(0);

    } // if opfx

    if(err != ok)
        os.setstate(err); // assume this does NOT throw
    return os;

}
#else

template &lt;typename Ch, typename Tr, typename Block, typename Alloc&gt;
std::basic_ostream&lt;Ch, Tr&gt;&amp;
operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr&gt;&amp; os,
           const dynamic_bitset&lt;Block, Alloc&gt;&amp; b)
{

    using namespace std;

    const ios_base::iostate ok = ios_base::goodbit;
    ios_base::iostate err = ok;

    typename basic_ostream&lt;Ch, Tr&gt;::sentry cerberos(os);
    if (cerberos) {

        BOOST_DYNAMIC_BITSET_CTYPE_FACET(Ch, fac, os.getloc());
        const Ch zero = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '0');
        const Ch one  = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '1');

        try {

            typedef typename dynamic_bitset&lt;Block, Alloc&gt;::size_type bitsetsize_type;
            typedef basic_streambuf&lt;Ch, Tr&gt; buffer_type;

            buffer_type * buf = os.rdbuf();
            size_t npad = os.width() &lt;= 0  // careful: os.width() is signed (and can be &lt; 0)
                || (bitsetsize_type) os.width() &lt;= b.size()? 0 : os.width() - b.size();

            const Ch fill_char = os.fill();
            const ios_base::fmtflags adjustfield = os.flags() &amp; ios_base::adjustfield;

            // if needed fill at left; pad is decresed along the way
            if (adjustfield != ios_base::left) {
                for (; 0 &lt; npad; --npad)
                    if (Tr::eq_int_type(Tr::eof(), buf-&gt;sputc(fill_char))) {
                          err |= ios_base::failbit;
                          break;
                    }
            }

            if (err == ok) {
                // output the bitset
                for (bitsetsize_type i = b.size(); 0 &lt; i; --i) {
                    typename buffer_type::int_type
                        ret = buf-&gt;sputc(b.test(i-1)? one : zero);
                    if (Tr::eq_int_type(Tr::eof(), ret)) {
                        err |= ios_base::failbit;
                        break;
                    }
                }
            }

            if (err == ok) {
                // if needed fill at right
                for (; 0 &lt; npad; --npad) {
                    if (Tr::eq_int_type(Tr::eof(), buf-&gt;sputc(fill_char))) {
                        err |= ios_base::failbit;
                        break;
                    }
                }
            }


            os.width(0);

        } catch (...) { // see std 27.6.1.1/4
            bool rethrow = false;
            try { os.setstate(ios_base::failbit); } catch (...) { rethrow = true; }

            if (rethrow)
                throw;
        }
    }

    if(err != ok)
        os.setstate(err); // may throw exception
    return os;

}
#endif


#ifdef BOOST_OLD_IOSTREAMS

    // A sentry-like class that calls isfx in its destructor.
    // &quot;Necessary&quot; because bit_appender::do_append may throw.
    class pseudo_sentry {
        std::istream &amp; m_r;
        const bool m_ok;
    public:
        explicit pseudo_sentry(std::istream &amp; r) : m_r(r), m_ok(r.ipfx(0)) { }
        ~pseudo_sentry() { m_r.isfx(); }
        operator bool() const { return m_ok; }
    };

template &lt;typename Block, typename Alloc&gt;
std::istream&amp;
operator&gt;&gt;(std::istream&amp; is, dynamic_bitset&lt;Block, Alloc&gt;&amp; b)
{

// Extractor for classic IO streams (libstdc++ &lt; 3.0)
// ----------------------------------------------------//
//  It's assumed that the stream buffer functions, and
//  the stream's setstate() _cannot_ throw.


    typedef dynamic_bitset&lt;Block, Alloc&gt; bitset_type;
    typedef typename bitset_type::size_type size_type;

    std::ios::iostate err = std::ios::goodbit;
    pseudo_sentry cerberos(is); // skips whitespaces
    if(cerberos) {

        b.clear();

        const std::streamsize w = is.width();
        const size_type limit = w &gt; 0 &amp;&amp; static_cast&lt;size_type&gt;(w) &lt; b.max_size()
                                                         ? w : b.max_size();
        typename bitset_type::bit_appender appender(b);
        std::streambuf * buf = is.rdbuf();
        for(int c = buf-&gt;sgetc(); appender.get_count() &lt; limit; c = buf-&gt;snextc() ) {

            if (c == EOF) {
                err |= std::ios::eofbit;
                break;
            }
            else if (char(c) != '0' &amp;&amp; char(c) != '1')
                break; // non digit character

            else {
                try {
                    appender.do_append(char(c) == '1');
                }
                catch(...) {
                    is.setstate(std::ios::failbit); // assume this can't throw
                    throw;
                }
            }

        } // for
    }

    is.width(0);
    if (b.size() == 0)
        err |= std::ios::failbit;
    if (err != std::ios::goodbit)
        is.setstate (err); // may throw

    return is;
}

#else // BOOST_OLD_IOSTREAMS

template &lt;typename Ch, typename Tr, typename Block, typename Alloc&gt;
std::basic_istream&lt;Ch, Tr&gt;&amp;
operator&gt;&gt;(std::basic_istream&lt;Ch, Tr&gt;&amp; is, dynamic_bitset&lt;Block, Alloc&gt;&amp; b)
{

    using namespace std;

    typedef dynamic_bitset&lt;Block, Alloc&gt; bitset_type;
    typedef typename bitset_type::size_type size_type;

    const streamsize w = is.width();
    const size_type limit = 0 &lt; w &amp;&amp; static_cast&lt;size_type&gt;(w) &lt; b.max_size()?
                                         w : b.max_size();

    ios_base::iostate err = ios_base::goodbit;
    typename basic_istream&lt;Ch, Tr&gt;::sentry cerberos(is); // skips whitespaces
    if(cerberos) {

        // in accordance with prop. resol. of lib DR 303 [last checked 4 Feb 2004]
        BOOST_DYNAMIC_BITSET_CTYPE_FACET(Ch, fac, is.getloc());
        const Ch zero = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '0');
        const Ch one  = BOOST_DYNAMIC_BITSET_WIDEN_CHAR(fac, '1');

        b.clear();
        try {
            typename bitset_type::bit_appender appender(b);
            basic_streambuf &lt;Ch, Tr&gt; * buf = is.rdbuf();
            typename Tr::int_type c = buf-&gt;sgetc();
            for( ; appender.get_count() &lt; limit; c = buf-&gt;snextc() ) {

                if (Tr::eq_int_type(Tr::eof(), c)) {
                    err |= ios_base::eofbit;
                    break;
                }
                else {
                    const Ch to_c = Tr::to_char_type(c);
                    const bool is_one = Tr::eq(to_c, one);

                    if (!is_one &amp;&amp; !Tr::eq(to_c, zero))
                        break; // non digit character

                    appender.do_append(is_one);

                }

            } // for
        }
        catch (...) {
            // catches from stream buf, or from vector:
            //
            // bits_stored bits have been extracted and stored, and
            // either no further character is extractable or we can't
            // append to the underlying vector (out of memory)

            bool rethrow = false;   // see std 27.6.1.1/4
            try { is.setstate(ios_base::badbit); }
            catch(...) { rethrow = true; }

            if (rethrow)
                throw;

        }
    }

    is.width(0);
    if (b.size() == 0 /*|| !cerberos*/)
        err |= ios_base::failbit;
    if (err != ios_base::goodbit)
        is.setstate (err); // may throw

    return is;

}


#endif


//-----------------------------------------------------------------------------
// bitset operations

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator&amp;(const dynamic_bitset&lt;Block, Allocator&gt;&amp; x,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; y)
{
    dynamic_bitset&lt;Block, Allocator&gt; b(x);
    return b &amp;= y;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator|(const dynamic_bitset&lt;Block, Allocator&gt;&amp; x,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; y)
{
    dynamic_bitset&lt;Block, Allocator&gt; b(x);
    return b |= y;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator^(const dynamic_bitset&lt;Block, Allocator&gt;&amp; x,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; y)
{
    dynamic_bitset&lt;Block, Allocator&gt; b(x);
    return b ^= y;
}

template &lt;typename Block, typename Allocator&gt;
dynamic_bitset&lt;Block, Allocator&gt;
operator-(const dynamic_bitset&lt;Block, Allocator&gt;&amp; x,
          const dynamic_bitset&lt;Block, Allocator&gt;&amp; y)
{
    dynamic_bitset&lt;Block, Allocator&gt; b(x);
    return b -= y;
}

//-----------------------------------------------------------------------------
// namespace scope swap

template&lt;typename Block, typename Allocator&gt;
inline void
swap(dynamic_bitset&lt;Block, Allocator&gt;&amp; left,
     dynamic_bitset&lt;Block, Allocator&gt;&amp; right) // no throw
{
    left.swap(right);
}


//-----------------------------------------------------------------------------
// private (on conforming compilers) member functions


template &lt;typename Block, typename Allocator&gt;
inline typename dynamic_bitset&lt;Block, Allocator&gt;::size_type
dynamic_bitset&lt;Block, Allocator&gt;::calc_num_blocks(size_type num_bits)
{
    return num_bits / bits_per_block
           + static_cast&lt;int&gt;( num_bits % bits_per_block != 0 );
}

// gives a reference to the highest block
//
template &lt;typename Block, typename Allocator&gt;
inline Block&amp; dynamic_bitset&lt;Block, Allocator&gt;::m_highest_block()
{
    return const_cast&lt;Block &amp;&gt;
           (static_cast&lt;const dynamic_bitset *&gt;(this)-&gt;m_highest_block());
}

// gives a const-reference to the highest block
//
template &lt;typename Block, typename Allocator&gt;
inline const Block&amp; dynamic_bitset&lt;Block, Allocator&gt;::m_highest_block() const
{
    assert(size() &gt; 0 &amp;&amp; num_blocks() &gt; 0);
    return m_bits.back();
}


// If size() is not a multiple of bits_per_block
// then not all the bits in the last block are used.
// This function resets the unused bits (convenient
// for the implementation of many member functions)
//
template &lt;typename Block, typename Allocator&gt;
inline void dynamic_bitset&lt;Block, Allocator&gt;::m_zero_unused_bits()
{
    assert (num_blocks() == calc_num_blocks(m_num_bits));

    // if != 0 this is the number of bits used in the last block
    const block_width_type extra_bits = count_extra_bits();

    if (extra_bits != 0)
        m_highest_block() &amp;= ~(~static_cast&lt;Block&gt;(0) &lt;&lt; extra_bits);

}

// check class invariants
template &lt;typename Block, typename Allocator&gt;
bool dynamic_bitset&lt;Block, Allocator&gt;::m_check_invariants() const
{
    const block_width_type extra_bits = count_extra_bits();
    if (extra_bits &gt; 0) {
        block_type const mask = (~static_cast&lt;Block&gt;(0) &lt;&lt; extra_bits);
        if ((m_highest_block() &amp; mask) != 0)
            return false;
    }
    if (m_bits.size() &gt; m_bits.capacity() || num_blocks() != calc_num_blocks(size()))
        return false;

    return true;

}


} // namespace boost


#undef BOOST_BITSET_CHAR

#endif // include guard

</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="clear"></div>
    </div>
  </div>

  <div id="footer">
    <div id="footer-left">
      <div id="revised">
        <p>Revised $Date: 2010-09-26 09:11:52 -0400 (Sun, 26 Sep 2010) $</p>
      </div>

      <div id="copyright">
        <p>Copyright Beman Dawes, David Abrahams, 1998-2005.</p>

        <p>Copyright Rene Rivera 2004-2008.</p>
      </div>  <div id="license">
    <p>Distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt" class=
    "internal">Boost Software License, Version 1.0</a>.</p>
  </div>
    </div>

    <div id="footer-right">
        <div id="banners">
    <p id="banner-xhtml"><a href="http://validator.w3.org/check?uri=referer"
    class="external">XHTML 1.0</a></p>

    <p id="banner-css"><a href=
    "http://jigsaw.w3.org/css-validator/check/referer" class=
    "external">CSS</a></p>

    <p id="banner-osi"><a href=
    "http://www.opensource.org/docs/definition.php" class="external">OSI
    Certified</a></p>
  </div>
    </div>

    <div class="clear"></div>
  </div>
</body>

<!-- Mirrored from www.boost.org/doc/libs/1_54_0/boost/dynamic_bitset/dynamic_bitset.hpp by HTTrack Website Copier/3.x [XR&CO'2008], Sun, 15 Sep 2013 18:12:02 GMT -->
</html>
CALLING PARTS OF FUNCTIONS
The most important reason to use a curried format function is that it becomes possible to call this function with only some, but not all, the parameters that are needed for the computation it performs. This process is called partial application, for obvious reasons: the function is applied, but only in part. Partial application is one technique used for function construction.
Consider the following piece of code, which uses a function created from scratch in curried format:
Func<int, Func<int, int>> add = x => y => x + y;
var add5 = add(5);
The curried function add is called, but only one parameter is passed to it. Obviously the calculation can’t be performed at this point because it requires two parameters. The call with one parameter returns a new function, and instead of calling this immediately, it is stored away in the variable add5 for later use.
This new function that has been created can now be called like any other function:
// the result will be 42
int result = add5(37);
The technique of partial application has created a new function out of an existing one. In general, partial application takes a function that is rather generic in nature and creates a new function with a more specific purpose. In the example, the function add is generic in the sense that it can take any two arbitrary integer values and add them. Every time the function is called, a new combination of integer values is passed in and a new result returned. While this is flexible, it also has the requirement that both parameters need to be passed in every time. Sometimes this is not desirable if a given algorithm needs the functionality in question (adding two values in this case) but not all the flexibility offered by the function.
There is a different approach with a very similar purpose available in many programming languages, including C#: overloading. A programmer could have the following two methods in a class:
int Add(int x, int y) {
  return x + y;
}
 
int Add5(int y) {
  return Add(5, y);
}
It is important to understand that partial application is used for the same reasons that overloads are created. These reasons evolve largely around the usability of APIs. An existing class will provide certain functions or methods that have been created with particular use cases in mind. In some cases the programmers of frameworks and similar large collections of APIs will have had an eye on usability, and they might have provided convenient overloads for functions where it made sense to them. In other cases they might not have done so, and it is almost a philosophical question whether this should even be done.
Without functional approaches like partial application, there is no really good way of creating convenience functions that haven’t been prepared by the creators of an API. Imagine you are using a class that has been created by somebody else. The class has a function that does something you need, and it’s extremely flexible and has lots of parameters. In your algorithm, however, you only need part of that flexibility and all your calls use the same values for some of the parameters. Your code will be much less readable than it could be, if only you had a function that was stripped down to those few of the parameters that you actually need.
An overload would be a solution, but you can’t create that overload in the class in question because you don’t have the source code. Even if you did have the source code, perhaps creating a convenience function for your particular use case right there in the class wouldn’t be the right approach. Alternatively you could create a helper function in a class of your own, and this is probably the approach chosen by most programmers. But is that the right one? A new method in your class just for the use of the one algorithm you are writing right now? This is the approach suggested by the extension method feature in C# 3.0, but it isn’t always the right one.
With the help of partial application, you have one new choice: you can create that helper function in the exact place where it is needed. The context is correct because the function lives right next to the algorithm that utilizes it. It doesn’t “pollute” the class context with functionality that is really specific to a particular algorithm. And the approach can be used in all situations, whether you are working with functions you have under your own control or ones that have been created by somebody else.
Partial application (and other function construction techniques; see Chapter 14) enables modularization on a functional level. Building blocks in your application don’t have to be high-level entities like classes. Instead it’s possible to modularize and reuse on a low level, on the functional level. Reusability and modularization is thereby shifted from being an architecture concern into the realm of responsibility and capability of every programmer.
